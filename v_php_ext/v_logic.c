
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "6fa4008a2aa1f7ee94b4ef4e5471af5a0a7ed016"
#endif

#define V_USE_SIGNAL_H

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : macos
//     Turned ON custom defines: macos
#define CUSTOM_DEFINE_macos

#define __VTHREADS__ (1)

// V typedefs:
typedef struct IError IError;
typedef struct vphp__ITask vphp__ITask;
typedef struct vphp__compiler__PhpRepr vphp__compiler__PhpRepr;
typedef struct rand__PRNG rand__PRNG;
typedef struct hash__Hash hash__Hash;
typedef struct hash__Hash32er hash__Hash32er;
typedef struct hash__Hash64er hash__Hash64er;
typedef struct none none;
typedef struct v__ast__Stmt v__ast__Stmt;
typedef struct v__ast__TypeDecl v__ast__TypeDecl;
typedef struct v__ast__Expr v__ast__Expr;
typedef struct v__ast__ScopeObject v__ast__ScopeObject;
typedef struct v__ast__Node v__ast__Node;
typedef struct v__ast__ComptTimeConstValue v__ast__ComptTimeConstValue;
typedef struct v__ast__IdentInfo v__ast__IdentInfo;
typedef struct v__ast__AsmArg v__ast__AsmArg;
typedef struct v__ast__TypeInfo v__ast__TypeInfo;
typedef struct _option_term__FgColor _option_term__FgColor;
typedef struct _option_term__BgColor _option_term__BgColor;
typedef struct _option_string _option_string;

// BEGIN_array_fixed_return_typedefs
typedef struct _v_Array_fixed_bool_256 _v_Array_fixed_bool_256;
// END_array_fixed_return_typedefs


// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_strconv__ParserState_strconv__PrepNumber multi_return_strconv__ParserState_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_i64_int multi_return_i64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_string_string_string multi_return_string_string_string;
typedef struct multi_return_Array_string_Array_string multi_return_Array_string_Array_string;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_f64_int multi_return_f64_int;
typedef struct multi_return_v__ast__Fn_Array_v__ast__Type multi_return_v__ast__Fn_Array_v__ast__Type;
typedef struct multi_return_v__ast__StructField_Array_v__ast__Type multi_return_v__ast__StructField_Array_v__ast__Type;
typedef struct multi_return_ref_v__ast__TypeSymbol_int multi_return_ref_v__ast__TypeSymbol_int;
typedef struct multi_return_v__ast__Type_string multi_return_v__ast__Type_string;
typedef struct multi_return_int_v__ast__Type multi_return_int_v__ast__Type;
typedef struct multi_return_bool_bool_int multi_return_bool_bool_int;
typedef struct multi_return_ref_v__pref__Preferences_string multi_return_ref_v__pref__Preferences_string;
typedef struct multi_return_Array_v__ast__Param_bool_bool_bool multi_return_Array_v__ast__Param_bool_bool_bool;
typedef struct multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope;
typedef struct multi_return_Array_v__ast__Type_Array_string multi_return_Array_v__ast__Type_Array_string;
typedef struct multi_return_bool_string_int_Array_string multi_return_bool_string_int_Array_string;
typedef struct multi_return_Array_string_Array_string_Array_string multi_return_Array_string_Array_string_Array_string;
typedef struct multi_return_f64_f64 multi_return_f64_f64;
typedef struct multi_return_int_int_int_int multi_return_int_int_int_int;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_int_i64_bool multi_return_int_int_int_int_int_i64_bool;
typedef struct multi_return_Array_string_int multi_return_Array_string_int;
typedef struct multi_return_Array_string_v__vmod__ModFileAndFolder multi_return_Array_string_v__vmod__ModFileAndFolder;
typedef struct multi_return_ref_sync__SpinLock_ref_sync__Subscription multi_return_ref_sync__SpinLock_ref_sync__Subscription;
// END_multi_return_typedefs

typedef struct strings__IndentParam strings__IndentParam;
typedef struct builtin__closure__Closure builtin__closure__Closure;
typedef struct builtin__closure__ClosureMutex builtin__closure__ClosureMutex;
typedef struct strconv__AtoF64Param strconv__AtoF64Param;
typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct GCHeapUsage GCHeapUsage;
typedef struct array array;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct _result _result;
typedef struct Error Error;
typedef struct MessageError MessageError;
typedef struct _option _option;
typedef struct None__ None__;
typedef struct InputRuneIterator InputRuneIterator;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct EnumData EnumData;
typedef struct FieldData FieldData;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct RepIndex RepIndex;
typedef struct WrapConfig WrapConfig;
typedef struct RunesIterator RunesIterator;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpData StrIntpData;
typedef struct ToWideConfig ToWideConfig;
typedef struct vphp__zend__AsyncResult vphp__zend__AsyncResult;
typedef struct strings__textscanner__TextScanner strings__textscanner__TextScanner;
typedef struct term__termios__Termios term__termios__Termios;
typedef struct v__token__KeywordsMatcherTrie v__token__KeywordsMatcherTrie;
typedef struct v__token__TrieNode v__token__TrieNode;
typedef struct v__token__Pos v__token__Pos;
typedef struct v__token__Token v__token__Token;
typedef struct sync__stdatomic__AtomicVal sync__stdatomic__AtomicVal;
typedef struct time__DateTimeParser time__DateTimeParser;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct flag__Flag flag__Flag;
typedef struct flag__UnknownFlagError flag__UnknownFlagError;
typedef struct flag__ArgsCountError flag__ArgsCountError;
typedef struct flag__FlagParser flag__FlagParser;
typedef struct flag__FlagConfig flag__FlagConfig;
typedef struct flag__FlagData flag__FlagData;
typedef struct flag__FlagContext flag__FlagContext;
typedef struct flag__StructInfo flag__StructInfo;
typedef struct flag__StructField flag__StructField;
typedef struct flag__ParseConfig flag__ParseConfig;
typedef struct flag__DocConfig flag__DocConfig;
typedef struct flag__DocLayout flag__DocLayout;
typedef struct flag__DocOptions flag__DocOptions;
typedef struct flag__FlagMapper flag__FlagMapper;
typedef struct semver__RawVersion semver__RawVersion;
typedef struct semver__Comparator semver__Comparator;
typedef struct semver__ComparatorSet semver__ComparatorSet;
typedef struct semver__Range semver__Range;
typedef struct semver__InvalidComparatorFormatError semver__InvalidComparatorFormatError;
typedef struct semver__Version semver__Version;
typedef struct semver__EmptyInputError semver__EmptyInputError;
typedef struct semver__InvalidVersionFormatError semver__InvalidVersionFormatError;
typedef struct rand__buffer__PRNGBuffer rand__buffer__PRNGBuffer;
typedef struct vphp__Context vphp__Context;
typedef struct vphp__TaskRegistry vphp__TaskRegistry;
typedef struct vphp__Val vphp__Val;
typedef struct vphp__MapContext vphp__MapContext;
typedef struct os__Command os__Command;
typedef struct os__Eof os__Eof;
typedef struct os__NotExpected os__NotExpected;
typedef struct os__File os__File;
typedef struct os__FileNotOpenedError os__FileNotOpenedError;
typedef struct os__SizeOfTypeIs0Error os__SizeOfTypeIs0Error;
typedef struct os__FileMode os__FileMode;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__CopyParams os__CopyParams;
typedef struct os__PathKind os__PathKind;
typedef struct os__SystemError os__SystemError;
typedef struct os__DiskUsage os__DiskUsage;
typedef struct os__Result os__Result;
typedef struct os__MvParams os__MvParams;
typedef struct os__ExecutableNotFoundError os__ExecutableNotFoundError;
typedef struct os__WalkParams os__WalkParams;
typedef struct os__MkdirParams os__MkdirParams;
typedef struct os__Uname os__Uname;
typedef struct os__Stat os__Stat;
typedef struct os__Pipe os__Pipe;
typedef struct os__IOCapture os__IOCapture;
typedef struct os__Process os__Process;
typedef struct v__errors__CallStackItem v__errors__CallStackItem;
typedef struct v__errors__CompilerMessage v__errors__CompilerMessage;
typedef struct v__errors__Error v__errors__Error;
typedef struct v__errors__Warning v__errors__Warning;
typedef struct v__errors__Notice v__errors__Notice;
typedef struct os__filelock__FileLock os__filelock__FileLock;
typedef struct v__cflag__CFlag v__cflag__CFlag;
typedef struct v__vcache__CacheManager v__vcache__CacheManager;
typedef struct v__pkgconfig__Main v__pkgconfig__Main;
typedef struct v__pkgconfig__MainOptions v__pkgconfig__MainOptions;
typedef struct v__pkgconfig__Options v__pkgconfig__Options;
typedef struct v__pkgconfig__PkgConfig v__pkgconfig__PkgConfig;
typedef struct term__ColorConfig term__ColorConfig;
typedef struct term__Coord term__Coord;
typedef struct term__KeyPressedParams term__KeyPressedParams;
typedef struct v__vmod__Manifest v__vmod__Manifest;
typedef struct v__vmod__Scanner v__vmod__Scanner;
typedef struct v__vmod__Parser v__vmod__Parser;
typedef struct v__vmod__Token v__vmod__Token;
typedef struct v__vmod__ModFileAndFolder v__vmod__ModFileAndFolder;
typedef struct v__vmod__ModFileCacher v__vmod__ModFileCacher;
typedef struct rand__config__PRNGConfigStruct rand__config__PRNGConfigStruct;
typedef struct rand__config__NormalConfigStruct rand__config__NormalConfigStruct;
typedef struct rand__config__ShuffleConfigStruct rand__config__ShuffleConfigStruct;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct rand__UUIDSession rand__UUIDSession;
typedef struct v__pref__LineInfo v__pref__LineInfo;
typedef struct v__pref__Preferences v__pref__Preferences;
typedef struct sync__Subscription sync__Subscription;
typedef struct sync__Channel sync__Channel;
typedef struct sync__Cond sync__Cond;
typedef struct sync__ManyTimes sync__ManyTimes;
typedef struct sync__Once sync__Once;
typedef struct sync__SpinLock sync__SpinLock;
typedef struct sync__Mutex sync__Mutex;
typedef struct sync__RwMutex sync__RwMutex;
typedef struct sync__RwMutexAttr sync__RwMutexAttr;
typedef struct sync__CondAttr sync__CondAttr;
typedef struct sync__Semaphore sync__Semaphore;
typedef struct sync__ThreadLocalStorage sync__ThreadLocalStorage;
typedef struct sync__WaitGroup sync__WaitGroup;
typedef struct v__util__EManager v__util__EManager;
typedef struct v__util__LinesCache v__util__LinesCache;
typedef struct v__util__JsonError v__util__JsonError;
typedef struct v__util__Possibility v__util__Possibility;
typedef struct v__util__Suggestion v__util__Suggestion;
typedef struct v__util__SuggestionParams v__util__SuggestionParams;
typedef struct v__util__Surrounder v__util__Surrounder;
typedef struct v__util__Timers v__util__Timers;
typedef struct v__util__TimerParams v__util__TimerParams;
typedef struct v__util__SourceCache v__util__SourceCache;
typedef struct v__ast__EmptyScopeObject v__ast__EmptyScopeObject;
typedef struct v__ast__TypeNode v__ast__TypeNode;
typedef struct v__ast__ComptimeType v__ast__ComptimeType;
typedef struct v__ast__EmptyStmt v__ast__EmptyStmt;
typedef struct v__ast__EmptyNode v__ast__EmptyNode;
typedef struct v__ast__Block v__ast__Block;
typedef struct v__ast__ExprStmt v__ast__ExprStmt;
typedef struct v__ast__IntegerLiteral v__ast__IntegerLiteral;
typedef struct v__ast__FloatLiteral v__ast__FloatLiteral;
typedef struct v__ast__StringLiteral v__ast__StringLiteral;
typedef struct v__ast__StringInterLiteral v__ast__StringInterLiteral;
typedef struct v__ast__CharLiteral v__ast__CharLiteral;
typedef struct v__ast__BoolLiteral v__ast__BoolLiteral;
typedef struct v__ast__Nil v__ast__Nil;
typedef struct v__ast__SelectorExpr v__ast__SelectorExpr;
typedef struct v__ast__Module v__ast__Module;
typedef struct v__ast__SemicolonStmt v__ast__SemicolonStmt;
typedef struct v__ast__StructField v__ast__StructField;
typedef struct v__ast__ConstField v__ast__ConstField;
typedef struct v__ast__ConstDecl v__ast__ConstDecl;
typedef struct v__ast__StructDecl v__ast__StructDecl;
typedef struct v__ast__Embed v__ast__Embed;
typedef struct v__ast__InterfaceEmbedding v__ast__InterfaceEmbedding;
typedef struct v__ast__InterfaceDecl v__ast__InterfaceDecl;
typedef struct v__ast__StructInitField v__ast__StructInitField;
typedef struct v__ast__StructInit v__ast__StructInit;
typedef struct v__ast__Import v__ast__Import;
typedef struct v__ast__ImportSymbol v__ast__ImportSymbol;
typedef struct v__ast__AnonFn v__ast__AnonFn;
typedef struct v__ast__FnDecl v__ast__FnDecl;
typedef struct v__ast__FnTrace v__ast__FnTrace;
typedef struct v__ast__Fn v__ast__Fn;
typedef struct v__ast__Param v__ast__Param;
typedef struct v__ast__BranchStmt v__ast__BranchStmt;
typedef struct v__ast__CallExpr v__ast__CallExpr;
typedef struct v__ast__CallArg v__ast__CallArg;
typedef struct v__ast__Return v__ast__Return;
typedef struct v__ast__Var v__ast__Var;
typedef struct v__ast__ScopeStructField v__ast__ScopeStructField;
typedef struct v__ast__GlobalField v__ast__GlobalField;
typedef struct v__ast__GlobalDecl v__ast__GlobalDecl;
typedef struct v__ast__EmbeddedFile v__ast__EmbeddedFile;
typedef struct v__ast__TemplateLineInfo v__ast__TemplateLineInfo;
typedef struct v__ast__File v__ast__File;
typedef struct v__ast__IdentFn v__ast__IdentFn;
typedef struct v__ast__IdentVar v__ast__IdentVar;
typedef struct v__ast__Ident v__ast__Ident;
typedef struct v__ast__InfixExpr v__ast__InfixExpr;
typedef struct v__ast__PostfixExpr v__ast__PostfixExpr;
typedef struct v__ast__PrefixExpr v__ast__PrefixExpr;
typedef struct v__ast__IndexExpr v__ast__IndexExpr;
typedef struct v__ast__IfExpr v__ast__IfExpr;
typedef struct v__ast__IfBranch v__ast__IfBranch;
typedef struct v__ast__UnsafeExpr v__ast__UnsafeExpr;
typedef struct v__ast__LockExpr v__ast__LockExpr;
typedef struct v__ast__MatchExpr v__ast__MatchExpr;
typedef struct v__ast__MatchBranch v__ast__MatchBranch;
typedef struct v__ast__SelectExpr v__ast__SelectExpr;
typedef struct v__ast__SelectBranch v__ast__SelectBranch;
typedef struct v__ast__ComptimeFor v__ast__ComptimeFor;
typedef struct v__ast__ForStmt v__ast__ForStmt;
typedef struct v__ast__ForInStmt v__ast__ForInStmt;
typedef struct v__ast__ForCStmt v__ast__ForCStmt;
typedef struct v__ast__HashStmt v__ast__HashStmt;
typedef struct v__ast__AssignStmt v__ast__AssignStmt;
typedef struct v__ast__AsCast v__ast__AsCast;
typedef struct v__ast__EnumVal v__ast__EnumVal;
typedef struct v__ast__EnumField v__ast__EnumField;
typedef struct v__ast__EnumDecl v__ast__EnumDecl;
typedef struct v__ast__AliasTypeDecl v__ast__AliasTypeDecl;
typedef struct v__ast__SumTypeDecl v__ast__SumTypeDecl;
typedef struct v__ast__FnTypeDecl v__ast__FnTypeDecl;
typedef struct v__ast__DeferStmt v__ast__DeferStmt;
typedef struct v__ast__ParExpr v__ast__ParExpr;
typedef struct v__ast__GoExpr v__ast__GoExpr;
typedef struct v__ast__SpawnExpr v__ast__SpawnExpr;
typedef struct v__ast__GotoLabel v__ast__GotoLabel;
typedef struct v__ast__GotoStmt v__ast__GotoStmt;
typedef struct v__ast__ArrayInit v__ast__ArrayInit;
typedef struct v__ast__ArrayDecompose v__ast__ArrayDecompose;
typedef struct v__ast__ChanInit v__ast__ChanInit;
typedef struct v__ast__MapInit v__ast__MapInit;
typedef struct v__ast__RangeExpr v__ast__RangeExpr;
typedef struct v__ast__CastExpr v__ast__CastExpr;
typedef struct v__ast__AsmStmt v__ast__AsmStmt;
typedef struct v__ast__AsmTemplate v__ast__AsmTemplate;
typedef struct v__ast__AsmRegister v__ast__AsmRegister;
typedef struct v__ast__AsmDisp v__ast__AsmDisp;
typedef struct v__ast__AsmAlias v__ast__AsmAlias;
typedef struct v__ast__AsmAddressing v__ast__AsmAddressing;
typedef struct v__ast__AsmClobbered v__ast__AsmClobbered;
typedef struct v__ast__AsmIO v__ast__AsmIO;
typedef struct v__ast__DebuggerStmt v__ast__DebuggerStmt;
typedef struct v__ast__AssertStmt v__ast__AssertStmt;
typedef struct v__ast__IfGuardVar v__ast__IfGuardVar;
typedef struct v__ast__IfGuardExpr v__ast__IfGuardExpr;
typedef struct v__ast__OrExpr v__ast__OrExpr;
typedef struct v__ast__Assoc v__ast__Assoc;
typedef struct v__ast__SizeOf v__ast__SizeOf;
typedef struct v__ast__IsRefType v__ast__IsRefType;
typedef struct v__ast__OffsetOf v__ast__OffsetOf;
typedef struct v__ast__LambdaExpr v__ast__LambdaExpr;
typedef struct v__ast__Likely v__ast__Likely;
typedef struct v__ast__TypeOf v__ast__TypeOf;
typedef struct v__ast__DumpExpr v__ast__DumpExpr;
typedef struct v__ast__Comment v__ast__Comment;
typedef struct v__ast__ConcatExpr v__ast__ConcatExpr;
typedef struct v__ast__AtExpr v__ast__AtExpr;
typedef struct v__ast__ComptimeSelector v__ast__ComptimeSelector;
typedef struct v__ast__ComptimeCall v__ast__ComptimeCall;
typedef struct v__ast__None v__ast__None;
typedef struct v__ast__SqlStmt v__ast__SqlStmt;
typedef struct v__ast__SqlStmtLine v__ast__SqlStmtLine;
typedef struct v__ast__JoinClause v__ast__JoinClause;
typedef struct v__ast__SqlExpr v__ast__SqlExpr;
typedef struct v__ast__NodeError v__ast__NodeError;
typedef struct v__ast__CTempVar v__ast__CTempVar;
typedef struct v__ast__Attr v__ast__Attr;
typedef struct v__ast__Scope v__ast__Scope;
typedef struct v__ast__StringifyModReplacement v__ast__StringifyModReplacement;
typedef struct v__ast__UsedFeatures v__ast__UsedFeatures;
typedef struct v__ast__Table v__ast__Table;
typedef struct v__ast__ComptTimeCondResult v__ast__ComptTimeCondResult;
typedef struct v__ast__VlsInfo v__ast__VlsInfo;
typedef struct v__ast__GetEmbedsOptions v__ast__GetEmbedsOptions;
typedef struct v__ast__UnknownTypeInfo v__ast__UnknownTypeInfo;
typedef struct v__ast__TypeSymbol v__ast__TypeSymbol;
typedef struct v__ast__MultiReturn v__ast__MultiReturn;
typedef struct v__ast__FnType v__ast__FnType;
typedef struct v__ast__Struct v__ast__Struct;
typedef struct v__ast__GenericInst v__ast__GenericInst;
typedef struct v__ast__Interface v__ast__Interface;
typedef struct v__ast__Enum v__ast__Enum;
typedef struct v__ast__Alias v__ast__Alias;
typedef struct v__ast__Aggregate v__ast__Aggregate;
typedef struct v__ast__Array v__ast__Array;
typedef struct v__ast__ArrayFixed v__ast__ArrayFixed;
typedef struct v__ast__Chan v__ast__Chan;
typedef struct v__ast__Thread v__ast__Thread;
typedef struct v__ast__Map v__ast__Map;
typedef struct v__ast__SumType v__ast__SumType;
typedef struct v__ast__FnSignatureOpts v__ast__FnSignatureOpts;
typedef struct v__scanner__Scanner v__scanner__Scanner;
typedef struct v__scanner__DecodedEscape v__scanner__DecodedEscape;
typedef struct v__transformer__KeyVal v__transformer__KeyVal;
typedef struct v__transformer__IndexState v__transformer__IndexState;
typedef struct v__transformer__Transformer v__transformer__Transformer;
typedef struct v__parser__ReceiverParsingInfo v__parser__ReceiverParsingInfo;
typedef struct v__parser__ParamsForUnexpected v__parser__ParamsForUnexpected;
typedef struct v__parser__Parser v__parser__Parser;
typedef struct v__parser__EatCommentsConfig v__parser__EatCommentsConfig;
typedef struct v__parser__DependencyCache v__parser__DependencyCache;
typedef struct v__parser__IncludeError v__parser__IncludeError;
typedef struct vphp__compiler__PhpClassRepr vphp__compiler__PhpClassRepr;
typedef struct vphp__compiler__PhpClassConst vphp__compiler__PhpClassConst;
typedef struct vphp__compiler__PhpClassProp vphp__compiler__PhpClassProp;
typedef struct vphp__compiler__PhpMethodRepr vphp__compiler__PhpMethodRepr;
typedef struct vphp__compiler__PhpArg vphp__compiler__PhpArg;
typedef struct vphp__compiler__PhpConstRepr vphp__compiler__PhpConstRepr;
typedef struct vphp__compiler__PhpFuncRepr vphp__compiler__PhpFuncRepr;
typedef struct vphp__compiler__Compiler vphp__compiler__Compiler;
typedef struct vphp__compiler__PhpTaskRepr vphp__compiler__PhpTaskRepr;
typedef struct main__Coach main__Coach;
typedef struct main__Database main__Database;
typedef struct main__MotionReport main__MotionReport;
typedef struct main__HeartPoint main__HeartPoint;
typedef struct main__StockParams main__StockParams;
typedef struct main__AnalyzeTask main__AnalyzeTask;
typedef struct main__Article main__Article;
typedef struct __shared__Map_u64_string __shared__Map_u64_string;
typedef struct __shared__Map_string_time__StopWatch __shared__Map_string_time__StopWatch;
typedef struct __shared__Map_int_Array_v__ast__Type __shared__Map_int_Array_v__ast__Type;
typedef struct _result_int _result_int;
typedef struct _result_f64 _result_f64;
typedef struct _result_u64 _result_u64;
typedef struct _result_i64 _result_i64;
typedef struct _result_multi_return_i64_int _result_multi_return_i64_int;
typedef struct _result_i8 _result_i8;
typedef struct _result_i16 _result_i16;
typedef struct _result_i32 _result_i32;
typedef struct _result_u8 _result_u8;
typedef struct _result_u16 _result_u16;
typedef struct _result_u32 _result_u32;
typedef struct _result_void _result_void;
typedef struct _result_rune _result_rune;
typedef struct _result_string _result_string;
typedef struct _result_voidptr _result_voidptr;
typedef struct _result_Array_string _result_Array_string;
typedef struct _result_time__Time _result_time__Time;
typedef struct _result_multi_return_int_int_int_int _result_multi_return_int_int_int_int;
typedef struct _result_multi_return_int_int_int _result_multi_return_int_int_int;
typedef struct _result_multi_return_int_int_int_int_int_i64_bool _result_multi_return_int_int_int_int_int_i64_bool;
typedef struct _result_bool _result_bool;
typedef struct _result_flag__Flag _result_flag__Flag;
typedef struct _result_semver__Range _result_semver__Range;
typedef struct _result_semver__Version _result_semver__Version;
typedef struct _result_semver__ComparatorSet _result_semver__ComparatorSet;
typedef struct _result_vphp__Val _result_vphp__Val;
typedef struct _result_os__Command _result_os__Command;
typedef struct _result_os__File _result_os__File;
typedef struct _result_FILE_ptr _result_FILE_ptr;
typedef struct _result_os__Stat _result_os__Stat;
typedef struct _result_Array_u8 _result_Array_u8;
typedef struct _result_strings__Builder _result_strings__Builder;
typedef struct _result_os__Result _result_os__Result;
typedef struct _result_os__DiskUsage _result_os__DiskUsage;
typedef struct _result_os__Pipe _result_os__Pipe;
typedef struct _result_os__IOCapture _result_os__IOCapture;
typedef struct _result_anon_fn_os__signal _result_anon_fn_os__signal;
typedef struct _result_v__pkgconfig__PkgConfig_ptr _result_v__pkgconfig__PkgConfig_ptr;
typedef struct _result_v__pkgconfig__Main_ptr _result_v__pkgconfig__Main_ptr;
typedef struct _result_term__Coord _result_term__Coord;
typedef struct _result_usize _result_usize;
typedef struct _result_v__vmod__Manifest _result_v__vmod__Manifest;
typedef struct _result_multi_return_Array_string_int _result_multi_return_Array_string_int;
typedef struct _result_f32 _result_f32;
typedef struct _result_multi_return_f64_f64 _result_multi_return_f64_f64;
typedef struct _result_v__pref__Arch _result_v__pref__Arch;
typedef struct _result_v__pref__OS _result_v__pref__OS;
typedef struct _result_v__pref__Subsystem _result_v__pref__Subsystem;
typedef struct _result_v__pref__Backend _result_v__pref__Backend;
typedef struct _result_v__ast__Fn _result_v__ast__Fn;
typedef struct _result_multi_return_v__ast__Fn_Array_v__ast__Type _result_multi_return_v__ast__Fn_Array_v__ast__Type;
typedef struct _result_v__ast__StructField _result_v__ast__StructField;
typedef struct _result_multi_return_v__ast__StructField_Array_v__ast__Type _result_multi_return_v__ast__StructField_Array_v__ast__Type;
typedef struct _result_v__scanner__Scanner_ptr _result_v__scanner__Scanner_ptr;
typedef struct _result_v__ast__Expr _result_v__ast__Expr;
typedef struct _result_main__StockParams _result_main__StockParams;
typedef struct _option_rune _option_rune;
typedef struct _option_multi_return_string_string _option_multi_return_string_string;
typedef struct _option_int _option_int;
typedef struct _option_u8 _option_u8;
typedef struct _option_semver__Version _option_semver__Version;
typedef struct _option_semver__ComparatorSet _option_semver__ComparatorSet;
typedef struct _option_semver__Comparator _option_semver__Comparator;
typedef struct _option_anon_fn_string__vphp__ITask _option_anon_fn_string__vphp__ITask;
typedef struct _option_Array_string _option_Array_string;
typedef struct _option_time__StopWatch _option_time__StopWatch;
typedef struct _option_v__ast__Ident _option_v__ast__Ident;
typedef struct _option_v__ast__CallArg _option_v__ast__CallArg;
typedef struct _option_v__ast__Attr _option_v__ast__Attr;
typedef struct _option_i8 _option_i8;
typedef struct _option_i64 _option_i64;
typedef struct _option_i16 _option_i16;
typedef struct _option_i32 _option_i32;
typedef struct _option_voidptr _option_voidptr;
typedef struct _option_u64 _option_u64;
typedef struct _option_u16 _option_u16;
typedef struct _option_u32 _option_u32;
typedef struct _option_f32 _option_f32;
typedef struct _option_f64 _option_f64;
typedef struct _option_v__ast__ComptTimeConstValue _option_v__ast__ComptTimeConstValue;
typedef struct _option_v__ast__ScopeObject _option_v__ast__ScopeObject;
typedef struct _option_v__ast__ScopeStructField _option_v__ast__ScopeStructField;
typedef struct _option_v__ast__Var_ptr _option_v__ast__Var_ptr;
typedef struct _option_v__ast__GlobalField_ptr _option_v__ast__GlobalField_ptr;
typedef struct _option_v__ast__ConstField_ptr _option_v__ast__ConstField_ptr;
typedef struct _option_v__ast__Fn _option_v__ast__Fn;
typedef struct _option_v__ast__StructField _option_v__ast__StructField;
typedef struct _option_v__ast__TypeSymbol_ptr _option_v__ast__TypeSymbol_ptr;
typedef struct _option_Array_Array_v__ast__Type _option_Array_Array_v__ast__Type;
typedef struct _option_v__ast__Type _option_v__ast__Type;
typedef struct _option_v__token__Pos _option_v__token__Pos;
typedef struct _option_v__ast__EnumDecl _option_v__ast__EnumDecl;
typedef struct _option_v__ast__LambdaExpr _option_v__ast__LambdaExpr;
typedef struct _option_bool _option_bool;

 // V preincludes:

#if defined(__TINYC__) && defined(__has_include) // tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// V cheaders:
// Generated by the V compiler

#if defined __GNUC__ && __GNUC__ >= 14
#pragma GCC diagnostic warning "-Wimplicit-function-declaration"
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#pragma GCC diagnostic warning "-Wint-conversion"
#pragma GCC diagnostic warning "-Wreturn-mismatch"
#endif


#if defined(__TINYC__) && defined(__has_include) // tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)
#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install the package `build-essential`.
#endif
#else
#include <inttypes.h>
#endif


#if defined(__has_include)
#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install the package `build-essential`.
#endif
#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
#if defined(__x86_64__) || defined(_M_AMD64) || defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64) || (defined(__riscv_xlen) && __riscv_xlen == 64) || defined(__s390x__) || (defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)) || defined(__loongarch64)
typedef int64_t vint_t;
#else
typedef int32_t vint_t;
#endif
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef u8 byte;
typedef int32_t i32;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];
typedef struct sync__Channel* chan;
#ifndef CUSTOM_DEFINE_no_bool
	#ifndef __cplusplus
		#ifndef bool
			#ifdef CUSTOM_DEFINE_4bytebool
				typedef int bool;
			#else
				typedef u8 bool;
			#endif
			#define true 1
			#define false 0
		#endif
	#endif
#endif


typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _S(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})
// optimized way to compare literal strings
#define _SLIT_EQ(sptr, slen, lit) (slen == sizeof("" lit)-1 && !builtin__vmemcmp(sptr, "" lit, slen))
#define _SLIT_NE(sptr, slen, lit) (slen != sizeof("" lit)-1 || builtin__vmemcmp(sptr, "" lit, slen))
// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))
// copy something to the heap
#define HEAP(type, expr) ((type*)builtin__memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)builtin__memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_align(type, expr, align) ((type*)builtin__memdup_align((void*)&((type[]){expr}[0]), sizeof(type), align))
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); builtin__array_push_many_noscan(arr, tmp.data, tmp.len);}

#define E_STRUCT_DECL
#define E_STRUCT
#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))
#define __V_architecture 0
#if defined(__x86_64__) || defined(_M_AMD64)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif
#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif
#if defined(__arm__) || defined(_M_ARM)
	#define __V_arm32  1
	#undef __V_architecture
	#define __V_architecture 3
#endif
#if defined(__riscv) && __riscv_xlen == 64
	#define __V_rv64  1
	#undef __V_architecture
	#define __V_architecture 4
#endif
#if defined(__riscv) && __riscv_xlen == 32
	#define __V_rv32  1
	#undef __V_architecture
	#define __V_architecture 5
#endif
#if defined(__i386__) || defined(_M_IX86)
	#define __V_x86    1
	#undef __V_architecture
	#define __V_architecture 6
#endif
#if defined(__s390x__)
	#define __V_s390x  1
	#undef __V_architecture
	#define __V_architecture 7
#endif
#if defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)
	#define __V_ppc64le  1
	#undef __V_architecture
	#define __V_architecture 8
#endif
#if defined(__loongarch64)
	#define __V_loongarch64  1
	#undef __V_architecture
	#define __V_architecture 9
#endif
// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
#endif
#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// On linux: int backtrace(void **__array, int __size);
			// On BSD: size_t backtrace(void **, size_t);
		#endif
	#endif
#endif
#ifdef __TINYC__
	#define _Atomic volatile
	#undef E_STRUCT_DECL
	#undef E_STRUCT
	#define E_STRUCT_DECL unsigned char _dummy_pad
	#define E_STRUCT 0
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	// #include <byteswap.h>
	int tcc_backtrace(const char *fmt, ...);
#endif
// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif
// for __offset_of
#ifndef __offsetof
#if defined(__TINYC__) || defined(_MSC_VER)
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)(&((PTYPE *)0)->FIELDNAME))
#else
	#define __offsetof(st, m) __builtin_offsetof(st, m)
#endif
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXP extern __declspec(dllexport)
	#define VV_LOC static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXP  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXP  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOC static
		#else
			#define VV_LOC  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXP extern
		#define VV_LOC static
	#endif
#endif
#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif
#if defined(__TINYC__) && defined(__has_include) // tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif
//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif

// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO: remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>
#include <stdarg.h> // for va_list
#if defined(__TINYC__)
// https://lists.nongnu.org/archive/html/tinycc-devel/2025-10/msg00007.html
// gnu headers use to #define __attribute__ to empty for non-gcc compilers
#undef __attribute__
#endif
//================================== GLOBALS =================================*/
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#ifdef _WIN32
	// workaround for windows, export _vinit_caller/_vcleanup_caller, let dl.open()/dl.close() call it
	// NOTE: This is hardcoded in vlib/dl/dl_windows.c.v!
	VV_EXP void _vinit_caller();
	VV_EXP void _vcleanup_caller();
#endif
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )
#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_ARM64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif
#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif
#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun) || defined(__plan9__) || defined(__OpenBSD__)
	#include <sys/types.h>
	#include <sys/wait.h> // for os__wait
#endif
#ifdef __OpenBSD__
	#include <sys/resource.h>
#endif
#ifdef __FreeBSD__
	#include <signal.h>
	#include <execinfo.h>
#endif
#ifdef __NetBSD__
	#include <sys/wait.h> // for os__wait
#endif
#ifdef __TERMUX__
#if !defined(__BIONIC_AVAILABILITY_GUARD)
	#define __BIONIC_AVAILABILITY_GUARD(api_level) 0
#endif
#if __BIONIC_AVAILABILITY_GUARD(28)
#else
void * aligned_alloc(size_t alignment, size_t size) { return malloc(size); }
#endif
#endif
#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>
	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#ifdef V_USE_SIGNAL_H
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler
	#endif
	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile
		// MSVC cannot parse some things properly
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)
		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#endif
#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif
#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif
#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }


#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif !defined(VNORETURN) && defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif


#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L) && !defined(__TINYC__)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin) && !defined(__TINYC__)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif


#ifndef wyhash_final_version_4_2
#define wyhash_final_version_4_2
#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif
#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif
// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif
// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__) && !defined(VWASM)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}
// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }
// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif
// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif !defined(__TINYC__) && (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=_wymix(seed^secret[0],secret[1]);	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>=48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>=48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	a^=secret[1]; b^=seed;  _wymum(&a,&b);
	return  _wymix(a^secret[0]^len,b^secret[1]);
}
// the default secret parameters
static const uint64_t _wyp[4] = {0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull, 0x4d5a2da51de1aa47ull};
// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0x2d358dccaa6c78a5ull; B^=0x8bb84b93962eacc9ull; _wymum(&A,&B); return _wymix(A^0x2d358dccaa6c78a5ull,B^0x8bb84b93962eacc9ull);}
// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0x2d358dccaa6c78a5ull; return _wymix(*seed,*seed^0x8bb84b93962eacc9ull);}
#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}
// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif
#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif
#define _IN_MAP(val, m) builtin__map_exists(m, val)


// V includes:

#if defined(__TINYC__) && defined(__has_include) // tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if !defined(_VFREESTANDING) && !defined(__vinix__)

// added by module `builtin.closure`, file: closure_nix.c.v:4:

#if defined(__has_include)
#if __has_include(<sys/mman.h>)
#include <sys/mman.h>
#else
#error VERROR_MESSAGE Header file <sys/mman.h>, needed for module `builtin.closure` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/mman.h>
#endif

#endif

#if !defined(_VNATIVE)

// added by module `builtin`, file: float.c.v:10:

#if defined(__has_include)
#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif
#else
#include <float.h>
#endif

#endif

// added by module `json`, file: json_primitives.c.v:8:

#if defined(__has_include)
#if __has_include("cJSON.h")
#include "cJSON.h"
#else
#error VERROR_MESSAGE Header file "cJSON.h", needed for module `json` was not found. Please install the corresponding development headers.
#endif
#else
#include "cJSON.h"
#endif

// defined by module `json`
#define js_get(object, key) cJSON_GetObjectItemCaseSensitive((object), (key))

// added by module `vphp.zend`, file: mod.v:3:

#if defined(__has_include)
#if __has_include(<php.h>)
#include <php.h>
#else
#error VERROR_MESSAGE Header file <php.h>, needed for module `vphp.zend` was not found. Please install the corresponding development headers.
#endif
#else
#include <php.h>
#endif


// added by module `vphp.zend`, file: mod.v:4:

#if defined(__has_include)
#if __has_include("v_bridge.h")
#include "v_bridge.h"
#else
#error VERROR_MESSAGE Header file "v_bridge.h", needed for module `vphp.zend` was not found. Please install the corresponding development headers.
#endif
#else
#include "v_bridge.h"
#endif


// added by module `vphp.zend`, file: types.v:3:

#if defined(__has_include)
#if __has_include(<php.h>)
#include <php.h>
#else
#error VERROR_MESSAGE Header file <php.h>, needed for module `vphp.zend` was not found. Please install the corresponding development headers.
#endif
#else
#include <php.h>
#endif


// added by module `term.termios`, file: termios_darwin.c.v:10:

#if defined(__has_include)
#if __has_include(<termios.h>)
#include <termios.h>
#else
#error VERROR_MESSAGE Header file <termios.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif
#else
#include <termios.h>
#endif


// added by module `term.termios`, file: termios_darwin.c.v:11:

#if defined(__has_include)
#if __has_include(<sys/ioctl.h>)
#include <sys/ioctl.h>
#else
#error VERROR_MESSAGE Header file <sys/ioctl.h>, needed for module `term.termios` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/ioctl.h>
#endif


#if defined(_WIN32)
#else

// inserted by module `sync.stdatomic`, file: 1.declarations.c.v:11:
/*
    Compatibility header for stdatomic.h that works for all compilers supported by V.
    For TCC, we use libatomic from the OS.
*/
#ifndef __ATOMIC_H
#define __ATOMIC_H

#ifndef __cplusplus
// If C just use stdatomic.h
#ifndef __TINYC__
#include <stdatomic.h>
#endif
#else
// CPP wrapper for atomic operations that are compatible with C
#include "atomic_cpp.h"
#endif

#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
    /* x86 architecture: uses PAUSE instruction for efficient spinning */
    #define cpu_relax() __asm__ __volatile__ ("pause")
#elif defined(__aarch64__) || defined(_M_ARM64) || defined(__arm__) || defined(_M_ARM)
    #if defined(__TINYC__)
        /* TCC compiler limitation: assembly not supported on ARM */
        #define cpu_relax()
    #else
        /* ARM architecture: uses YIELD instruction for power-efficient spinning */
        #define cpu_relax() __asm__ __volatile__ ("yield" ::: "memory")
    #endif
#elif defined(__riscv) && __riscv_xlen == 64
    /* RISC-V 64-bit: no dedicated pause instruction, using alternative sequence */
    #define cpu_relax() __asm__ __volatile__ ( \
        "fence rw, rw\n\t"   /* Full memory barrier (read-write ordering) */ \
        "andi a0, a0, 0\n\t" /* Dummy arithmetic instruction (always sets a0 = 0) */ \
        ::: "memory", "a0")  /* Clobbers memory and a0 register to prevent optimizations */
#elif defined(__powerpc64__) || defined(__ppc64__)
    /* PowerPC 64-bit: use OR instruction for synchronization */
    #define cpu_relax() __asm__ __volatile__ ("or 1,1,1\n\t" ::: "memory")
#elif defined(__mips64)
    /* MIPS 64-bit: use series of super-scalar NOPs */
    #define cpu_relax() __asm__ __volatile__ ("ssnop\n\tssnop\n\tssnop\n\t" ::: "memory")
#else
    /* Fallback implementation for unsupported architectures */
    #define cpu_relax() __asm__ __volatile__ ( \
        "nop\n\t" "nop\n\t" "nop\n\t" "nop\n\t" /* Series of no-operation instructions */ \
        ::: "memory") /* Memory clobber to prevent instruction reordering */
#endif

#ifdef __TINYC__

typedef volatile long long atomic_llong;
typedef volatile unsigned long long atomic_ullong;
typedef volatile uintptr_t atomic_uintptr_t;

extern void atomic_thread_fence (int memory_order);
extern void __atomic_thread_fence (int memory_order);

// workaround for tcc/aarch64; Note: latest prebuilt tcc works, and does not need this hack:
#if !defined(__APPLE__)
#if (defined(__aarch64__) || defined(_M_ARM64))
    // `_V_atomic_thread_fence` is defined in `atomic.S`
    extern void _V_atomic_thread_fence(int memory_order);
    #define atomic_thread_fence(order) _V_atomic_thread_fence(order)
    #define __atomic_thread_fence(order) _V_atomic_thread_fence(order)
#else
    #define atomic_thread_fence(order) __atomic_thread_fence(order)
#endif
#endif

// use functions for 64, 32 and 8 bit from libatomic directly
// since tcc is not capible to use "generic" C functions
// there is no header file for libatomic so we provide function declarations here

extern unsigned long long __atomic_load_8(unsigned long long* x, int mo);
extern void __atomic_store_8(unsigned long long* x, unsigned long long y, int mo);
extern _Bool __atomic_compare_exchange_8(unsigned long long* x, unsigned long long* expected, unsigned long long y, int mo, int mo2);
extern unsigned long long __atomic_exchange_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_add_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_sub_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_and_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_or_8(unsigned long long* x, unsigned long long y, int mo);
extern unsigned long long __atomic_fetch_xor_8(unsigned long long* x, unsigned long long y, int mo);

extern unsigned int __atomic_load_4(unsigned int* x, int mo);
extern void __atomic_store_4(unsigned int* x, unsigned int y, int mo);
extern _Bool __atomic_compare_exchange_4(unsigned int* x, unsigned int* expected, unsigned int y, int mo, int mo2);
extern unsigned int __atomic_exchange_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_add_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_sub_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_and_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_or_4(unsigned int* x, unsigned int y, int mo);
extern unsigned int __atomic_fetch_xor_4(unsigned int* x, unsigned int y, int mo);

extern unsigned short __atomic_load_2(unsigned short* x, int mo);
extern void __atomic_store_2(unsigned short* x, unsigned short y, int mo);
extern _Bool __atomic_compare_exchange_2(unsigned short* x, unsigned short* expected, unsigned short y, int mo, int mo2);
extern unsigned short __atomic_exchange_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_add_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_sub_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_and_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_or_2(unsigned short* x, unsigned short y, int mo);
extern unsigned short __atomic_fetch_xor_2(unsigned short* x, unsigned short y, int mo);

extern unsigned char __atomic_load_1(unsigned char* x, int mo);
extern void __atomic_store_1(unsigned char* x, unsigned char y, int mo);
extern _Bool __atomic_compare_exchange_1(unsigned char* x, unsigned char* expected, unsigned char y, int mo, int mo2);
extern unsigned char __atomic_exchange_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_add_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_sub_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_and_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_or_1(unsigned char* x, unsigned char y, int mo);
extern unsigned char __atomic_fetch_xor_1(unsigned char* x, unsigned char y, int mo);

// The default functions should work with pointers so we have to decide based on pointer size
#if UINTPTR_MAX == 0xFFFFFFFF

#define atomic_load_explicit __atomic_load_4
#define atomic_store_explicit __atomic_store_4
#define atomic_compare_exchange_weak_explicit __atomic_compare_exchange_4
#define atomic_compare_exchange_strong_explicit __atomic_compare_exchange_4
#define atomic_exchange_explicit __atomic_exchange_4
#define atomic_fetch_add_explicit __atomic_fetch_add_4
#define atomic_fetch_sub_explicit __atomic_sub_fetch_4


#else

#define atomic_load_explicit __atomic_load_8
#define atomic_store_explicit __atomic_store_8
#define atomic_compare_exchange_weak_explicit __atomic_compare_exchange_8
#define atomic_compare_exchange_strong_explicit __atomic_compare_exchange_8
#define atomic_exchange_explicit __atomic_exchange_8
#define atomic_fetch_add_explicit __atomic_fetch_add_8
#define atomic_fetch_sub_explicit __atomic_sub_fetch_8

#endif

// memory order policies - we use "sequentially consistent" by default

#define memory_order_relaxed 0
#define memory_order_consume 1
#define memory_order_acquire 2
#define memory_order_release 3
#define memory_order_acq_rel 4
#define memory_order_seq_cst 5

static inline void** atomic_load(void** x) {
	return (void**)atomic_load_explicit((unsigned long long*)x, memory_order_seq_cst);
}
static inline void atomic_store(void** x, void* y) {
	atomic_store_explicit((unsigned long long*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_weak_explicit((unsigned long long*)x, (unsigned long long*)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong(void** x,  void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_strong_explicit((unsigned long long*)x, (unsigned long long*)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline uintptr_t atomic_exchange(void** x, void* y) {
	return atomic_exchange_explicit((unsigned long long*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_add(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_add_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_sub(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_sub_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_and(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_and_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_or(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_or_explicit(x, y, memory_order_seq_cst);
}
static inline uintptr_t atomic_fetch_xor(uintptr_t* x, uintptr_t y) {
	return atomic_fetch_xor_explicit(x, y, memory_order_seq_cst);
}

#define atomic_load_ptr atomic_load
#define atomic_store_ptr atomic_store
#define atomic_compare_exchange_weak_ptr atomic_compare_exchange_weak
#define atomic_compare_exchange_strong_ptr atomic_compare_exchange_strong
#define atomic_exchange_ptr atomic_exchange
#define atomic_fetch_add_ptr atomic_fetch_add
#define atomic_fetch_sub_ptr atomic_fetch_sub
#define atomic_fetch_and_ptr atomic_fetch_and
#define atomic_fetch_or_ptr atomic_fetch_or
#define atomic_fetch_xor_ptr atomic_fetch_xor

// specialized versions for 64 bit

static inline unsigned long long atomic_load_u64(unsigned long long* x) {
	return __atomic_load_8(x, memory_order_seq_cst);
}
static inline void atomic_store_u64(unsigned long long* x, unsigned long long y) {
	__atomic_store_8(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)__atomic_compare_exchange_8(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u64(unsigned long long* x, unsigned long long* expected, unsigned long long y) {
	return (int)__atomic_compare_exchange_8(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned long long atomic_exchange_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_exchange_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_add_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_add_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_sub_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_sub_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_and_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_and_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_or_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_or_8(x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_xor_u64(unsigned long long* x, unsigned long long y) {
	return __atomic_fetch_xor_8(x, y, memory_order_seq_cst);
}

static inline unsigned atomic_load_u32(unsigned* x) {
	return __atomic_load_4(x, memory_order_seq_cst);
}
static inline void atomic_store_u32(unsigned* x, unsigned y) {
	__atomic_store_4(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)__atomic_compare_exchange_4(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)__atomic_compare_exchange_4(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned atomic_exchange_u32(unsigned* x, unsigned y) {
	return __atomic_exchange_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_add_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_add_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_sub_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_sub_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_and_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_and_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_or_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_or_4(x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_xor_u32(unsigned* x, unsigned y) {
	return __atomic_fetch_xor_4(x, y, memory_order_seq_cst);
}

static inline unsigned short atomic_load_u16(unsigned short* x) {
	return __atomic_load_2(x, memory_order_seq_cst);
}
static inline void atomic_store_u16(void* x, unsigned short y) {
	__atomic_store_2(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u16(void* x, unsigned short* expected, unsigned short y) {
	return (int)__atomic_compare_exchange_2(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u16(unsigned short* x, unsigned short* expected, unsigned short y) {
	return (int)__atomic_compare_exchange_2(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned short atomic_exchange_u16(unsigned short* x, unsigned short y) {
	return __atomic_exchange_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_add_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_add_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_sub_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_sub_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_and_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_and_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_or_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_or_2(x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_xor_u16(unsigned short* x, unsigned short y) {
	return __atomic_fetch_xor_2(x, y, memory_order_seq_cst);
}

static inline unsigned char atomic_load_byte(unsigned char* x) {
	return __atomic_load_1(x, memory_order_seq_cst);
}
static inline void atomic_store_byte(unsigned char* x, unsigned char y) {
	__atomic_store_1(x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return __atomic_compare_exchange_1(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return __atomic_compare_exchange_1(x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned char atomic_exchange_byte(unsigned char* x, unsigned char y) {
	return __atomic_exchange_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_add_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_add_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_sub_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_sub_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_and_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_and_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_or_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_or_1(x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_xor_byte(unsigned char* x, unsigned char y) {
	return __atomic_fetch_xor_1(x, y, memory_order_seq_cst);
}

#ifdef __aarch64__
// must has an `extern` to link with libatomic.a

// acq_rel version
extern inline _Bool __aarch64_cas1_acq_rel(unsigned char*ptr, unsigned char*expected, unsigned char desired) {
    return __atomic_compare_exchange_1(
        ptr,
        expected,
        desired,
		memory_order_acq_rel,
		memory_order_acquire
    );
}

extern inline _Bool __aarch64_cas2_acq_rel(unsigned short*ptr, unsigned short*expected, unsigned short desired) {
    return __atomic_compare_exchange_2(
        ptr,
        expected,
        desired,
		memory_order_acq_rel,
		memory_order_acquire
    );
}

extern inline _Bool __aarch64_cas4_acq_rel(unsigned int*ptr, unsigned int*expected, unsigned int desired) {
    return __atomic_compare_exchange_4(
        ptr,
        expected,
        desired,
        memory_order_acq_rel,
        memory_order_acquire
    );
}

extern inline _Bool __aarch64_cas8_acq_rel(unsigned long long*ptr, unsigned long long*expected, unsigned long long desired) {
    return __atomic_compare_exchange_8(
        ptr,
        expected,
        desired,
        memory_order_acq_rel,
        memory_order_acquire
    );
}

extern inline char __aarch64_ldadd1_acq_rel(char*ptr, char value) {
    return __atomic_fetch_add_1(
        (unsigned char*)ptr,
        (unsigned char)value,
        memory_order_acq_rel
    );
}

extern inline short __aarch64_ldadd2_acq_rel(short*ptr, short value) {
    return __atomic_fetch_add_2(
        (unsigned short*)ptr,
        (unsigned short)value,
        memory_order_acq_rel
    );
}

extern inline int __aarch64_ldadd4_acq_rel(int*ptr, int value) {
    return __atomic_fetch_add_4(
        (unsigned int*)ptr,
        (unsigned int)value,
        memory_order_acq_rel
    );
}

extern inline long long __aarch64_ldadd8_acq_rel(long long*ptr, long long value) {
    return __atomic_fetch_add_8(
        (unsigned long long*)ptr,
        (unsigned long long)value,
        memory_order_acq_rel
    );
}

extern inline unsigned char __aarch64_swp1_acq_rel(unsigned char*ptr, unsigned char newval) {
    return __atomic_exchange_1(
        ptr,
        newval,
        memory_order_acq_rel
    );
}

extern inline unsigned short __aarch64_swp2_acq_rel(unsigned short*ptr, unsigned short newval) {
    return __atomic_exchange_2(
        ptr,
        newval,
        memory_order_acq_rel
    );
}

extern inline unsigned int __aarch64_swp4_acq_rel(unsigned int*ptr, unsigned int newval) {
    return __atomic_exchange_4(
        ptr,
        newval,
        memory_order_acq_rel
    );
}

extern inline unsigned long long __aarch64_swp8_acq_rel(unsigned long long*ptr, unsigned long long newval) {
    return __atomic_exchange_8(
        ptr,
        newval,
        memory_order_acq_rel
    );
}

extern inline unsigned char __aarch64_ldclr1_acq_rel(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_and_1(
        ptr,
        ~mask,
        memory_order_acq_rel
    );
}

extern inline unsigned short __aarch64_ldclr2_acq_rel(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_and_2(
        ptr,
        ~mask,
        memory_order_acq_rel
    );
}

extern inline unsigned int __aarch64_ldclr4_acq_rel(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_and_4(
        ptr,
        ~mask,
        memory_order_acq_rel
    );
}

extern inline unsigned long long __aarch64_ldclr8_acq_rel(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_and_8(
        ptr,
        ~mask,
        memory_order_acq_rel
    );
}

extern inline unsigned char __aarch64_ldset1_acq_rel(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_or_1(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned short __aarch64_ldset2_acq_rel(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_or_2(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned int __aarch64_ldset4_acq_rel(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_or_4(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned long long __aarch64_ldset8_acq_rel(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_or_8(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned char __aarch64_ldeor1_acq_rel(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_xor_1(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned short __aarch64_ldeor2_acq_rel(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_xor_2(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned int __aarch64_ldeor4_acq_rel(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_xor_4(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

extern inline unsigned long long __aarch64_ldeor8_acq_rel(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_xor_8(
        ptr,
        mask,
        memory_order_acq_rel
    );
}

#define aarch64_cas_acq_rel(ptr, expected, desired)      \
    _Generic((ptr),                                      \
        char*:         __aarch64_cas1_acq_rel,  \
        short*:        __aarch64_cas2_acq_rel,  \
        int*:          __aarch64_cas4_acq_rel,  \
        long long*:    __aarch64_cas8_acq_rel   \
    )(ptr, expected, desired)

// relax version
extern inline _Bool __aarch64_cas1_relax(unsigned char*ptr, unsigned char*expected, unsigned char desired) {
    return __atomic_compare_exchange_1(
        ptr,
        expected,
        desired,
		memory_order_relaxed,
		memory_order_relaxed
    );
}

extern inline _Bool __aarch64_cas2_relax(unsigned short*ptr, unsigned short*expected, unsigned short desired) {
    return __atomic_compare_exchange_2(
        ptr,
        expected,
        desired,
		memory_order_relaxed,
		memory_order_relaxed
    );
}

extern inline _Bool __aarch64_cas4_relax(unsigned int*ptr, unsigned int*expected, unsigned int desired) {
    return __atomic_compare_exchange_4(
        ptr,
        expected,
        desired,
        memory_order_relaxed,
        memory_order_relaxed
    );
}

extern inline _Bool __aarch64_cas8_relax(unsigned long long*ptr, unsigned long long*expected, unsigned long long desired) {
    return __atomic_compare_exchange_8(
        ptr,
        expected,
        desired,
        memory_order_relaxed,
        memory_order_relaxed
    );
}

extern inline char __aarch64_ldadd1_relax(char*ptr, char value) {
    return __atomic_fetch_add_1(
        (unsigned char*)ptr,
        (unsigned char)value,
        memory_order_relaxed
    );
}

extern inline short __aarch64_ldadd2_relax(short*ptr, short value) {
    return __atomic_fetch_add_2(
        (unsigned short*)ptr,
        (unsigned short)value,
        memory_order_relaxed
    );
}

extern inline int __aarch64_ldadd4_relax(int*ptr, int value) {
    return __atomic_fetch_add_4(
        (unsigned int*)ptr,
        (unsigned int)value,
        memory_order_relaxed
    );
}

extern inline long long __aarch64_ldadd8_relax(long long*ptr, long long value) {
    return __atomic_fetch_add_8(
        (unsigned long long*)ptr,
        (unsigned long long)value,
        memory_order_relaxed
    );
}

extern inline unsigned char __aarch64_swp1_relax(unsigned char*ptr, unsigned char newval) {
    return __atomic_exchange_1(
        ptr,
        newval,
        memory_order_relaxed
    );
}

extern inline unsigned short __aarch64_swp2_relax(unsigned short*ptr, unsigned short newval) {
    return __atomic_exchange_2(
        ptr,
        newval,
        memory_order_relaxed
    );
}

extern inline unsigned int __aarch64_swp4_relax(unsigned int*ptr, unsigned int newval) {
    return __atomic_exchange_4(
        ptr,
        newval,
        memory_order_relaxed
    );
}

extern inline unsigned long long __aarch64_swp8_relax(unsigned long long*ptr, unsigned long long newval) {
    return __atomic_exchange_8(
        ptr,
        newval,
        memory_order_relaxed
    );
}

extern inline unsigned char __aarch64_ldclr1_relax(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_and_1(
        ptr,
        ~mask,
        memory_order_relaxed
    );
}

extern inline unsigned short __aarch64_ldclr2_relax(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_and_2(
        ptr,
        ~mask,
        memory_order_relaxed
    );
}

extern inline unsigned int __aarch64_ldclr4_relax(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_and_4(
        ptr,
        ~mask,
        memory_order_relaxed
    );
}

extern inline unsigned long long __aarch64_ldclr8_relax(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_and_8(
        ptr,
        ~mask,
        memory_order_relaxed
    );
}

extern inline unsigned char __aarch64_ldset1_relax(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_or_1(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned short __aarch64_ldset2_relax(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_or_2(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned int __aarch64_ldset4_relax(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_or_4(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned long long __aarch64_ldset8_relax(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_or_8(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned char __aarch64_ldeor1_relax(unsigned char*ptr, unsigned char mask) {
    return __atomic_fetch_xor_1(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned short __aarch64_ldeor2_relax(unsigned short*ptr, unsigned short mask) {
    return __atomic_fetch_xor_2(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned int __aarch64_ldeor4_relax(unsigned int*ptr, unsigned int mask) {
    return __atomic_fetch_xor_4(
        ptr,
        mask,
        memory_order_relaxed
    );
}

extern inline unsigned long long __aarch64_ldeor8_relax(unsigned long long*ptr, unsigned long long mask) {
    return __atomic_fetch_xor_8(
        ptr,
        mask,
        memory_order_relaxed
    );
}

#define aarch64_cas_relax(ptr, expected, desired)      \
    _Generic((ptr),                                      \
        char*:         __aarch64_cas1_relax,  \
        short*:        __aarch64_cas2_relax,  \
        int*:          __aarch64_cas4_relax,  \
        long long*:    __aarch64_cas8_relax   \
    )(ptr, expected, desired)

#endif // __aarch64__

#else

// Since V might be confused with "generic" C functions either we provide special versions
// for gcc/clang, too
static inline unsigned long long atomic_load_u64(uint64_t* x) {
	return atomic_load_explicit((_Atomic (uint64_t)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u64(uint64_t* x, uint64_t y) {
	atomic_store_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u64(uint64_t* x, uint64_t* expected, uint64_t y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(uint64_t)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u64(uint64_t* x, uint64_t* expected, uint64_t y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(uint64_t)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned long long atomic_exchange_u64(uint64_t* x, uint64_t y) {
	return atomic_exchange_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_add_u64(uint64_t* x, uint64_t y) {
	return atomic_fetch_add_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_sub_u64(uint64_t* x, uint64_t y) {
	return atomic_fetch_sub_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_and_u64(uint64_t* x, uint64_t y) {
	return atomic_fetch_and_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_or_u64(uint64_t* x, uint64_t y) {
	return atomic_fetch_or_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}
static inline unsigned long long atomic_fetch_xor_u64(uint64_t* x, uint64_t y) {
	return atomic_fetch_xor_explicit((_Atomic(uint64_t)*)x, y, memory_order_seq_cst);
}


static inline void* atomic_load_ptr(void** x) {
	return (void*)atomic_load_explicit((_Atomic(uintptr_t)*)x, memory_order_seq_cst);
}
static inline void atomic_store_ptr(void** x, void* y) {
	atomic_store_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_ptr(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(uintptr_t)*)x, (unsigned long *)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_ptr(void** x, void** expected, intptr_t y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(uintptr_t)*)x, (unsigned long *)expected, (uintptr_t)y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline void* atomic_exchange_ptr(void** x, void* y) {
	return (void*)atomic_exchange_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_add_ptr(void** x, void* y) {
	return (void*)atomic_fetch_add_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_sub_ptr(void** x, void* y) {
	return (void*)atomic_fetch_sub_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_and_ptr(void** x, void* y) {
	return (void*)atomic_fetch_and_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_or_ptr(void** x, void* y) {
	return (void*)atomic_fetch_or_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}
static inline void* atomic_fetch_xor_ptr(void** x, void* y) {
	return (void*)atomic_fetch_xor_explicit((_Atomic(uintptr_t)*)x, (uintptr_t)y, memory_order_seq_cst);
}


static inline unsigned atomic_load_u32(unsigned* x) {
	return atomic_load_explicit((_Atomic(unsigned)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u32(unsigned* x, unsigned y) {
	atomic_store_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u32(unsigned* x, unsigned* expected, unsigned y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned atomic_exchange_u32(unsigned* x, unsigned y) {
	return atomic_exchange_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_add_u32(unsigned* x, unsigned y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_sub_u32(unsigned* x, unsigned y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_and_u32(unsigned* x, unsigned y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_or_u32(unsigned* x, unsigned y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}
static inline unsigned atomic_fetch_xor_u32(unsigned* x, unsigned y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned)*)x, y, memory_order_seq_cst);
}

static inline unsigned short atomic_load_u16(unsigned short* x) {
	return atomic_load_explicit((_Atomic(unsigned short)*)x, memory_order_seq_cst);
}
static inline void atomic_store_u16(void* x, unsigned short y) {
	atomic_store_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_u16(void* x, unsigned short* expected, unsigned short y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned short)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_u16(unsigned short* x, unsigned short* expected, unsigned short y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned short)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned short atomic_exchange_u16(unsigned short* x, unsigned short y) {
	return atomic_exchange_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_add_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_sub_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_and_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_or_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}
static inline unsigned short atomic_fetch_xor_u16(unsigned short* x, unsigned short y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned short)*)x, y, memory_order_seq_cst);
}

static inline unsigned char atomic_load_byte(unsigned char* x) {
	return atomic_load_explicit((_Atomic(unsigned char)*)x, memory_order_seq_cst);
}
static inline void atomic_store_byte(unsigned char* x, unsigned char y) {
	atomic_store_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_weak_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return (int)atomic_compare_exchange_weak_explicit((_Atomic(unsigned char)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline int atomic_compare_exchange_strong_byte(unsigned char* x, unsigned char* expected, unsigned char y) {
	return (int)atomic_compare_exchange_strong_explicit((_Atomic(unsigned char)*)x, expected, y, memory_order_seq_cst, memory_order_seq_cst);
}
static inline unsigned char atomic_exchange_byte(unsigned char* x, unsigned char y) {
	return atomic_exchange_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_add_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_add_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_sub_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_sub_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_and_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_and_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_or_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_or_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}
static inline unsigned char atomic_fetch_xor_byte(unsigned char* x, unsigned char y) {
	return atomic_fetch_xor_explicit((_Atomic(unsigned char)*)x, y, memory_order_seq_cst);
}

#endif
#endif

#endif

// added by module `time`, file: time.c.v:6:

#if defined(__has_include)
#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif
#else
#include <time.h>
#endif


// added by module `time`, file: time_darwin.c.v:3:

#if defined(__has_include)
#if __has_include(<mach/mach_time.h>)
#include <mach/mach_time.h>
#else
#error VERROR_MESSAGE Header file <mach/mach_time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif
#else
#include <mach/mach_time.h>
#endif


// added by module `time`, file: time_nix.c.v:7:

#if defined(__has_include)
#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif
#else
#include <time.h>
#endif


// added by module `time`, file: time_nix.c.v:8:
#include <errno.h>

// added by module `vphp`, file: mod.v:5:

#if defined(__has_include)
#if __has_include(<php.h>)
#include <php.h>
#else
#error VERROR_MESSAGE Header file <php.h>, needed for module `vphp` was not found. Please install the corresponding development headers.
#endif
#else
#include <php.h>
#endif


// added by module `vphp`, file: mod.v:6:

#if defined(__has_include)
#if __has_include("v_bridge.h")
#include "v_bridge.h"
#else
#error VERROR_MESSAGE Header file "v_bridge.h", needed for module `vphp` was not found. Please install the corresponding development headers.
#endif
#else
#include "v_bridge.h"
#endif


// added by module `os`, file: debugger_darwin.c.v:3:

#if defined(__has_include)
#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/types.h>
#endif


// added by module `os`, file: debugger_darwin.c.v:4:

#if defined(__has_include)
#if __has_include(<sys/ptrace.h>)
#include <sys/ptrace.h>
#else
#error VERROR_MESSAGE Header file <sys/ptrace.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/ptrace.h>
#endif


#if !defined(_WIN32)

// added by module `os`, file: fd.c.v:6:

#if defined(__has_include)
#if __has_include(<sys/select.h>)
#include <sys/select.h>
#else
#error VERROR_MESSAGE Header file <sys/select.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/select.h>
#endif

#endif

// added by module `os`, file: os.c.v:5:

#if defined(__has_include)
#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/stat.h>
#endif


// added by module `os`, file: os.c.v:6:
#include <errno.h>

// added by module `os`, file: os.c.v:9:

#if defined(__has_include)
#if __has_include(<mach-o/dyld.h>)
#include <mach-o/dyld.h>
#else
#error VERROR_MESSAGE Header file <mach-o/dyld.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <mach-o/dyld.h>
#endif


// added by module `os`, file: os_nix.c.v:5:

#if defined(__has_include)
#if __has_include(<dirent.h>)
#include <dirent.h>
#else
#error VERROR_MESSAGE Header file <dirent.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <dirent.h>
#endif


// added by module `os`, file: os_nix.c.v:6:

#if defined(__has_include)
#if __has_include(<unistd.h>)
#include <unistd.h>
#else
#error VERROR_MESSAGE Header file <unistd.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <unistd.h>
#endif


// added by module `os`, file: os_nix.c.v:7:

#if defined(__has_include)
#if __has_include(<fcntl.h>)
#include <fcntl.h>
#else
#error VERROR_MESSAGE Header file <fcntl.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <fcntl.h>
#endif


// added by module `os`, file: os_nix.c.v:8:

#if defined(__has_include)
#if __has_include(<sys/utsname.h>)
#include <sys/utsname.h>
#else
#error VERROR_MESSAGE Header file <sys/utsname.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/utsname.h>
#endif


// added by module `os`, file: os_nix.c.v:9:

#if defined(__has_include)
#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/types.h>
#endif


// added by module `os`, file: os_nix.c.v:10:

#if defined(__has_include)
#if __has_include(<sys/statvfs.h>)
#include <sys/statvfs.h>
#else
#error VERROR_MESSAGE Header file <sys/statvfs.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/statvfs.h>
#endif


// added by module `os`, file: os_nix.c.v:11:

#if defined(__has_include)
#if __has_include(<utime.h>)
#include <utime.h>
#else
#error VERROR_MESSAGE Header file <utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <utime.h>
#endif


// added by module `os`, file: signal.c.v:3:

#if defined(__has_include)
#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <signal.h>
#endif


// added by module `os`, file: signal_darwin.c.v:5:

#if defined(__has_include)
#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif
#else
#include <signal.h>
#endif


// added by module `os.filelock`, file: lib_nix.c.v:3:

#if defined(__has_include)
#if __has_include(<sys/file.h>)
#include <sys/file.h>
#else
#error VERROR_MESSAGE Header file <sys/file.h>, needed for module `os.filelock` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/file.h>
#endif


// added by module `term`, file: term_nix.c.v:7:

#if defined(__has_include)
#if __has_include(<sys/ioctl.h>)
#include <sys/ioctl.h>
#else
#error VERROR_MESSAGE Header file <sys/ioctl.h>, needed for module `term` was not found. Please install the corresponding development headers.
#endif
#else
#include <sys/ioctl.h>
#endif


// added by module `runtime`, file: free_memory_impl_darwin.c.v:3:

#if defined(__has_include)
#if __has_include(<mach/mach.h>)
#include <mach/mach.h>
#else
#error VERROR_MESSAGE Header file <mach/mach.h>, needed for module `runtime` was not found. Please install the corresponding development headers.
#endif
#else
#include <mach/mach.h>
#endif


// added by module `runtime`, file: free_memory_impl_darwin.c.v:4:

#if defined(__has_include)
#if __has_include(<mach/task.h>)
#include <mach/task.h>
#else
#error VERROR_MESSAGE Header file <mach/task.h>, needed for module `runtime` was not found. Please install the corresponding development headers.
#endif
#else
#include <mach/task.h>
#endif


// V global/const #define ... :
#define _const_builtin__closure__assumed_page_size 16384
#define _const_strconv__digits 18
#define _const_strconv__c_dpoint '.'
#define _const_strconv__c_plus '+'
#define _const_strconv__c_minus '-'
#define _const_strconv__c_zero '0'
#define _const_strconv__c_nine '9'
#define _const_strconv__int_size 32
#define _const_strconv__max_size_f64_char 512
#define _const_min_int -2147483648
#define _const_max_int 2147483647
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_init_capicity 32
#define _const_init_even_index 30
#define _const_extra_metas_inc 4
#define _const_rune_maps_columns_in_row 4
#define _const_rune_maps_ul -3
#define _const_rune_maps_utl -2
#define _const_degree 6
#define _const_mid_index 5
#define _const_replace_stack_buffer_size 10
#define _const_kmp_stack_buffer_size 20
#define _const_vphp__zend__is_undef 0
#define _const_vphp__zend__is_null 1
#define _const_vphp__zend__is_false 2
#define _const_vphp__zend__is_true 3
#define _const_vphp__zend__is_long 4
#define _const_vphp__zend__is_double 5
#define _const_vphp__zend__is_string 6
#define _const_vphp__zend__is_array 7
#define _const_vphp__zend__is_object 8
#define _const_vphp__zend__is_resource 9
#define _const_vphp__zend__is_reference 10
#define _const_vphp__zend__e_error 1
#define _const_vphp__zend__e_warning 2
#define _const_vphp__zend__e_notice 8
#define _const_time__seconds_per_minute 60
#define _const_time__seconds_per_hour 3600
#define _const_time__seconds_per_day 86400
#define _const_time__seconds_per_week 604800
#define _const_time__days_per_400_years 146097
#define _const_time__days_per_100_years 36524
#define _const_time__days_per_4_years 1461
#define _const_time__days_in_year 365
#define _const_flag__max_args_number 4048
#define _const_semver__ver_major 0
#define _const_semver__ver_minor 1
#define _const_semver__ver_patch 2
#define _const_vphp__e_error 1
#define _const_vphp__e_warning 2
#define _const_os__max_path_buffer_size 4096
#define _const_os__o_binary 0
#define _const_os__fslash '/'
#define _const_os__dot '.'
#define _const_os__buf_size 4096
#define _const_os__error_code_not_set -1
#define _const_os__max_path_len 4096
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
#define _const_os__sys_write 4
#define _const_os__sys_open 5
#define _const_os__sys_close 6
#define _const_os__sys_mkdir 136
#define _const_os__sys_creat 8
#define _const_os__sys_open_nocancel 398
#define _const_os__sys_stat64 338
#define _const_os__s_ifmt 61440
#define _const_os__s_ifdir 16384
#define _const_os__s_ifreg 32768
#define _const_os__s_iflnk 40960
#define _const_os__s_isuid 2048
#define _const_os__s_isgid 1024
#define _const_os__s_isvtx 512
#define _const_os__s_irusr 256
#define _const_os__s_iwusr 128
#define _const_os__s_ixusr 64
#define _const_os__s_irgrp 32
#define _const_os__s_iwgrp 16
#define _const_os__s_ixgrp 8
#define _const_os__s_iroth 4
#define _const_os__s_iwoth 2
#define _const_os__s_ixoth 1
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
#define _const_rand__wyrand__seed_len 2
#define _const_v__util__backslash 92
#define _const_v__util__double_quote 34
#define _const_v__ast__invalid_type_idx -1
#define _const_v__ast__no_type_idx 0
#define _const_v__ast__void_type_idx 1
#define _const_v__ast__voidptr_type_idx 2
#define _const_v__ast__byteptr_type_idx 3
#define _const_v__ast__charptr_type_idx 4
#define _const_v__ast__i8_type_idx 5
#define _const_v__ast__i16_type_idx 6
#define _const_v__ast__i32_type_idx 7
#define _const_v__ast__int_type_idx 8
#define _const_v__ast__i64_type_idx 9
#define _const_v__ast__isize_type_idx 10
#define _const_v__ast__u8_type_idx 11
#define _const_v__ast__u16_type_idx 12
#define _const_v__ast__u32_type_idx 13
#define _const_v__ast__u64_type_idx 14
#define _const_v__ast__usize_type_idx 15
#define _const_v__ast__f32_type_idx 16
#define _const_v__ast__f64_type_idx 17
#define _const_v__ast__char_type_idx 18
#define _const_v__ast__bool_type_idx 19
#define _const_v__ast__none_type_idx 20
#define _const_v__ast__string_type_idx 21
#define _const_v__ast__rune_type_idx 22
#define _const_v__ast__array_type_idx 23
#define _const_v__ast__map_type_idx 24
#define _const_v__ast__chan_type_idx 25
#define _const_v__ast__any_type_idx 26
#define _const_v__ast__float_literal_type_idx 27
#define _const_v__ast__int_literal_type_idx 28
#define _const_v__ast__thread_type_idx 29
#define _const_v__ast__error_type_idx 30
#define _const_v__ast__nil_type_idx 31
#define _const_v__scanner__single_quote '\''
#define _const_v__scanner__double_quote '"'
#define _const_v__scanner__num_sep '_'
#define _const_v__scanner__backslash '\\'
#define _const_v__parser__max_expr_level 100

// Enum definitions:

typedef enum {
	strings__IndentState__normal, // 
	strings__IndentState__in_string, // +1
}  strings__IndentState;

typedef enum {
	builtin__closure__MemoryProtectAtrr__read_exec, // 
	builtin__closure__MemoryProtectAtrr__read_write, // +1
}  builtin__closure__MemoryProtectAtrr;

typedef enum {
	strconv__ParserState__ok, // 
	strconv__ParserState__pzero, // +1
	strconv__ParserState__mzero, // +2
	strconv__ParserState__pinf, // +3
	strconv__ParserState__minf, // +4
	strconv__ParserState__invalid_number, // +5
	strconv__ParserState__extra_char, // +6
}  strconv__ParserState;

typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
}  strconv__Align_text;

typedef enum {
	strconv__Char_parse_state__start, // 
	strconv__Char_parse_state__norm_char, // +1
	strconv__Char_parse_state__field_char, // +2
	strconv__Char_parse_state__pad_ch, // +3
	strconv__Char_parse_state__len_set_start, // +4
	strconv__Char_parse_state__len_set_in, // +5
	strconv__Char_parse_state__check_type, // +6
	strconv__Char_parse_state__check_float, // +7
	strconv__Char_parse_state__check_float_in, // +8
	strconv__Char_parse_state__reset_params, // +9
}  strconv__Char_parse_state;

typedef enum {
	ArrayFlags__noslices = 1U, // u64(1) << 0
	ArrayFlags__noshrink = 2U, // u64(1) << 1
	ArrayFlags__nogrow = 4U, // u64(1) << 2
	ArrayFlags__nofree = 8U, // u64(1) << 3
}  ArrayFlags;

typedef enum {
	ChanState__success, // 
	ChanState__not_ready, // +1
	ChanState__closed, // +2
}  ChanState;

typedef enum {
	AttributeKind__plain, // 
	AttributeKind__string, // +1
	AttributeKind__number, // +2
	AttributeKind__bool, // +3
	AttributeKind__comptime_define, // +4
}  AttributeKind;

typedef enum {
	MapMode__to_upper, // 
	MapMode__to_lower, // +1
	MapMode__to_title, // +2
}  MapMode;

typedef enum {
	TrimMode__trim_left, // 
	TrimMode__trim_right, // +1
	TrimMode__trim_both, // +2
}  TrimMode;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_r, // 0+18
	StrIntpType__si_vp, // 0+19
}  StrIntpType;

typedef enum {
	v__token__Kind__unknown, // 
	v__token__Kind__eof, // +1
	v__token__Kind__name, // +2
	v__token__Kind__number, // +3
	v__token__Kind__string, // +4
	v__token__Kind__str_inter, // +5
	v__token__Kind__chartoken, // +6
	v__token__Kind__plus, // +7
	v__token__Kind__minus, // +8
	v__token__Kind__mul, // +9
	v__token__Kind__div, // +10
	v__token__Kind__mod, // +11
	v__token__Kind__xor, // +12
	v__token__Kind__pipe, // +13
	v__token__Kind__inc, // +14
	v__token__Kind__dec, // +15
	v__token__Kind__and, // +16
	v__token__Kind__logical_or, // +17
	v__token__Kind__not, // +18
	v__token__Kind__bit_not, // +19
	v__token__Kind__question, // +20
	v__token__Kind__comma, // +21
	v__token__Kind__semicolon, // +22
	v__token__Kind__colon, // +23
	v__token__Kind__arrow, // +24
	v__token__Kind__amp, // +25
	v__token__Kind__hash, // +26
	v__token__Kind__dollar, // +27
	v__token__Kind__at, // +28
	v__token__Kind__str_dollar, // +29
	v__token__Kind__left_shift, // +30
	v__token__Kind__right_shift, // +31
	v__token__Kind__unsigned_right_shift, // +32
	v__token__Kind__not_in, // +33
	v__token__Kind__not_is, // +34
	v__token__Kind__assign, // +35
	v__token__Kind__decl_assign, // +36
	v__token__Kind__plus_assign, // +37
	v__token__Kind__minus_assign, // +38
	v__token__Kind__div_assign, // +39
	v__token__Kind__mult_assign, // +40
	v__token__Kind__xor_assign, // +41
	v__token__Kind__mod_assign, // +42
	v__token__Kind__or_assign, // +43
	v__token__Kind__and_assign, // +44
	v__token__Kind__right_shift_assign, // +45
	v__token__Kind__left_shift_assign, // +46
	v__token__Kind__unsigned_right_shift_assign, // +47
	v__token__Kind__boolean_and_assign, // +48
	v__token__Kind__boolean_or_assign, // +49
	v__token__Kind__lcbr, // +50
	v__token__Kind__rcbr, // +51
	v__token__Kind__lpar, // +52
	v__token__Kind__rpar, // +53
	v__token__Kind__lsbr, // +54
	v__token__Kind__nilsbr, // +55
	v__token__Kind__rsbr, // +56
	v__token__Kind__eq, // +57
	v__token__Kind__ne, // +58
	v__token__Kind__gt, // +59
	v__token__Kind__lt, // +60
	v__token__Kind__ge, // +61
	v__token__Kind__le, // +62
	v__token__Kind__comment, // +63
	v__token__Kind__nl, // +64
	v__token__Kind__dot, // +65
	v__token__Kind__dotdot, // +66
	v__token__Kind__ellipsis, // +67
	v__token__Kind__keyword_beg, // +68
	v__token__Kind__key_as, // +69
	v__token__Kind__key_asm, // +70
	v__token__Kind__key_assert, // +71
	v__token__Kind__key_atomic, // +72
	v__token__Kind__key_break, // +73
	v__token__Kind__key_const, // +74
	v__token__Kind__key_continue, // +75
	v__token__Kind__key_defer, // +76
	v__token__Kind__key_else, // +77
	v__token__Kind__key_enum, // +78
	v__token__Kind__key_false, // +79
	v__token__Kind__key_for, // +80
	v__token__Kind__key_fn, // +81
	v__token__Kind__key_global, // +82
	v__token__Kind__key_go, // +83
	v__token__Kind__key_goto, // +84
	v__token__Kind__key_if, // +85
	v__token__Kind__key_import, // +86
	v__token__Kind__key_in, // +87
	v__token__Kind__key_interface, // +88
	v__token__Kind__key_is, // +89
	v__token__Kind__key_match, // +90
	v__token__Kind__key_module, // +91
	v__token__Kind__key_mut, // +92
	v__token__Kind__key_nil, // +93
	v__token__Kind__key_shared, // +94
	v__token__Kind__key_lock, // +95
	v__token__Kind__key_rlock, // +96
	v__token__Kind__key_none, // +97
	v__token__Kind__key_return, // +98
	v__token__Kind__key_select, // +99
	v__token__Kind__key_like, // +100
	v__token__Kind__key_ilike, // +101
	v__token__Kind__key_sizeof, // +102
	v__token__Kind__key_isreftype, // +103
	v__token__Kind__key_likely, // +104
	v__token__Kind__key_unlikely, // +105
	v__token__Kind__key_offsetof, // +106
	v__token__Kind__key_struct, // +107
	v__token__Kind__key_true, // +108
	v__token__Kind__key_type, // +109
	v__token__Kind__key_typeof, // +110
	v__token__Kind__key_dump, // +111
	v__token__Kind__key_orelse, // +112
	v__token__Kind__key_union, // +113
	v__token__Kind__key_pub, // +114
	v__token__Kind__key_static, // +115
	v__token__Kind__key_volatile, // +116
	v__token__Kind__key_unsafe, // +117
	v__token__Kind__key_spawn, // +118
	v__token__Kind__key_implements, // +119
	v__token__Kind__keyword_end, // +120
	v__token__Kind___end_, // +121
}  v__token__Kind;

typedef enum {
	v__token__AtKind__unknown, // 
	v__token__AtKind__fn_name, // +1
	v__token__AtKind__method_name, // +2
	v__token__AtKind__mod_name, // +3
	v__token__AtKind__struct_name, // +4
	v__token__AtKind__vexe_path, // +5
	v__token__AtKind__file_path, // +6
	v__token__AtKind__file_dir, // +7
	v__token__AtKind__line_nr, // +8
	v__token__AtKind__column_nr, // +9
	v__token__AtKind__vhash, // +10
	v__token__AtKind__v_current_hash, // +11
	v__token__AtKind__vmod_file, // +12
	v__token__AtKind__vmodroot_path, // +13
	v__token__AtKind__vmod_hash, // +14
	v__token__AtKind__vroot_path, // +15
	v__token__AtKind__vexeroot_path, // +16
	v__token__AtKind__file_path_line_nr, // +17
	v__token__AtKind__location, // +18
	v__token__AtKind__build_date, // +19
	v__token__AtKind__build_time, // +20
	v__token__AtKind__build_timestamp, // +21
	v__token__AtKind__os, // +22
	v__token__AtKind__ccompiler, // +23
	v__token__AtKind__backend, // +24
	v__token__AtKind__platform, // +25
}  v__token__AtKind;

typedef enum {
	v__token__Precedence__lowest, // 
	v__token__Precedence__cond, // +1
	v__token__Precedence__in_as, // +2
	v__token__Precedence__assign, // +3
	v__token__Precedence__eq, // +4
	v__token__Precedence__sum, // +5
	v__token__Precedence__product, // +6
	v__token__Precedence__prefix, // +7
	v__token__Precedence__postfix, // +8
	v__token__Precedence__call, // +9
	v__token__Precedence__index, // +10
	v__token__Precedence__highest, // +11
}  v__token__Precedence;

typedef enum {
	time__FormatTime__hhmm12, // 
	time__FormatTime__hhmm24, // +1
	time__FormatTime__hhmmss12, // +2
	time__FormatTime__hhmmss24, // +3
	time__FormatTime__hhmmss24_milli, // +4
	time__FormatTime__hhmmss24_micro, // +5
	time__FormatTime__hhmmss24_nano, // +6
	time__FormatTime__no_time, // +7
}  time__FormatTime;

typedef enum {
	time__FormatDate__ddmmyy, // 
	time__FormatDate__ddmmyyyy, // +1
	time__FormatDate__mmddyy, // +2
	time__FormatDate__mmddyyyy, // +3
	time__FormatDate__mmmd, // +4
	time__FormatDate__mmmdd, // +5
	time__FormatDate__mmmddyy, // +6
	time__FormatDate__mmmddyyyy, // +7
	time__FormatDate__no_date, // +8
	time__FormatDate__yyyymmdd, // +9
	time__FormatDate__yymmdd, // +10
}  time__FormatDate;

typedef enum {
	time__FormatDelimiter__dot, // 
	time__FormatDelimiter__hyphen, // +1
	time__FormatDelimiter__slash, // +2
	time__FormatDelimiter__space, // +3
	time__FormatDelimiter__no_delimiter, // +4
}  time__FormatDelimiter;

typedef enum {
	flag__ParseMode__strict, // 
	flag__ParseMode__relaxed, // +1
}  flag__ParseMode;

typedef enum {
	flag__Style__short, // 
	flag__Style__long, // +1
	flag__Style__short_long, // +2
	flag__Style__v, // +3
	flag__Style__v_flag_parser, // +4
	flag__Style__go_flag, // +5
	flag__Style__cmd_exe, // +6
}  flag__Style;

typedef enum {
	flag__FieldHints__is_bool = 1U, // u64(1) << 0
	flag__FieldHints__is_array = 2U, // u64(1) << 1
	flag__FieldHints__is_ignore = 4U, // u64(1) << 2
	flag__FieldHints__is_int_type = 8U, // u64(1) << 3
	flag__FieldHints__has_tail = 16U, // u64(1) << 4
	flag__FieldHints__short_only = 32U, // u64(1) << 5
	flag__FieldHints__can_repeat = 64U, // u64(1) << 6
}  flag__FieldHints;

typedef enum {
	flag__Show__name = 1U, // u64(1) << 0
	flag__Show__version = 2U, // u64(1) << 1
	flag__Show__flags = 4U, // u64(1) << 2
	flag__Show__flag_type = 8U, // u64(1) << 3
	flag__Show__flag_hint = 16U, // u64(1) << 4
	flag__Show__description = 32U, // u64(1) << 5
	flag__Show__flags_header = 64U, // u64(1) << 6
	flag__Show__footer = 128U, // u64(1) << 7
}  flag__Show;

typedef enum {
	semver__Operator__gt, // 
	semver__Operator__lt, // +1
	semver__Operator__ge, // +2
	semver__Operator__le, // +3
	semver__Operator__eq, // +4
}  semver__Operator;

typedef enum {
	semver__Increment__major, // 
	semver__Increment__minor, // +1
	semver__Increment__patch, // +2
}  semver__Increment;

typedef enum {
	vphp__PHPType__undef = _const_vphp__zend__is_undef, // _const_vphp__zend__is_undef
	vphp__PHPType__null = _const_vphp__zend__is_null, // _const_vphp__zend__is_null
	vphp__PHPType__false_ = _const_vphp__zend__is_false, // _const_vphp__zend__is_false
	vphp__PHPType__true_ = _const_vphp__zend__is_true, // _const_vphp__zend__is_true
	vphp__PHPType__long = _const_vphp__zend__is_long, // _const_vphp__zend__is_long
	vphp__PHPType__double = _const_vphp__zend__is_double, // _const_vphp__zend__is_double
	vphp__PHPType__string = _const_vphp__zend__is_string, // _const_vphp__zend__is_string
	vphp__PHPType__array = _const_vphp__zend__is_array, // _const_vphp__zend__is_array
	vphp__PHPType__object = _const_vphp__zend__is_object, // _const_vphp__zend__is_object
	vphp__PHPType__resource = _const_vphp__zend__is_resource, // _const_vphp__zend__is_resource
	vphp__PHPType__reference = _const_vphp__zend__is_reference, // _const_vphp__zend__is_reference
}  vphp__PHPType;

typedef enum {
	os__SeekMode__start, // 
	os__SeekMode__current, // +1
	os__SeekMode__end, // +2
}  os__SeekMode;

typedef enum {
	os__FileBufferMode__fully_buffered = _IOFBF, // _IOFBF
	os__FileBufferMode__line_buffered = _IOLBF, // _IOLBF
	os__FileBufferMode__not_buffered = _IONBF, // _IONBF
}  os__FileBufferMode;

typedef enum {
	os__FileType__unknown, // 
	os__FileType__regular, // +1
	os__FileType__directory, // +2
	os__FileType__character_device, // +3
	os__FileType__block_device, // +4
	os__FileType__fifo, // +5
	os__FileType__symbolic_link, // +6
	os__FileType__socket, // +7
}  os__FileType;

typedef enum {
	os__GlobMatch__exact, // 
	os__GlobMatch__ends_with, // +1
	os__GlobMatch__starts_with, // +2
	os__GlobMatch__start_and_ends_with, // +3
	os__GlobMatch__contains, // +4
	os__GlobMatch__any, // +5
}  os__GlobMatch;

typedef enum {
	os__ChildProcessPipeKind__stdin, // 
	os__ChildProcessPipeKind__stdout, // +1
	os__ChildProcessPipeKind__stderr, // +2
}  os__ChildProcessPipeKind;

typedef enum {
	os__ProcessState__not_started, // 
	os__ProcessState__running, // +1
	os__ProcessState__stopped, // +2
	os__ProcessState__exited, // +3
	os__ProcessState__aborted, // +4
	os__ProcessState__closed, // +5
}  os__ProcessState;

typedef enum {
	os__Signal__hup = 1, // 1
	os__Signal__int = 2, // 2
	os__Signal__quit = 3, // 3
	os__Signal__ill = 4, // 4
	os__Signal__trap = 5, // 5
	os__Signal__abrt = 6, // 6
	os__Signal__bus = 7, // 7
	os__Signal__fpe = 8, // 8
	os__Signal__kill = 9, // 9
	os__Signal__usr1 = 10, // 10
	os__Signal__segv = 11, // 11
	os__Signal__usr2 = 12, // 12
	os__Signal__pipe = 13, // 13
	os__Signal__alrm = 14, // 14
	os__Signal__term = 15, // 15
	os__Signal__stkflt = 16, // 16
	os__Signal__chld = 17, // 17
	os__Signal__cont = 18, // 18
	os__Signal__stop = 19, // 19
	os__Signal__tstp = 20, // 20
	os__Signal__ttin = 21, // 21
	os__Signal__ttou = 22, // 22
	os__Signal__urg = 23, // 23
	os__Signal__xcpu = 24, // 24
	os__Signal__xfsz = 25, // 25
	os__Signal__vtalrm = 26, // 26
	os__Signal__prof = 27, // 27
	os__Signal__winch = 28, // 28
	os__Signal__poll = 29, // 29
	os__Signal__pwr = 30, // 30
	os__Signal__sys = 31, // 31
}  os__Signal;

typedef enum {
	v__errors__Reporter__scanner, // 
	v__errors__Reporter__parser, // +1
	v__errors__Reporter__checker, // +2
	v__errors__Reporter__builder, // +3
	v__errors__Reporter__gen, // +4
}  v__errors__Reporter;

typedef enum {
	term__TextStyle__bold = 1, // 1
	term__TextStyle__dim = 2, // 2
	term__TextStyle__italic = 3, // 3
	term__TextStyle__underline = 4, // 4
	term__TextStyle__blink = 5, // 5
	term__TextStyle__reverse = 7, // 7
}  term__TextStyle;

typedef enum {
	term__FgColor__black = 30, // 30
	term__FgColor__red = 31, // 31
	term__FgColor__green = 32, // 32
	term__FgColor__yellow = 33, // 33
	term__FgColor__blue = 34, // 34
	term__FgColor__magenta = 35, // 35
	term__FgColor__cyan = 36, // 36
	term__FgColor__white = 37, // 37
}  term__FgColor;

typedef enum {
	term__BgColor__black = 40, // 40
	term__BgColor__red = 41, // 41
	term__BgColor__green = 42, // 42
	term__BgColor__yellow = 43, // 43
	term__BgColor__blue = 44, // 44
	term__BgColor__magenta = 45, // 45
	term__BgColor__cyan = 46, // 46
	term__BgColor__white = 47, // 47
}  term__BgColor;

typedef enum {
	v__vmod__TokenKind__module_keyword, // 
	v__vmod__TokenKind__field_key, // +1
	v__vmod__TokenKind__lcbr, // +2
	v__vmod__TokenKind__rcbr, // +3
	v__vmod__TokenKind__labr, // +4
	v__vmod__TokenKind__rabr, // +5
	v__vmod__TokenKind__comma, // +6
	v__vmod__TokenKind__colon, // +7
	v__vmod__TokenKind__eof, // +8
	v__vmod__TokenKind__str, // +9
	v__vmod__TokenKind__ident, // +10
	v__vmod__TokenKind__unknown, // +11
}  v__vmod__TokenKind;

typedef enum {
	v__pref__Arch___auto, // 
	v__pref__Arch__amd64, // +1
	v__pref__Arch__arm64, // +2
	v__pref__Arch__arm32, // +3
	v__pref__Arch__rv64, // +4
	v__pref__Arch__rv32, // +5
	v__pref__Arch__i386, // +6
	v__pref__Arch__s390x, // +7
	v__pref__Arch__ppc64le, // +8
	v__pref__Arch__loongarch64, // +9
	v__pref__Arch__js_node, // +10
	v__pref__Arch__js_browser, // +11
	v__pref__Arch__js_freestanding, // +12
	v__pref__Arch__wasm32, // +13
	v__pref__Arch___max, // +14
}  v__pref__Arch;

typedef enum {
	v__pref__Method__unknown, // 
	v__pref__Method__initialize, // +1
	v__pref__Method__initialized, // +2
	v__pref__Method__did_open, // +3
	v__pref__Method__did_change, // +4
	v__pref__Method__definition, // +5
	v__pref__Method__completion, // +6
	v__pref__Method__signature_help, // +7
	v__pref__Method__set_trace, // +8
	v__pref__Method__cancel_request, // +9
	v__pref__Method__shutdown, // +10
	v__pref__Method__exit, // +11
}  v__pref__Method;

typedef enum {
	v__pref__OS___auto, // 
	v__pref__OS__ios, // +1
	v__pref__OS__macos, // +2
	v__pref__OS__linux, // +3
	v__pref__OS__windows, // +4
	v__pref__OS__freebsd, // +5
	v__pref__OS__openbsd, // +6
	v__pref__OS__netbsd, // +7
	v__pref__OS__dragonfly, // +8
	v__pref__OS__js_node, // +9
	v__pref__OS__js_browser, // +10
	v__pref__OS__js_freestanding, // +11
	v__pref__OS__android, // +12
	v__pref__OS__termux, // +13
	v__pref__OS__solaris, // +14
	v__pref__OS__qnx, // +15
	v__pref__OS__serenity, // +16
	v__pref__OS__plan9, // +17
	v__pref__OS__vinix, // +18
	v__pref__OS__haiku, // +19
	v__pref__OS__wasm32, // +20
	v__pref__OS__wasm32_emscripten, // +21
	v__pref__OS__wasm32_wasi, // +22
	v__pref__OS__browser, // +23
	v__pref__OS__wasi, // +24
	v__pref__OS__raw, // +25
	v__pref__OS__all, // +26
}  v__pref__OS;

typedef enum {
	v__pref__BuildMode__default_mode, // 
	v__pref__BuildMode__build_module, // +1
}  v__pref__BuildMode;

typedef enum {
	v__pref__AssertFailureMode__default, // 
	v__pref__AssertFailureMode__aborts, // +1
	v__pref__AssertFailureMode__backtraces, // +2
	v__pref__AssertFailureMode__continues, // +3
}  v__pref__AssertFailureMode;

typedef enum {
	v__pref__GarbageCollectionMode__unknown, // 
	v__pref__GarbageCollectionMode__no_gc, // +1
	v__pref__GarbageCollectionMode__boehm_full, // +2
	v__pref__GarbageCollectionMode__boehm_incr, // +3
	v__pref__GarbageCollectionMode__boehm_full_opt, // +4
	v__pref__GarbageCollectionMode__boehm_incr_opt, // +5
	v__pref__GarbageCollectionMode__boehm_leak, // +6
}  v__pref__GarbageCollectionMode;

typedef enum {
	v__pref__OutputMode__stdout, // 
	v__pref__OutputMode__silent, // +1
}  v__pref__OutputMode;

typedef enum {
	v__pref__ColorOutput__auto, // 
	v__pref__ColorOutput__always, // +1
	v__pref__ColorOutput__never, // +2
}  v__pref__ColorOutput;

typedef enum {
	v__pref__Subsystem__auto, // 
	v__pref__Subsystem__console, // +1
	v__pref__Subsystem__windows, // +2
}  v__pref__Subsystem;

typedef enum {
	v__pref__Backend__c, // 
	v__pref__Backend__golang, // +1
	v__pref__Backend__interpret, // +2
	v__pref__Backend__js_node, // +3
	v__pref__Backend__js_browser, // +4
	v__pref__Backend__js_freestanding, // +5
	v__pref__Backend__native, // +6
	v__pref__Backend__wasm, // +7
}  v__pref__Backend;

typedef enum {
	v__pref__CompilerType__gcc, // 
	v__pref__CompilerType__tinyc, // +1
	v__pref__CompilerType__clang, // +2
	v__pref__CompilerType__emcc, // +3
	v__pref__CompilerType__mingw, // +4
	v__pref__CompilerType__msvc, // +5
	v__pref__CompilerType__cplusplus, // +6
}  v__pref__CompilerType;

typedef enum {
	sync__BufferElemStat__unused = 0, // 0
	sync__BufferElemStat__writing, // 0+1
	sync__BufferElemStat__written, // 0+2
	sync__BufferElemStat__reading, // 0+3
}  sync__BufferElemStat;

typedef enum {
	sync__Direction__pop, // 
	sync__Direction__push, // +1
}  sync__Direction;

typedef enum {
	v__ast__ComptimeTypeKind__unknown, // 
	v__ast__ComptimeTypeKind__map, // +1
	v__ast__ComptimeTypeKind__int, // +2
	v__ast__ComptimeTypeKind__float, // +3
	v__ast__ComptimeTypeKind__struct, // +4
	v__ast__ComptimeTypeKind__iface, // +5
	v__ast__ComptimeTypeKind__array, // +6
	v__ast__ComptimeTypeKind__array_fixed, // +7
	v__ast__ComptimeTypeKind__array_dynamic, // +8
	v__ast__ComptimeTypeKind__sum_type, // +9
	v__ast__ComptimeTypeKind__enum, // +10
	v__ast__ComptimeTypeKind__alias, // +11
	v__ast__ComptimeTypeKind__function, // +12
	v__ast__ComptimeTypeKind__option, // +13
	v__ast__ComptimeTypeKind__shared, // +14
	v__ast__ComptimeTypeKind__string, // +15
	v__ast__ComptimeTypeKind__pointer, // +16
	v__ast__ComptimeTypeKind__voidptr, // +17
}  v__ast__ComptimeTypeKind;

typedef enum {
	v__ast__GenericKindField__unknown, // 
	v__ast__GenericKindField__name, // +1
	v__ast__GenericKindField__typ, // +2
	v__ast__GenericKindField__unaliased_typ, // +3
	v__ast__GenericKindField__indirections, // +4
}  v__ast__GenericKindField;

typedef enum {
	v__ast__StructInitKind__normal, // 
	v__ast__StructInitKind__short_syntax, // +1
	v__ast__StructInitKind__anon, // +2
}  v__ast__StructInitKind;

typedef enum {
	v__ast__CallKind__unknown, // 
	v__ast__CallKind__str, // +1
	v__ast__CallKind__wait, // +2
	v__ast__CallKind__free, // +3
	v__ast__CallKind__try_push, // +4
	v__ast__CallKind__try_pop, // +5
	v__ast__CallKind__keys, // +6
	v__ast__CallKind__values, // +7
	v__ast__CallKind__slice, // +8
	v__ast__CallKind__map, // +9
	v__ast__CallKind__insert, // +10
	v__ast__CallKind__prepend, // +11
	v__ast__CallKind__sort_with_compare, // +12
	v__ast__CallKind__sorted_with_compare, // +13
	v__ast__CallKind__sort, // +14
	v__ast__CallKind__sorted, // +15
	v__ast__CallKind__filter, // +16
	v__ast__CallKind__any, // +17
	v__ast__CallKind__all, // +18
	v__ast__CallKind__count, // +19
	v__ast__CallKind__clone, // +20
	v__ast__CallKind__clone_to_depth, // +21
	v__ast__CallKind__trim, // +22
	v__ast__CallKind__contains, // +23
	v__ast__CallKind__index, // +24
	v__ast__CallKind__last_index, // +25
	v__ast__CallKind__first, // +26
	v__ast__CallKind__last, // +27
	v__ast__CallKind__pop_left, // +28
	v__ast__CallKind__pop, // +29
	v__ast__CallKind__delete, // +30
	v__ast__CallKind__delete_many, // +31
	v__ast__CallKind__delete_last, // +32
	v__ast__CallKind__drop, // +33
	v__ast__CallKind__reverse, // +34
	v__ast__CallKind__reverse_in_place, // +35
	v__ast__CallKind__panic, // +36
	v__ast__CallKind__json_decode, // +37
	v__ast__CallKind__json_encode, // +38
	v__ast__CallKind__json_encode_pretty, // +39
	v__ast__CallKind__repeat, // +40
	v__ast__CallKind__type_name, // +41
	v__ast__CallKind__type_idx, // +42
	v__ast__CallKind__clear, // +43
	v__ast__CallKind__reserve, // +44
	v__ast__CallKind__move, // +45
	v__ast__CallKind__main_main, // +46
	v__ast__CallKind__va_arg, // +47
	v__ast__CallKind__addr, // +48
	v__ast__CallKind__main, // +49
	v__ast__CallKind__jsawait, // +50
	v__ast__CallKind__error, // +51
	v__ast__CallKind__grow_cap, // +52
	v__ast__CallKind__grow_len, // +53
	v__ast__CallKind__eprint, // +54
	v__ast__CallKind__eprintln, // +55
	v__ast__CallKind__print, // +56
	v__ast__CallKind__println, // +57
	v__ast__CallKind__close, // +58
	v__ast__CallKind__pointers, // +59
	v__ast__CallKind__push_many, // +60
	v__ast__CallKind__malloc, // +61
	v__ast__CallKind__writeln, // +62
}  v__ast__CallKind;

typedef enum {
	v__ast__ComptimeVarKind__no_comptime, // 
	v__ast__ComptimeVarKind__key_var, // +1
	v__ast__ComptimeVarKind__value_var, // +2
	v__ast__ComptimeVarKind__field_var, // +3
	v__ast__ComptimeVarKind__generic_param, // +4
	v__ast__ComptimeVarKind__generic_var, // +5
	v__ast__ComptimeVarKind__smartcast, // +6
	v__ast__ComptimeVarKind__aggregate, // +7
}  v__ast__ComptimeVarKind;

typedef enum {
	v__ast__IdentKind__unresolved, // 
	v__ast__IdentKind__blank_ident, // +1
	v__ast__IdentKind__variable, // +2
	v__ast__IdentKind__constant, // +3
	v__ast__IdentKind__global, // +4
	v__ast__IdentKind__function, // +5
}  v__ast__IdentKind;

typedef enum {
	v__ast__ComptimeForKind__methods, // 
	v__ast__ComptimeForKind__fields, // +1
	v__ast__ComptimeForKind__attributes, // +2
	v__ast__ComptimeForKind__values, // +3
	v__ast__ComptimeForKind__variants, // +4
	v__ast__ComptimeForKind__params, // +5
}  v__ast__ComptimeForKind;

typedef enum {
	v__ast__DeferMode__scoped, // 
	v__ast__DeferMode__function, // +1
}  v__ast__DeferMode;

typedef enum {
	v__ast__AddressingMode__invalid, // 
	v__ast__AddressingMode__displacement, // +1
	v__ast__AddressingMode__base, // +2
	v__ast__AddressingMode__base_plus_displacement, // +3
	v__ast__AddressingMode__index_times_scale_plus_displacement, // +4
	v__ast__AddressingMode__base_plus_index_plus_displacement, // +5
	v__ast__AddressingMode__base_plus_index_times_scale_plus_displacement, // +6
	v__ast__AddressingMode__rip_plus_displacement, // +7
}  v__ast__AddressingMode;

typedef enum {
	v__ast__OrKind__absent, // 
	v__ast__OrKind__block, // +1
	v__ast__OrKind__propagate_option, // +2
	v__ast__OrKind__propagate_result, // +3
}  v__ast__OrKind;

typedef enum {
	v__ast__ComptimeCallKind__unknown, // 
	v__ast__ComptimeCallKind__d, // +1
	v__ast__ComptimeCallKind__env, // +2
	v__ast__ComptimeCallKind__res, // +3
	v__ast__ComptimeCallKind__html, // +4
	v__ast__ComptimeCallKind__tmpl, // +5
	v__ast__ComptimeCallKind__method, // +6
	v__ast__ComptimeCallKind__pkgconfig, // +7
	v__ast__ComptimeCallKind__embed_file, // +8
	v__ast__ComptimeCallKind__compile_warn, // +9
	v__ast__ComptimeCallKind__compile_error, // +10
}  v__ast__ComptimeCallKind;

typedef enum {
	v__ast__SqlStmtKind__insert, // 
	v__ast__SqlStmtKind__update, // +1
	v__ast__SqlStmtKind__delete, // +2
	v__ast__SqlStmtKind__create, // +3
	v__ast__SqlStmtKind__drop, // +4
}  v__ast__SqlStmtKind;

typedef enum {
	v__ast__SqlExprKind__insert, // 
	v__ast__SqlExprKind__select_, // +1
}  v__ast__SqlExprKind;

typedef enum {
	v__ast__JoinKind__inner, // 
	v__ast__JoinKind__left, // +1
	v__ast__JoinKind__right, // +2
	v__ast__JoinKind__full_outer, // +3
}  v__ast__JoinKind;

typedef enum {
	v__ast__AttrKind__plain, // 
	v__ast__AttrKind__string, // +1
	v__ast__AttrKind__number, // +2
	v__ast__AttrKind__bool, // +3
	v__ast__AttrKind__comptime_define, // +4
}  v__ast__AttrKind;

typedef enum {
	v__ast__Language__v, // 
	v__ast__Language__c, // +1
	v__ast__Language__js, // +2
	v__ast__Language__wasm, // +3
	v__ast__Language__amd64, // +4
	v__ast__Language__i386, // +5
	v__ast__Language__arm64, // +6
	v__ast__Language__arm32, // +7
	v__ast__Language__rv64, // +8
	v__ast__Language__rv32, // +9
	v__ast__Language__s390x, // +10
	v__ast__Language__ppc64le, // +11
	v__ast__Language__loongarch64, // +12
	v__ast__Language__wasm32, // +13
}  v__ast__Language;

#pragma pack(push, 1)
typedef enum {
	v__ast__TypeFlag__option = 16777216, // 16777216
	v__ast__TypeFlag__result = 33554432, // 33554432
	v__ast__TypeFlag__variadic = 67108864, // 67108864
	v__ast__TypeFlag__generic = 134217728, // 134217728
	v__ast__TypeFlag__shared_f = 268435456, // 268435456
	v__ast__TypeFlag__atomic_f = 536870912, // 536870912
	v__ast__TypeFlag__option_mut_param_t = 1073741824, // 1073741824
} __attribute__((packed)) v__ast__TypeFlag;
#pragma pack(pop)


typedef enum {
	v__ast__ShareType__mut_t, // 
	v__ast__ShareType__shared_t, // +1
	v__ast__ShareType__atomic_t, // +2
}  v__ast__ShareType;

typedef enum {
	v__ast__Kind__placeholder, // 
	v__ast__Kind__void, // +1
	v__ast__Kind__voidptr, // +2
	v__ast__Kind__byteptr, // +3
	v__ast__Kind__charptr, // +4
	v__ast__Kind__i8, // +5
	v__ast__Kind__i16, // +6
	v__ast__Kind__i32, // +7
	v__ast__Kind__int, // +8
	v__ast__Kind__i64, // +9
	v__ast__Kind__isize, // +10
	v__ast__Kind__u8, // +11
	v__ast__Kind__u16, // +12
	v__ast__Kind__u32, // +13
	v__ast__Kind__u64, // +14
	v__ast__Kind__usize, // +15
	v__ast__Kind__f32, // +16
	v__ast__Kind__f64, // +17
	v__ast__Kind__char, // +18
	v__ast__Kind__rune, // +19
	v__ast__Kind__bool, // +20
	v__ast__Kind__none, // +21
	v__ast__Kind__string, // +22
	v__ast__Kind__array, // +23
	v__ast__Kind__array_fixed, // +24
	v__ast__Kind__map, // +25
	v__ast__Kind__chan, // +26
	v__ast__Kind__any, // +27
	v__ast__Kind__struct, // +28
	v__ast__Kind__generic_inst, // +29
	v__ast__Kind__multi_return, // +30
	v__ast__Kind__sum_type, // +31
	v__ast__Kind__alias, // +32
	v__ast__Kind__enum, // +33
	v__ast__Kind__function, // +34
	v__ast__Kind__interface, // +35
	v__ast__Kind__float_literal, // +36
	v__ast__Kind__int_literal, // +37
	v__ast__Kind__aggregate, // +38
	v__ast__Kind__thread, // +39
}  v__ast__Kind;

typedef enum {
	v__scanner__CommentsMode__skip_comments, // 
	v__scanner__CommentsMode__parse_comments, // +1
	v__scanner__CommentsMode__toplevel_comments, // +2
}  v__scanner__CommentsMode;

typedef enum {
	v__parser__ParseContentKind__file, // 
	v__parser__ParseContentKind__text, // +1
	v__parser__ParseContentKind__stmt, // +2
	v__parser__ParseContentKind__comptime, // +3
}  v__parser__ParseContentKind;

typedef enum {
	v__parser__OrBlockErrVarMode__no_err_var, // 
	v__parser__OrBlockErrVarMode__with_err_var, // +1
}  v__parser__OrBlockErrVarMode;

typedef enum {
	v__parser__State__simple, // 
	v__parser__State__html, // +1
	v__parser__State__css, // +2
	v__parser__State__js, // +3
}  v__parser__State;

// Thread definitions:
typedef pthread_t __v_thread;
typedef pthread_t __v_thread_Array_f64;

// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		voidptr* _voidptr;
		Error* _Error;
		MessageError* _MessageError;
		time__TimeParseError* _time__TimeParseError;
		flag__UnknownFlagError* _flag__UnknownFlagError;
		flag__ArgsCountError* _flag__ArgsCountError;
		semver__InvalidComparatorFormatError* _semver__InvalidComparatorFormatError;
		semver__EmptyInputError* _semver__EmptyInputError;
		semver__InvalidVersionFormatError* _semver__InvalidVersionFormatError;
		os__Eof* _os__Eof;
		os__NotExpected* _os__NotExpected;
		os__FileNotOpenedError* _os__FileNotOpenedError;
		os__SizeOfTypeIs0Error* _os__SizeOfTypeIs0Error;
		os__ExecutableNotFoundError* _os__ExecutableNotFoundError;
		v__parser__IncludeError* _v__parser__IncludeError;
	};
	u32 _typ;
};

struct string {
	u8* str;
	int len;
	int is_lit;
};

struct array {
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
	int element_size;
};

struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	u8* all_deleted;
	u8* keys;
	u8* values;
};

struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	u8 cached_hashbits;
	u8 shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};

struct Error {
	E_STRUCT_DECL;
};

struct _option {
	u8 state;
	IError err;
};

struct _result {
	bool is_error;
	IError err;
};
typedef array Array_string;
typedef array Array_u8;
typedef array Array_voidptr;
typedef array Array_VCastTypeIndexName;
typedef array Array_int;
typedef array Array_rune;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_RepIndex;
typedef map Map_string_string;
typedef array Array_f64;
typedef array Array_main__HeartPoint;
typedef map Map_string_int;
typedef array Array_bool;
typedef map Map_string_f64;
typedef array Array_i64;
typedef map Map_string_vphp__TaskCreator;
typedef array Array_vphp__Val;
typedef array Array_char_ptr;
typedef int Array_fixed_int_3 [3];
typedef array Array_os__Signal;
typedef char Array_fixed_char_256 [256];
typedef array Array_vphp__compiler__PhpClassConst;
typedef array Array_vphp__compiler__PhpClassProp;
typedef array Array_vphp__compiler__PhpMethodRepr;
typedef array Array_vphp__compiler__PhpArg;
typedef array Array_vphp__compiler__PhpRepr;
typedef array Array_v__ast__Comment;
typedef array Array_v__ast__Stmt;
typedef array Array_v__token__Pos;
typedef array Array_v__ast__Expr;
typedef array Array_v__ast__Type;
typedef array Array_Array_v__ast__Type;
typedef array Array_v__ast__Attr;
typedef array Array_v__ast__ConstField;
typedef array Array_v__ast__Embed;
typedef array Array_v__ast__TypeNode;
typedef array Array_v__ast__StructField;
typedef array Array_v__ast__FnDecl;
typedef array Array_v__ast__InterfaceEmbedding;
typedef array Array_v__ast__StructInitField;
typedef array Array_v__ast__ImportSymbol;
typedef array Array_v__ast__Param;
typedef map Map_string_bool;
typedef array Array_v__ast__DeferStmt;
typedef map Map_string_v__ast__FnTrace;
typedef array Array_v__ast__CallArg;
typedef array Array_v__ast__GlobalField;
typedef array Array_v__ast__Import;
typedef array Array_v__ast__EmbeddedFile;
typedef array Array_v__errors__Error;
typedef array Array_v__errors__Warning;
typedef array Array_v__errors__Notice;
typedef array Array_v__errors__CallStackItem;
typedef array Array_v__ast__FnDecl_ptr;
typedef array Array_v__ast__TemplateLineInfo;
typedef array Array_v__ast__IfBranch;
typedef array Array_v__ast__MatchBranch;
typedef array Array_Array_v__ast__Comment;
typedef array Array_v__ast__SelectBranch;
typedef array Array_v__ast__EnumField;
typedef array Array_v__ast__Ident;
typedef array Array_v__ast__AsmClobbered;
typedef array Array_v__ast__AsmTemplate;
typedef array Array_v__ast__AsmIO;
typedef array Array_v__ast__AsmArg;
typedef array Array_v__ast__IfGuardVar;
typedef array Array_v__ast__SqlStmtLine;
typedef map Map_int_v__ast__SqlStmtLine;
typedef map Map_int_v__ast__SqlExpr;
typedef array Array_v__ast__JoinClause;
typedef array Array_v__ast__Node;
typedef map Map_string_v__ast__ScopeObject;
typedef map Map_string_v__ast__ScopeStructField;
typedef array Array_v__ast__Scope_ptr;
typedef array Array_v__ast__ScopeObject;
typedef array Array_v__ast__StringifyModReplacement;
typedef map Map_int_bool;
typedef map Map_v__ast__Type_bool;
typedef array Array_v__ast__TypeSymbol_ptr;
typedef map Map_string_v__ast__Fn;
typedef map Map_string_Array_v__ast__Type;
typedef map Map_int_string;
typedef array Array_v__cflag__CFlag;
typedef map Map_string_Array_Array_v__ast__Type;
typedef map Map_int_v__ast__InterfaceDecl;
typedef map Map_int_v__ast__SumTypeDecl;
typedef map Map_string_v__ast__EnumDecl;
typedef map Map_string_v__ast__VlsInfo;
typedef map Map_string_Array_v__ast__Attr;
typedef map Map_u64_string;
typedef map Map_string_v__ast__ComptTimeCondResult;
typedef array Array_v__ast__Fn;
typedef map Map_string_v__ast__StructField;
typedef map Map_int_Array_v__ast__Type;
typedef array Array_v__ast__TypeFlag;
typedef array Array_v__ast__Kind;
typedef map Map_string_Array_string;
typedef array Array_v__ast__File_ptr;
typedef array Array_v__token__TrieNode_ptr;
typedef map Map_string_T;
typedef map Map_string_v__token__Kind;
typedef array Array_v__token__Precedence;
typedef array Array_v__util__JsonError;
typedef array Array_v__util__Possibility;
typedef map Map_string_time__StopWatch;
typedef array Array_sync__Channel_ptr;
typedef array Array_sync__Direction;
typedef array Array_sync__Subscription;
typedef chan chan_bool;
typedef array Array_chan_bool;
typedef u8 Array_fixed_u8_63 [63];
typedef array Array_u32;
typedef array Array_v__transformer__KeyVal;
typedef array Array_Array_v__transformer__KeyVal;
typedef array Array_v__token__Token;
typedef array Array_term__TextStyle;
typedef array Array_v__vmod__Token;
typedef map Map_string_v__vmod__ModFileAndFolder;
typedef array Array_flag__Flag;
typedef map Map_string_flag__StructField;
typedef map Map_string_flag__FlagData;
typedef array Array_flag__FlagData;
typedef map Map_string_Array_flag__FlagData;
typedef array Array_u64;
typedef array Array_i32;
typedef array Array_i16;
typedef array Array_u16;
typedef array Array_i8;
typedef array Array_f32;
typedef array Array_semver__Comparator;
typedef array Array_semver__ComparatorSet;
typedef u8 Array_fixed_u8_5 [5];
typedef u8 Array_fixed_u8_25 [25];
typedef u8 Array_fixed_u8_12 [12];
typedef u8 Array_fixed_u8_8 [8];
typedef u8 Array_fixed_u8_32 [32];
typedef u8 Array_fixed_u8_64 [64];
typedef u8 Array_fixed_u8_256 [256];
typedef u64 Array_fixed_u64_309 [309];
typedef u64 Array_fixed_u64_324 [324];
typedef u32 Array_fixed_u32_10 [10];
typedef u64 Array_fixed_u64_20 [20];
typedef u64 Array_fixed_u64_584 [584];
typedef u64 Array_fixed_u64_652 [652];
typedef f64 Array_fixed_f64_36 [36];
typedef u8 Array_fixed_u8_26 [26];
typedef u8 Array_fixed_u8_512 [512];
typedef u64 Array_fixed_u64_47 [47];
typedef u64 Array_fixed_u64_31 [31];
typedef voidptr Array_fixed_voidptr_100 [100];
typedef u8 Array_fixed_u8_17 [17];
typedef i32 Array_fixed_i32_1264 [1264];
typedef int Array_fixed_int_10 [10];
typedef int Array_fixed_int_20 [20];
typedef array Array_StrIntpType;
typedef array Array_v__token__Kind;
typedef string Array_fixed_string_7 [7];
typedef map Map_string_i64;
typedef u8 Array_fixed_u8_29 [29];
typedef u8 Array_fixed_u8_10 [10];
typedef char Array_fixed_char_1024 [1024];
typedef int Array_fixed_int_12 [12];
typedef int Array_fixed_int_13 [13];
typedef u8 Array_fixed_u8_4096 [4096];
typedef u8 Array_fixed_u8_1024 [1024];
typedef int Array_fixed_int_2 [2];
typedef array Array_os__ProcessState;
typedef int Array_fixed_int_6 [6];
typedef array Array_v__vmod__TokenKind;
typedef u16 Array_fixed_u16_8 [8];
typedef int Array_fixed_int_4 [4];
typedef array Array_v__pref__Backend;
typedef array Array_v__pref__OS;
typedef bool Array_fixed_bool_256 [256];
typedef string Array_fixed_string_9 [9];
typedef map Map_int_Array_string;
typedef map Map_int_Map_string_int;
typedef array Array_v__ast__IdentKind;
typedef array Array_v__ast__IntegerLiteral;
typedef array Array_v__pref__Arch;
typedef array Array_v__ast__CallExpr;
typedef Array_u8 strings__Builder;
typedef usize term__termios__TcFlag;
typedef usize term__termios__Speed;
typedef u8 term__termios__Cc;
typedef u8 v__ast__EmptyExpr;
typedef u32 v__ast__Type;
typedef i64 time__Duration;
#define C__time_t time_t
typedef int (*anon_fn_voidptr_voidptr__int)(voidptr,voidptr);
typedef void (*FnExitCb)();
typedef void (*FnGC_WarnCB)(char*,usize);
typedef int (*FnSortCB)(voidptr,voidptr);
typedef voidptr (*anon_fn___voidptr)();
typedef vphp__ITask (*vphp__TaskCreator)(string);
typedef void (*anon_fn_string)(string);
typedef void (*os__FnWalkContextCB)(voidptr,string);
typedef void (*os__SignalHandler)(os__Signal);
typedef void (*v__ast__FnPanicHandler)(v__ast__Table*,string);
typedef f32 (*v__util__CalculateSuggestionSimilarityFN)(string,string);
typedef void (*anon_fn_)();
typedef void (*anon_fn_voidptr)(voidptr);
typedef string (*anon_fn_string__string)(string);
struct vphp__ITask {
	union {
		void* _object;
		main__AnalyzeTask* _main__AnalyzeTask;
		voidptr* _voidptr;
	};
	u32 _typ;
	string* json_data;
};
struct vphp__compiler__PhpRepr {
	union {
		void* _object;
		vphp__compiler__PhpFuncRepr* _vphp__compiler__PhpFuncRepr;
		voidptr* _voidptr;
		vphp__compiler__PhpTaskRepr* _vphp__compiler__PhpTaskRepr;
		vphp__compiler__PhpClassRepr* _vphp__compiler__PhpClassRepr;
		vphp__compiler__PhpConstRepr* _vphp__compiler__PhpConstRepr;
	};
	u32 _typ;
};
struct rand__PRNG {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
		voidptr* _voidptr;
	};
	u32 _typ;
};
// #start sorted_symbols
struct none {
	E_STRUCT_DECL;
};

struct None__ {
	Error Error;
};

struct InputRuneIterator {
	E_STRUCT_DECL;
};

struct main__AnalyzeTask {
	string json_data;
};

struct vphp__Context {
	zend_execute_data* ex;
	zval* ret;
};

struct vphp__Val {
	zval* raw;
};

struct main__Coach {
	string name;
};

struct os__Eof {
	Error Error;
};

struct os__FileNotOpenedError {
	Error Error;
};

struct os__SizeOfTypeIs0Error {
	Error Error;
};

struct os__ExecutableNotFoundError {
	Error Error;
};

struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};

struct vphp__compiler__PhpTaskRepr {
	string task_name;
};

struct vphp__compiler__PhpClassConst {
	string name;
	string value;
};

struct vphp__compiler__PhpArg {
	string name;
	string v_type;
};

// Union sum type v__ast__Stmt = 
//          |  311 = v__ast__AsmStmt
//          |  312 = v__ast__AssertStmt
//          |  313 = v__ast__AssignStmt
//          |  314 = v__ast__Block
//          |  315 = v__ast__BranchStmt
//          |  316 = v__ast__ComptimeFor
//          |  231 = v__ast__ConstDecl
//          |  317 = v__ast__DebuggerStmt
//          |  318 = v__ast__DeferStmt
//          |  319 = v__ast__EmptyStmt
//          |  320 = v__ast__EnumDecl
//          |  321 = v__ast__ExprStmt
//          |  229 = v__ast__FnDecl
//          |  322 = v__ast__ForCStmt
//          |  323 = v__ast__ForInStmt
//          |  324 = v__ast__ForStmt
//          |  325 = v__ast__GlobalDecl
//          |  326 = v__ast__GotoLabel
//          |  327 = v__ast__GotoStmt
//          |  328 = v__ast__HashStmt
//          |  329 = v__ast__Import
//          |  330 = v__ast__InterfaceDecl
//          |  331 = v__ast__Module
//          |  258 = v__ast__NodeError
//          |  332 = v__ast__Return
//          |  333 = v__ast__SemicolonStmt
//          |  334 = v__ast__SqlStmt
//          |  228 = v__ast__StructDecl
//          |  257 = v__ast__TypeDecl
struct v__ast__Stmt {
	union {
		v__ast__AsmStmt* _v__ast__AsmStmt;
		v__ast__AssertStmt* _v__ast__AssertStmt;
		v__ast__AssignStmt* _v__ast__AssignStmt;
		v__ast__Block* _v__ast__Block;
		v__ast__BranchStmt* _v__ast__BranchStmt;
		v__ast__ComptimeFor* _v__ast__ComptimeFor;
		v__ast__ConstDecl* _v__ast__ConstDecl;
		v__ast__DebuggerStmt* _v__ast__DebuggerStmt;
		v__ast__DeferStmt* _v__ast__DeferStmt;
		v__ast__EmptyStmt* _v__ast__EmptyStmt;
		v__ast__EnumDecl* _v__ast__EnumDecl;
		v__ast__ExprStmt* _v__ast__ExprStmt;
		v__ast__FnDecl* _v__ast__FnDecl;
		v__ast__ForCStmt* _v__ast__ForCStmt;
		v__ast__ForInStmt* _v__ast__ForInStmt;
		v__ast__ForStmt* _v__ast__ForStmt;
		v__ast__GlobalDecl* _v__ast__GlobalDecl;
		v__ast__GotoLabel* _v__ast__GotoLabel;
		v__ast__GotoStmt* _v__ast__GotoStmt;
		v__ast__HashStmt* _v__ast__HashStmt;
		v__ast__Import* _v__ast__Import;
		v__ast__InterfaceDecl* _v__ast__InterfaceDecl;
		v__ast__Module* _v__ast__Module;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Return* _v__ast__Return;
		v__ast__SemicolonStmt* _v__ast__SemicolonStmt;
		v__ast__SqlStmt* _v__ast__SqlStmt;
		v__ast__StructDecl* _v__ast__StructDecl;
		v__ast__TypeDecl* _v__ast__TypeDecl;
	};
	u32 _typ;
	v__token__Pos* pos;
};

struct vphp__compiler__PhpConstRepr {
	string name;
	string value;
};

// Union sum type v__ast__TypeDecl = 
//          |  254 = v__ast__AliasTypeDecl
//          |  255 = v__ast__FnTypeDecl
//          |  256 = v__ast__SumTypeDecl
struct v__ast__TypeDecl {
	union {
		v__ast__AliasTypeDecl* _v__ast__AliasTypeDecl;
		v__ast__FnTypeDecl* _v__ast__FnTypeDecl;
		v__ast__SumTypeDecl* _v__ast__SumTypeDecl;
	};
	u32 _typ;
	string* name;
	string* mod;
	bool* is_pub;
	v__ast__Type* typ;
	v__token__Pos* pos;
	Array_v__ast__Attr* attrs;
	bool* is_markused;
};

// Union sum type v__ast__Expr = 
//          |  258 = v__ast__NodeError
//          |  259 = v__ast__AnonFn
//          |  260 = v__ast__ArrayDecompose
//          |  261 = v__ast__ArrayInit
//          |  262 = v__ast__AsCast
//          |  263 = v__ast__Assoc
//          |  264 = v__ast__AtExpr
//          |  265 = v__ast__BoolLiteral
//          |  266 = v__ast__CTempVar
//          |  267 = v__ast__CallExpr
//          |  268 = v__ast__CastExpr
//          |  269 = v__ast__ChanInit
//          |  270 = v__ast__CharLiteral
//          |  271 = v__ast__Comment
//          |  272 = v__ast__ComptimeCall
//          |  273 = v__ast__ComptimeSelector
//          |  274 = v__ast__ComptimeType
//          |  275 = v__ast__ConcatExpr
//          |  276 = v__ast__DumpExpr
//          |  277 = v__ast__EmptyExpr
//          |  278 = v__ast__EnumVal
//          |  279 = v__ast__FloatLiteral
//          |  280 = v__ast__GoExpr
//          |  281 = v__ast__Ident
//          |  282 = v__ast__IfExpr
//          |  283 = v__ast__IfGuardExpr
//          |  284 = v__ast__IndexExpr
//          |  285 = v__ast__InfixExpr
//          |  286 = v__ast__IntegerLiteral
//          |  287 = v__ast__IsRefType
//          |  288 = v__ast__LambdaExpr
//          |  289 = v__ast__Likely
//          |  290 = v__ast__LockExpr
//          |  291 = v__ast__MapInit
//          |  292 = v__ast__MatchExpr
//          |  293 = v__ast__Nil
//          |  294 = v__ast__None
//          |  295 = v__ast__OffsetOf
//          |  296 = v__ast__OrExpr
//          |  297 = v__ast__ParExpr
//          |  298 = v__ast__PostfixExpr
//          |  299 = v__ast__PrefixExpr
//          |  300 = v__ast__RangeExpr
//          |  301 = v__ast__SelectExpr
//          |  302 = v__ast__SelectorExpr
//          |  303 = v__ast__SizeOf
//          |  304 = v__ast__SpawnExpr
//          |  305 = v__ast__SqlExpr
//          |  306 = v__ast__StringInterLiteral
//          |  237 = v__ast__StringLiteral
//          |  236 = v__ast__StructInit
//          |  307 = v__ast__TypeNode
//          |  308 = v__ast__TypeOf
//          |  309 = v__ast__UnsafeExpr
struct v__ast__Expr {
	union {
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__AnonFn* _v__ast__AnonFn;
		v__ast__ArrayDecompose* _v__ast__ArrayDecompose;
		v__ast__ArrayInit* _v__ast__ArrayInit;
		v__ast__AsCast* _v__ast__AsCast;
		v__ast__Assoc* _v__ast__Assoc;
		v__ast__AtExpr* _v__ast__AtExpr;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CTempVar* _v__ast__CTempVar;
		v__ast__CallExpr* _v__ast__CallExpr;
		v__ast__CastExpr* _v__ast__CastExpr;
		v__ast__ChanInit* _v__ast__ChanInit;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__Comment* _v__ast__Comment;
		v__ast__ComptimeCall* _v__ast__ComptimeCall;
		v__ast__ComptimeSelector* _v__ast__ComptimeSelector;
		v__ast__ComptimeType* _v__ast__ComptimeType;
		v__ast__ConcatExpr* _v__ast__ConcatExpr;
		v__ast__DumpExpr* _v__ast__DumpExpr;
		v__ast__EmptyExpr* _v__ast__EmptyExpr;
		v__ast__EnumVal* _v__ast__EnumVal;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__GoExpr* _v__ast__GoExpr;
		v__ast__Ident* _v__ast__Ident;
		v__ast__IfExpr* _v__ast__IfExpr;
		v__ast__IfGuardExpr* _v__ast__IfGuardExpr;
		v__ast__IndexExpr* _v__ast__IndexExpr;
		v__ast__InfixExpr* _v__ast__InfixExpr;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		v__ast__IsRefType* _v__ast__IsRefType;
		v__ast__LambdaExpr* _v__ast__LambdaExpr;
		v__ast__Likely* _v__ast__Likely;
		v__ast__LockExpr* _v__ast__LockExpr;
		v__ast__MapInit* _v__ast__MapInit;
		v__ast__MatchExpr* _v__ast__MatchExpr;
		v__ast__Nil* _v__ast__Nil;
		v__ast__None* _v__ast__None;
		v__ast__OffsetOf* _v__ast__OffsetOf;
		v__ast__OrExpr* _v__ast__OrExpr;
		v__ast__ParExpr* _v__ast__ParExpr;
		v__ast__PostfixExpr* _v__ast__PostfixExpr;
		v__ast__PrefixExpr* _v__ast__PrefixExpr;
		v__ast__RangeExpr* _v__ast__RangeExpr;
		v__ast__SelectExpr* _v__ast__SelectExpr;
		v__ast__SelectorExpr* _v__ast__SelectorExpr;
		v__ast__SizeOf* _v__ast__SizeOf;
		v__ast__SpawnExpr* _v__ast__SpawnExpr;
		v__ast__SqlExpr* _v__ast__SqlExpr;
		v__ast__StringInterLiteral* _v__ast__StringInterLiteral;
		v__ast__StringLiteral* _v__ast__StringLiteral;
		v__ast__StructInit* _v__ast__StructInit;
		v__ast__TypeNode* _v__ast__TypeNode;
		v__ast__TypeOf* _v__ast__TypeOf;
		v__ast__UnsafeExpr* _v__ast__UnsafeExpr;
	};
	u32 _typ;
};

// Union sum type v__ast__ScopeObject = 
//          |  337 = v__ast__EmptyScopeObject
//          |  338 = v__ast__AsmRegister
//          |  339 = v__ast__ConstField
//          |  340 = v__ast__GlobalField
//          |  341 = v__ast__Var
struct v__ast__ScopeObject {
	union {
		v__ast__EmptyScopeObject* _v__ast__EmptyScopeObject;
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__Var* _v__ast__Var;
	};
	u32 _typ;
	string* name;
	v__ast__Type* typ;
};

// Union sum type v__ast__Node = 
//          |  343 = v__ast__CallArg
//          |  339 = v__ast__ConstField
//          |  344 = v__ast__EmptyNode
//          |  345 = v__ast__EnumField
//          |  310 = v__ast__Expr
//          |  235 = v__ast__File
//          |  340 = v__ast__GlobalField
//          |  346 = v__ast__IfBranch
//          |  347 = v__ast__MatchBranch
//          |  258 = v__ast__NodeError
//          |  348 = v__ast__Param
//          |  342 = v__ast__ScopeObject
//          |  349 = v__ast__SelectBranch
//          |  226 = v__ast__Stmt
//          |  350 = v__ast__StructField
//          |  351 = v__ast__StructInitField
struct v__ast__Node {
	union {
		v__ast__CallArg* _v__ast__CallArg;
		v__ast__ConstField* _v__ast__ConstField;
		v__ast__EmptyNode* _v__ast__EmptyNode;
		v__ast__EnumField* _v__ast__EnumField;
		v__ast__Expr* _v__ast__Expr;
		v__ast__File* _v__ast__File;
		v__ast__GlobalField* _v__ast__GlobalField;
		v__ast__IfBranch* _v__ast__IfBranch;
		v__ast__MatchBranch* _v__ast__MatchBranch;
		v__ast__NodeError* _v__ast__NodeError;
		v__ast__Param* _v__ast__Param;
		v__ast__ScopeObject* _v__ast__ScopeObject;
		v__ast__SelectBranch* _v__ast__SelectBranch;
		v__ast__Stmt* _v__ast__Stmt;
		v__ast__StructField* _v__ast__StructField;
		v__ast__StructInitField* _v__ast__StructInitField;
	};
	u32 _typ;
};

// Union sum type v__ast__ComptTimeConstValue = 
//          |  277 = v__ast__EmptyExpr
//          |   16 = f32
//          |   17 = f64
//          |    6 = i16
//          |    7 = i32
//          |    9 = i64
//          |    5 = i8
//          |   22 = rune
//          |   21 = string
//          |   12 = u16
//          |   13 = u32
//          |   14 = u64
//          |   11 = u8
//          |    2 = voidptr
struct v__ast__ComptTimeConstValue {
	union {
		v__ast__EmptyExpr* _v__ast__EmptyExpr;
		f32* _f32;
		f64* _f64;
		i16* _i16;
		i32* _i32;
		i64* _i64;
		i8* _i8;
		rune* _rune;
		string* _string;
		u16* _u16;
		u32* _u32;
		u64* _u64;
		u8* _u8;
		voidptr* _voidptr;
	};
	u32 _typ;
};

// Union sum type v__ast__IdentInfo = 
//          |  407 = v__ast__IdentFn
//          |  408 = v__ast__IdentVar
struct v__ast__IdentInfo {
	union {
		v__ast__IdentFn* _v__ast__IdentFn;
		v__ast__IdentVar* _v__ast__IdentVar;
	};
	u32 _typ;
	v__ast__Type* typ;
};

// Union sum type v__ast__AsmArg = 
//          |  429 = v__ast__AsmAddressing
//          |  430 = v__ast__AsmAlias
//          |  431 = v__ast__AsmDisp
//          |  338 = v__ast__AsmRegister
//          |  265 = v__ast__BoolLiteral
//          |  270 = v__ast__CharLiteral
//          |  279 = v__ast__FloatLiteral
//          |  286 = v__ast__IntegerLiteral
//          |   21 = string
struct v__ast__AsmArg {
	union {
		v__ast__AsmAddressing* _v__ast__AsmAddressing;
		v__ast__AsmAlias* _v__ast__AsmAlias;
		v__ast__AsmDisp* _v__ast__AsmDisp;
		v__ast__AsmRegister* _v__ast__AsmRegister;
		v__ast__BoolLiteral* _v__ast__BoolLiteral;
		v__ast__CharLiteral* _v__ast__CharLiteral;
		v__ast__FloatLiteral* _v__ast__FloatLiteral;
		v__ast__IntegerLiteral* _v__ast__IntegerLiteral;
		string* _string;
	};
	u32 _typ;
};

struct v__cflag__CFlag {
	string mod;
	string os;
	string name;
	string value;
	string cached;
};

struct v__ast__UnknownTypeInfo {
	E_STRUCT_DECL;
};

// Union sum type v__ast__TypeInfo = 
//          |  498 = v__ast__UnknownTypeInfo
//          |  480 = v__ast__Aggregate
//          |  482 = v__ast__Alias
//          |  452 = v__ast__Array
//          |  491 = v__ast__ArrayFixed
//          |  492 = v__ast__Chan
//          |  490 = v__ast__Enum
//          |  495 = v__ast__FnType
//          |  496 = v__ast__GenericInst
//          |  485 = v__ast__Interface
//          |  453 = v__ast__Map
//          |  494 = v__ast__MultiReturn
//          |  457 = v__ast__Struct
//          |  486 = v__ast__SumType
//          |  493 = v__ast__Thread
struct v__ast__TypeInfo {
	union {
		v__ast__UnknownTypeInfo* _v__ast__UnknownTypeInfo;
		v__ast__Aggregate* _v__ast__Aggregate;
		v__ast__Alias* _v__ast__Alias;
		v__ast__Array* _v__ast__Array;
		v__ast__ArrayFixed* _v__ast__ArrayFixed;
		v__ast__Chan* _v__ast__Chan;
		v__ast__Enum* _v__ast__Enum;
		v__ast__FnType* _v__ast__FnType;
		v__ast__GenericInst* _v__ast__GenericInst;
		v__ast__Interface* _v__ast__Interface;
		v__ast__Map* _v__ast__Map;
		v__ast__MultiReturn* _v__ast__MultiReturn;
		v__ast__Struct* _v__ast__Struct;
		v__ast__SumType* _v__ast__SumType;
		v__ast__Thread* _v__ast__Thread;
	};
	u32 _typ;
};

struct v__parser__ParamsForUnexpected {
	string got;
	string expecting;
	string prepend_msg;
	string additional_msg;
};
typedef v__token__TrieNode* Array_fixed_v__token__TrieNode_ptr1_123 [123];

struct sync__Subscription {
	sync__Semaphore* sem;
	sync__Subscription** prev;
	sync__Subscription* nxt;
};

struct v__vmod__ModFileAndFolder {
	string vmod_file;
	string vmod_folder;
};

struct flag__UnknownFlagError {
	Error Error;
	string flag;
};

struct flag__FlagConfig {
	string val_desc;
};

struct semver__EmptyInputError {
	Error Error;
};

struct semver__InvalidVersionFormatError {
	Error Error;
	string input;
};

struct GCHeapUsage {
	usize heap_size;
	usize free_bytes;
	usize total_bytes;
	usize unmapped_bytes;
	usize bytes_since_gc;
};

struct VCastTypeIndexName {
	int tindex;
	string tname;
};

struct MessageError {
	string msg;
	int code;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

union strconv__Float32u {
	f32 f;
	u32 u;
};

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
	string message;
	bool has_msg;
};

struct EnumData {
	string name;
	i64 value;
	Array_string attrs;
};

struct FieldData {
	string name;
	int typ;
	int unaliased_typ;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	bool is_embed;
	bool is_shared;
	bool is_atomic;
	bool is_option;
	bool is_array;
	bool is_map;
	bool is_chan;
	bool is_enum;
	bool is_struct;
	bool is_alias;
	u8 indirections;
};

struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};

struct RepIndex {
	int idx;
	int val_idx;
};

struct WrapConfig {
	int width;
	string end;
};

struct RunesIterator {
	string s;
	int i;
};

union StrIntpMem {
	u32 d_c;
	u8 d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	i32 d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	string d_r;
	voidptr d_p;
	voidptr d_vp;
};

struct strconv__BF_param {
	u8 pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text align;
	bool rm_tail_zero;
};

struct ToWideConfig {
	bool from_ansi;
};

struct main__Article {
	int id;
	string title;
	bool is_top;
};

struct main__Database {
	bool connected;
};

struct main__MotionReport {
	string user_name;
	f64 max_hr;
	f64 min_hr;
	f64 avg_hr;
	string risk_level;
	string device_mode;
};

struct main__HeartPoint {
	int timestamp;
	f64 hr;
};

struct main__StockParams {
	string symbol;
	int count;
};

struct strings__IndentParam {
	rune block_start;
	rune block_end;
	rune indent_char;
	int indent_count;
	int starting_level;
};

struct builtin__closure__ClosureMutex {
	pthread_mutex_t closure_mtx;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

struct strconv__AtoF64Param {
	bool allow_extra_chars;
};

struct strconv__Dec32 {
	u32 m;
	int e;
};

union strconv__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__Dec64 {
	u64 m;
	int e;
};

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};

union strconv__Uf64 {
	f64 f;
	u64 u;
};

struct vphp__MapContext {
	Map_string_string m;
};

struct vphp__TaskRegistry {
	Map_string_vphp__TaskCreator tasks;
};

struct vphp__zend__AsyncResult {
	__v_thread_Array_f64 handle;
};

struct os__Command {
	voidptr f;
	bool eof;
	int exit_code;
	string path;
	bool redirect_stdout;
};

struct os__NotExpected {
	string cause;
	int code;
};

struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};

struct os__Stat {
	u64 dev;
	u64 inode;
	u32 mode;
	u64 nlink;
	u32 uid;
	u32 gid;
	u64 rdev;
	u64 size;
	i64 atime;
	i64 mtime;
	i64 ctime;
};

struct os__CopyParams {
	bool fail_if_exists;
};

struct os__PathKind {
	bool is_file;
	bool is_dir;
	bool is_link;
};

struct os__SystemError {
	string msg;
	int code;
};

struct os__DiskUsage {
	u64 total;
	u64 available;
	u64 used;
};

struct os__Result {
	int exit_code;
	string output;
};

struct os__MvParams {
	bool overwrite;
};

struct os__WalkParams {
	bool hidden;
};

struct os__MkdirParams {
	u32 mode;
};

struct os__Pipe {
	int read_fd;
	int write_fd;
};

struct vphp__compiler__Compiler {
	string target_file;
	string ext_name;
	Array_vphp__compiler__PhpRepr elements;
	v__ast__Table* table;
	v__pref__Preferences* pref_set;
	Map_string_int class_index;
};

struct vphp__compiler__PhpFuncRepr {
	string name;
	bool is_internal;
};

struct vphp__compiler__PhpClassRepr {
	string name;
	string parent;
	bool is_final;
	Array_vphp__compiler__PhpClassConst constants;
	Array_vphp__compiler__PhpClassProp properties;
	Array_vphp__compiler__PhpMethodRepr methods;
};

struct vphp__compiler__PhpClassProp {
	string name;
	string v_type;
	string visibility;
	bool is_static;
};

struct vphp__compiler__PhpMethodRepr {
	string name;
	string v_c_func;
	bool is_static;
	string return_type;
	Array_vphp__compiler__PhpArg args;
	string visibility;
};

struct v__ast__Table {
	Map_string_bool module_deprecated;
	Map_string_int unwrap_generic_type_in_depth;
	Map_string_v__ast__ComptTimeCondResult comptime_is_true;
	Map_string_v__ast__EnumDecl enum_decls;
	Map_string_v__ast__Fn fns;
	Map_string_int type_idxs;
	Map_string_string export_names;
	Map_string_int anon_struct_names;
	Map_int_string dumps;
	Map_string_bool builtin_pub_fns;
	Map_string_int anon_union_names;
	Map_string_Array_v__ast__Type iface_types;
	Map_string_Array_Array_v__ast__Type fn_generic_types;
	Map_int_v__ast__InterfaceDecl interfaces;
	Map_int_v__ast__SumTypeDecl sumtypes;
	Map_string_Array_v__ast__Attr module_attrs;
	Map_string_v__ast__VlsInfo vls_info;
	Array_string filelist;
	Array_string imports;
	Array_string modules;
	Array_v__cflag__CFlag cflags;
	Array_string redefined_fns;
	Array_v__ast__TypeSymbol_ptr type_symbols;
	Array_v__ast__Type cur_concrete_types;
	string parsing_type;
	string cmod_prefix;
	v__ast__FnPanicHandler panic_handler;
	v__ast__UsedFeatures* used_features;
	__shared__Map_u64_string* cached_type_to_str;
	v__ast__Scope* global_scope;
	v__ast__LambdaExpr* cur_lambda;
	v__ast__FnDecl* cur_fn;
	voidptr panic_userdata;
	int anon_union_counter;
	int veb_res_idx_cache;
	int veb_ctx_idx_cache;
	int panic_npanics;
	int gostmts;
	int pointer_size;
	int anon_struct_counter;
	bool new_int_fmt_fix : 1;
	bool new_int : 1;
	bool is_fmt : 1;
};

struct strings__textscanner__TextScanner {
	string input;
	int ilen;
	int pos;
};
typedef term__termios__Cc Array_fixed_term__termios__Cc_20 [20];

struct v__ast__CTempVar {
	string name;
	v__ast__Type typ;
	bool is_ptr;
	v__ast__Expr orig;
	bool is_fixed_ret;
};

struct v__ast__IfGuardExpr {
	Array_v__ast__IfGuardVar vars;
	v__ast__Expr expr;
	v__ast__Type expr_type;
};

struct v__ast__EmptyScopeObject {
	string name;
	v__ast__Type typ;
};

struct v__ast__AsmRegister {
	string name;
	v__ast__Type typ;
	int size;
};

struct v__token__Pos {
	int len;
	int line_nr;
	int pos;
	u16 col;
	i16 file_idx;
	int last_line;
};

struct v__ast__Scope {
	Map_string_v__ast__ScopeObject objects;
	Map_string_v__ast__ScopeStructField struct_fields;
	v__ast__Scope* parent;
	bool detached_from_parent;
	Array_v__ast__Scope_ptr children;
	int start_pos;
	int end_pos;
};

struct v__ast__FnTrace {
	string name;
	string file;
	i64 line;
	v__ast__Fn* func;
	v__ast__Type return_type;
	bool is_fn_var : 1;
};

struct v__ast__EmbeddedFile {
	Array_u8 bytes;
	string compression_type;
	string rpath;
	string apath;
	int len;
	bool is_compressed : 1;
};

struct v__ast__TemplateLineInfo {
	string tmpl_path;
	int tmpl_line;
};

struct v__token__KeywordsMatcherTrie {
	Array_v__token__TrieNode_ptr nodes;
	int min_len;
	int max_len;
};

struct v__ast__IdentFn {
	v__ast__Type typ;
};

struct v__ast__IdentVar {
	v__ast__Type typ;
	v__ast__ShareType share : 2;
	bool is_mut : 1;
	bool is_static : 1;
	bool is_volatile : 1;
	bool is_option : 1;
};

struct v__token__Token {
	string lit;
	int pos;
	int len;
	int line_nr;
	int tidx;
	i16 file_idx;
	u16 col;
	v__token__Kind kind : 7;
};

struct v__ast__Array {
	int nr_dims;
	v__ast__Type elem_type;
};

struct v__ast__StringifyModReplacement {
	string mod;
	string alias;
	int weight;
};

struct v__ast__UsedFeatures {
	Map_string_bool used_globals;
	Map_int_bool used_syms;
	Map_v__ast__Type_bool comptime_syms;
	Map_int_bool print_types;
	Map_string_bool used_fns;
	Map_string_bool used_consts;
	Map_string_bool comptime_calls;
	Array_v__ast__Type used_veb_types;
	int used_maps;
	int used_none;
	int used_closures;
	bool arr_delete : 1;
	bool arr_reverse : 1;
	bool arr_map : 1;
	bool print_options : 1;
	bool safe_int : 1;
	bool used_attr_noreturn : 1;
	bool used_attr_hidden : 1;
	bool dump : 1;
	bool used_attr_weak : 1;
	bool anon_fn : 1;
	bool auto_str : 1;
	bool auto_str_ptr : 1;
	bool auto_str_arr : 1;
	bool arr_prepend : 1;
	bool arr_insert : 1;
	bool arr_first : 1;
	bool arr_last : 1;
	bool arr_pop_left : 1;
	bool arr_pop : 1;
};

struct v__ast__TypeSymbol {
	Array_v__ast__Type generic_types;
	Array_v__ast__Fn methods;
	string mod;
	string name;
	string cname;
	string rname;
	string ngname;
	v__ast__TypeInfo info;
	int align;
	int idx;
	int size;
	int parent_idx;
	v__ast__Kind kind : 6;
	v__ast__Language language : 4;
	bool is_pub : 1;
	bool is_builtin : 1;
};

struct v__ast__ComptTimeCondResult {
	bool val;
	string c_str;
};

struct v__ast__Aggregate {
	Array_v__ast__StructField fields;
	v__ast__Type sum_type;
	Array_v__ast__Type types;
};

struct v__ast__GetEmbedsOptions {
	Array_v__ast__Type preceding;
};

struct v__ast__ArrayFixed {
	v__ast__Expr size_expr;
	int size;
	v__ast__Type elem_type;
	bool is_fn_ret : 1;
};

struct v__ast__Chan {
	v__ast__Type elem_type;
	bool is_mut;
};

struct v__ast__Thread {
	v__ast__Type return_type;
};

struct v__ast__MultiReturn {
	Array_v__ast__Type types;
};

struct v__ast__GenericInst {
	int parent_idx;
	Array_v__ast__Type concrete_types;
};

struct v__ast__FnSignatureOpts {
	bool skip_receiver : 1;
	bool type_only : 1;
};

struct v__pref__LineInfo {
	v__pref__Method method;
	string path;
	int line_nr;
	int col;
	Map_string_bool vars_printed;
};

struct v__vcache__CacheManager {
	string basepath;
	string original_vopts;
	string vopts;
	Map_string_string k2cpath;
};

struct v__scanner__Scanner {
	Array_v__errors__Error errors;
	Array_string str_segments;
	Array_string error_details;
	Array_v__token__Token all_tokens;
	Array_int h_escapes_pos;
	Array_int u32_escapes_pos;
	Array_int u16_escapes_pos;
	Array_int all_pos;
	Array_v__errors__Notice notices;
	Array_v__errors__Warning warnings;
	Array_u8 str_helper_tokens;
	string file_path;
	string file_base;
	string text;
	string line_comment;
	v__pref__Preferences* pref;
	int pos;
	int line_nr;
	int nr_lines;
	int last_nl_pos;
	int last_lt;
	int max_eofs;
	int eofs;
	int tidx;
	i16 file_idx;
	u8 quote;
	v__scanner__CommentsMode comments_mode : 2;
	bool is_inter_end : 1;
	bool is_inter_start : 1;
	bool is_nested_string : 1;
	bool should_abort : 1;
	bool is_inside_string : 1;
	bool is_fmt : 1;
	bool is_print_rel_paths_on_error : 1;
	bool is_print_line_on_error : 1;
	bool is_print_colored_error : 1;
	bool is_inside_toplvl_statement : 1;
};

struct v__parser__EatCommentsConfig {
	bool same_line;
	bool follow_up;
};

struct v__parser__DependencyCache {
	Map_string_Array_string dependencies;
	Map_string_Array_string cache;
};

struct v__parser__IncludeError {
	Error Error;
	string calling_file;
	int line_nr;
	int position;
	u16 col;
	string message;
};

struct v__token__TrieNode {
	Array_fixed_v__token__TrieNode_ptr1_123 children;
	int value;
};

struct v__util__EManager {
	bool support_color;
};

struct v__util__LinesCache {
	Map_string_Array_string lines;
};

struct v__util__JsonError {
	string path;
	string message;
	int line_nr;
	int col;
	int len;
};

struct v__util__Possibility {
	string value;
	string svalue;
	f32 similarity;
};

struct v__util__Suggestion {
	Array_v__util__Possibility known;
	string wanted;
	string swanted;
	f32 similarity_threshold;
	v__util__CalculateSuggestionSimilarityFN similarity_fn;
};

struct v__util__SuggestionParams {
	f32 similarity_threshold;
	v__util__CalculateSuggestionSimilarityFN similarity_fn;
};

struct v__util__Surrounder {
	Array_string befores;
	Array_string afters;
};

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};

struct v__util__Timers {
	string label;
	__shared__Map_string_time__StopWatch* swatches;
	bool should_print;
	Array_string already_shown;
};

struct v__util__TimerParams {
	bool should_print;
	string label;
};

struct time__Time {
	i64 __v_unix;
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int nanosecond;
	bool is_local;
};

struct v__util__SourceCache {
	Map_string_string sources;
};

struct sync__Semaphore {
	pthread_mutex_t mtx;
	pthread_cond_t cond;
	u32 count;
};

struct sync__Mutex {
	pthread_mutex_t mutex;
};

struct sync__RwMutex {
	pthread_rwlock_t mutex;
};

struct sync__RwMutexAttr {
	pthread_rwlockattr_t attr;
};

struct sync__CondAttr {
	pthread_condattr_t attr;
};

struct rand__UUIDSession {
	u8 counter;
};

struct rand__config__PRNGConfigStruct {
	Array_u32 seed_;
};

struct rand__config__NormalConfigStruct {
	f64 mu;
	f64 sigma;
};

struct rand__config__ShuffleConfigStruct {
	int start;
	int end;
};

struct v__pkgconfig__MainOptions {
	bool modversion;
	bool description;
	bool help;
	bool debug;
	bool listall;
	bool exists;
	bool variables;
	bool __v_requires;
	string atleast;
	string atleastpc;
	string exactversion;
	bool version;
	bool cflags;
	bool cflags_only_path;
	bool cflags_only_other;
	bool stat1c;
	bool libs;
	bool libs_only_link;
	bool libs_only_path;
	bool libs_only_other;
	Array_string args;
};

struct v__pkgconfig__Main {
	v__pkgconfig__MainOptions* opt;
	string res;
	bool has_actions;
};

struct v__pkgconfig__Options {
	string path;
	bool debug;
	bool norecurse;
	bool only_description;
	bool use_default_paths;
};

struct flag__FlagParser {
	Array_string original_args;
	int idx_dashdash;
	Array_string all_after_dashdash;
	Array_string usage_examples;
	string default_help_label;
	string default_version_label;
	Array_string args;
	int max_free_args;
	Array_flag__Flag flags;
	string application_name;
	string application_version;
	string application_description;
	int min_free_args;
	string args_description;
	bool allow_unknown_args;
	Array_string footers;
};

struct v__transformer__Transformer {
	v__pref__Preferences* pref;
	v__transformer__IndexState* index;
	v__ast__Table* table;
	v__ast__File* file;
	bool skip_array_transform;
	bool is_assert;
	bool inside_dump;
	bool inside_in;
	bool inside_sql;
	v__ast__Type strings_builder_type;
};

struct v__transformer__KeyVal {
	string key;
	int value;
};

struct v__transformer__IndexState {
	Map_string_int max_index;
	Array_bool saved_disabled;
	Array_Array_v__transformer__KeyVal saved_key_vals;
	bool disabled;
	int level;
};

struct v__scanner__DecodedEscape {
	int idx;
	string segment;
};
struct _option_term__BgColor {
	byte state;
	IError err;
	byte data[sizeof(term__BgColor) > 1 ? sizeof(term__BgColor) : 1];
};
struct _option_term__FgColor {
	byte state;
	IError err;
	byte data[sizeof(term__FgColor) > 1 ? sizeof(term__FgColor) : 1];
};

struct term__ColorConfig {
	Array_term__TextStyle styles;
	_option_term__FgColor fg;
	_option_term__BgColor bg;
	string custom;
};

struct term__Coord {
	int x;
	int y;
};

struct term__KeyPressedParams {
	bool blocking;
	bool echo;
};

struct time__DateTimeParser {
	string datetime;
	string format;
	int current_pos_datetime;
};

struct time__TimeParseError {
	Error Error;
	int code;
	string message;
};

struct time__StopWatchOptions {
	bool auto_start;
};

struct os__filelock__FileLock {
	string name;
	i64 fd;
};

struct v__vmod__Manifest {
	string name;
	string description;
	string version;
	string license;
	string repo_url;
	string repo_branch;
	string author;
	Array_string dependencies;
	Map_string_Array_string unknown;
};

struct v__vmod__Token {
	v__vmod__TokenKind typ;
	string val;
	int line;
};

struct v__vmod__Scanner {
	int pos;
	int line;
	string text;
	bool inside_text;
	Array_v__vmod__Token tokens;
};

struct v__vmod__ModFileCacher {
	Map_string_v__vmod__ModFileAndFolder cache;
	Map_string_Array_string folder_files;
	int hits;
	int misses;
	int get_files_hits;
	int get_files_misses;
};

struct rand__buffer__PRNGBuffer {
	int bytes_left;
	u64 buffer;
};

struct flag__Flag {
	string name;
	u8 abbr;
	string usage;
	string val_desc;
};

struct flag__ArgsCountError {
	Error Error;
	int got;
	int want;
};
struct _option_string {
	byte state;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct flag__FlagData {
	string raw;
	string field_name;
	string delimiter;
	string name;
	_option_string arg;
	int pos;
	int repeats;
};

struct flag__FlagContext {
	string raw;
	string delimiter;
	string name;
	string next;
	int pos;
};

struct flag__StructField {
	string name;
	string match_name;
	string __v_short;
	flag__FieldHints hints;
	Map_string_string attrs;
	string type_name;
	string doc;
};

struct flag__StructInfo {
	string name;
	Map_string_string attrs;
	Map_string_flag__StructField fields;
};

struct flag__ParseConfig {
	string delimiter;
	flag__ParseMode mode;
	flag__Style style;
	_option_string stop;
	u16 skip;
};

struct flag__DocLayout {
	int description_padding;
	int description_width;
	int flag_indent;
};

struct flag__DocOptions {
	string flag_header;
	bool compact;
	flag__Show show;
};

struct semver__Version {
	int major;
	int minor;
	int patch;
	string prerelease;
	string metadata;
};

struct semver__RawVersion {
	string prerelease;
	string metadata;
	Array_string raw_ints;
};

struct semver__ComparatorSet {
	Array_semver__Comparator comparators;
};

struct semver__Range {
	Array_semver__ComparatorSet comparator_sets;
};

struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
};

struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};

struct builtin__closure__Closure {
	builtin__closure__ClosureMutex ClosureMutex;
	voidptr closure_ptr;
	anon_fn___voidptr closure_get_data;
	int closure_cap;
	int v_page_size;
};

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};

struct term__termios__Termios {
	term__termios__TcFlag c_iflag;
	term__termios__TcFlag c_oflag;
	term__termios__TcFlag c_cflag;
	term__termios__TcFlag c_lflag;
	Array_fixed_term__termios__Cc_20 c_cc;
	term__termios__Speed c_ispeed;
	term__termios__Speed c_ospeed;
};

struct os__IOCapture {
	os__Pipe __v_stdout;
	os__Pipe __v_stderr;
	int original_stdout_fd;
	int original_stderr_fd;
};

struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	string work_folder;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
	bool create_no_window;
};

struct v__ast__StructDecl {
	Array_v__ast__StructField fields;
	Array_v__ast__TypeNode implements_types;
	Array_v__ast__Embed embeds;
	Array_v__ast__Attr attrs;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Type generic_types;
	string name;
	string scoped_name;
	v__token__Pos pos;
	int idx;
	int mut_pos;
	int pub_pos;
	int pub_mut_pos;
	int global_pos;
	int module_pos;
	v__ast__Language language : 4;
	bool is_aligned : 1;
	bool is_implements : 1;
	bool is_option : 1;
	bool is_union : 1;
	bool is_pub : 1;
};

struct v__ast__ConstDecl {
	Array_v__ast__Attr attrs;
	Array_v__ast__ConstField fields;
	Array_v__ast__Comment end_comments;
	v__token__Pos pos;
	bool is_pub : 1;
	bool is_block : 1;
};

struct v__pref__Preferences {
	v__vcache__CacheManager cache_manager;
	v__pref__LineInfo linfo;
	Map_string_string compile_values;
	Array_string file_list;
	Array_string compile_defines;
	Array_string compile_defines_all;
	Array_string profile_fns;
	Array_string run_only;
	Array_string cleanup_files;
	Array_string trace_fns;
	Array_string run_args;
	Array_string printfn_list;
	Array_string vmodules_paths;
	Array_string build_options;
	Array_string lookup_path;
	Array_string exclude;
	string dump_defines;
	string custom_prelude;
	string out_name_c;
	string out_name;
	string path;
	string line_info;
	string ldflags;
	string profile_file;
	string ccompiler;
	string cppcompiler;
	string third_party_option;
	string coverage_dir;
	string raw_vsh_tmp_prefix;
	string print_autofree_vars_in_fn;
	string dump_c_flags;
	string dump_modules;
	string dump_files;
	string bare_builtin_dir;
	string vlib;
	string eval_argument;
	string cmain;
	string test_runner;
	string macosx_version_min;
	string cflags;
	string vroot;
	int message_limit;
	int checker_match_exhaustive_cutoff_limit;
	int thread_stack_size;
	int wasm_stack_top;
	v__pref__OS os : 5;
	v__pref__Arch arch : 4;
	v__pref__Backend backend : 4;
	v__pref__CompilerType ccompiler_type : 3;
	v__pref__GarbageCollectionMode gc_mode : 3;
	v__pref__AssertFailureMode assert_failure_mode : 3;
	v__pref__Subsystem subsystem : 2;
	v__pref__ColorOutput use_color : 2;
	v__pref__OutputMode output_mode : 2;
	v__pref__BuildMode build_mode : 2;
	bool building_v : 1;
	bool no_bounds_checking : 1;
	bool force_bounds_checking : 1;
	bool autofree : 1;
	bool print_autofree_vars : 1;
	bool trace_calls : 1;
	bool compress : 1;
	bool no_builtin : 1;
	bool enable_globals : 1;
	bool is_bare : 1;
	bool no_preludes : 1;
	bool no_closures : 1;
	bool output_cross_c : 1;
	bool output_es5 : 1;
	bool prealloc : 1;
	bool print_v_files : 1;
	bool print_watched_files : 1;
	bool skip_running : 1;
	bool skip_warnings : 1;
	bool skip_notes : 1;
	bool warn_impure_v : 1;
	bool warns_are_errors : 1;
	bool notes_are_errors : 1;
	bool fatal_errors : 1;
	bool reuse_tmpc : 1;
	bool no_rsp : 1;
	bool no_std : 1;
	bool no_parallel : 1;
	bool parallel_cc : 1;
	bool only_check_syntax : 1;
	bool check_only : 1;
	bool experimental : 1;
	bool skip_unused : 1;
	bool nofloat : 1;
	bool use_coroutines : 1;
	bool fast_math : 1;
	bool wasm_validate : 1;
	bool warn_about_allocs : 1;
	bool div_by_zero_is_zero : 1;
	bool relaxed_gcc14 : 1;
	bool is_vls : 1;
	bool json_errors : 1;
	bool new_transform : 1;
	bool new_generic_solver : 1;
	bool backend_set_by_flag : 1;
	bool is_verbose : 1;
	bool is_glibc : 1;
	bool is_musl : 1;
	bool is_test : 1;
	bool is_script : 1;
	bool is_vsh : 1;
	bool is_livemain : 1;
	bool is_liveshared : 1;
	bool is_shared : 1;
	bool is_o : 1;
	bool is_prof : 1;
	bool is_prod : 1;
	bool no_prod_options : 1;
	bool is_repl : 1;
	bool is_eval_argument : 1;
	bool is_run : 1;
	bool is_crun : 1;
	bool is_debug : 1;
	bool is_vlines : 1;
	bool is_stats : 1;
	bool show_asserts : 1;
	bool show_timings : 1;
	bool is_fmt : 1;
	bool is_vet : 1;
	bool is_vweb : 1;
	bool is_ios_simulator : 1;
	bool is_apk : 1;
	bool is_help : 1;
	bool is_quiet : 1;
	bool is_cstrict : 1;
	bool is_callstack : 1;
	bool is_trace : 1;
	bool is_coverage : 1;
	bool is_check_return : 1;
	bool is_check_overflow : 1;
	bool profile_no_inline : 1;
	bool translated : 1;
	bool translated_go : 1;
	bool obfuscate_removed : 1;
	bool hide_auto_str : 1;
	bool sanitize : 1;
	bool sourcemap : 1;
	bool sourcemap_inline : 1;
	bool sourcemap_src_included : 1;
	bool show_cc : 1;
	bool show_c_output : 1;
	bool show_callgraph : 1;
	bool show_depgraph : 1;
	bool show_unused_params : 1;
	bool use_cache : 1;
	bool retry_compilation : 1;
	bool use_os_system_to_run : 1;
	bool m64 : 1;
};

struct v__ast__StructInit {
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Type generic_types;
	Array_v__ast__StructInitField init_fields;
	Array_v__ast__Comment update_expr_comments;
	string typ_str;
	v__ast__Expr update_expr;
	v__token__Pos pos;
	v__token__Pos name_pos;
	v__token__Pos update_expr_pos;
	v__ast__Type update_expr_type;
	v__ast__Type typ;
	v__ast__Language language : 4;
	bool has_update_expr : 1;
	bool is_short_syntax : 1;
	bool no_keys : 1;
	bool is_update_embed : 1;
	bool is_anon : 1;
	bool unresolved : 1;
};

struct v__ast__StringLiteral {
	string val;
	v__token__Pos pos;
	v__ast__Language language : 4;
	bool is_raw : 1;
};

struct v__ast__AliasTypeDecl {
	string name;
	string mod;
	bool is_pub;
	v__ast__Type typ;
	v__token__Pos pos;
	v__token__Pos type_pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Attr attrs;
	v__ast__Type parent_type;
	bool is_markused;
};

struct v__ast__FnTypeDecl {
	string name;
	string mod;
	bool is_pub;
	v__ast__Type typ;
	v__token__Pos pos;
	v__token__Pos type_pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Type generic_types;
	Array_v__ast__Attr attrs;
	bool is_markused;
};

struct v__ast__SumTypeDecl {
	string name;
	string mod;
	bool is_pub;
	v__token__Pos pos;
	v__token__Pos name_pos;
	v__ast__Type typ;
	Array_v__ast__Type generic_types;
	Array_v__ast__Attr attrs;
	Array_v__ast__TypeNode variants;
	bool is_markused;
};

struct v__ast__NodeError {
	int idx;
	v__token__Pos pos;
};

struct v__ast__ArrayDecompose {
	v__token__Pos pos;
	v__ast__Expr expr;
	v__ast__Type expr_type;
	v__ast__Type arg_type;
};

struct v__ast__ArrayInit {
	Array_v__ast__Comment pre_cmnts;
	Array_Array_v__ast__Comment ecmnts;
	Array_v__ast__Type expr_types;
	Array_v__ast__Expr exprs;
	v__ast__Expr cap_expr;
	v__ast__Expr init_expr;
	string mod;
	v__ast__Expr len_expr;
	v__token__Pos elem_type_pos;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Type init_type;
	v__ast__Type elem_type;
	v__ast__Type alias_type;
	bool has_callexpr : 1;
	bool is_fixed : 1;
	bool is_option : 1;
	bool has_val : 1;
	bool has_len : 1;
	bool has_cap : 1;
	bool has_init : 1;
	bool has_index : 1;
};

struct v__ast__AsCast {
	v__ast__Type typ;
	v__token__Pos pos;
	v__ast__Expr expr;
	v__ast__Type expr_type;
};

struct v__ast__Assoc {
	Array_string fields;
	Array_v__ast__Expr exprs;
	string var_name;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__ast__Type typ;
};

struct v__ast__AtExpr {
	string name;
	v__token__Pos pos;
	v__token__AtKind kind;
	string val;
};

struct v__ast__BoolLiteral {
	bool val;
	v__token__Pos pos;
};

struct v__ast__CastExpr {
	v__ast__Expr arg;
	v__ast__Expr expr;
	string typname;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Type expr_type;
	bool has_arg : 1;
};

struct v__ast__ChanInit {
	v__token__Pos pos;
	v__token__Pos elem_type_pos;
	bool has_cap;
	v__ast__Expr cap_expr;
	v__ast__Type typ;
	v__ast__Type elem_type;
};

struct v__ast__CharLiteral {
	string val;
	v__token__Pos pos;
};

struct v__ast__Comment {
	string text;
	bool is_multi;
	v__token__Pos pos;
};

struct v__ast__ComptimeType {
	v__ast__ComptimeTypeKind kind;
	v__token__Pos pos;
};

struct v__ast__ConcatExpr {
	Array_v__ast__Expr vals;
	v__token__Pos pos;
	v__ast__Type return_type;
};

struct v__ast__DumpExpr {
	v__ast__Expr expr;
	string cname;
	v__token__Pos pos;
	v__ast__Type expr_type;
};

struct v__ast__EnumVal {
	string enum_name;
	string val;
	string mod;
	v__token__Pos pos;
	v__ast__Type typ;
};

struct v__ast__FloatLiteral {
	string val;
	v__token__Pos pos;
};

struct v__ast__IfExpr {
	Array_v__ast__Comment post_comments;
	Array_v__ast__IfBranch branches;
	v__ast__Expr left;
	v__token__Pos pos;
	v__ast__Type typ;
	v__token__Kind tok_kind : 7;
	bool has_else : 1;
	bool is_expr : 1;
	bool is_comptime : 1;
};

struct v__ast__IntegerLiteral {
	string val;
	v__token__Pos pos;
};

struct v__ast__IsRefType {
	bool guessed_type;
	bool is_type;
	v__token__Pos pos;
	v__ast__Expr expr;
	v__ast__Type typ;
};

struct v__ast__LambdaExpr {
	v__token__Pos pos;
	Array_v__ast__Ident params;
	v__token__Pos pos_expr;
	v__ast__Expr expr;
	v__token__Pos pos_end;
	v__ast__Scope* scope;
	v__ast__AnonFn* func;
	bool is_checked;
	v__ast__Type typ;
	v__ast__CallExpr* call_ctx;
};

struct v__ast__Likely {
	v__token__Pos pos;
	bool is_likely;
	v__ast__Expr expr;
};

struct v__ast__LockExpr {
	Array_bool is_rlock;
	v__token__Pos pos;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Expr lockeds;
	Array_v__ast__Comment comments;
	bool is_expr;
	v__ast__Type typ;
	v__ast__Scope* scope;
};

struct v__ast__MapInit {
	Array_Array_v__ast__Comment comments;
	Array_v__ast__Comment pre_cmnts;
	Array_v__ast__Expr keys;
	Array_v__ast__Expr vals;
	Array_v__ast__Type val_types;
	Array_v__ast__Comment update_expr_comments;
	v__ast__Expr update_expr;
	v__token__Pos pos;
	v__token__Pos update_expr_pos;
	v__ast__Type key_type;
	v__ast__Type typ;
	v__ast__Type value_type;
	bool has_update_expr : 1;
};

struct v__ast__MatchExpr {
	Array_v__ast__MatchBranch branches;
	Array_v__ast__Comment comments;
	v__ast__Expr cond;
	v__token__Pos pos;
	v__ast__Type return_type;
	v__ast__Type expected_type;
	v__ast__Type cond_type;
	v__token__Kind tok_kind : 7;
	bool is_sum_type : 1;
	bool is_expr : 1;
	bool is_comptime : 1;
};

struct v__ast__Nil {
	v__token__Pos pos;
};

struct v__ast__None {
	v__token__Pos pos;
};

struct v__ast__OffsetOf {
	string field;
	v__token__Pos pos;
	v__ast__Type struct_type;
};

struct v__ast__OrExpr {
	v__ast__OrKind kind;
	v__token__Pos pos;
	v__ast__Scope* scope;
	bool err_used;
	Array_v__ast__Stmt stmts;
};

struct v__ast__ParExpr {
	v__token__Pos pos;
	v__ast__Expr expr;
	Array_v__ast__Comment comments;
};

struct v__ast__PostfixExpr {
	v__token__Kind op;
	v__token__Pos pos;
	bool is_c2v_prefix;
	v__ast__Expr expr;
	v__ast__Type typ;
	string auto_locked;
};

struct v__ast__RangeExpr {
	v__ast__Expr low;
	v__ast__Expr high;
	v__token__Pos pos;
	v__ast__Type typ;
	bool has_high : 1;
	bool has_low : 1;
	bool is_gated : 1;
};

struct v__ast__SelectExpr {
	Array_v__ast__SelectBranch branches;
	v__token__Pos pos;
	bool has_exception;
	bool is_expr;
	v__ast__Type expected_type;
};

struct v__ast__SizeOf {
	bool guessed_type;
	bool is_type;
	v__token__Pos pos;
	v__ast__Expr expr;
	v__ast__Type typ;
};

struct v__ast__StringInterLiteral {
	Array_string vals;
	Array_int fwidths;
	Array_int precisions;
	Array_bool pluss;
	Array_bool fills;
	Array_v__token__Pos fmt_poss;
	v__token__Pos pos;
	Array_v__ast__Expr exprs;
	Array_v__ast__Type expr_types;
	Array_u8 fmts;
	Array_bool need_fmts;
};

struct v__ast__TypeNode {
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Stmt stmt;
	Array_v__ast__Comment end_comments;
};

struct v__ast__TypeOf {
	v__ast__Expr expr;
	v__token__Pos pos;
	v__ast__Type typ;
	bool is_type : 1;
};

struct v__ast__UnsafeExpr {
	v__token__Pos pos;
	v__ast__Expr expr;
};

struct v__ast__AsmStmt {
	Array_string local_labels;
	Array_v__ast__AsmClobbered clobbered;
	Array_v__ast__AsmTemplate templates;
	Array_v__ast__AsmIO output;
	Array_v__ast__AsmIO input;
	Array_string global_labels;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__pref__Arch arch : 4;
	bool is_basic : 1;
	bool is_volatile : 1;
	bool is_goto : 1;
};

struct v__ast__AssertStmt {
	v__ast__Expr expr;
	v__ast__Expr extra;
	v__token__Pos pos;
	v__token__Pos extra_pos;
	bool is_used : 1;
};

struct v__ast__Block {
	bool is_unsafe;
	v__token__Pos pos;
	v__ast__Scope* scope;
	Array_v__ast__Stmt stmts;
};

struct v__ast__BranchStmt {
	string label;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__token__Kind kind : 7;
};

struct v__ast__ComptimeFor {
	string val_var;
	v__ast__ComptimeForKind kind;
	v__token__Pos pos;
	v__token__Pos typ_pos;
	v__ast__Scope* scope;
	Array_v__ast__Stmt stmts;
	v__ast__Type typ;
	v__ast__Expr expr;
};

struct v__ast__DebuggerStmt {
	v__token__Pos pos;
};

struct v__ast__DeferStmt {
	Array_v__ast__Stmt stmts;
	Array_v__ast__Ident defer_vars;
	string ifdef;
	v__ast__Scope* scope;
	v__token__Pos pos;
	int idx_in_fn;
	v__ast__DeferMode mode : 2;
};

struct v__ast__EmptyStmt {
	v__token__Pos pos;
};

struct v__ast__EnumDecl {
	Array_v__ast__Comment comments;
	Array_v__ast__Attr attrs;
	Array_v__ast__EnumField fields;
	string name;
	v__token__Pos typ_pos;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Type enum_typ;
	bool is_multi_allowed : 1;
	bool is_flag : 1;
	bool is_pub : 1;
};

struct v__ast__ExprStmt {
	v__token__Pos pos;
	Array_v__ast__Comment comments;
	v__ast__Expr expr;
	bool is_expr;
	v__ast__Type typ;
};

struct v__ast__ForCStmt {
	bool has_init;
	bool has_cond;
	bool has_inc;
	bool is_multi;
	v__token__Pos pos;
	Array_v__ast__Comment comments;
	v__ast__Stmt init;
	v__ast__Expr cond;
	v__ast__Stmt inc;
	Array_v__ast__Stmt stmts;
	string label;
	v__ast__Scope* scope;
};

struct v__ast__ForInStmt {
	Array_v__ast__Stmt stmts;
	Array_v__ast__Comment comments;
	v__ast__Expr cond;
	string val_var;
	string key_var;
	v__ast__Expr high;
	string label;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__token__Pos kv_pos;
	v__token__Pos vv_pos;
	v__ast__Type val_type;
	v__ast__Type cond_type;
	v__ast__Type high_type;
	v__ast__Type key_type;
	v__ast__Kind kind : 6;
	bool val_is_mut : 1;
	bool val_is_ref : 1;
	bool is_range : 1;
};

struct v__ast__ForStmt {
	bool is_inf;
	v__token__Pos pos;
	Array_v__ast__Comment comments;
	v__ast__Expr cond;
	Array_v__ast__Stmt stmts;
	string label;
	v__ast__Scope* scope;
};

struct v__ast__GlobalDecl {
	string mod;
	v__token__Pos pos;
	bool is_block;
	Array_v__ast__Attr attrs;
	Array_v__ast__GlobalField fields;
	Array_v__ast__Comment end_comments;
};

struct v__ast__GotoLabel {
	string name;
	v__token__Pos pos;
	bool is_used;
};

struct v__ast__GotoStmt {
	string name;
	v__token__Pos pos;
};

struct v__ast__HashStmt {
	string mod;
	v__token__Pos pos;
	string source_file;
	bool is_use_once;
	string val;
	string kind;
	string main;
	string msg;
	Array_v__ast__Expr ct_conds;
	Array_v__ast__Attr attrs;
};

struct v__ast__Import {
	string source_name;
	string mod;
	string alias;
	v__token__Pos pos;
	v__token__Pos mod_pos;
	v__token__Pos alias_pos;
	v__token__Pos syms_pos;
	Array_v__ast__ImportSymbol syms;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
};

struct v__ast__InterfaceDecl {
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Type generic_types;
	Array_v__ast__InterfaceEmbedding embeds;
	Array_v__ast__StructField fields;
	Array_string field_names;
	Array_v__ast__FnDecl methods;
	Array_v__ast__Attr attrs;
	string name;
	v__token__Pos pos;
	v__token__Pos name_pos;
	int mut_pos;
	v__ast__Type typ;
	v__ast__Language language : 4;
	bool is_pub : 1;
	bool are_embeds_expanded : 1;
};

struct v__ast__Module {
	string name;
	string short_name;
	Array_v__ast__Attr attrs;
	v__token__Pos pos;
	v__token__Pos name_pos;
	bool is_skipped;
};

struct v__ast__Return {
	v__ast__Scope* scope;
	v__token__Pos pos;
	Array_v__ast__Comment comments;
	Array_v__ast__Expr exprs;
	Array_v__ast__Type types;
};

struct v__ast__SemicolonStmt {
	v__token__Pos pos;
};

struct v__ast__ConstField {
	string mod;
	string name;
	bool is_pub;
	bool is_markused;
	bool is_exported;
	v__token__Pos pos;
	Array_v__ast__Attr attrs;
	bool is_virtual_c;
	v__ast__Expr expr;
	v__ast__Type typ;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment end_comments;
	v__ast__ComptTimeConstValue comptime_expr_value;
};

struct v__ast__GlobalField {
	Array_v__ast__Comment comments;
	string name;
	v__ast__Expr expr;
	v__token__Pos typ_pos;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Language language : 4;
	bool is_weak : 1;
	bool is_hidden : 1;
	bool is_extern : 1;
	bool has_expr : 1;
	bool is_volatile : 1;
	bool is_markused : 1;
	bool is_exported : 1;
};

struct v__ast__Var {
	Array_v__ast__Type smartcasts;
	v__ast__Expr expr;
	string name;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Type orig_type;
	v__ast__ComptimeVarKind ct_type_var : 4;
	v__ast__ShareType share : 2;
	bool is_arg : 1;
	bool is_auto_deref : 1;
	bool is_unwrapped : 1;
	bool is_index_var : 1;
	bool is_volatile : 1;
	bool is_static : 1;
	bool is_special : 1;
	bool is_mut : 1;
	bool is_used : 1;
	bool is_changed : 1;
	bool ct_type_unwrapped : 1;
	bool is_or : 1;
	bool is_tmp : 1;
	bool is_auto_heap : 1;
	bool is_stack_obj : 1;
	bool is_inherited : 1;
	bool is_autofree_tmp : 1;
	bool has_inherited : 1;
};

struct v__ast__CallArg {
	Array_v__ast__Comment comments;
	v__ast__Expr expr;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__ShareType share : 2;
	bool ct_expr : 1;
	bool is_tmp_autofree : 1;
	bool should_be_ptr : 1;
	bool is_mut : 1;
};

struct v__ast__EmptyNode {
	v__token__Pos pos;
};

struct v__ast__EnumField {
	string name;
	string source_name;
	v__token__Pos pos;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	bool has_expr;
	bool has_prev_newline;
	bool has_break_line;
	Array_v__ast__Attr attrs;
	v__ast__Expr expr;
};

struct v__ast__IfBranch {
	v__token__Pos pos;
	v__token__Pos body_pos;
	Array_v__ast__Comment comments;
	v__ast__Expr cond;
	Array_v__ast__Stmt stmts;
	v__ast__Scope* scope;
	int id;
};

struct v__ast__MatchBranch {
	Array_Array_v__ast__Comment ecmnts;
	v__token__Pos pos;
	bool is_else;
	Array_v__ast__Comment post_comments;
	v__token__Pos branch_pos;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Expr exprs;
	v__ast__Scope* scope;
	int id;
	bool is_comptime_err;
};

struct v__ast__Param {
	string name;
	v__token__Pos type_pos;
	v__token__Pos pos;
	v__ast__Type typ;
	bool is_atomic : 1;
	bool is_shared : 1;
	bool is_hidden : 1;
	bool on_newline : 1;
	bool is_mut : 1;
};

struct v__ast__StructInitField {
	v__token__Pos pos;
	v__token__Pos name_pos;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Comment next_comments;
	bool has_prev_newline;
	bool has_break_line;
	bool is_embed;
	v__ast__Expr expr;
	string name;
	v__ast__Type typ;
	v__ast__Type expected_type;
	v__ast__Type parent_type;
};

struct v__ast__Attr {
	string name;
	v__ast__Expr ct_expr;
	string arg;
	v__token__Pos pos;
	v__ast__AttrKind kind : 3;
	bool ct_opt : 1;
	bool has_at : 1;
	bool has_arg : 1;
	bool ct_evaled : 1;
	bool ct_skip : 1;
};

struct v__ast__Embed {
	v__ast__Type typ;
	v__token__Pos pos;
	Array_v__ast__Comment comments;
};

struct v__ast__InterfaceEmbedding {
	string name;
	v__ast__Type typ;
	v__token__Pos pos;
	Array_v__ast__Comment comments;
};

struct v__ast__ImportSymbol {
	v__token__Pos pos;
	string name;
};

struct v__ast__Fn {
	Array_v__ast__Param params;
	Array_v__ast__Attr attrs;
	Array_string dep_names;
	Array_string generic_names;
	string file;
	string name;
	string mod;
	voidptr source_fn;
	v__token__Pos name_pos;
	v__token__Pos pos;
	v__token__Pos return_type_pos;
	v__ast__Type receiver_type;
	int usages;
	v__ast__Type return_type;
	v__ast__Type from_embedded_type;
	int ctdefine_idx;
	v__ast__Language file_mode : 4;
	v__ast__Language language : 4;
	bool is_expand_simple_interpolation : 1;
	bool is_c_variadic : 1;
	bool is_pub : 1;
	bool is_ctor_new : 1;
	bool is_deprecated : 1;
	bool is_noreturn : 1;
	bool is_unsafe : 1;
	bool is_must_use : 1;
	bool is_placeholder : 1;
	bool is_main : 1;
	bool is_test : 1;
	bool is_keep_alive : 1;
	bool is_method : 1;
	bool is_static_type_method : 1;
	bool no_body : 1;
	bool is_file_translated : 1;
	bool is_conditional : 1;
	bool is_variadic : 1;
};

struct v__ast__ScopeStructField {
	Array_v__ast__Type smartcasts;
	string name;
	v__token__Pos pos;
	v__ast__Type struct_type;
	v__ast__Type typ;
	v__ast__Type orig_type;
};

struct v__errors__CallStackItem {
	string file_path;
	v__token__Pos pos;
};

struct v__ast__AsmClobbered {
	v__ast__AsmRegister reg;
	Array_v__ast__Comment comments;
};

struct v__ast__AsmTemplate {
	Array_v__ast__AsmArg args;
	Array_v__ast__Comment comments;
	string name;
	v__token__Pos pos;
	bool is_label : 1;
	bool is_directive : 1;
};

struct v__ast__AsmIO {
	string alias;
	string constraint;
	Array_v__ast__Comment comments;
	v__ast__Type typ;
	v__token__Pos pos;
	v__ast__Expr expr;
};

struct v__ast__AsmAddressing {
	int scale;
	v__ast__AddressingMode mode;
	v__token__Pos pos;
	string segment;
	v__ast__AsmArg displacement;
	v__ast__AsmArg base;
	v__ast__AsmArg index;
};

struct v__ast__AsmAlias {
	v__token__Pos pos;
	string name;
};

struct v__ast__AsmDisp {
	string val;
	v__token__Pos pos;
};

struct v__ast__IfGuardVar {
	string name;
	bool is_mut;
	v__token__Pos pos;
};

struct v__ast__Map {
	v__ast__Type key_type;
	v__ast__Type value_type;
	v__token__Pos name_pos;
};

struct v__ast__Struct {
	Array_v__ast__Type generic_types;
	Array_v__ast__Type embeds;
	Array_v__ast__StructField fields;
	Array_v__ast__Attr attrs;
	Array_v__ast__Type concrete_types;
	string scoped_name;
	v__token__Pos name_pos;
	v__ast__Type parent_type;
	bool is_anon : 1;
	bool is_generic : 1;
	bool is_shared : 1;
	bool is_markused : 1;
	bool has_option : 1;
	bool is_heap : 1;
	bool is_union : 1;
	bool is_minify : 1;
	bool is_typedef : 1;
};

struct v__ast__VlsInfo {
	v__token__Pos pos;
	string doc;
};

struct v__ast__Alias {
	v__token__Pos name_pos;
	v__ast__Type parent_type;
	v__ast__Language language : 4;
	bool is_import : 1;
};

struct v__ast__Interface {
	Array_v__ast__Type generic_types;
	Array_v__ast__StructField fields;
	Array_v__ast__Fn methods;
	Array_v__ast__Type embeds;
	Array_v__ast__Type types;
	Array_v__ast__Type concrete_types;
	__shared__Map_int_Array_v__ast__Type* conversions;
	v__token__Pos name_pos;
	v__ast__Type parent_type;
	bool is_markused : 1;
	bool is_generic : 1;
};

struct v__ast__SumType {
	Array_v__ast__StructField fields;
	Array_v__ast__Type variants;
	Array_v__ast__Type generic_types;
	Array_v__ast__Type concrete_types;
	v__token__Pos name_pos;
	v__ast__Type parent_type;
	bool found_fields : 1;
	bool is_anon : 1;
	bool is_generic : 1;
};

struct v__ast__Enum {
	Array_string vals;
	bool is_flag;
	bool is_multi_allowed;
	bool uses_exprs;
	v__ast__Type typ;
	Map_string_Array_v__ast__Attr attrs;
	v__token__Pos name_pos;
};

struct v__parser__ReceiverParsingInfo {
	string name;
	v__token__Pos pos;
	v__ast__Type typ;
	v__token__Pos type_pos;
	bool is_mut;
	v__ast__Language language;
};

struct v__errors__CompilerMessage {
	string message;
	string details;
	string file_path;
	v__token__Pos pos;
	v__errors__Reporter reporter;
	Array_v__errors__CallStackItem call_stack;
};

struct sync__SpinLock {
	u8 locked;
	Array_fixed_u8_63 padding;
};

struct sync__Channel {
	u8* ringbuf;
	u8* statusbuf;
	u32 objsize;
	sync__Semaphore writesem;
	sync__Semaphore readsem;
	sync__Semaphore writesem_im;
	sync__Semaphore readsem_im;
	atomic_uintptr_t write_adr;
	atomic_uintptr_t read_adr;
	atomic_uintptr_t adr_read;
	atomic_uintptr_t adr_written;
	u32 write_free;
	u32 read_avail;
	u32 buf_elem_write_idx;
	u32 buf_elem_read_idx;
	sync__Subscription* write_subscriber;
	sync__Subscription* read_subscriber;
	sync__SpinLock* write_sub_mtx;
	sync__SpinLock* read_sub_mtx;
	u16 closed;
	u32 cap;
};

struct sync__Cond {
	sync__Mutex* mutex;
	sync__Mutex inner_mutex;
	Array_chan_bool waiters;
};

struct sync__ManyTimes {
	sync__RwMutex m;
	u64 times;
	u64 count;
};

struct sync__Once {
	sync__RwMutex m;
	u64 count;
};

struct sync__WaitGroup {
	u32 task_count;
	u32 wait_count;
	sync__Semaphore sem;
};

struct rand__wyrand__WyRandRNG {
	rand__buffer__PRNGBuffer PRNGBuffer;
	u64 state;
	int bytes_left;
	u64 buffer;
};

struct v__pkgconfig__PkgConfig {
	string file_path;
	v__pkgconfig__Options options;
	string name;
	string modname;
	string url;
	string version;
	string description;
	Array_string libs;
	Array_string libs_private;
	Array_string cflags;
	Array_string paths;
	Map_string_string vars;
	Array_string __v_requires;
	Array_string requires_private;
	Array_string conflicts;
	Array_string loaded;
};

struct v__vmod__Parser {
	string file_path;
	v__vmod__Scanner scanner;
};

struct flag__DocConfig {
	string delimiter;
	flag__Style style;
	string name;
	string version;
	string description;
	string footer;
	flag__DocLayout layout;
	flag__DocOptions options;
	Map_string_string fields;
};

struct flag__FlagMapper {
	flag__ParseConfig config;
	Array_string input;
	flag__StructInfo si;
	Array_int handled_pos;
	Map_string_flag__FlagData field_map_flag;
	Map_string_Array_flag__FlagData array_field_map_flag;
	Array_int no_match;
};

struct semver__Comparator {
	semver__Version ver;
	semver__Operator op;
};

struct semver__InvalidComparatorFormatError {
	MessageError MessageError;
};

struct os__FileInfo {
	os__FileMode FileMode;
	u64 size;
	i64 mtime;
};

struct v__ast__File {
	int nr_lines;
	int nr_bytes;
	int nr_tokens;
	v__ast__Module mod;
	v__ast__Scope* global_scope;
	bool is_test;
	bool is_generated;
	bool is_translated;
	v__ast__Language language;
	int idx;
	string path;
	string path_base;
	v__ast__Scope* scope;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Import imports;
	Array_string auto_imports;
	Array_string used_imports;
	Array_string implied_imports;
	Array_v__ast__EmbeddedFile embedded_files;
	Map_string_string imported_symbols;
	v__token__KeywordsMatcherTrie imported_symbols_trie;
	Map_string_bool imported_symbols_used;
	Array_v__errors__Error errors;
	Array_v__errors__Warning warnings;
	Array_v__errors__Notice notices;
	Array_v__errors__CallStackItem call_stack;
	Array_v__ast__FnDecl_ptr generic_fns;
	Array_string global_labels;
	Array_string template_paths;
	Array_v__ast__TemplateLineInfo template_line_map;
	string unique_prefix;
	bool is_parse_text;
	bool is_template_text;
};

struct v__ast__CallExpr {
	v__ast__OrExpr or_block;
	Array_v__ast__Type expected_arg_types;
	Array_v__ast__CallArg args;
	Array_v__ast__Type concrete_types;
	Array_v__ast__Type raw_concrete_types;
	Array_v__ast__Type from_embed_types;
	Array_v__ast__Comment comments;
	string name;
	string const_name;
	v__ast__Expr left;
	string mod;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__token__Pos concrete_list_pos;
	v__token__Pos name_pos;
	v__ast__Type receiver_type;
	v__ast__Type return_type;
	v__ast__Type return_type_generic;
	int nr_ret_values;
	v__ast__Type fn_var_type;
	v__ast__Type left_type;
	v__ast__Type receiver_concrete_type;
	v__ast__CallKind kind : 6;
	v__ast__Language language : 4;
	bool is_unwrapped_fn_selector : 1;
	bool is_method : 1;
	bool is_field : 1;
	bool is_fn_var : 1;
	bool is_fn_a_const : 1;
	bool is_keep_alive : 1;
	bool is_noreturn : 1;
	bool is_ctor_new : 1;
	bool is_file_translated : 1;
	bool is_static_method : 1;
	bool is_variadic : 1;
	bool is_c_variadic : 1;
	bool comptime_ret_val : 1;
	bool should_be_skipped : 1;
	bool free_receiver : 1;
	bool is_return_used : 1;
	bool is_expand_simple_interpolation : 1;
};

struct v__ast__ComptimeSelector {
	v__ast__OrExpr or_block;
	v__ast__Expr field_expr;
	v__ast__Expr left;
	string typ_key;
	v__token__Pos pos;
	v__ast__Type left_type;
	v__ast__Type typ;
	bool is_name : 1;
	bool has_parens : 1;
};

struct v__ast__Ident {
	v__ast__OrExpr or_expr;
	Array_v__ast__Type concrete_types;
	v__ast__ScopeObject obj;
	string mod;
	string name;
	string full_name;
	string cached_name;
	v__ast__IdentInfo info;
	v__ast__Scope* scope;
	v__token__Pos mut_pos;
	v__token__Pos pos;
	v__token__Kind tok_kind : 7;
	v__ast__Language language : 4;
	v__ast__IdentKind kind : 3;
	bool is_mut : 1;
	bool comptime : 1;
	bool ct_expr : 1;
};

struct v__ast__IndexExpr {
	v__ast__OrExpr or_expr;
	v__ast__Expr index;
	v__ast__Expr left;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Type left_type;
	bool is_map : 1;
	bool is_array : 1;
	bool is_farray : 1;
	bool is_option : 1;
	bool is_direct : 1;
	bool is_gated : 1;
	bool is_setter : 1;
};

struct v__ast__InfixExpr {
	v__ast__OrExpr or_block;
	Array_v__ast__Comment after_op_comments;
	Array_v__ast__Comment before_op_comments;
	v__ast__Expr right;
	v__ast__ComptTimeConstValue ct_right_value;
	v__ast__ComptTimeConstValue ct_left_value;
	v__ast__Expr left;
	string auto_locked;
	v__token__Pos pos;
	v__ast__Type left_type;
	v__ast__Type promoted_type;
	v__ast__Type right_type;
	v__token__Kind op : 7;
	bool is_stmt : 1;
	bool ct_left_value_evaled : 1;
	bool left_ct_expr : 1;
	bool ct_right_value_evaled : 1;
	bool right_ct_expr : 1;
};

struct v__ast__PrefixExpr {
	v__ast__OrExpr or_block;
	v__ast__Expr right;
	v__token__Pos pos;
	v__ast__Type right_type;
	v__token__Kind op : 7;
	bool is_option : 1;
};

struct v__ast__SelectorExpr {
	v__ast__OrExpr or_block;
	Array_Array_v__ast__Type generic_from_embed_types;
	Array_v__ast__Type from_embed_types;
	v__ast__Expr expr;
	string field_name;
	v__ast__Scope* scope;
	v__token__Pos mut_pos;
	v__token__Pos pos;
	v__ast__Type name_type;
	v__ast__Type expr_type;
	v__ast__Type typ;
	v__token__Kind next_token : 7;
	v__ast__GenericKindField gkind_field : 3;
	bool is_mut : 1;
	bool has_hidden_receiver : 1;
	bool is_field_typ : 1;
};

struct v__ast__SqlExpr {
	bool is_count;
	bool is_insert;
	string inserted_var;
	bool has_where;
	bool has_order;
	bool has_limit;
	bool has_offset;
	bool has_desc;
	bool has_distinct;
	bool is_array;
	bool is_generated;
	v__token__Pos pos;
	v__ast__Type typ;
	v__ast__Expr db_expr;
	v__ast__Expr where_expr;
	v__ast__Expr order_expr;
	v__ast__Expr limit_expr;
	v__ast__Expr offset_expr;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlExpr sub_structs;
	v__ast__OrExpr or_expr;
	Array_v__ast__JoinClause joins;
};

struct v__ast__AssignStmt {
	v__ast__Attr attr;
	Array_v__ast__Comment end_comments;
	Array_v__ast__Expr right;
	Array_v__ast__Expr left;
	Array_v__ast__Type left_types;
	Array_v__ast__Type right_types;
	v__token__Pos pos;
	v__token__Kind op : 7;
	bool is_static : 1;
	bool is_volatile : 1;
	bool is_simple : 1;
	bool has_cross_var : 1;
};

struct v__ast__SqlStmt {
	v__token__Pos pos;
	Array_v__ast__SqlStmtLine lines;
	v__ast__Expr db_expr;
	v__ast__OrExpr or_expr;
	v__ast__Type db_expr_type;
};

struct v__ast__SelectBranch {
	v__ast__Comment comment;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Comment post_comments;
	v__ast__Stmt stmt;
	v__ast__Scope* scope;
	v__token__Pos pos;
	bool is_timeout : 1;
	bool is_else : 1;
};

struct v__ast__StructField {
	v__ast__StructDecl anon_struct_decl;
	Array_v__ast__Attr attrs;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Comment comments;
	Array_v__ast__Comment next_comments;
	string default_val;
	string name;
	v__ast__Expr default_expr;
	v__token__Pos pos;
	v__token__Pos type_pos;
	v__token__Pos option_pos;
	v__ast__Type default_expr_typ;
	v__ast__Type container_typ;
	v__ast__Type typ;
	v__ast__Type unaliased_typ;
	int i;
	bool is_pub : 1;
	bool has_break_line : 1;
	bool is_recursive : 1;
	bool is_mut : 1;
	bool has_prev_newline : 1;
	bool has_default_expr : 1;
	bool is_part_of_union : 1;
	bool is_global : 1;
	bool is_volatile : 1;
	bool is_deprecated : 1;
	bool is_embed : 1;
};

struct v__errors__Error {
	v__errors__CompilerMessage CompilerMessage;
};

struct v__errors__Warning {
	v__errors__CompilerMessage CompilerMessage;
};

struct v__errors__Notice {
	v__errors__CompilerMessage CompilerMessage;
};

struct v__ast__SqlStmtLine {
	v__ast__SqlStmtKind kind;
	v__token__Pos pos;
	bool is_generated;
	v__ast__Scope* scope;
	string object_var;
	Array_string updated_columns;
	v__ast__TypeNode table_expr;
	Array_v__ast__StructField fields;
	Map_int_v__ast__SqlStmtLine sub_structs;
	v__ast__Expr where_expr;
	Array_v__ast__Expr update_exprs;
	Array_v__ast__Comment pre_comments;
	Array_v__ast__Comment end_comments;
};

struct v__ast__JoinClause {
	v__ast__JoinKind kind;
	v__token__Pos pos;
	v__ast__TypeNode table_expr;
	v__ast__Expr on_expr;
};

struct v__ast__FnType {
	bool is_anon;
	bool has_decl;
	v__ast__Fn func;
};

struct v__parser__Parser {
	v__ast__StructDecl anon_struct_decl;
	Map_string_string imported_symbols;
	Map_string_bool imported_symbols_used;
	Map_string_string imports;
	v__token__KeywordsMatcherTrie imported_symbols_trie;
	v__token__Token tok;
	v__token__Token prev_tok;
	v__token__Token peek_tok;
	v__token__Token script_mode_start_token;
	Array_v__errors__Warning warnings;
	Array_v__errors__Error errors;
	Array_v__ast__Type init_generic_types;
	Array_string implied_imports;
	Array_string auto_imports;
	Array_string used_imports;
	Array_v__ast__Import ast_imports;
	Array_v__ast__Attr attrs;
	Array_v__ast__TemplateLineInfo template_line_map;
	Array_string template_paths;
	Array_v__errors__Notice notices;
	Array_v__ast__Comment cur_comments;
	Array_v__ast__Comment left_comments;
	Array_v__ast__Comment if_cond_comments;
	Array_v__ast__Ident defer_vars;
	Array_string global_labels;
	Array_string label_names;
	string unique_prefix;
	string cur_fn_name;
	string last_enum_name;
	string file_path;
	string mod;
	string file_display_path;
	string expr_mod;
	string file_base;
	string last_enum_mod;
	string codegen_text;
	v__pref__Preferences* pref;
	v__ast__Table* table;
	v__ast__Scope* cur_fn_scope;
	v__scanner__Scanner* scanner;
	v__ast__Scope* scope;
	int generic_type_level;
	int expr_level;
	int max_opened_scopes;
	int opened_scopes;
	int array_dim;
	int n_asm;
	int fixed_array_dim;
	i16 file_idx;
	v__ast__Language fn_language : 4;
	v__ast__Language language : 4;
	v__ast__Language file_backend_mode : 4;
	v__ast__Language struct_language : 4;
	v__parser__ParseContentKind content : 3;
	v__ast__DeferMode defer_mode : 2;
	bool inside_lock_exprs : 1;
	bool inside_chan_decl : 1;
	bool inside_orm : 1;
	bool or_is_handled : 1;
	bool builtin_mod : 1;
	bool inside_map_init : 1;
	bool is_manualfree : 1;
	bool has_globals : 1;
	bool is_generated : 1;
	bool is_translated : 1;
	bool inside_struct_attr_decl : 1;
	bool inside_struct_field_decl : 1;
	bool inside_receiver_param : 1;
	bool inside_generic_params : 1;
	bool inside_defer : 1;
	bool inside_asm : 1;
	bool inside_asm_template : 1;
	bool inside_sum_type : 1;
	bool inside_unsafe : 1;
	bool inside_ct_match_body : 1;
	bool inside_ct_match_case : 1;
	bool is_amp : 1;
	bool returns : 1;
	bool is_stmt_ident : 1;
	bool expecting_type : 1;
	bool expecting_value : 1;
	bool inside_ct_match : 1;
	bool inside_match_body : 1;
	bool inside_match_case : 1;
	bool name_error : 1;
	bool inside_select : 1;
	bool inside_match : 1;
	bool comptime_if_cond : 1;
	bool inside_assign_rhs : 1;
	bool should_abort : 1;
	bool inside_infix : 1;
	bool inside_in_array : 1;
	bool inside_array_lit : 1;
	bool inside_str_interp : 1;
	bool inside_unsafe_fn : 1;
	bool script_mode : 1;
	bool inside_call_args : 1;
	bool inside_fn_concrete_type : 1;
	bool main_already_defined : 1;
	bool is_vls : 1;
	bool is_vls_skip_file : 1;
	bool inside_import_section : 1;
	bool inside_fn_return : 1;
	bool inside_fn : 1;
	bool inside_for_expr : 1;
	bool inside_for : 1;
	bool inside_or_expr : 1;
	bool inside_ct_if_expr : 1;
	bool inside_if_cond : 1;
	bool inside_if_expr : 1;
	bool inside_comptime_if : 1;
	bool inside_if : 1;
	bool inside_test_file : 1;
	bool inside_attr_decl : 1;
	bool inside_vlib_file : 1;
};

struct v__ast__FnDecl {
	v__ast__StructField receiver;
	Map_string_v__ast__FnTrace trace_fns;
	Array_v__ast__Comment comments;
	Array_string label_names;
	Array_v__ast__Comment end_comments;
	Array_v__ast__DeferStmt defer_stmts;
	Array_v__ast__Stmt stmts;
	Array_v__ast__Param params;
	Array_v__ast__Attr attrs;
	Array_string generic_names;
	Array_v__ast__Comment next_comments;
	string name;
	string file;
	string mod;
	string short_name;
	v__ast__Scope* scope;
	v__ast__File* source_file;
	v__token__Pos receiver_pos;
	v__token__Pos static_type_pos;
	v__token__Pos method_type_pos;
	v__token__Pos name_pos;
	v__token__Pos body_pos;
	v__token__Pos return_type_pos;
	v__token__Pos pos;
	v__token__Pos end_pos;
	int ninstances;
	v__ast__Type return_type;
	int idx;
	int ctdefine_idx;
	int method_idx;
	v__ast__CallKind kind : 6;
	v__ast__Language language : 4;
	v__ast__Language file_mode : 4;
	v__ast__ShareType rec_share : 2;
	bool is_exported : 1;
	bool is_keep_alive : 1;
	bool no_body : 1;
	bool is_builtin : 1;
	bool is_deprecated : 1;
	bool rec_mut : 1;
	bool is_conditional : 1;
	bool is_test : 1;
	bool is_direct_arr : 1;
	bool is_main : 1;
	bool is_pub : 1;
	bool is_c_variadic : 1;
	bool is_manualfree : 1;
	bool is_noreturn : 1;
	bool is_weak : 1;
	bool is_anon : 1;
	bool is_static_type_method : 1;
	bool is_expand_simple_interpolation : 1;
	bool has_return : 1;
	bool should_be_skipped : 1;
	bool is_method : 1;
	bool has_await : 1;
	bool is_variadic : 1;
	bool is_c_extern : 1;
	bool is_unsafe : 1;
	bool is_must_use : 1;
	bool is_markused : 1;
	bool is_ignore_overflow : 1;
	bool is_file_translated : 1;
	bool is_closure : 1;
	bool has_break_line : 1;
	bool has_prev_newline : 1;
};

struct v__ast__ComptimeCall {
	v__ast__File veb_tmpl;
	v__ast__EmbeddedFile embed_file;
	v__ast__OrExpr or_block;
	Array_v__ast__CallArg args;
	string method_name;
	v__ast__Expr left;
	string env_value;
	string args_var;
	string compile_value;
	v__ast__Scope* scope;
	v__token__Pos pos;
	v__token__Pos method_pos;
	v__token__Pos env_pos;
	v__ast__Type result_type;
	v__ast__Type left_type;
	v__ast__ComptimeCallKind kind : 4;
	bool is_d_resolved : 1;
	bool is_veb : 1;
	bool is_vweb : 1;
	bool has_parens : 1;
};

struct v__ast__GoExpr {
	v__ast__CallExpr call_expr;
	v__token__Pos pos;
	bool is_expr : 1;
};

struct v__ast__SpawnExpr {
	v__ast__CallExpr call_expr;
	v__token__Pos pos;
	bool is_expr : 1;
};

struct v__ast__AnonFn {
	v__ast__FnDecl decl;
	Array_v__ast__Param inherited_vars;
	bool has_ct_var;
	v__ast__Type typ;
	Map_string_bool has_gen;
};
// #end sorted_symbols

// BEGIN_array_fixed_return_structs
struct _v_Array_fixed_bool_256 {
	bool ret_arr[256];
};
// END_array_fixed_return_structs


// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_strconv__ParserState_strconv__PrepNumber {
	strconv__ParserState arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_i64_int {
	i64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_string_string_string {
	string arg0;
	string arg1;
	string arg2;
};

struct multi_return_Array_string_Array_string {
	Array_string arg0;
	Array_string arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_f64_int {
	f64 arg0;
	int arg1;
};

struct multi_return_v__ast__Fn_Array_v__ast__Type {
	v__ast__Fn arg0;
	Array_v__ast__Type arg1;
};

struct multi_return_v__ast__StructField_Array_v__ast__Type {
	v__ast__StructField arg0;
	Array_v__ast__Type arg1;
};

struct multi_return_ref_v__ast__TypeSymbol_int {
	v__ast__TypeSymbol* arg0;
	int arg1;
};

struct multi_return_v__ast__Type_string {
	v__ast__Type arg0;
	string arg1;
};

struct multi_return_int_v__ast__Type {
	int arg0;
	v__ast__Type arg1;
};

struct multi_return_bool_bool_int {
	bool arg0;
	bool arg1;
	int arg2;
};

struct multi_return_ref_v__pref__Preferences_string {
	v__pref__Preferences* arg0;
	string arg1;
};

struct multi_return_Array_v__ast__Param_bool_bool_bool {
	Array_v__ast__Param arg0;
	bool arg1;
	bool arg2;
	bool arg3;
};

struct multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope {
	Array_v__ast__Stmt arg0;
	v__token__Pos arg1;
	v__ast__Scope* arg2;
};

struct multi_return_Array_v__ast__Type_Array_string {
	Array_v__ast__Type arg0;
	Array_string arg1;
};

struct multi_return_bool_string_int_Array_string {
	bool arg0;
	string arg1;
	int arg2;
	Array_string arg3;
};

struct multi_return_Array_string_Array_string_Array_string {
	Array_string arg0;
	Array_string arg1;
	Array_string arg2;
};

struct multi_return_f64_f64 {
	f64 arg0;
	f64 arg1;
};

struct multi_return_int_int_int_int {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	i64 arg5;
	bool arg6;
};

struct multi_return_Array_string_int {
	Array_string arg0;
	int arg1;
};

struct multi_return_Array_string_v__vmod__ModFileAndFolder {
	Array_string arg0;
	v__vmod__ModFileAndFolder arg1;
};

struct multi_return_ref_sync__SpinLock_ref_sync__Subscription {
	sync__SpinLock* arg0;
	sync__Subscription** arg1;
};

// END_multi_return_structs


typedef struct thread_arg_vphp__ITask_run {
	Array_f64 (*fn) (vphp__ITask);
	vphp__ITask arg0;
} thread_arg_vphp__ITask_run;

typedef struct thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731 {
	void (*fn) (sync__WaitGroup*, void (*) ());
	sync__WaitGroup* arg1;
	void (*arg2) ();
} thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731;
static bool Array_u8_contains(Array_u8 a, u8 v);
static bool Array_string_contains(Array_string a, string v);
static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v);
static bool Array_fixed_string_9_contains(Array_fixed_string_9 a, string v);
static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v);
static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v);
static bool Array_v__ast__Kind_contains(Array_v__ast__Kind a, v__ast__Kind v);
static bool Array_int_contains(Array_int a, int v);
static bool Array_rune_contains(Array_rune a, rune v);
static int Array_string_index(Array_string a, string v);

// V shared types:
struct __shared__Map_u64_string {
	sync__RwMutex mtx;
	Map_u64_string val;
};
struct __shared__Map_string_time__StopWatch {
	sync__RwMutex mtx;
	Map_string_time__StopWatch val;
};
struct __shared__Map_int_Array_v__ast__Type {
	sync__RwMutex mtx;
	Map_int_Array_v__ast__Type val;
};

// V Option_xxx definitions:
struct _option_rune {
	byte state;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _option_multi_return_string_string {
	byte state;
	IError err;
	byte data[sizeof(multi_return_string_string) > 1 ? sizeof(multi_return_string_string) : 1];
};

struct _option_int {
	byte state;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _option_u8 {
	byte state;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _option_semver__Version {
	byte state;
	IError err;
	byte data[sizeof(semver__Version) > 1 ? sizeof(semver__Version) : 1];
};

struct _option_semver__ComparatorSet {
	byte state;
	IError err;
	byte data[sizeof(semver__ComparatorSet) > 1 ? sizeof(semver__ComparatorSet) : 1];
};

struct _option_semver__Comparator {
	byte state;
	IError err;
	byte data[sizeof(semver__Comparator) > 1 ? sizeof(semver__Comparator) : 1];
};

struct _option_anon_fn_string__vphp__ITask {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct _option_Array_string {
	byte state;
	IError err;
	byte data[sizeof(Array_string) > 1 ? sizeof(Array_string) : 1];
};

struct _option_time__StopWatch {
	byte state;
	IError err;
	byte data[sizeof(time__StopWatch) > 1 ? sizeof(time__StopWatch) : 1];
};

struct _option_v__ast__Ident {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Ident) > 1 ? sizeof(v__ast__Ident) : 1];
};

struct _option_v__ast__CallArg {
	byte state;
	IError err;
	byte data[sizeof(v__ast__CallArg) > 1 ? sizeof(v__ast__CallArg) : 1];
};

struct _option_v__ast__Attr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Attr) > 1 ? sizeof(v__ast__Attr) : 1];
};

struct _option_i8 {
	byte state;
	IError err;
	byte data[sizeof(i8) > 1 ? sizeof(i8) : 1];
};

struct _option_i64 {
	byte state;
	IError err;
	byte data[sizeof(i64) > 1 ? sizeof(i64) : 1];
};

struct _option_i16 {
	byte state;
	IError err;
	byte data[sizeof(i16) > 1 ? sizeof(i16) : 1];
};

struct _option_i32 {
	byte state;
	IError err;
	byte data[sizeof(i32) > 1 ? sizeof(i32) : 1];
};

struct _option_voidptr {
	byte state;
	IError err;
	byte data[sizeof(voidptr) > 1 ? sizeof(voidptr) : 1];
};

struct _option_u64 {
	byte state;
	IError err;
	byte data[sizeof(u64) > 1 ? sizeof(u64) : 1];
};

struct _option_u16 {
	byte state;
	IError err;
	byte data[sizeof(u16) > 1 ? sizeof(u16) : 1];
};

struct _option_u32 {
	byte state;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};

struct _option_f32 {
	byte state;
	IError err;
	byte data[sizeof(f32) > 1 ? sizeof(f32) : 1];
};

struct _option_f64 {
	byte state;
	IError err;
	byte data[sizeof(f64) > 1 ? sizeof(f64) : 1];
};

struct _option_v__ast__ComptTimeConstValue {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ComptTimeConstValue) > 1 ? sizeof(v__ast__ComptTimeConstValue) : 1];
};

struct _option_v__ast__ScopeObject {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeObject) > 1 ? sizeof(v__ast__ScopeObject) : 1];
};

struct _option_v__ast__ScopeStructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ScopeStructField) > 1 ? sizeof(v__ast__ScopeStructField) : 1];
};

struct _option_v__ast__Var_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Var*) > 1 ? sizeof(v__ast__Var*) : 1];
};

struct _option_v__ast__GlobalField_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__GlobalField*) > 1 ? sizeof(v__ast__GlobalField*) : 1];
};

struct _option_v__ast__ConstField_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__ConstField*) > 1 ? sizeof(v__ast__ConstField*) : 1];
};

struct _option_v__ast__Fn {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Fn) > 1 ? sizeof(v__ast__Fn) : 1];
};

struct _option_v__ast__StructField {
	byte state;
	IError err;
	byte data[sizeof(v__ast__StructField) > 1 ? sizeof(v__ast__StructField) : 1];
};

struct _option_v__ast__TypeSymbol_ptr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__TypeSymbol*) > 1 ? sizeof(v__ast__TypeSymbol*) : 1];
};

struct _option_Array_Array_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(Array_Array_v__ast__Type) > 1 ? sizeof(Array_Array_v__ast__Type) : 1];
};

struct _option_v__ast__Type {
	byte state;
	IError err;
	byte data[sizeof(v__ast__Type) > 1 ? sizeof(v__ast__Type) : 1];
};

struct _option_v__token__Pos {
	byte state;
	IError err;
	byte data[sizeof(v__token__Pos) > 1 ? sizeof(v__token__Pos) : 1];
};

struct _option_v__ast__EnumDecl {
	byte state;
	IError err;
	byte data[sizeof(v__ast__EnumDecl) > 1 ? sizeof(v__ast__EnumDecl) : 1];
};

struct _option_v__ast__LambdaExpr {
	byte state;
	IError err;
	byte data[sizeof(v__ast__LambdaExpr) > 1 ? sizeof(v__ast__LambdaExpr) : 1];
};

struct _option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};


// V result_xxx definitions:
struct _result_int {
	bool is_error;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _result_f64 {
	bool is_error;
	IError err;
	byte data[sizeof(f64) > 1 ? sizeof(f64) : 1];
};

struct _result_u64 {
	bool is_error;
	IError err;
	byte data[sizeof(u64) > 1 ? sizeof(u64) : 1];
};

struct _result_i64 {
	bool is_error;
	IError err;
	byte data[sizeof(i64) > 1 ? sizeof(i64) : 1];
};

struct _result_multi_return_i64_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_i64_int) > 1 ? sizeof(multi_return_i64_int) : 1];
};

struct _result_i8 {
	bool is_error;
	IError err;
	byte data[sizeof(i8) > 1 ? sizeof(i8) : 1];
};

struct _result_i16 {
	bool is_error;
	IError err;
	byte data[sizeof(i16) > 1 ? sizeof(i16) : 1];
};

struct _result_i32 {
	bool is_error;
	IError err;
	byte data[sizeof(i32) > 1 ? sizeof(i32) : 1];
};

struct _result_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _result_u16 {
	bool is_error;
	IError err;
	byte data[sizeof(u16) > 1 ? sizeof(u16) : 1];
};

struct _result_u32 {
	bool is_error;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};

struct _result_void {
	bool is_error;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _result_rune {
	bool is_error;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _result_string {
	bool is_error;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _result_voidptr {
	bool is_error;
	IError err;
	byte data[sizeof(voidptr) > 1 ? sizeof(voidptr) : 1];
};

struct _result_Array_string {
	bool is_error;
	IError err;
	byte data[sizeof(Array_string) > 1 ? sizeof(Array_string) : 1];
};

struct _result_time__Time {
	bool is_error;
	IError err;
	byte data[sizeof(time__Time) > 1 ? sizeof(time__Time) : 1];
};

struct _result_multi_return_int_int_int_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int) > 1 ? sizeof(multi_return_int_int_int_int) : 1];
};

struct _result_multi_return_int_int_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int_int) > 1 ? sizeof(multi_return_int_int_int) : 1];
};

struct _result_multi_return_int_int_int_int_int_i64_bool {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int_int_i64_bool) > 1 ? sizeof(multi_return_int_int_int_int_int_i64_bool) : 1];
};

struct _result_bool {
	bool is_error;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};

struct _result_flag__Flag {
	bool is_error;
	IError err;
	byte data[sizeof(flag__Flag) > 1 ? sizeof(flag__Flag) : 1];
};

struct _result_semver__Range {
	bool is_error;
	IError err;
	byte data[sizeof(semver__Range) > 1 ? sizeof(semver__Range) : 1];
};

struct _result_semver__Version {
	bool is_error;
	IError err;
	byte data[sizeof(semver__Version) > 1 ? sizeof(semver__Version) : 1];
};

struct _result_semver__ComparatorSet {
	bool is_error;
	IError err;
	byte data[sizeof(semver__ComparatorSet) > 1 ? sizeof(semver__ComparatorSet) : 1];
};

struct _result_vphp__Val {
	bool is_error;
	IError err;
	byte data[sizeof(vphp__Val) > 1 ? sizeof(vphp__Val) : 1];
};

struct _result_os__Command {
	bool is_error;
	IError err;
	byte data[sizeof(os__Command) > 1 ? sizeof(os__Command) : 1];
};

struct _result_os__File {
	bool is_error;
	IError err;
	byte data[sizeof(os__File) > 1 ? sizeof(os__File) : 1];
};

struct _result_FILE_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(FILE*) > 1 ? sizeof(FILE*) : 1];
};

struct _result_os__Stat {
	bool is_error;
	IError err;
	byte data[sizeof(os__Stat) > 1 ? sizeof(os__Stat) : 1];
};

struct _result_Array_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(Array_u8) > 1 ? sizeof(Array_u8) : 1];
};

struct _result_strings__Builder {
	bool is_error;
	IError err;
	byte data[sizeof(strings__Builder) > 1 ? sizeof(strings__Builder) : 1];
};

struct _result_os__Result {
	bool is_error;
	IError err;
	byte data[sizeof(os__Result) > 1 ? sizeof(os__Result) : 1];
};

struct _result_os__DiskUsage {
	bool is_error;
	IError err;
	byte data[sizeof(os__DiskUsage) > 1 ? sizeof(os__DiskUsage) : 1];
};

struct _result_os__Pipe {
	bool is_error;
	IError err;
	byte data[sizeof(os__Pipe) > 1 ? sizeof(os__Pipe) : 1];
};

struct _result_os__IOCapture {
	bool is_error;
	IError err;
	byte data[sizeof(os__IOCapture) > 1 ? sizeof(os__IOCapture) : 1];
};

struct _result_anon_fn_os__signal {
	bool is_error;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct _result_v__pkgconfig__PkgConfig_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(v__pkgconfig__PkgConfig*) > 1 ? sizeof(v__pkgconfig__PkgConfig*) : 1];
};

struct _result_v__pkgconfig__Main_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(v__pkgconfig__Main*) > 1 ? sizeof(v__pkgconfig__Main*) : 1];
};

struct _result_term__Coord {
	bool is_error;
	IError err;
	byte data[sizeof(term__Coord) > 1 ? sizeof(term__Coord) : 1];
};

struct _result_usize {
	bool is_error;
	IError err;
	byte data[sizeof(usize) > 1 ? sizeof(usize) : 1];
};

struct _result_v__vmod__Manifest {
	bool is_error;
	IError err;
	byte data[sizeof(v__vmod__Manifest) > 1 ? sizeof(v__vmod__Manifest) : 1];
};

struct _result_multi_return_Array_string_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_Array_string_int) > 1 ? sizeof(multi_return_Array_string_int) : 1];
};

struct _result_f32 {
	bool is_error;
	IError err;
	byte data[sizeof(f32) > 1 ? sizeof(f32) : 1];
};

struct _result_multi_return_f64_f64 {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_f64_f64) > 1 ? sizeof(multi_return_f64_f64) : 1];
};

struct _result_v__pref__Arch {
	bool is_error;
	IError err;
	byte data[sizeof(v__pref__Arch) > 1 ? sizeof(v__pref__Arch) : 1];
};

struct _result_v__pref__OS {
	bool is_error;
	IError err;
	byte data[sizeof(v__pref__OS) > 1 ? sizeof(v__pref__OS) : 1];
};

struct _result_v__pref__Subsystem {
	bool is_error;
	IError err;
	byte data[sizeof(v__pref__Subsystem) > 1 ? sizeof(v__pref__Subsystem) : 1];
};

struct _result_v__pref__Backend {
	bool is_error;
	IError err;
	byte data[sizeof(v__pref__Backend) > 1 ? sizeof(v__pref__Backend) : 1];
};

struct _result_v__ast__Fn {
	bool is_error;
	IError err;
	byte data[sizeof(v__ast__Fn) > 1 ? sizeof(v__ast__Fn) : 1];
};

struct _result_multi_return_v__ast__Fn_Array_v__ast__Type {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_v__ast__Fn_Array_v__ast__Type) > 1 ? sizeof(multi_return_v__ast__Fn_Array_v__ast__Type) : 1];
};

struct _result_v__ast__StructField {
	bool is_error;
	IError err;
	byte data[sizeof(v__ast__StructField) > 1 ? sizeof(v__ast__StructField) : 1];
};

struct _result_multi_return_v__ast__StructField_Array_v__ast__Type {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_v__ast__StructField_Array_v__ast__Type) > 1 ? sizeof(multi_return_v__ast__StructField_Array_v__ast__Type) : 1];
};

struct _result_v__scanner__Scanner_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(v__scanner__Scanner*) > 1 ? sizeof(v__scanner__Scanner*) : 1];
};

struct _result_v__ast__Expr {
	bool is_error;
	IError err;
	byte data[sizeof(v__ast__Expr) > 1 ? sizeof(v__ast__Expr) : 1];
};

struct _result_main__StockParams {
	bool is_error;
	IError err;
	byte data[sizeof(main__StockParams) > 1 ? sizeof(main__StockParams) : 1];
};


// V definitions:
static char * v_typeof_interface_IError(u32 sidx);
u32 v_typeof_interface_idx_IError(u32 sidx);
static char * v_typeof_interface_vphp__ITask(u32 sidx);
u32 v_typeof_interface_idx_vphp__ITask(u32 sidx);
char * v_typeof_sumtype_v__ast__Stmt(u32);
static char * v_typeof_interface_vphp__compiler__PhpRepr(u32 sidx);
u32 v_typeof_interface_idx_vphp__compiler__PhpRepr(u32 sidx);
char * v_typeof_sumtype_v__ast__TypeDecl(u32);
char * v_typeof_sumtype_v__ast__Expr(u32);
char * v_typeof_sumtype_v__ast__ScopeObject(u32);
char * v_typeof_sumtype_v__ast__Node(u32);
char * v_typeof_sumtype_v__ast__ComptTimeConstValue(u32);
char * v_typeof_sumtype_v__ast__IdentInfo(u32);
char * v_typeof_sumtype_v__ast__AsmArg(u32);
char * v_typeof_sumtype_v__ast__TypeInfo(u32);
static char * v_typeof_interface_rand__PRNG(u32 sidx);
u32 v_typeof_interface_idx_rand__PRNG(u32 sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b);
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len);
void strings__Builder_write_rune(strings__Builder* b, rune r);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_write_u8(strings__Builder* b, u8 data);
void strings__Builder_write_byte(strings__Builder* b, u8 data);
void strings__Builder_write_decimal(strings__Builder* b, i64 n);
_result_int strings__Builder_write(strings__Builder* b, Array_u8 data);
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap);
u8 strings__Builder_byte_at(strings__Builder* b, int n);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_write_string2(strings__Builder* b, string s1, string s2);
void strings__Builder_go_back(strings__Builder* b, int n);
string strings__Builder_spart(strings__Builder* b, int start_pos, int n);
string strings__Builder_cut_last(strings__Builder* b, int n);
string strings__Builder_cut_to(strings__Builder* b, int pos);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
void strings__Builder_writeln2(strings__Builder* b, string s1, string s2);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_ensure_cap(strings__Builder* b, int n);
void strings__Builder_grow_len(strings__Builder* b, int n);
void strings__Builder_free(strings__Builder* b);
void strings__Builder_write_repeated_rune(strings__Builder* b, rune r, int count);
void strings__Builder_indent(strings__Builder* b, string s, strings__IndentParam param);
VV_LOC int strings__min(int a, int b, int c);
VV_LOC int strings__max2(int a, int b);
VV_LOC int strings__min2(int a, int b);
VV_LOC int strings__abs2(int a, int b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
int strings__hamming_distance(string a, string b);
f32 strings__hamming_similarity(string a, string b);
f64 strings__jaro_similarity(string a, string b);
f64 strings__jaro_winkler_similarity(string a, string b);
string strings__repeat(u8 c, int n);
string strings__repeat_string(string s, int n);
string strings__find_between_pair_u8(string input, u8 start, u8 end);
string strings__find_between_pair_rune(string input, rune start, rune end);
string strings__find_between_pair_string(string input, string start, string end);
Array_string strings__split_capital(string s);
VV_LOC void builtin__closure__closure_alloc(void);
VV_LOC void builtin__closure__closure_init(void);
VV_LOC voidptr builtin__closure__closure_create(voidptr func, voidptr data);
VV_LOC u8* builtin__closure__closure_alloc_platform(void);
VV_LOC void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr);
VV_LOC int builtin__closure__get_page_size_platform(void);
VV_LOC void builtin__closure__closure_mtx_lock_init_platform(void);
VV_LOC void builtin__closure__closure_mtx_lock_platform(void);
VV_LOC void builtin__closure__closure_mtx_unlock_platform(void);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u64_u64 math__bits__mul_add_64(u64 x, u64 y, u64 z);
int math__bits__leading_zeros_8(u8 x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(u8 x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(u8 x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
int math__bits__pure_v_but_overridden_by_c_leading_zeros_8(u8 x);
VV_LOC int math__bits__leading_zeros_8_default(u8 x);
int math__bits__pure_v_but_overridden_by_c_leading_zeros_16(u16 x);
VV_LOC int math__bits__leading_zeros_16_default(u16 x);
int math__bits__pure_v_but_overridden_by_c_leading_zeros_32(u32 x);
VV_LOC int math__bits__leading_zeros_32_default(u32 x);
int math__bits__pure_v_but_overridden_by_c_leading_zeros_64(u64 x);
VV_LOC int math__bits__leading_zeros_64_default(u64 x);
int math__bits__pure_v_but_overridden_by_c_trailing_zeros_8(u8 x);
VV_LOC int math__bits__trailing_zeros_8_default(u8 x);
int math__bits__pure_v_but_overridden_by_c_trailing_zeros_16(u16 x);
VV_LOC int math__bits__trailing_zeros_16_default(u16 x);
int math__bits__pure_v_but_overridden_by_c_trailing_zeros_32(u32 x);
VV_LOC int math__bits__trailing_zeros_32_default(u32 x);
int math__bits__pure_v_but_overridden_by_c_trailing_zeros_64(u64 x);
VV_LOC int math__bits__trailing_zeros_64_default(u64 x);
int math__bits__pure_v_but_overridden_by_c_ones_count_8(u8 x);
VV_LOC int math__bits__ones_count_8_default(u8 x);
int math__bits__pure_v_but_overridden_by_c_ones_count_16(u16 x);
VV_LOC int math__bits__ones_count_16_default(u16 x);
int math__bits__pure_v_but_overridden_by_c_ones_count_32(u32 x);
VV_LOC int math__bits__ones_count_32_default(u32 x);
int math__bits__pure_v_but_overridden_by_c_ones_count_64(u64 x);
VV_LOC int math__bits__ones_count_64_default(u64 x);
u8 math__bits__rotate_left_8(u8 x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
u8 math__bits__reverse_8(u8 x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(u8 x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
VV_LOC multi_return_u32_u32 math__bits__mul_32_default(u32 x, u32 y);
multi_return_u64_u64 math__bits__pure_v_but_overridden_by_arm64_mul_64(u64 x, u64 y);
VV_LOC multi_return_u64_u64 math__bits__mul_64_default(u64 x, u64 y);
multi_return_u32_u32 math__bits__mul_add_32(u32 x, u32 y, u32 z);
VV_LOC multi_return_u32_u32 math__bits__mul_add_32_default(u32 x, u32 y, u32 z);
multi_return_u64_u64 math__bits__pure_v_but_overridden_by_arm64_mul_add_64(u64 x, u64 y, u64 z);
VV_LOC multi_return_u64_u64 math__bits__mul_add_64_default(u64 x, u64 y, u64 z);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
VV_LOC multi_return_u32_u32 math__bits__div_32_default(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
VV_LOC multi_return_u64_u64 math__bits__div_64_default(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
multi_return_f64_int math__bits__normalize(f64 x);
u32 math__bits__f32_bits(f32 f);
f32 math__bits__f32_from_bits(u32 b);
u64 math__bits__f64_bits(f64 f);
f64 math__bits__f64_from_bits(u64 b);
VV_LOC multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
VV_LOC multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
VV_LOC multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOC multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s);
VV_LOC u64 strconv__converter(strconv__PrepNumber* pn);
_result_f64 strconv__atof64(string s, strconv__AtoF64Param param);
f64 strconv__atof_quick(string s);
u8 strconv__byte_to_lower(u8 c);
_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
_result_u64 strconv__parse_uint(string s, int _base, int _bit_size);
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
_result_i64 strconv__parse_int(string _s, int base, int _bit_size);
VV_LOC _result_multi_return_i64_int strconv__atoi_common_check(string s);
VV_LOC _result_i64 strconv__atoi_common(string s, i64 type_min, i64 type_max);
_result_int strconv__atoi(string s);
_result_i8 strconv__atoi8(string s);
_result_i16 strconv__atoi16(string s);
_result_i32 strconv__atoi32(string s);
_result_i64 strconv__atoi64(string s);
VV_LOC _result_i64 strconv__safe_add_64bits(i64 a, i64 b);
VV_LOC _result_i64 strconv__safe_mul10_64bits(i64 a);
VV_LOC _result_int strconv__atou_common_check(string s);
VV_LOC _result_u64 strconv__atou_common(string s, u64 type_max);
_result_u8 strconv__atou8(string s);
_result_u16 strconv__atou16(string s);
_result_u32 strconv__atou(string s);
_result_u32 strconv__atou32(string s);
_result_u64 strconv__atou64(string s);
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOC multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
VV_LOC strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
VV_LOC string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOC multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOC strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
string strconv__format_str(string s, strconv__BF_param p);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_with_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_with_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_with_dot(string s);
VV_LOC u32 strconv__bool_to_u32(bool b);
VV_LOC u64 strconv__bool_to_u64(bool b);
VV_LOC string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOC u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOC u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOC u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOC u32 strconv__pow5_factor_32(u32 i_v);
VV_LOC bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOC bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOC u32 strconv__log10_pow2(int e);
VV_LOC u32 strconv__log10_pow5(int e);
VV_LOC int strconv__pow5_bits(int e);
VV_LOC u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOC u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOC u32 strconv__pow5_factor_64(u64 v_i);
VV_LOC bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOC bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
void strconv__v_printf(string str, Array_voidptr pt);
string strconv__v_sprintf(string str, Array_voidptr pt);
VV_LOC void strconv__v_sprintf_panic(int idx, int len);
VV_LOC f64 strconv__fabs(f64 x);
string strconv__format_fl_old(f64 f, strconv__BF_param p);
VV_LOC string strconv__format_es_old(f64 f, strconv__BF_param p);
VV_LOC string strconv__remove_tail_zeros_old(string s);
string strconv__format_dec_old(u64 d, strconv__BF_param p);
VV_LOC void builtin___memory_panic(string fname, isize size);
u8* builtin___v_malloc(isize n);
u8* builtin__malloc_noscan(isize n);
VV_LOC u64 builtin____at_least_one(u64 how_many);
u8* builtin__malloc_uncollectable(isize n);
u8* builtin__v_realloc(u8* b, isize n);
u8* builtin__realloc_data(u8* old_data, int old_size, int new_size);
u8* builtin__vcalloc(isize n);
u8* builtin__vcalloc_noscan(isize n);
void builtin___v_free(voidptr ptr);
voidptr builtin__memdup(voidptr src, isize sz);
voidptr builtin__memdup_noscan(voidptr src, isize sz);
voidptr builtin__memdup_uncollectable(voidptr src, isize sz);
voidptr builtin__memdup_align(voidptr src, isize sz, isize align);
GCHeapUsage builtin__gc_heap_usage(void);
usize builtin__gc_memory_use(void);
VV_LOC array builtin____new_array(int mylen, int cap, int elm_size);
VV_LOC array builtin____new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth);
VV_LOC array builtin__new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
void builtin__array_ensure_cap(array* a, int required);
array builtin__array_repeat(array a, int count);
array builtin__array_repeat_to_depth(array a, int count, int depth);
void builtin__array_insert(array* a, int i, voidptr val);
VV_LOC void builtin__array_insert_many(array* a, int i, voidptr val, int size);
void builtin__array_prepend(array* a, voidptr val);
VV_LOC void builtin__array_prepend_many(array* a, voidptr val, int size);
void builtin__array_delete(array* a, int i);
void builtin__array_delete_many(array* a, int i, int size);
void builtin__array_clear(array* a);
void builtin__array_reset(array* a);
void builtin__array_trim(array* a, int index);
void builtin__array_drop(array* a, int num);
VV_LOC voidptr builtin__array_get_unsafe(array a, int i);
VV_LOC voidptr builtin__array_get(array a, int i);
VV_LOC voidptr builtin__array_get_with_check(array a, int i);
voidptr builtin__array_first(array a);
voidptr builtin__array_last(array a);
voidptr builtin__array_pop_left(array* a);
voidptr builtin__array_pop(array* a);
void builtin__array_delete_last(array* a);
VV_LOC array builtin__array_slice(array a, int start, int _end);
VV_LOC array builtin__array_slice_ni(array a, int _start, int _end);
VV_LOC array builtin__array_clone_static_to_depth(array a, int depth);
array builtin__array_clone(array* a);
array builtin__array_clone_to_depth(array* a, int depth);
VV_LOC void builtin__array_set_unsafe(array* a, int i, voidptr val);
VV_LOC void builtin__array_set(array* a, int i, voidptr val);
VV_LOC void builtin__array_push(array* a, voidptr val);
void builtin__array_push_many(array* a, voidptr val, int size);
void builtin__array_reverse_in_place(array* a);
array builtin__array_reverse(array a);
void builtin__array_free(array* a);
array builtin__array_filter(array a, bool (*predicate)(voidptr ));
bool builtin__array_any(array a, bool (*predicate)(voidptr ));
int builtin__array_count(array a, bool (*predicate)(voidptr ));
bool builtin__array_all(array a, bool (*predicate)(voidptr ));
array builtin__array_map(array a, voidptr (*callback)(voidptr ));
void builtin__array_sort(array* a, int (*callback)(voidptr , voidptr ));
array builtin__array_sorted(array* a, int (*callback)(voidptr , voidptr ));
void builtin__array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr ));
array builtin__array_sorted_with_compare(array* a, int (*callback)(voidptr , voidptr ));
bool builtin__array_contains(array a, voidptr value);
int builtin__array_index(array a, voidptr value);
int builtin__array_last_index(array a, voidptr value);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_u8_hex(Array_u8 b);
int builtin__copy(Array_u8* dst, Array_u8 src);
void builtin__array_grow_cap(array* a, int amount);
void builtin__array_grow_len(array* a, int amount);
Array_voidptr builtin__array_pointers(array a);
Array_u8 builtin__voidptr_vbytes(voidptr data, int len);
Array_u8 builtin__u8_vbytes(u8* data, int len);
void builtin__u8_free(u8* data);
VV_LOC void builtin__panic_on_negative_len(int len);
VV_LOC void builtin__panic_on_negative_cap(int cap);
VV_LOC array builtin____new_array_noscan(int mylen, int cap, int elm_size);
VV_LOC array builtin____new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOC array builtin____new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val, int depth);
VV_LOC void builtin__array_insert_noscan(array* a, int i, voidptr val);
VV_LOC void builtin__array_prepend_noscan(array* a, voidptr val);
VV_LOC voidptr builtin__array_pop_noscan(array* a);
VV_LOC void builtin__array_push_noscan(array* a, voidptr val);
VV_LOC void builtin__array_push_many_noscan(array* a, voidptr val, int size);
void builtin__print_backtrace(void);
bool builtin__print_backtrace_skipping_top_frames(int xskipframes);
VV_LOC bool builtin__print_backtrace_skipping_top_frames_bsd(int skipframes);
void builtin___v_exit(int code);
_result_void builtin__at_exit(void (*cb)());
VV_LOC void builtin__v_segmentation_fault_handler(i32 signal_number);
VV_LOC int builtin__v_fixed_index(int i, int len);
Array_string builtin__arguments(void);
string builtin__vcurrent_hash(void);
u64 builtin__v_getpid(void);
u64 builtin__v_gettid(void);
bool builtin__isnil(voidptr v);
VV_LOC voidptr builtin____as_cast(voidptr obj, int obj_type, int expected_type);
VV_LOC void builtin__builtin_init(void);
void builtin__panic_lasterr(string base);
void builtin__gc_check_leaks(void);
bool builtin__gc_is_enabled(void);
void builtin__gc_enable(void);
void builtin__gc_disable(void);
void builtin__gc_collect(void);
void builtin__gc_get_warn_proc(void);
void builtin__gc_set_warn_proc(void (*cb)(char* msg, usize arg));
int builtin__vstrlen(u8* s);
int builtin__vstrlen_char(char* s);
voidptr builtin__vmemcpy(voidptr dest, const voidptr const_src, isize n);
voidptr builtin__vmemmove(voidptr dest, const voidptr const_src, isize n);
int builtin__vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n);
voidptr builtin__vmemset(voidptr s, int c, isize n);
VV_LOC void builtin__vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b));
void builtin__chan_close(chan ch);
ChanState builtin__chan_try_pop(chan ch, voidptr obj);
ChanState builtin__chan_try_push(chan ch, voidptr obj);
VV_LOC void builtin___result_ok(voidptr data, _result* res, int size);
string builtin__IError_str(IError err);
string builtin__Error_msg(Error err);
int builtin__Error_code(Error err);
string builtin__MessageError_str(MessageError err);
string builtin__MessageError_msg(MessageError err);
int builtin__MessageError_code(MessageError err);
void builtin__MessageError_free(MessageError* err);
IError builtin___v_error(string message);
IError builtin__error_with_code(string message, int code);
VV_LOC void builtin___option_none(voidptr data, _option* option, int size);
VV_LOC void builtin___option_ok(voidptr data, _option* option, int size);
VV_LOC void builtin___option_clone(_option* current, _option* option, int size);
VV_LOC string builtin__None___str(None__ _d1);
string builtin__none_str(none _d1);
int builtin__input_character(void);
int builtin__print_character(u8 ch);
string builtin__f64_str(f64 x);
string builtin__f64_strg(f64 x);
string builtin__float_literal_str(float_literal d);
string builtin__f64_strsci(f64 x, int digit_num);
string builtin__f64_strlong(f64 x);
string builtin__f32_str(f32 x);
string builtin__f32_strg(f32 x);
string builtin__f32_strsci(f32 x, int digit_num);
string builtin__f32_strlong(f32 x);
f32 builtin__f32_abs(f32 a);
f64 builtin__f64_abs(f64 a);
f32 builtin__f32_min(f32 a, f32 b);
f32 builtin__f32_max(f32 a, f32 b);
f64 builtin__f64_min(f64 a, f64 b);
f64 builtin__f64_max(f64 a, f64 b);
bool builtin__f32_eq_epsilon(f32 a, f32 b);
bool builtin__f64_eq_epsilon(f64 a, f64 b);
_option_rune builtin__input_rune(void);
_option_rune builtin__InputRuneIterator_next(InputRuneIterator* self);
InputRuneIterator builtin__input_rune_iterator(void);
string builtin__ptr_str(voidptr ptr);
string builtin__isize_str(isize x);
string builtin__usize_str(usize x);
string builtin__char_str(char* cptr);
VV_LOC string builtin__int_str_l(int nn, int max);
string builtin__i8_str(i8 n);
string builtin__i16_str(i16 n);
string builtin__u16_str(u16 n);
string builtin__i32_str(i32 n);
string builtin__int_hex_full(int nn);
string builtin__int_str(int n);
string builtin__u32_str(u32 nn);
string builtin__int_literal_str(int_literal n);
string builtin__i64_str(i64 nn);
VV_LOC string builtin__impl_i64_to_string(i64 nn);
string builtin__u64_str(u64 nn);
string builtin__bool_str(bool b);
VV_LOC string builtin__u64_to_hex(u64 nn, u8 len);
VV_LOC string builtin__u64_to_hex_no_leading_zeros(u64 nn, u8 len);
string builtin__u8_hex(u8 nn);
string builtin__char_hex(char c);
string builtin__rune_hex(rune r);
string builtin__i8_hex(i8 nn);
string builtin__u16_hex(u16 nn);
string builtin__i16_hex(i16 nn);
string builtin__u32_hex(u32 nn);
string builtin__int_hex(int nn);
string builtin__int_hex2(int n);
string builtin__u64_hex(u64 nn);
string builtin__i64_hex(i64 nn);
string builtin__int_literal_hex(int_literal nn);
string builtin__voidptr_str(voidptr nn);
string builtin__byteptr_str(byteptr nn);
string builtin__charptr_str(charptr nn);
string builtin__u8_hex_full(u8 nn);
string builtin__i8_hex_full(i8 nn);
string builtin__u16_hex_full(u16 nn);
string builtin__i16_hex_full(i16 nn);
string builtin__u32_hex_full(u32 nn);
string builtin__i64_hex_full(i64 nn);
string builtin__voidptr_hex_full(voidptr nn);
string builtin__int_literal_hex_full(int_literal nn);
string builtin__u64_hex_full(u64 nn);
string builtin__u8_str(u8 b);
string builtin__u8_ascii_str(u8 b);
string builtin__u8_str_escaped(u8 b);
bool builtin__u8_is_capital(u8 c);
string Array_u8_bytestr(Array_u8 b);
_result_rune Array_u8_byterune(Array_u8 b);
string builtin__u8_repeat(u8 b, int count);
int builtin__int_min(int a, int b);
int builtin__int_max(int a, int b);
VV_LOC bool builtin__fast_string_eq(string a, string b);
VV_LOC u64 builtin__map_hash_string(voidptr pkey);
VV_LOC u64 builtin__map_hash_int_1(voidptr pkey);
VV_LOC u64 builtin__map_hash_int_2(voidptr pkey);
VV_LOC u64 builtin__map_hash_int_4(voidptr pkey);
VV_LOC u64 builtin__map_hash_int_8(voidptr pkey);
VV_LOC voidptr builtin__map_enum_fn(int kind, int esize);
VV_LOC void builtin__DenseArray_zeros_to_end(DenseArray* d);
VV_LOC DenseArray builtin__new_dense_array(int key_bytes, int value_bytes);
VV_LOC voidptr builtin__DenseArray_key(DenseArray* d, int i);
VV_LOC voidptr builtin__DenseArray_value(DenseArray* d, int i);
VV_LOC bool builtin__DenseArray_has_index(DenseArray* d, int i);
VV_LOC int builtin__DenseArray_expand(DenseArray* d);
VV_LOC bool builtin__map_eq_string(voidptr a, voidptr b);
VV_LOC bool builtin__map_eq_int_1(voidptr a, voidptr b);
VV_LOC bool builtin__map_eq_int_2(voidptr a, voidptr b);
VV_LOC bool builtin__map_eq_int_4(voidptr a, voidptr b);
VV_LOC bool builtin__map_eq_int_8(voidptr a, voidptr b);
VV_LOC void builtin__map_clone_string(voidptr dest, voidptr pkey);
VV_LOC void builtin__map_clone_int_1(voidptr dest, voidptr pkey);
VV_LOC void builtin__map_clone_int_2(voidptr dest, voidptr pkey);
VV_LOC void builtin__map_clone_int_4(voidptr dest, voidptr pkey);
VV_LOC void builtin__map_clone_int_8(voidptr dest, voidptr pkey);
VV_LOC void builtin__map_free_string(voidptr pkey);
VV_LOC void builtin__map_free_nop(voidptr _d1);
VV_LOC map builtin__new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOC map builtin__new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map builtin__map_move(map* m);
void builtin__map_clear(map* m);
VV_LOC multi_return_u32_u32 builtin__map_key_to_index(map* m, voidptr pkey);
VV_LOC multi_return_u32_u32 builtin__map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOC void builtin__map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOC void builtin__map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOC void builtin__map_set(map* m, voidptr key, voidptr value);
VV_LOC void builtin__map_expand(map* m);
VV_LOC void builtin__map_rehash(map* m);
void builtin__map_reserve(map* m, u32 meta_bytes);
VV_LOC void builtin__map_cached_rehash(map* m, u32 old_cap);
VV_LOC voidptr builtin__map_get_and_set(map* m, voidptr key, voidptr zero);
VV_LOC voidptr builtin__map_get(map* m, voidptr key, voidptr zero);
VV_LOC voidptr builtin__map_get_check(map* m, voidptr key);
VV_LOC bool builtin__map_exists(map* m, voidptr key);
VV_LOC void builtin__DenseArray_delete(DenseArray* d, int i);
void builtin__map_delete(map* m, voidptr key);
array builtin__map_keys(map* m);
array builtin__map_values(map* m);
VV_LOC DenseArray builtin__DenseArray_clone(DenseArray* d);
map builtin__map_clone(map* m);
void builtin__map_free(map* m);
void builtin__VAssertMetaInfo_free(VAssertMetaInfo* ami);
void builtin__IError_free(IError* ie);
void builtin__panic_option_not_set(string s);
void builtin__panic_result_not_set(string s);
void builtin___v_panic(string s);
string builtin__c_error_number_str(int errnum);
void builtin__panic_n(string s, i64 number1);
void builtin__panic_n2(string s, i64 number1, i64 number2);
VV_LOC void builtin__panic_n3(string s, i64 number1, i64 number2, i64 number3);
void builtin__panic_error_number(string basestr, int errnum);
void builtin__eprintln(string s);
void builtin__eprint(string s);
void builtin__flush_stdout(void);
void builtin__flush_stderr(void);
void builtin__unbuffer_stdout(void);
void builtin__print(string s);
void builtin__println(string s);
VV_LOC void builtin___writeln_to_fd(int fd, string s);
VV_LOC void builtin___write_buf_to_fd(int fd, u8* buf, int buf_len);
string builtin__reuse_data_as_string(Array_u8 buffer);
Array_u8 builtin__reuse_string_as_data(string s);
string builtin__rune_str(rune c);
string Array_rune_string(Array_rune ra);
string builtin__rune_repeat(rune c, int count);
Array_u8 builtin__rune_bytes(rune c);
int builtin__rune_length_in_bytes(rune c);
rune builtin__rune_to_upper(rune c);
rune builtin__rune_to_lower(rune c);
rune builtin__rune_to_title(rune c);
VV_LOC rune builtin__rune_map_to(rune c, MapMode mode);
VV_LOC int builtin__mapnode_find_key(mapnode* n, string k);
VV_LOC bool builtin__mapnode_remove_key(mapnode* n, string k);
VV_LOC void builtin__mapnode_remove_from_leaf(mapnode* n, int idx);
VV_LOC void builtin__mapnode_remove_from_non_leaf(mapnode* n, int idx);
VV_LOC void builtin__mapnode_fill(mapnode* n, int idx);
VV_LOC void builtin__mapnode_borrow_from_prev(mapnode* n, int idx);
VV_LOC void builtin__mapnode_borrow_from_next(mapnode* n, int idx);
VV_LOC void builtin__mapnode_merge(mapnode* n, int idx);
void builtin__SortedMap_delete(SortedMap* m, string key);
VV_LOC int builtin__mapnode_subkeys(mapnode* n, Array_string* keys, int at);
Array_string builtin__SortedMap_keys(SortedMap* m);
VV_LOC void builtin__mapnode_free(mapnode* n);
void builtin__SortedMap_free(SortedMap* m);
Array_rune builtin__string_runes(string s);
string builtin__cstring_to_vstring(const char* const_s);
string builtin__tos_clone(const u8* const_s);
string builtin__tos(u8* s, int len);
string builtin__tos2(u8* s);
string builtin__tos3(char* s);
string builtin__tos4(u8* s);
string builtin__tos5(char* s);
string builtin__u8_vstring(u8* bp);
string builtin__u8_vstring_with_len(u8* bp, int len);
string builtin__char_vstring(char* cp);
string builtin__char_vstring_with_len(char* cp, int len);
string builtin__u8_vstring_literal(u8* bp);
string builtin__u8_vstring_literal_with_len(u8* bp, int len);
string builtin__char_vstring_literal(char* cp);
string builtin__char_vstring_literal_with_len(char* cp, int len);
int builtin__string_len_utf8(string s);
bool builtin__string_is_pure_ascii(string s);
string builtin__string_clone(string a);
string builtin__string_replace_once(string s, string rep, string with);
string builtin__string_replace(string s, string rep, string with);
string builtin__string_replace_each(string s, Array_string vals);
string builtin__string_replace_char(string s, u8 rep, u8 with, int repeat);
string builtin__string_normalize_tabs(string s, int tab_len);
string builtin__string_expand_tabs(string s, int tab_len);
bool builtin__string_bool(string s);
i8 builtin__string_i8(string s);
i16 builtin__string_i16(string s);
i32 builtin__string_i32(string s);
int builtin__string_int(string s);
i64 builtin__string_i64(string s);
f32 builtin__string_f32(string s);
f64 builtin__string_f64(string s);
Array_u8 builtin__string_u8_array(string s);
u8 builtin__string_u8(string s);
u16 builtin__string_u16(string s);
u32 builtin__string_u32(string s);
u64 builtin__string_u64(string s);
_result_u64 builtin__string_parse_uint(string s, int _base, int _bit_size);
_result_i64 builtin__string_parse_int(string s, int _base, int _bit_size);
VV_LOC bool builtin__string__eq(string s, string a);
int builtin__string_compare(string s, string a);
VV_LOC bool builtin__string__lt(string s, string a);
VV_LOC string builtin__string__plus(string s, string a);
VV_LOC string builtin__string_plus_two(string s, string a, string b);
Array_string builtin__string_split_any(string s, string delim);
Array_string builtin__string_rsplit_any(string s, string delim);
Array_string builtin__string_split(string s, string delim);
Array_string builtin__string_rsplit(string s, string delim);
_option_multi_return_string_string builtin__string_split_once(string s, string delim);
_option_multi_return_string_string builtin__string_rsplit_once(string s, string delim);
Array_string builtin__string_split_n(string s, string delim, int n);
Array_string builtin__string_split_nth(string s, string delim, int nth);
Array_string builtin__string_rsplit_nth(string s, string delim, int nth);
Array_string builtin__string_split_into_lines(string s);
Array_string builtin__string_split_by_space(string s);
string builtin__string_substr(string s, int start, int _end);
string builtin__string_substr_unsafe(string s, int start, int _end);
_result_string builtin__string_substr_with_check(string s, int start, int _end);
string builtin__string_substr_ni(string s, int _start, int _end);
int builtin__string_index_(string s, string p);
_option_int builtin__string_index(string s, string p);
_option_int builtin__string_last_index(string s, string needle);
VV_LOC int builtin__string_index_kmp(string s, string p);
int builtin__string_index_any(string s, string chars);
VV_LOC int builtin__string_index_last_(string s, string p);
_option_int builtin__string_index_after(string s, string p, int start);
int builtin__string_index_after_(string s, string p, int start);
int builtin__string_index_u8(string s, u8 c);
int builtin__string_last_index_u8(string s, u8 c);
int builtin__string_count(string s, string substr);
bool builtin__string_contains_u8(string s, u8 x);
bool builtin__string_contains(string s, string substr);
bool builtin__string_contains_any(string s, string chars);
bool builtin__string_contains_only(string s, string chars);
bool builtin__string_contains_any_substr(string s, Array_string substrs);
bool builtin__string_starts_with(string s, string p);
bool builtin__string_ends_with(string s, string p);
string builtin__string_to_lower_ascii(string s);
string builtin__string_to_lower(string s);
bool builtin__string_is_lower(string s);
string builtin__string_to_upper_ascii(string s);
string builtin__string_to_upper(string s);
bool builtin__string_is_upper(string s);
string builtin__string_capitalize(string s);
string builtin__string_uncapitalize(string s);
bool builtin__string_is_capital(string s);
bool builtin__string_starts_with_capital(string s);
string builtin__string_title(string s);
bool builtin__string_is_title(string s);
string builtin__string_find_between(string s, string start, string end);
string builtin__string_trim_space(string s);
string builtin__string_trim_space_left(string s);
string builtin__string_trim_space_right(string s);
string builtin__string_trim(string s, string cutset);
multi_return_int_int builtin__string_trim_indexes(string s, string cutset);
VV_LOC string builtin__string_trim_chars(string s, string cutset, TrimMode mode);
VV_LOC string builtin__string_trim_runes(string s, string cutset, TrimMode mode);
string builtin__string_trim_left(string s, string cutset);
string builtin__string_trim_right(string s, string cutset);
string builtin__string_trim_string_left(string s, string str);
string builtin__string_trim_string_right(string s, string str);
int builtin__compare_strings(string* a, string* b);
VV_LOC int builtin__compare_strings_by_len(string* a, string* b);
VV_LOC int builtin__compare_lower_strings(string* a, string* b);
void Array_string_sort_ignore_case(Array_string* s);
void Array_string_sort_by_len(Array_string* s);
string builtin__string_str(string s);
VV_LOC u8 builtin__string_at(string s, int idx);
VV_LOC _option_u8 builtin__string_at_with_check(string s, int idx);
bool builtin__string_is_oct(string str);
bool builtin__string_is_bin(string str);
bool builtin__string_is_hex(string str);
bool builtin__string_is_int(string str);
bool builtin__u8_is_space(u8 c);
bool builtin__u8_is_digit(u8 c);
bool builtin__u8_is_hex_digit(u8 c);
bool builtin__u8_is_oct_digit(u8 c);
bool builtin__u8_is_bin_digit(u8 c);
bool builtin__u8_is_letter(u8 c);
bool builtin__u8_is_alnum(u8 c);
void builtin__string_free(string* s);
string builtin__string_before(string s, string sub);
string builtin__string_all_before(string s, string sub);
string builtin__string_all_before_last(string s, string sub);
string builtin__string_all_after(string s, string sub);
string builtin__string_all_after_last(string s, string sub);
string builtin__string_all_after_first(string s, string sub);
string builtin__string_after(string s, string sub);
string builtin__string_after_char(string s, u8 sub);
string Array_string_join(Array_string a, string sep);
string Array_string_join_lines(Array_string s);
string builtin__string_reverse(string s);
string builtin__string_limit(string s, int max);
int builtin__string_hash(string s);
Array_u8 builtin__string_bytes(string s);
string builtin__string_repeat(string s, int count);
Array_string builtin__string_fields(string s);
string builtin__string_strip_margin(string s);
string builtin__string_strip_margin_custom(string s, u8 del);
string builtin__string_trim_indent(string s);
int builtin__string_indent_width(string s);
bool builtin__string_is_blank(string s);
bool builtin__string_match_glob(string name, string pattern);
bool builtin__string_is_ascii(string s);
bool builtin__string_is_identifier(string s);
string builtin__string_camel_to_snake(string s);
string builtin__string_snake_to_camel(string s);
string builtin__string_wrap(string s, WrapConfig config);
string builtin__string_hex(string s);
VV_LOC string builtin__data_to_hex_string(u8* data, int len);
RunesIterator builtin__string_runes_iterator(string s);
_option_rune builtin__RunesIterator_next(RunesIterator* ri);
Array_u8 builtin__byteptr_vbytes(byteptr data, int len);
string builtin__byteptr_vstring(byteptr bp);
string builtin__byteptr_vstring_with_len(byteptr bp, int len);
string builtin__charptr_vstring(charptr cp);
string builtin__charptr_vstring_with_len(charptr cp, int len);
string builtin__byteptr_vstring_literal(byteptr bp);
string builtin__byteptr_vstring_literal_with_len(byteptr bp, int len);
string builtin__charptr_vstring_literal(charptr cp);
string builtin__charptr_vstring_literal_with_len(charptr cp, int len);
string builtin__StrIntpType_str(StrIntpType x);
VV_LOC f32 builtin__fabs32(f32 x);
VV_LOC f64 builtin__fabs64(f64 x);
VV_LOC u64 builtin__abs64(i64 x);
u64 builtin__get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case);
u32 builtin__get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case);
VV_LOC void builtin__StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string builtin__str_intp(int data_len, StrIntpData* input_base);
string builtin__str_intp_sq(string in_str);
string builtin__str_intp_rune(string in_str);
string builtin__str_intp_g32(string in_str);
string builtin__str_intp_g64(string in_str);
string builtin__str_intp_sub(string base_str, string in_str);
u16* builtin__string_to_wide(string _str, ToWideConfig param);
string builtin__string_from_wide(u16* _wstr);
string builtin__string_from_wide2(u16* _wstr, int len);
Array_u8 builtin__wide_to_ansi(u16* _wstr);
int builtin__utf8_char_len(u8 b);
string builtin__utf32_to_str(u32 code);
string builtin__utf32_to_str_no_malloc(u32 code, u8* buf);
int builtin__utf32_decode_to_buffer(u32 code, u8* buf);
int builtin__string_utf32_code(string _rune);
_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes);
VV_LOC rune builtin__impl_utf8_to_utf32(u8* _bytes, int _bytes_len);
int builtin__utf8_str_visible_length(string s);
Array_u8 builtin__string_to_ansi_not_null_terminated(string _str);
bool builtin__ArrayFlags_is_empty(ArrayFlags* e);
bool builtin__ArrayFlags_has(ArrayFlags* e, ArrayFlags flag_);
bool builtin__ArrayFlags_all(ArrayFlags* e, ArrayFlags flag_);
void builtin__ArrayFlags_set(ArrayFlags* e, ArrayFlags flag_);
void builtin__ArrayFlags_set_all(ArrayFlags* e);
void builtin__ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag_);
void builtin__ArrayFlags_clear_all(ArrayFlags* e);
void builtin__ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag_);
ArrayFlags builtin__ArrayFlags__static__zero(void);
_result_voidptr json__decode(voidptr typ, string s);
string json__encode(voidptr x);
string json__encode_pretty(voidptr x);
VV_LOC int json__decode_int(struct cJSON* root);
VV_LOC i8 json__decode_i8(struct cJSON* root);
VV_LOC i16 json__decode_i16(struct cJSON* root);
VV_LOC i64 json__decode_i64(struct cJSON* root);
VV_LOC u8 json__decode_byte(struct cJSON* root);
VV_LOC u8 json__decode_u8(struct cJSON* root);
VV_LOC u16 json__decode_u16(struct cJSON* root);
VV_LOC u32 json__decode_u32(struct cJSON* root);
VV_LOC u64 json__decode_u64(struct cJSON* root);
VV_LOC f32 json__decode_f32(struct cJSON* root);
VV_LOC f64 json__decode_f64(struct cJSON* root);
VV_LOC rune json__decode_rune(struct cJSON* root);
VV_LOC string json__decode_string(struct cJSON* root);
VV_LOC bool json__decode_bool(struct cJSON* root);
VV_LOC struct cJSON* json__encode_int(int val);
VV_LOC struct cJSON* json__encode_i8(i8 val);
VV_LOC struct cJSON* json__encode_i16(i16 val);
VV_LOC struct cJSON* json__encode_i64(i64 val);
VV_LOC struct cJSON* json__encode_byte(u8 root);
VV_LOC struct cJSON* json__encode_u8(u8 val);
VV_LOC struct cJSON* json__encode_u16(u16 val);
VV_LOC struct cJSON* json__encode_u32(u32 val);
VV_LOC struct cJSON* json__encode_u64(u64 val);
VV_LOC struct cJSON* json__encode_f32(f32 val);
VV_LOC struct cJSON* json__encode_f64(f64 val);
VV_LOC struct cJSON* json__encode_bool(bool val);
VV_LOC struct cJSON* json__encode_rune(rune val);
VV_LOC struct cJSON* json__encode_string(string val);
VV_LOC struct cJSON* json__json_parse(string s);
VV_LOC string json__json_print(struct cJSON* data);
VV_LOC string json__json_print_pretty(struct cJSON* data);
strings__textscanner__TextScanner strings__textscanner__new(string input);
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss);
u8 strings__textscanner__TextScanner_peek_u8(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n);
u8 strings__textscanner__TextScanner_peek_n_u8(strings__textscanner__TextScanner* ss, int n);
void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip_whitespace(strings__textscanner__TextScanner* ss);
term__termios__TcFlag term__termios__flag(int value);
term__termios__TcFlag term__termios__invert(term__termios__TcFlag value);
int term__termios__tcgetattr(int fd, term__termios__Termios* termios_p);
int term__termios__tcsetattr(int fd, int optional_actions, term__termios__Termios* termios_p);
int term__termios__ioctl(int fd, u64 request, voidptr arg);
int term__termios__set_state(int fd, term__termios__Termios new_state);
void term__termios__Termios_disable_echo(term__termios__Termios* t);
string v__token__KeywordsMatcherTrie_str(v__token__KeywordsMatcherTrie* km);
string v__token__TrieNode_str(v__token__TrieNode* node);
int v__token__KeywordsMatcherTrie_find(v__token__KeywordsMatcherTrie* km, string word);
bool v__token__KeywordsMatcherTrie_matches(v__token__KeywordsMatcherTrie* km, string word);
void v__token__KeywordsMatcherTrie_add_word(v__token__KeywordsMatcherTrie* km, string word, int value);
v__token__KeywordsMatcherTrie v__token__KeywordsMatcherTrie__static__new(int cap);
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_trie_T_int(Map_string_int kw_map);
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_trie_T_v__token__Kind(Map_string_v__token__Kind kw_map);
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_from_array_trie(Array_string names);
v__token__TrieNode* v__token__new_trie_node(void);
void v__token__TrieNode_show(v__token__TrieNode* node, int level);
void v__token__TrieNode_add_word(v__token__TrieNode* node, string word, int value, int word_idx);
int v__token__TrieNode_find(v__token__TrieNode* root, string word);
void v__token__Pos_free(v__token__Pos* p);
string v__token__Pos_line_str(v__token__Pos p);
v__token__Pos v__token__Pos_extend(v__token__Pos pos, v__token__Pos end);
v__token__Pos v__token__Pos_extend_with_last_line(v__token__Pos pos, v__token__Pos end, int last_line);
void v__token__Pos_update_last_line(v__token__Pos* pos, int last_line);
v__token__Pos v__token__Token_pos(v__token__Token* tok);
VV_LOC Map_string_v__token__Kind v__token__build_keys(void);
VV_LOC Array_string v__token__build_token_str(void);
bool v__token__is_key(string key);
bool v__token__is_decl(v__token__Kind t);
bool v__token__Kind_is_assign(v__token__Kind t);
string v__token__Kind_str(v__token__Kind t);
bool v__token__Token_is_next_to(v__token__Token t, v__token__Token pre_token);
bool v__token__Token_is_key(v__token__Token t);
string v__token__Token_str(v__token__Token t);
string v__token__Token_debug(v__token__Token t);
Array_v__token__Precedence v__token__build_precedences(void);
int v__token__Token_precedence(v__token__Token tok);
int v__token__Kind_precedence(v__token__Kind kind);
bool v__token__Token_is_scalar(v__token__Token tok);
bool v__token__Token_is_unary(v__token__Token tok);
bool v__token__Kind_is_relational(v__token__Kind tok);
bool v__token__Kind_is_start_of_type(v__token__Kind k);
bool v__token__Kind_is_prefix(v__token__Kind kind);
bool v__token__Kind_is_infix(v__token__Kind kind);
bool v__token__Kind_is_postfix(v__token__Kind kind);
string v__token__kind_to_string(v__token__Kind k);
v__token__Kind v__token__assign_op_to_infix_op(v__token__Kind op);
u64 sync__stdatomic__add_u64(u64* ptr, int delta);
u64 sync__stdatomic__sub_u64(u64* ptr, int delta);
i64 sync__stdatomic__add_i64(i64* ptr, int delta);
i64 sync__stdatomic__sub_i64(i64* ptr, int delta);
void sync__stdatomic__store_u64(u64* ptr, u64 val);
u64 sync__stdatomic__load_u64(u64* ptr);
void sync__stdatomic__store_i64(i64* ptr, i64 val);
i64 sync__stdatomic__load_i64(i64* ptr);
u32 hash__fnv1a__sum32_string(string data);
u32 hash__fnv1a__sum32(Array_u8 data);
u32 hash__fnv1a__sum32_bytes(u8* data, int data_len);
u64 hash__fnv1a__sum64_string(string data);
u64 hash__fnv1a__sum64(Array_u8 data);
u64 hash__fnv1a__sum64_bytes(u8* data, int data_len);
Array_string os__cmdline__options(Array_string args, string param);
string os__cmdline__option(Array_string args, string param, string def);
Array_string os__cmdline__options_before(Array_string args, Array_string what);
Array_string os__cmdline__options_after(Array_string args, Array_string what);
Array_string os__cmdline__only_non_options(Array_string args);
Array_string os__cmdline__only_options(Array_string args);
i64 time__portable_timegm(struct tm* t);
int time__days_from_unix_epoch(int year, int month, int day);
int time__Time_days_from_unix_epoch(time__Time t);
time__Time time__date_from_days_after_unix_epoch(int days);
VV_LOC time__DateTimeParser time__new_date_time_parser(string datetime, string format);
VV_LOC _result_string time__DateTimeParser_next(time__DateTimeParser* p, int length);
VV_LOC _result_string time__DateTimeParser_peek(time__DateTimeParser* p, int length);
VV_LOC _result_int time__DateTimeParser_must_be_int(time__DateTimeParser* p, int length);
VV_LOC _result_int time__DateTimeParser_must_be_int_with_minimum_length(time__DateTimeParser* p, int min, int max, bool allow_leading_zero);
VV_LOC _result_void time__DateTimeParser_must_be_string(time__DateTimeParser* p, string must);
VV_LOC _result_int time__DateTimeParser_must_be_valid_month(time__DateTimeParser* p);
VV_LOC _result_int time__DateTimeParser_must_be_valid_three_letter_month(time__DateTimeParser* p);
VV_LOC _result_string time__DateTimeParser_must_be_valid_week_day(time__DateTimeParser* p);
VV_LOC _result_int time__DateTimeParser_must_be_valid_two_letter_week_day(time__DateTimeParser* p);
VV_LOC _result_int time__DateTimeParser_must_be_valid_three_letter_week_day(time__DateTimeParser* p);
VV_LOC _result_Array_string time__extract_tokens(string s);
VV_LOC _result_time__Time time__DateTimeParser_parse(time__DateTimeParser* p);
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
f64 time__Duration_days(time__Duration d);
string time__Duration_str(time__Duration d);
string time__Duration_debug(time__Duration d);
time__Duration time__Duration_times(time__Duration d, f64 x);
VV_LOC int time__iclamp(int x, int a, int b);
VV_LOC void time__int_to_byte_array_no_pad(int value, Array_u8* arr, int size);
VV_LOC void time__int_to_ptr_byte_array_no_pad(int value, u8* arr_prt, int arr_len);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_format_ss_nano(time__Time t);
string time__Time_format_rfc3339(time__Time t);
string time__Time_format_rfc3339_micro(time__Time t);
string time__Time_format_rfc3339_nano(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
VV_LOC string time__ordinal_suffix(int n);
string time__Time_custom_format(time__Time t, string s);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
string time__Time_http_header_string(time__Time t);
void time__Time_push_to_http_header(time__Time t, Array_u8* buffer);
_result_void time__Time_from_json_number(time__Time* t, string raw_number);
_result_void time__Time_from_json_string(time__Time* t, string raw_string);
string time__Time_to_json(time__Time t);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
VV_LOC _result_void time__validate_time_bounds(int hour, int minute, int second, int nanosecond);
VV_LOC _result_multi_return_int_int_int_int time__check_and_extract_time(string s);
VV_LOC _result_multi_return_int_int_int time__check_and_extract_date(string s);
_result_time__Time time__parse_rfc3339(string s);
_result_time__Time time__parse(string s);
_result_time__Time time__parse_format(string s, string format);
_result_time__Time time__parse_iso8601(string s);
_result_time__Time time__parse_rfc2822(string s);
VV_LOC _result_multi_return_int_int_int time__parse_iso8601_date(string s);
VV_LOC _result_multi_return_int_int_int_int_int_i64_bool time__parse_iso8601_time(string s);
string time__TimeParseError_msg(time__TimeParseError err);
VV_LOC IError time__error_invalid_time(int code, string message);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
time__Time time__now(void);
time__Time time__utc(void);
VV_LOC time__Time time__time_with_unix(time__Time t);
i64 time__ticks(void);
string time__Time_str(time__Time t);
VV_LOC time__Time time__convert_ctime(struct tm t, int nanosecond);
string time__Time_strftime(time__Time t, string fmt);
int time__Duration_sys_milliseconds(time__Duration d);
time__Time time__Time__static__new(time__Time t);
time__Time time__new(time__Time t);
string time__Time_smonth(time__Time t);
i64 time__Time_unix(time__Time t);
i64 time__Time_local_unix(time__Time t);
i64 time__Time_unix_milli(time__Time t);
i64 time__Time_unix_micro(time__Time t);
i64 time__Time_unix_nano(time__Time t);
time__Time time__Time_add(time__Time t, time__Duration duration_in_nanosecond);
time__Time time__Time_add_seconds(time__Time t, int seconds);
time__Time time__Time_add_days(time__Time t, int days);
time__Duration time__since(time__Time t);
string time__Time_relative(time__Time t);
string time__Time_relative_short(time__Time t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time t);
int time__Time_week_of_year(time__Time t);
int time__Time_year_day(time__Time t);
string time__Time_weekday_str(time__Time t);
string time__Time_long_weekday_str(time__Time t);
bool time__is_leap_year(int year);
_result_int time__days_in_month(int month, int year);
string time__Time_debug(time__Time t);
int time__offset(void);
time__Time time__Time_local_to_utc(time__Time t);
time__Time time__Time_utc_to_local(time__Time u);
time__Time time__Time_as_local(time__Time t);
time__Time time__Time_as_utc(time__Time t);
bool time__Time_is_utc(time__Time t);
VV_LOC mach_timebase_info_data_t time__init_time_base(void);
VV_LOC u64 time__sys_mono_now_darwin(void);
VV_LOC time__Time time__darwin_now(void);
VV_LOC time__Time time__darwin_utc(void);
VV_LOC i64 time__make_unix_time(struct tm t);
time__Time time__Time_local(time__Time t);
u64 time__sys_mono_now(void);
VV_LOC time__Time time__linux_now(void);
VV_LOC time__Time time__linux_utc(void);
struct timespec time__Duration_timespec(time__Duration d);
void time__sleep(time__Duration duration);
time__Time time__unix(i64 epoch);
time__Time time__unix_milli(i64 ms);
time__Time time__unix_micro(i64 us);
time__Time time__unix_nano(i64 ns);
VV_LOC time__Time time__ts_to_time_impl(i64 value, i64 down, i64 up);
time__Time time__unix_microsecond(i64 epoch, int microsecond);
time__Time time__unix_nanosecond(i64 abs_unix_timestamp, int nanosecond);
VV_LOC multi_return_int_int_int time__calculate_date_from_day_offset(i64 day_offset_);
VV_LOC multi_return_int_int_int time__calculate_time_from_second_offset(i64 second_offset_);
u64 hash__wyhash_c(u8* key, u64 len, u64 seed);
u64 hash__wyhash64_c(u64 a, u64 b);
u64 hash__sum64_string(string key, u64 seed);
u64 hash__sum64(Array_u8 key, u64 seed);
u64 hash__wymum(u64 a, u64 b);
VV_LOC string flag__UnknownFlagError_msg(flag__UnknownFlagError err);
VV_LOC string flag__ArgsCountError_msg(flag__ArgsCountError err);
VV_LOC void flag__Flag_free(flag__Flag* f);
string flag__Flag_str(flag__Flag f);
string Array_flag__Flag_str(Array_flag__Flag af);
VV_LOC void flag__FlagParser_free(flag__FlagParser* f);
flag__FlagParser* flag__new_flag_parser(Array_string args);
void flag__FlagParser_usage_example(flag__FlagParser* fs, string example);
void flag__FlagParser_footer(flag__FlagParser* fs, string footer);
void flag__FlagParser_application(flag__FlagParser* fs, string name);
void flag__FlagParser_version(flag__FlagParser* fs, string vers);
void flag__FlagParser_description(flag__FlagParser* fs, string desc);
void flag__FlagParser_skip_executable(flag__FlagParser* fs);
void flag__FlagParser_allow_unknown_args(flag__FlagParser* fs);
VV_LOC void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, u8 abbr, string usage, string desc);
VV_LOC Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, u8 shorthand);
VV_LOC _result_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, u8 shorthand);
_result_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
bool flag__FlagParser_bool(flag__FlagParser* fs, string name, u8 abbr, bool bdefault, string usage, flag__FlagConfig c);
Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
_result_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
int flag__FlagParser_int(flag__FlagParser* fs, string name, u8 abbr, int idefault, string usage, flag__FlagConfig c);
Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
_result_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
f64 flag__FlagParser_float(flag__FlagParser* fs, string name, u8 abbr, f64 fdefault, string usage, flag__FlagConfig c);
Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
_result_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c);
string flag__FlagParser_string(flag__FlagParser* fs, string name, u8 abbr, string sdefault, string usage, flag__FlagConfig c);
_result_void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n);
_result_void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n);
_result_void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max);
void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description);
string flag__FlagParser_usage(flag__FlagParser* fs);
VV_LOC _result_flag__Flag flag__FlagParser_find_existing_flag(flag__FlagParser* fs, string fname);
VV_LOC void flag__FlagParser_handle_builtin_options(flag__FlagParser* fs);
_result_Array_string flag__FlagParser_finalize(flag__FlagParser* fs);
Array_string flag__FlagParser_remaining_parameters(flag__FlagParser* fs);
VV_LOC _option_string flag__StructField_shortest_match_name(flag__StructField sf);
int flag__DocLayout_max_width(flag__DocLayout dl);
Array_string flag__FlagMapper_no_matches(flag__FlagMapper fm);
_result_string flag__FlagMapper_to_doc(flag__FlagMapper fm, flag__DocConfig dc);
_result_Array_string flag__FlagMapper_fields_docs(flag__FlagMapper fm, flag__DocConfig dc);
VV_LOC string flag__keep_at_max(string str, int max);
bool flag__FieldHints_is_empty(flag__FieldHints* e);
bool flag__FieldHints_has(flag__FieldHints* e, flag__FieldHints flag_);
bool flag__FieldHints_all(flag__FieldHints* e, flag__FieldHints flag_);
void flag__FieldHints_set(flag__FieldHints* e, flag__FieldHints flag_);
void flag__FieldHints_set_all(flag__FieldHints* e);
void flag__FieldHints_clear(flag__FieldHints* e, flag__FieldHints flag_);
void flag__FieldHints_clear_all(flag__FieldHints* e);
void flag__FieldHints_toggle(flag__FieldHints* e, flag__FieldHints flag_);
flag__FieldHints flag__FieldHints__static__zero(void);
bool flag__Show_is_empty(flag__Show* e);
bool flag__Show_has(flag__Show* e, flag__Show flag_);
bool flag__Show_all(flag__Show* e, flag__Show flag_);
void flag__Show_set(flag__Show* e, flag__Show flag_);
void flag__Show_set_all(flag__Show* e);
void flag__Show_clear(flag__Show* e, flag__Show flag_);
void flag__Show_clear_all(flag__Show* e);
void flag__Show_toggle(flag__Show* e, flag__Show flag_);
flag__Show flag__Show__static__zero(void);
VV_LOC bool semver__version_satisfies(semver__Version ver, string input);
VV_LOC bool semver__compare_eq(semver__Version v1, semver__Version v2);
VV_LOC bool semver__compare_lt(semver__Version v1, semver__Version v2);
VV_LOC semver__RawVersion semver__parse(string input);
VV_LOC bool semver__RawVersion_is_valid(semver__RawVersion ver);
VV_LOC bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ);
VV_LOC _result_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver);
VV_LOC semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver);
VV_LOC _option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver);
VV_LOC semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver);
VV_LOC bool semver__Range_satisfies(semver__Range r, semver__Version ver);
VV_LOC bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver);
VV_LOC bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver);
VV_LOC _result_semver__Range semver__parse_range(string input);
VV_LOC _result_semver__ComparatorSet semver__parse_comparator_set(string input);
VV_LOC _option_semver__Comparator semver__parse_comparator(string input);
VV_LOC _option_semver__Version semver__parse_xrange(string input);
VV_LOC bool semver__can_expand(string input);
VV_LOC _option_semver__ComparatorSet semver__expand_comparator_set(string input);
VV_LOC _option_semver__ComparatorSet semver__expand_tilda(string raw_version);
VV_LOC _option_semver__ComparatorSet semver__expand_caret(string raw_version);
VV_LOC _option_semver__ComparatorSet semver__expand_hyphen(string raw_range);
VV_LOC _option_semver__ComparatorSet semver__expand_xrange(string raw_range);
VV_LOC semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max);
VV_LOC semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max);
string semver__EmptyInputError_msg(semver__EmptyInputError err);
string semver__InvalidVersionFormatError_msg(semver__InvalidVersionFormatError err);
_result_semver__Version semver__from(string input);
semver__Version semver__build(int major, int minor, int patch);
semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ);
bool semver__Version_satisfies(semver__Version ver, string input);
bool semver__Version__eq(semver__Version v1, semver__Version v2);
bool semver__Version__lt(semver__Version v1, semver__Version v2);
string semver__Version_str(semver__Version ver);
_result_semver__Version semver__coerce(string input);
bool semver__is_valid(string input);
VV_LOC bool semver__is_version_valid(string input);
VV_LOC _result_semver__Version semver__coerce_version(string input);
VV_LOC semver__Version semver__increment_version(semver__Version ver, semver__Increment typ);
VV_LOC bool semver__is_valid_string(string input);
VV_LOC bool semver__is_valid_number(string input);
void vphp__Context_return_int(vphp__Context ctx, i64 val);
void vphp__Context_return_string(vphp__Context ctx, string val);
void vphp__Context_return_map_f64(vphp__Context ctx, Map_string_f64 m);
void vphp__Context_return_map_int(vphp__Context ctx, Map_string_int m);
int vphp__Context_num_args(vphp__Context ctx);
string vphp__Context_arg_T_string(vphp__Context ctx, int index);
i64 vphp__Context_arg_T_i64(vphp__Context ctx, int index);
Array_string vphp__Context_arg_T_Array_string(vphp__Context ctx, int index);
Map_string_string vphp__Context_arg_T_Map_string_string(vphp__Context ctx, int index);
Array_f64 vphp__Context_arg_T_Array_f64(vphp__Context ctx, int index);
int vphp__Context_arg_T_int(vphp__Context ctx, int index);
bool vphp__Context_arg_T_bool(vphp__Context ctx, int index);
void vphp__return_val_T_i64(vphp__Context ctx, i64 val);
void vphp__return_val_T_string(vphp__Context ctx, string val);
bool vphp__Context_has_exception(vphp__Context ctx);
void vphp__Context_return_res(vphp__Context ctx, voidptr ptr, string label);
void vphp__Context_return_map(vphp__Context ctx, Map_string_string m);
void vphp__Context_return_struct_T_main__MotionReport(vphp__Context ctx, main__MotionReport s);
void vphp__Context_return_list_T_main__HeartPoint(vphp__Context ctx, Array_main__HeartPoint list);
vphp__Val vphp__Context_arg_raw(vphp__Context ctx, int index);
void vphp__Context_return_object(vphp__Context ctx, Map_string_string props);
void vphp__Context_sync_props_T_main__Article(vphp__Context ctx, main__Article* obj);
VV_LOC void vphp__vphp_framework_init(int module_number);
VV_EXP void vphp_framework_init(int module_number); // exported fn vphp.vphp_framework_init
void vphp__init_framework(int module_number);
void vphp__throw_exception(string msg, int code);
VV_LOC vphp__TaskRegistry* vphp__get_registry(void);
void vphp__ITask__static__register(string name, vphp__ITask (*creator)(string json_data));
_option_anon_fn_string__vphp__ITask vphp__ITask__static__get_creator(string name);
VV_LOC void vphp__framework_v_spawn(zend_execute_data* ex, zval* retval);
VV_EXP void v_spawn(zend_execute_data* ex, zval* retval); // exported fn vphp.framework_v_spawn
VV_LOC void vphp__framework_v_wait(zend_execute_data* ex, zval* retval);
VV_EXP void v_wait(zend_execute_data* ex, zval* retval); // exported fn vphp.framework_v_wait
int vphp__Val_type_id(vphp__Val v);
bool vphp__Val_is_array(vphp__Val v);
bool vphp__Val_is_string(vphp__Val v);
bool vphp__Val_is_long(vphp__Val v);
bool vphp__Val_is_double(vphp__Val v);
bool vphp__Val_is_bool(vphp__Val v);
bool vphp__Val_is_null(vphp__Val v);
bool vphp__Val_is_object(vphp__Val v);
vphp__Val vphp__Val_invoke(vphp__Val v, Array_vphp__Val args);
voidptr vphp__Val_to_res(vphp__Val v);
bool vphp__Val_to_bool(vphp__Val v);
string vphp__Val_type_name(vphp__Val v);
vphp__Val vphp__Val_call(vphp__Val v, string method, Array_vphp__Val args);
_result_vphp__Val vphp__Val_get(vphp__Val v, string key);
string vphp__Val_to_string(vphp__Val v);
void vphp__Val_set_string(vphp__Val v, string s);
i64 vphp__Val_as_int(vphp__Val v);
vphp__Val vphp__Val_get_prop(vphp__Val v, string name);
string vphp__Val_get_prop_string(vphp__Val v, string name);
int vphp__Val_get_prop_int(vphp__Val v, string name);
void vphp__Val_set_int(vphp__Val v, i64 val);
void vphp__Val_set_bool(vphp__Val* v, bool b);
void vphp__report_error(int level, string msg);
Array_vphp__Val vphp__get_args(zend_execute_data* ex);
vphp__Context vphp__new_context(zend_execute_data* ex, zval* ret);
VV_LOC void vphp__map_callback(voidptr p_ctx, char* key, zval* val);
vphp__Val vphp__call_php(string name, Array_vphp__Val args);
void vphp__return_val_raw_T_i64(zval* ret, i64 val);
void vphp__return_val_raw_T_string(zval* ret, string val);
void vphp__return_val_raw_T_bool(zval* ret, bool val);
Array_string os__args_after(string cut_word);
Array_string os__args_before(string cut_word);
_result_os__Command os__start_new_command(string cmd);
_result_void os__Command_start(os__Command* c);
string os__Command_read_line(os__Command* c);
_result_void os__Command_close(os__Command* c);
bool os__debugger_present(void);
string os__getenv(string key);
_option_string os__getenv_opt(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
Map_string_string os__environ(void);
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
Array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
bool os__fd_is_pending(int fd);
VV_LOC string os__NotExpected_msg(os__NotExpected err);
VV_LOC int os__NotExpected_code(os__NotExpected err);
VV_LOC string os__fix_windows_path(string path);
_result_os__File os__open_file(string path, string mode, Array_int options);
_result_os__File os__open(string path);
_result_os__File os__create(string path);
os__File os__stdin(void);
os__File os__stdout(void);
os__File os__stderr(void);
bool os__File_eof(os__File* f);
_result_void os__File_reopen(os__File* f, string path, string mode);
_result_int os__File_read(os__File* f, Array_u8* buf);
_result_int os__File_write(os__File* f, Array_u8 buf);
_result_int os__File_writeln(os__File* f, string s);
_result_int os__File_write_string(os__File* f, string s);
_result_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf);
int os__File_write_ptr(os__File* f, voidptr data, int size);
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len);
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos);
VV_LOC _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
Array_u8 os__File_read_bytes(os__File* f, int size);
Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos);
_result_int os__File_read_bytes_with_newline(os__File* f, Array_u8* buf);
_result_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf);
_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf);
_result_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size);
void os__File_flush(os__File* f);
string os__FileNotOpenedError_msg(os__FileNotOpenedError err);
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err);
VV_LOC IError os__error_file_not_opened(void);
_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode);
_result_i64 os__File_tell(os__File* f);
int os__File_setvbuf(os__File* f, char* buffer, os__FileBufferMode mode, usize size);
int os__File_set_buffer(os__File* f, Array_u8* buffer, os__FileBufferMode mode);
void os__File_set_line_buffered(os__File* f);
void os__File_set_unbuffered(os__File* f);
_result_void os__File_write_u8(os__File* f, u8 b);
_result_u8 os__File_read_u8(os__File* f);
VV_LOC _result_void os__check_cf(usize x, string label);
VV_LOC _result_void os__check_fwrite(usize x);
VV_LOC _result_void os__check_fread(usize x);
bool os__is_abs_path(string path);
string os__abs_path(string path);
string os__norm_path(string path);
_result_string os__existing_path(string path);
VV_LOC string os__clean_path(string path);
string os__to_slash(string path);
string os__from_slash(string path);
VV_LOC int os__win_volume_len(string path);
VV_LOC bool os__is_slash(u8 b);
VV_LOC bool os__has_drive_letter(string path);
VV_LOC bool os__starts_w_slash_slash(string path);
VV_LOC bool os__is_curr_dir_ref(int byte_one, int byte_two, int byte_three);
u32 os__FilePermission_bitmask(os__FilePermission p);
u32 os__FileMode_bitmask(os__FileMode m);
os__FileInfo os__inode(string path);
_result_Array_u8 os__read_bytes(string path);
_result_void os__write_bytes(string path, Array_u8 bytes);
VV_LOC _result_int os__find_cfile_size(FILE* fp);
VV_LOC _result_strings__Builder os__slurp_file_in_builder(FILE* fp);
_result_string os__read_file(string path);
_result_void os__truncate(string path, u64 len);
u64 os__file_size(string path);
_result_void os__rename_dir(string src, string dst);
_result_void os__rename(string src, string dst);
_result_void os__cp(string src, string dst, os__CopyParams config);
_result_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
VV_LOC voidptr os__vpopen(string path);
VV_LOC multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
VV_LOC int os__vpclose(voidptr f);
int os__system(string cmd);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
_result_void os__rm(string path);
_result_void os__rmdir(string path);
VV_LOC void os__print_c_errno(void);
string os__get_raw_line(void);
Array_u8 os__get_raw_stdin(void);
string os__executable(void);
_result_void os__chdir(string path);
string os__getwd(void);
string os__real_path(string fpath);
VV_LOC void os__normalize_drive_letter(string path);
int os__fork(void);
int os__wait(void);
i64 os__file_last_mod_unix(string path);
void os__flush(void);
_result_void os__chmod(string path, int mode);
_result_void os__chown(string path, int owner, int group);
_result_os__File os__open_append(string path);
_result_void os__execvp(string cmdpath, Array_string cmdargs);
_result_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs);
int os__is_atty(int fd);
_result_void os__write_file_array(string path, array buffer);
_result_Array_string os__glob(Array_string patterns);
IError os__last_error(void);
IError os__error_posix(os__SystemError e);
IError os__error_win32(os__SystemError e);
void os__Result_free(os__Result* result);
VV_LOC string os__executable_fallback(void);
_result_void os__cp_all(string src, string dst, bool overwrite);
_result_void os__mv_by_cp(string source, string target, os__MvParams opts);
_result_void os__mv(string source, string target, os__MvParams opts);
_result_Array_string os__read_lines(string path);
_result_void os__write_lines(string path, Array_string lines);
string os__sigint_to_signal_name(int si);
_result_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
string os__file_ext(string opath);
string os__dir(string path);
string os__base(string path);
string os__file_name(string path);
multi_return_string_string_string os__split_path(string path);
_option_string os__input_opt(string prompt);
string os__input(string prompt);
string os__get_line(void);
Array_string os__get_lines(void);
string os__get_lines_joined(void);
Array_string os__get_raw_lines(void);
string os__get_raw_lines_joined(void);
Array_string os__get_trimmed_lines(void);
string os__user_os(void);
_result_Array_string os__user_names(void);
string os__home_dir(void);
string os__expand_tilde_to_home(string path);
_result_void os__write_file(string path, string text);
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err);
VV_LOC IError os__error_failed_to_find_executable(void);
_result_string os__find_abs_path_of_executable(string exe_name);
bool os__exists_in_system_path(string prog);
bool os__is_file(string path);
string os__join_path(string base, Array_string dirs);
string os__join_path_single(string base, string elem);
VV_LOC void os__normalize_path_in_builder(strings__Builder* sb);
Array_string os__walk_ext(string path, string ext, os__WalkParams opts);
VV_LOC void os__impl_walk_ext(string path, string ext, Array_string* out, os__WalkParams opts);
void os__walk(string path, void (*f)(string ));
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string ));
void os__log(string s);
_result_void os__mkdir_all(string opath, os__MkdirParams params);
VV_LOC void os__create_folder_when_it_does_not_exist(string path);
VV_LOC string os__xdg_home_folder(string ename, string lpath);
string os__cache_dir(void);
string os__data_dir(void);
string os__state_dir(void);
string os__local_bin_dir(void);
string os__temp_dir(void);
string os__vtmp_dir(void);
VV_LOC string os__default_vmodules_path(void);
string os__vmodules_dir(void);
Array_string os__vmodules_paths(void);
string os__resource_abs_path(string path);
os__Result os__execute_or_panic(string cmd);
os__Result os__execute_or_exit(string cmd);
_result_os__Result os__execute_opt(string cmd);
string os__quoted_path(string path);
_result_string os__config_dir(void);
VV_LOC Array_string os__glob_match(string dir, string pattern, string next_pattern, Array_string* matches);
VV_LOC _result_void os__native_glob_pattern(string pattern, Array_string* matches);
_result_void os__utime(string path, int actime, int modtime);
os__Uname os__uname(void);
_result_string os__hostname(void);
_result_string os__loginname(void);
_result_Array_string os__ls(string path);
_result_void os__mkdir(string path, os__MkdirParams params);
os__Result os__execute(string cmd);
os__Result os__raw_execute(string cmd);
_result_void os__symlink(string target, string link_name);
_result_string os__readlink(string path);
_result_void os__link(string origin, string target);
string os__get_error_msg(int code);
void os__File_close(os__File* f);
_result_void os__ensure_folder_is_writable(string folder);
int os__getpid(void);
int os__getppid(void);
int os__getuid(void);
int os__geteuid(void);
int os__getgid(void);
int os__getegid(void);
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable);
int os__page_size(void);
_result_os__DiskUsage os__disk_usage(string path);
_result_string os__input_password(string prompt);
int os__fd_dup(int fd);
int os__fd_dup2(int fd1, int fd2);
_result_os__Pipe os__pipe(void);
void os__Pipe_close(os__Pipe* p);
_result_int os__Pipe_read(os__Pipe* p, Array_u8* buffer);
_result_int os__Pipe_write(os__Pipe* p, Array_u8 buffer);
_result_int os__Pipe_write_string(os__Pipe* p, string s);
Array_string os__Pipe_slurp(os__Pipe* p);
_result_os__IOCapture os__stdio_capture(void);
void os__IOCapture_stop(os__IOCapture* c);
void os__IOCapture_close(os__IOCapture* c);
multi_return_Array_string_Array_string os__IOCapture_finish(os__IOCapture* c);
void os__Process_signal_kill(os__Process* p);
void os__Process_signal_term(os__Process* p);
void os__Process_signal_pgkill(os__Process* p);
void os__Process_signal_stop(os__Process* p);
void os__Process_signal_continue(os__Process* p);
void os__Process_wait(os__Process* p);
void os__Process_close(os__Process* p);
void os__Process_free(os__Process* p);
VV_LOC int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
void os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
_option_string os__Process_pipe_read(os__Process* p, os__ChildProcessPipeKind pkind);
bool os__Process_is_pending(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOC string os__Process__read_from(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOC string os__Process__slurp_from(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOC void os__Process__write_to(os__Process* p, os__ChildProcessPipeKind pkind, string s);
VV_LOC bool os__Process__is_pending(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOC void os__Process__check_redirection_call(os__Process* p, string fn_name);
VV_LOC void os__Process__signal_stop(os__Process* p);
VV_LOC void os__Process__signal_continue(os__Process* p);
VV_LOC void os__Process__signal_kill(os__Process* p);
VV_LOC void os__Process__signal_term(os__Process* p);
VV_LOC void os__Process__signal_pgkill(os__Process* p);
VV_LOC void os__Process__wait(os__Process* p);
VV_LOC bool os__Process__is_alive(os__Process* p);
void os__Process_run(os__Process* p);
os__Process* os__new_process(string filename);
void os__Process_set_args(os__Process* p, Array_string pargs);
void os__Process_set_work_folder(os__Process* p, string path);
void os__Process_set_environment(os__Process* p, Map_string_string envs);
VV_LOC int os__Process_unix_spawn_process(os__Process* p);
VV_LOC void os__Process_unix_stop_process(os__Process* p);
VV_LOC void os__Process_unix_resume_process(os__Process* p);
VV_LOC void os__Process_unix_term_process(os__Process* p);
VV_LOC void os__Process_unix_kill_process(os__Process* p);
VV_LOC void os__Process_unix_kill_pgroup(os__Process* p);
VV_LOC void os__Process_unix_wait(os__Process* p);
VV_LOC bool os__Process_unix_is_alive(os__Process* p);
VV_LOC bool os__Process_impl_check_pid_status(os__Process* p, bool exit_early_on_ret0, int waitpid_options);
_result_anon_fn_os__signal os__signal_opt(os__Signal signum, void (*handler)(os__Signal ));
VV_LOC void os__ignore_signal_handler(os__Signal _signal);
void os__signal_ignore(Array_os__Signal args);
bool os__is_main_thread(void);
VV_LOC void os__signal_ignore_internal(Array_os__Signal args);
VV_LOC void os__sleep_ms(i64 ms);
_result_void os__open_uri(string uri);
_result_os__Stat os__stat(string path);
_result_os__Stat os__lstat(string path);
os__FileType os__Stat_get_filetype(os__Stat st);
os__FileMode os__Stat_get_mode(os__Stat st);
bool os__is_dir(string path);
bool os__is_link(string path);
VV_LOC os__PathKind os__kind_of_existing_path(string path);
os__filelock__FileLock os__filelock__new(string fileName);
bool os__filelock__FileLock_wait_acquire(os__filelock__FileLock* l, time__Duration timeout);
bool os__filelock__FileLock_release(os__filelock__FileLock* l);
void os__filelock__FileLock_unlink(os__filelock__FileLock* l);
_result_void os__filelock__FileLock_acquire(os__filelock__FileLock* l);
VV_LOC int os__filelock__open_lockfile(string f);
bool os__filelock__FileLock_try_acquire(os__filelock__FileLock* l);
VV_LOC u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u32 rand__seed__time_seed_32(void);
u64 rand__seed__time_seed_64(void);
string v__cflag__CFlag_str(v__cflag__CFlag* c);
VV_LOC multi_return_bool_string_int_Array_string v__cflag__find_first_existing_path(string remainder, string literal);
_option_string v__cflag__CFlag_eval(v__cflag__CFlag* cf);
_option_string v__cflag__CFlag_format(v__cflag__CFlag* cf);
Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags);
Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags);
multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags);
VV_LOC Array_string v__cflag__uniq_non_empty(Array_string args);
VV_LOC void v__vcache__remove_old_cache_folder(void);
v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts);
void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts);
string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key);
string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key);
VV_LOC string v__vcache__normalise_mod(string mod);
string v__vcache__CacheManager_mod_postfix_with_key2cpath(v__vcache__CacheManager* cm, string mod, string postfix, string key);
_result_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key);
_result_string v__vcache__CacheManager_mod_exists(v__vcache__CacheManager* cm, string mod, string postfix, string key);
_result_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content);
_result_string v__vcache__CacheManager_mod_save(v__vcache__CacheManager* cm, string mod, string postfix, string key, string content);
_result_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key);
_result_string v__vcache__CacheManager_mod_load(v__vcache__CacheManager* cm, string mod, string postfix, string key);
VV_LOC void v__vcache__xlog(string fname, string s);
VV_LOC int v__vcache__mypid(void);
VV_LOC _result_string v__pkgconfig__desc(string mod);
_result_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args);
_result_string v__pkgconfig__Main_run(v__pkgconfig__Main* m);
VV_LOC string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2);
VV_LOC v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp);
VV_LOC Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s);
VV_LOC Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s);
VV_LOC string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s);
VV_LOC void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line);
VV_LOC bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file);
VV_LOC _result_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname);
bool v__pkgconfig__atleast(string v);
bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v);
string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep);
VV_LOC _result_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc);
VV_LOC _result_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep);
VV_LOC void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path);
VV_LOC void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc);
_result_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options);
Array_string v__pkgconfig__list(void);
string term__format_esc(string code);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__reset(string msg);
string term__bold(string msg);
string term__dim(string msg);
string term__italic(string msg);
string term__underline(string msg);
string term__slow_blink(string msg);
string term__rapid_blink(string msg);
string term__inverse(string msg);
string term__hidden(string msg);
string term__strikethrough(string msg);
string term__black(string msg);
string term__red(string msg);
string term__green(string msg);
string term__yellow(string msg);
string term__blue(string msg);
string term__magenta(string msg);
string term__cyan(string msg);
string term__white(string msg);
string term__bg_black(string msg);
string term__bg_red(string msg);
string term__bg_green(string msg);
string term__bg_yellow(string msg);
string term__bg_blue(string msg);
string term__bg_magenta(string msg);
string term__bg_cyan(string msg);
string term__bg_white(string msg);
string term__gray(string msg);
string term__bright_black(string msg);
string term__bright_red(string msg);
string term__bright_green(string msg);
string term__bright_yellow(string msg);
string term__bright_blue(string msg);
string term__bright_magenta(string msg);
string term__bright_cyan(string msg);
string term__bright_white(string msg);
string term__bright_bg_black(string msg);
string term__bright_bg_red(string msg);
string term__bright_bg_green(string msg);
string term__bright_bg_yellow(string msg);
string term__bright_bg_blue(string msg);
string term__bright_bg_magenta(string msg);
string term__bright_bg_cyan(string msg);
string term__bright_bg_white(string msg);
string term__highlight_command(string command);
void term__write_color(strings__Builder* b, string s, term__ColorConfig config);
void term__writeln_color(strings__Builder* b, string s, term__ColorConfig color);
void term__set_cursor_position(term__Coord c);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend(void);
void term__erase_tobeg(void);
void term__erase_clear(void);
void term__erase_del_clear(void);
void term__erase_line(string t);
void term__erase_line_toend(void);
void term__erase_line_tobeg(void);
void term__erase_line_clear(void);
void term__show_cursor(void);
void term__hide_cursor(void);
void term__clear_previous_line(void);
bool term__can_show_color_on_stdout(void);
bool term__can_show_color_on_stderr(void);
string term__failed(string s);
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__colorize(string (*cfn)(string ), string s);
string term__ecolorize(string (*cfn)(string ), string s);
string term__strip_ansi(string text);
string term__h_divider(string divider);
string term__header_left(string text, string divider);
string term__header(string text, string divider);
VV_LOC int term__imax(int x, int y);
VV_LOC bool term__supports_escape_sequences(int fd);
multi_return_int_int term__get_terminal_size(void);
_result_term__Coord term__get_cursor_position(void);
bool term__set_terminal_title(string title);
bool term__set_tab_title(string title);
bool term__clear(void);
bool term__supports_sixel(void);
u16 term__graphics_num_colors(void);
void term__enable_echo(bool enable);
i64 term__key_pressed(term__KeyPressedParams params);
_option_rune term__utf8_getchar(void);
int term__utf8_len(u8 c);
string v__util__recompilation__disabling_file(string vroot);
void v__util__recompilation__must_be_enabled(string vroot, string error_message);
Array_string v__util__vflags__join_env_vflags_and_os_args(void);
Array_string v__util__vflags__tokenize_to_args(string s);
VV_LOC _result_usize runtime__free_memory_impl(void);
int runtime__nr_jobs(void);
bool runtime__is_32bit(void);
bool runtime__is_64bit(void);
bool runtime__is_little_endian(void);
bool runtime__is_big_endian(void);
int runtime__nr_cpus(void);
_result_usize runtime__total_memory(void);
_result_usize runtime__free_memory(void);
_result_u64 runtime__used_memory(void);
VV_LOC string v__vmod__quote(string input);
VV_LOC void v__vmod__encode_array(strings__Builder* b, Array_string input);
string v__vmod__encode(v__vmod__Manifest manifest);
_result_v__vmod__Manifest v__vmod__from_file(string vmod_path);
_result_v__vmod__Manifest v__vmod__decode(string contents);
VV_LOC void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val);
VV_LOC bool v__vmod__is_name_alpha(u8 chr);
VV_LOC string v__vmod__Scanner_create_string(v__vmod__Scanner* s, u8 q);
VV_LOC string v__vmod__Scanner_create_ident(v__vmod__Scanner* s);
VV_LOC bool v__vmod__Scanner_peek_char(v__vmod__Scanner* s, u8 c);
VV_LOC void v__vmod__Scanner_scan_all(v__vmod__Scanner* s);
VV_LOC _result_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx);
VV_LOC _result_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p);
v__vmod__ModFileCacher* v__vmod__get_cache(void);
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher(void);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile);
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder);
VV_LOC void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result);
VV_LOC multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder);
VV_LOC void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod);
VV_LOC void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far);
VV_LOC bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, Array_string files);
VV_LOC Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder);
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng);
u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng);
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
VV_LOC f64 rand__msqrt(f64 a);
VV_LOC f64 rand__mlog(f64 a);
VV_LOC multi_return_f64_int rand__frexp(f64 x);
VV_LOC f64 rand__scalbn(f64 x, int n_);
VV_LOC f64 rand__f64_from_bits(u64 b);
VV_LOC u64 rand__f64_bits(f64 f);
string rand__uuid_v4(void);
VV_LOC string rand__internal_uuid(u8 version, u64 rand_1, u64 rand_2);
string rand__uuid_v7(void);
rand__UUIDSession rand__new_uuid_v7_session(void);
string rand__UUIDSession_next(rand__UUIDSession* u);
VV_LOC string rand__internal_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli);
VV_LOC string rand__internal_string_from_set(rand__PRNG* rng, string charset, int len);
VV_LOC void rand__internal_fill_buffer_from_set(rand__PRNG* rng, string charset, Array_u8* buf);
VV_LOC void rand__deinit(void);
VV_LOC void rand__init(void);
VV_LOC void rand__read_32(rand__PRNG* rng, Array_u8* buf);
VV_LOC void rand__read_64(rand__PRNG* rng, Array_u8* buf);
VV_LOC void rand__read_internal(rand__PRNG* rng, Array_u8* buf);
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_);
rand__PRNG* rand__get_current_rng(void);
void rand__set_rng(rand__PRNG* rng);
void rand__seed(Array_u32 seed);
_result_Array_u8 rand__PRNG_bytes(rand__PRNG* rng, int bytes_needed);
void rand__PRNG_read(rand__PRNG* rng, Array_u8* buf);
_result_i32 rand__PRNG_i32n(rand__PRNG* rng, i32 max);
_result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max);
_result_u64 rand__PRNG_u64n(rand__PRNG* rng, u64 max);
_result_u32 rand__PRNG_u32_in_range(rand__PRNG* rng, u32 min, u32 max);
_result_u64 rand__PRNG_u64_in_range(rand__PRNG* rng, u64 min, u64 max);
i8 rand__PRNG_i8(rand__PRNG* rng);
i16 rand__PRNG_i16(rand__PRNG* rng);
i32 rand__PRNG_i32(rand__PRNG* rng);
int rand__PRNG_int(rand__PRNG* rng);
i64 rand__PRNG_i64(rand__PRNG* rng);
int rand__PRNG_int31(rand__PRNG* rng);
i64 rand__PRNG_int63(rand__PRNG* rng);
_result_int rand__PRNG_intn(rand__PRNG* rng, int max);
_result_i64 rand__PRNG_i64n(rand__PRNG* rng, i64 max);
_result_int rand__PRNG_int_in_range(rand__PRNG* rng, int min, int max);
_result_i32 rand__PRNG_i32_in_range(rand__PRNG* rng, i32 min, i32 max);
_result_i64 rand__PRNG_i64_in_range(rand__PRNG* rng, i64 min, i64 max);
f32 rand__PRNG_f32(rand__PRNG* rng);
f32 rand__PRNG_f32cp(rand__PRNG* rng);
f64 rand__PRNG_f64(rand__PRNG* rng);
f64 rand__PRNG_f64cp(rand__PRNG* rng);
_result_f32 rand__PRNG_f32n(rand__PRNG* rng, f32 max);
_result_f64 rand__PRNG_f64n(rand__PRNG* rng, f64 max);
_result_f32 rand__PRNG_f32_in_range(rand__PRNG* rng, f32 min, f32 max);
_result_f64 rand__PRNG_f64_in_range(rand__PRNG* rng, f64 min, f64 max);
string rand__PRNG_ulid(rand__PRNG* rng);
string rand__PRNG_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli);
string rand__PRNG_string_from_set(rand__PRNG* rng, string charset, int len);
string rand__PRNG_string(rand__PRNG* rng, int len);
string rand__PRNG_hex(rand__PRNG* rng, int len);
string rand__PRNG_ascii(rand__PRNG* rng, int len);
void rand__PRNG_fill_buffer_from_set(rand__PRNG* rng, string charset, Array_u8* buf);
_result_bool rand__PRNG_bernoulli(rand__PRNG* rng, f64 p);
_result_f64 rand__PRNG_normal(rand__PRNG* rng, rand__config__NormalConfigStruct conf);
_result_multi_return_f64_f64 rand__PRNG_normal_pair(rand__PRNG* rng, rand__config__NormalConfigStruct conf);
_result_int rand__PRNG_binomial(rand__PRNG* rng, int n, f64 p);
f64 rand__PRNG_exponential(rand__PRNG* rng, f64 lambda);
u8 rand__u8(void);
u16 rand__u16(void);
u32 rand__u32(void);
u64 rand__u64(void);
_result_u32 rand__u32n(u32 max);
_result_u64 rand__u64n(u64 max);
_result_u32 rand__u32_in_range(u32 min, u32 max);
_result_u64 rand__u64_in_range(u64 min, u64 max);
i8 rand__i8(void);
i16 rand__i16(void);
i32 rand__i32(void);
int rand__int(void);
_result_i32 rand__i32n(i32 max);
_result_int rand__intn(int max);
_result_int rand__int_in_range(int min, int max);
_result_i32 rand__i32_in_range(i32 min, i32 max);
int rand__int31(void);
i64 rand__i64(void);
_result_i64 rand__i64n(i64 max);
_result_i64 rand__i64_in_range(i64 min, i64 max);
i64 rand__int63(void);
f32 rand__f32(void);
f32 rand__f32cp(void);
f64 rand__f64(void);
f64 rand__f64cp(void);
_result_f32 rand__f32n(f32 max);
_result_f64 rand__f64n(f64 max);
_result_f32 rand__f32_in_range(f32 min, f32 max);
_result_f64 rand__f64_in_range(f64 min, f64 max);
_result_Array_u8 rand__bytes(int bytes_needed);
void rand__read(Array_u8* buf);
string rand__ulid(void);
string rand__ulid_at_millisecond(u64 unix_time_milli);
string rand__string_from_set(string charset, int len);
void rand__fill_buffer_from_set(string charset, Array_u8* buf);
string rand__string(int len);
string rand__hex(int len);
string rand__ascii(int len);
_result_bool rand__bernoulli(f64 p);
_result_f64 rand__normal(rand__config__NormalConfigStruct config_);
_result_multi_return_f64_f64 rand__normal_pair(rand__config__NormalConfigStruct config_);
_result_int rand__binomial(int n, f64 p);
f64 rand__exponential(f64 lambda);
v__pref__Arch v__pref__get_host_arch(void);
_result_v__pref__Arch v__pref__arch_from_string(string arch_str);
multi_return_Array_string_Array_string v__pref__get_build_facts_and_defines(void);
void v__pref__set_build_flags_and_defines(Array_string facts, Array_string defines);
v__pref__Preferences* v__pref__new_preferences(void);
VV_LOC void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p);
VV_LOC void v__pref__Preferences_expand_exclude_paths(v__pref__Preferences* p);
VV_LOC void v__pref__Preferences_setup_os_and_arch_when_not_explicitly_set(v__pref__Preferences* p);
string v__pref__Preferences_defines_map_unique_keys(v__pref__Preferences* p);
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p);
VV_LOC void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p);
VV_LOC void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p);
string v__pref__default_tcc_compiler(void);
void v__pref__Preferences_default_c_compiler(v__pref__Preferences* p);
void v__pref__Preferences_default_cpp_compiler(v__pref__Preferences* p);
string v__pref__vexe_path(void);
string v__pref__Preferences_vcross_linker_name(v__pref__Preferences* p);
string v__pref__Preferences_vcross_compiler_name(v__pref__Preferences* p);
string v__pref__Preferences_vroot_file(v__pref__Preferences* p, string path);
VV_LOC void v__pref__Preferences_parse_line_info(v__pref__Preferences* p, string line);
_result_v__pref__OS v__pref__os_from_string(string os_str);
string v__pref__OS_lower(v__pref__OS o);
string v__pref__OS_str(v__pref__OS o);
v__pref__OS v__pref__get_host_os(void);
bool v__pref__Backend_is_js(v__pref__Backend b);
multi_return_ref_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args);
VV_LOC void v__pref__run_code_in_tmp_vfile_and_exit(Array_string args, v__pref__Preferences* res, string option_name, string extension, string content);
multi_return_ref_v__pref__Preferences_string v__pref__parse_args_and_show_errors(Array_string known_external_commands, Array_string args, bool show_output);
void v__pref__eprintln_exit(string s);
void v__pref__eprintln_cond(bool condition, string s);
void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s);
bool v__pref__Preferences_should_output_to_stdout(v__pref__Preferences* pref);
VV_LOC void v__pref__must_exist(string path);
VV_LOC bool v__pref__is_source_file(string path);
_result_v__pref__Backend v__pref__backend_from_string(string s);
v__pref__CompilerType v__pref__cc_from_string(string s);
VV_LOC void v__pref__Preferences_parse_define(v__pref__Preferences* prefs, string define);
string v__pref__supported_test_runners_list(void);
bool v__pref__Preferences_should_trace_fn_name(v__pref__Preferences* pref, string fname);
bool v__pref__Preferences_should_use_segfault_handler(v__pref__Preferences* pref);
Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_);
VV_LOC string v__pref__fname_without_platform_postfix(string file);
bool v__pref__Preferences_should_compile_native(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path);
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file);
bool v__pref__Preferences_should_compile_wasm(v__pref__Preferences* prefs, string file);
bool v__pref__OS_is_target_of(v__pref__OS this_os, string target);
_result_v__pref__Subsystem v__pref__Subsystem__static__from_T_string(string input);
VV_LOC sync__Channel* sync__new_channel_st(u32 n, u32 st);
void sync__Channel_close(sync__Channel* ch);
int sync__Channel_len(sync__Channel* ch);
bool sync__Channel_closed(sync__Channel* ch);
void sync__Channel_push(sync__Channel* ch, voidptr src);
ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src);
VV_LOC ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block);
bool sync__Channel_pop(sync__Channel* ch, voidptr dest);
ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest);
VV_LOC ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block);
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout);
string sync__Mutex_str(sync__Mutex* m);
string sync__RwMutex_str(sync__RwMutex* m);
sync__Cond* sync__new_cond(sync__Mutex* m);
void sync__Cond_wait(sync__Cond* c);
void sync__Cond_signal(sync__Cond* c);
void sync__Cond_broadcast(sync__Cond* c);
sync__ManyTimes* sync__new_many_times(u64 times);
void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)());
VV_LOC void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)());
sync__Once* sync__new_once(void);
void sync__Once_do(sync__Once* o, void (*f)());
VV_LOC void sync__Once_do_slow(sync__Once* o, void (*f)());
void sync__Once_do_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param);
VV_LOC void sync__Once_do_slow_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param);
VV_LOC void sync__cpanic(int res);
VV_LOC void sync__should_be_zero(int res);
sync__SpinLock* sync__new_spin_lock(void);
void sync__SpinLock_lock(sync__SpinLock* s);
bool sync__SpinLock_try_lock(sync__SpinLock* s);
void sync__SpinLock_unlock(sync__SpinLock* s);
void sync__SpinLock_destroy(sync__SpinLock* s);
sync__Mutex* sync__new_mutex(void);
void sync__Mutex_init(sync__Mutex* m);
sync__RwMutex* sync__new_rwmutex(void);
void sync__RwMutex_init(sync__RwMutex* m);
void sync__Mutex_lock(sync__Mutex* m);
bool sync__Mutex_try_lock(sync__Mutex* m);
void sync__Mutex_unlock(sync__Mutex* m);
void sync__Mutex_destroy(sync__Mutex* m);
void sync__RwMutex_rlock(sync__RwMutex* m);
void sync__RwMutex_lock(sync__RwMutex* m);
bool sync__RwMutex_try_rlock(sync__RwMutex* m);
bool sync__RwMutex_try_wlock(sync__RwMutex* m);
void sync__RwMutex_destroy(sync__RwMutex* m);
void sync__RwMutex_runlock(sync__RwMutex* m);
void sync__RwMutex_unlock(sync__RwMutex* m);
sync__Semaphore* sync__new_semaphore(void);
sync__Semaphore* sync__new_semaphore_init(u32 n);
void sync__Semaphore_init(sync__Semaphore* sem, u32 n);
void sync__Semaphore_post(sync__Semaphore* sem);
void sync__Semaphore_wait(sync__Semaphore* sem);
bool sync__Semaphore_try_wait(sync__Semaphore* sem);
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout);
void sync__Semaphore_destroy(sync__Semaphore* sem);
sync__WaitGroup* sync__new_waitgroup(void);
void sync__WaitGroup_init(sync__WaitGroup* wg);
void sync__WaitGroup_add(sync__WaitGroup* wg, int delta);
void sync__WaitGroup_done(sync__WaitGroup* wg);
void sync__WaitGroup_wait(sync__WaitGroup* wg);
void sync__WaitGroup_go(sync__WaitGroup* wg, void (*f)());
VV_LOC void anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731(sync__WaitGroup* wg, void (*f)());
u64 sync__thread_id(void);
_result_string v__util__resolve_d_value(Map_string_string compile_values, string str);
_result_string v__util__resolve_env_value(string str, bool check_for_presence);
v__util__EManager* v__util__new_error_manager(void);
void v__util__EManager_set_support_color(v__util__EManager* e, bool b);
string v__util__bold(string msg);
string v__util__color(string kind, string msg);
string v__util__path_styled_for_error_messages(string path);
string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Pos pos);
Array_string v__util__cached_file2sourcelines(string path);
Array_string v__util__set_source_for_path(string path, string source);
Array_string v__util__source_file_context(string kind, string filepath, v__token__Pos pos);
void v__util__verror(string kind, string s);
string v__util__vlines_escape_path(string path, string ccompiler);
void v__util__show_compiler_message(string kind, v__errors__CompilerMessage err);
void v__util__print_json_errors(Array_v__util__JsonError errs);
string v__util__qualify_import(v__pref__Preferences* pref_, string mod, string file_path);
string v__util__qualify_module(v__pref__Preferences* pref_, string mod, string file_path);
VV_LOC _result_string v__util__mod_path_to_full_name(v__pref__Preferences* pref_, string mod, string path);
string v__util__smart_quote(string str, bool raw);
VV_LOC _v_Array_fixed_bool_256 v__util__get_non_white_space_table(void);
VV_LOC _v_Array_fixed_bool_256 v__util__get_name_char_table(void);
VV_LOC _v_Array_fixed_bool_256 v__util__get_func_char_table(void);
bool v__util__is_name_char(u8 c);
bool v__util__is_func_char(u8 c);
bool v__util__contains_capital(string s);
bool v__util__good_type_name(string s);
bool v__util__is_generic_type_name(string name);
string v__util__cescaped_path(string s);
v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities, v__util__SuggestionParams params);
void v__util__Suggestion_add(v__util__Suggestion* s, string val);
void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many);
void v__util__Suggestion_sort(v__util__Suggestion* s);
string v__util__Suggestion_say(v__util__Suggestion s, string msg);
string v__util__short_module_name(string name);
string v__util__highlight_suggestion(string message);
v__util__Surrounder v__util__new_surrounder(int expected_length);
void v__util__Surrounder_add(v__util__Surrounder* s, string before, string after);
string v__util__Surrounder_before(v__util__Surrounder* s);
string v__util__Surrounder_after(v__util__Surrounder* s);
void v__util__Surrounder_builder_write_befores(v__util__Surrounder* s, strings__Builder* sb);
void v__util__Surrounder_builder_write_afters(v__util__Surrounder* s, strings__Builder* sb);
void v__util__Surrounder_free(v__util__Surrounder* s);
v__util__Timers* v__util__new_timers(v__util__TimerParams params);
v__util__Timers* v__util__get_timers(void);
void v__util__timing_start(string label);
void v__util__timing_measure(string label);
void v__util__timing_measure_cumulative(string label);
void v__util__timing_set_should_print(bool should_print);
void v__util__Timers_start(v__util__Timers* t, string name);
i64 v__util__Timers_measure(v__util__Timers* t, string name);
i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name);
void v__util__Timers_measure_pause(v__util__Timers* t, string name);
void v__util__Timers_measure_resume(v__util__Timers* t, string name);
string v__util__Timers_message(v__util__Timers* t, string name);
void v__util__Timers_show(v__util__Timers* t, string label);
void v__util__Timers_show_if_exists(v__util__Timers* t, string label);
void v__util__Timers_show_remaining(v__util__Timers* t);
void v__util__Timers_dump_all(v__util__Timers* t);
VV_LOC Array_string v__util__Timers_tsafe_get_keys(v__util__Timers* t);
VV_LOC void v__util__Timers_tsafe_set_sw(v__util__Timers* t, string name, time__StopWatch sw);
VV_LOC _option_time__StopWatch v__util__Timers_tsafe_get_sw(v__util__Timers* t, string name);
string v__util__skip_bom(string file_content);
bool v__util__module_is_builtin(string mod);
string v__util__tabs(int n);
time__Time v__util__get_build_time(void);
void v__util__set_vroot_folder(string vroot_path);
bool v__util__is_escape_sequence(u8 c);
void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args);
bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe);
VV_LOC multi_return_string_string v__util__tool_source2name_and_exe(string tool_source);
string v__util__quote_path(string s);
string v__util__args_quote_paths(Array_string args);
string v__util__path_of_executable(string path);
_result_string v__util__cached_read_source_file(string path);
string v__util__replace_op(string s);
Array_string v__util__join_env_vflags_and_os_args(void);
_result_bool v__util__check_module_is_installed(string modulename, bool is_verbose, bool need_update);
void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose);
string v__util__strip_mod_name(string name);
string v__util__strip_main_name(string name);
string v__util__no_dots(string s);
string v__util__no_cur_mod(string __v_typename, string cur_mod);
void v__util__prepare_tool_when_needed(string source_name);
void v__util__recompile_file(string vexe, string file);
string v__util__get_vtmp_folder(void);
bool v__util__should_bundle_module(string mod);
_result_Array_string v__util__find_all_v_files(Array_string roots);
void v__util__free_caches(void);
_result_string v__util__read_file(string file_path);
_result_string v__util__resolve_vmodroot(string str, string dir);
string v__ast__ComptimeType_str(v__ast__ComptimeType cty);
_option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e);
bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o);
v__ast__FnDecl v__ast__FnDecl_new_method_with_receiver_type(v__ast__FnDecl* f, v__ast__Type new_type_);
VV_LOC bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o);
string v__ast__Param_specifier(v__ast__Param* p);
v__ast__Fn v__ast__Fn_new_method_with_receiver_type(v__ast__Fn* f, v__ast__Type new_type_);
VV_LOC bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o);
VV_LOC bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o);
void v__ast__File_free(v__ast__File* f);
string v__ast__Ident_full_name(v__ast__Ident* i);
bool v__ast__Ident_is_auto_heap(v__ast__Ident* i);
bool v__ast__Ident_is_mut(v__ast__Ident* i);
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i);
_result_void v__ast__ComptimeCall_resolve_compile_value(v__ast__ComptimeCall* cc, Map_string_string compile_values);
string v__ast__ComptimeCall_expr_str(v__ast__ComptimeCall _v_toheap_cc);
v__ast__Type v__ast__Expr_type(v__ast__Expr e);
bool v__ast__Expr_is_blank_ident(v__ast__Expr expr);
bool v__ast__Expr_is_as_cast(v__ast__Expr expr);
v__token__Pos v__ast__Expr_pos(v__ast__Expr expr);
bool v__ast__Expr_is_constant(v__ast__Expr expr);
bool v__ast__Expr_is_lvalue(v__ast__Expr expr);
bool v__ast__Expr_is_expr(v__ast__Expr expr);
v__ast__Type v__ast__Expr_get_pure_type(v__ast__Expr expr);
bool v__ast__Expr_is_pure_literal(v__ast__Expr expr);
bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr);
bool v__ast__Expr_is_lockable(v__ast__Expr* e);
bool v__ast__Expr_has_fn_call(v__ast__Expr* e);
v__token__Pos v__ast__Node_pos(v__ast__Node node);
Array_v__ast__Node v__ast__Node_children(v__ast__Node node);
void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val);
void v__ast__IndexExpr_recursive_arraymap_set_is_setter(v__ast__IndexExpr* lx);
Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch);
VV_LOC Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size);
bool v__ast__Expr_is_reference(v__ast__Expr expr);
v__ast__Expr v__ast__Expr_remove_par(v__ast__Expr* expr);
bool v__ast__Expr_is_literal(v__ast__Expr expr);
bool v__ast__Expr_is_nil(v__ast__Expr e);
bool v__ast__type_can_start_with_token(v__token__Token* tok);
_result_void v__ast__validate_type_string_is_pure_literal(v__ast__Type typ, string str);
string v__ast__Attr_debug(v__ast__Attr* a);
string v__ast__Attr_str(v__ast__Attr* a);
bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str);
bool Array_v__ast__Attr_contains_arg(Array_v__ast__Attr attrs, string str, string arg);
_option_v__ast__Attr Array_v__ast__Attr_find_first(Array_v__ast__Attr attrs, string aname);
_option_v__ast__Attr Array_v__ast__Attr_find_last(Array_v__ast__Attr attrs, string aname);
_option_int Array_v__ast__Attr_find_comptime_define(Array_v__ast__Attr attrs);
bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag);
_result_void v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines);
_option_i8 v__ast__ComptTimeConstValue_i8(v__ast__ComptTimeConstValue val);
_option_i16 v__ast__ComptTimeConstValue_i16(v__ast__ComptTimeConstValue val);
_option_int v__ast__ComptTimeConstValue_int(v__ast__ComptTimeConstValue val);
_option_i32 v__ast__ComptTimeConstValue_i32(v__ast__ComptTimeConstValue val);
_option_voidptr v__ast__ComptTimeConstValue_voidptr(v__ast__ComptTimeConstValue val);
_option_i64 v__ast__ComptTimeConstValue_i64(v__ast__ComptTimeConstValue val);
_option_u8 v__ast__ComptTimeConstValue_u8(v__ast__ComptTimeConstValue val);
_option_u16 v__ast__ComptTimeConstValue_u16(v__ast__ComptTimeConstValue val);
_option_u32 v__ast__ComptTimeConstValue_u32(v__ast__ComptTimeConstValue val);
_option_u64 v__ast__ComptTimeConstValue_u64(v__ast__ComptTimeConstValue val);
_option_f32 v__ast__ComptTimeConstValue_f32(v__ast__ComptTimeConstValue val);
_option_f64 v__ast__ComptTimeConstValue_f64(v__ast__ComptTimeConstValue val);
_option_string v__ast__ComptTimeConstValue_string(v__ast__ComptTimeConstValue val);
_option_v__ast__ComptTimeConstValue v__ast__ConstField_comptime_expr_value(v__ast__ConstField obj);
bool v__ast__ConstField_is_simple_define_const(v__ast__ConstField obj);
bool v__ast__ScopeObject_is_simple_define_const(v__ast__ScopeObject obj);
VV_LOC Array_string v__ast__all_valid_comptime_idents(void);
_result_bool v__ast__eval_comptime_not_user_defined_ident(string ident, v__pref__Preferences* the_pref);
_result_string v__ast__comptime_if_to_ifdef(string name, v__pref__Preferences* the_pref);
u64 v__ast__EmbeddedFile_hash(v__ast__EmbeddedFile e);
v__ast__Expr v__ast__Table_resolve_init(v__ast__Table* t, v__ast__StructInit node, v__ast__Type typ);
void v__ast__Scope_free(v__ast__Scope* s);
VV_LOC bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s);
_option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name);
v__ast__ScopeObject* v__ast__Scope_find_ptr(v__ast__Scope* s, string name);
v__ast__ScopeStructField* v__ast__Scope_find_struct_field(v__ast__Scope* s, string name, v__ast__Type struct_type, string field_name);
_option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name);
_option_v__ast__GlobalField_ptr v__ast__Scope_find_global(v__ast__Scope* s, string name);
_option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name);
bool v__ast__Scope_known_var(v__ast__Scope* s, string name);
bool v__ast__Scope_known_global(v__ast__Scope* s, string name);
bool v__ast__Scope_known_const(v__ast__Scope* s, string name);
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ);
void v__ast__Scope_update_ct_var_kind(v__ast__Scope* s, string name, v__ast__ComptimeVarKind kind);
void v__ast__Scope_update_smartcasts(v__ast__Scope* s, string name, v__ast__Type typ, bool is_unwrapped);
void v__ast__Scope_register_struct_field(v__ast__Scope* s, string name, v__ast__ScopeStructField field);
void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj);
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos);
Array_v__ast__ScopeObject v__ast__Scope_get_all_vars(v__ast__Scope* s);
bool v__ast__Scope_contains(v__ast__Scope* s, int pos);
bool v__ast__Scope__eq(v__ast__Scope* s, v__ast__Scope* o);
bool v__ast__Scope_has_inherited_vars(v__ast__Scope* s);
bool v__ast__Scope_is_inherited_var(v__ast__Scope* s, string var_name);
string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth);
bool v__ast__Scope_mark_var_as_used(v__ast__Scope* sc, string varname);
string v__ast__Scope_str(v__ast__Scope* sc);
string v__ast__FnDecl_get_name(v__ast__FnDecl* f);
string v__ast__Table_get_anon_fn_name(v__ast__Table* table, string prefix, v__ast__Fn* func, v__token__Pos pos);
string v__ast__CallExpr_get_name(v__ast__CallExpr* f);
string v__ast__FnDecl_modname(v__ast__FnDecl* node);
string v__ast__FnDecl_fkey(v__ast__FnDecl* node);
string v__ast__StructField_sfkey(v__ast__StructField* node);
string v__ast__Fn_fkey(v__ast__Fn* node);
string v__ast__CallExpr_fkey(v__ast__CallExpr* node);
string v__ast__Table_stringify_anon_decl(v__ast__Table* t, v__ast__AnonFn* node, string cur_mod, Map_string_string m2a);
string v__ast__Table_stringify_fn_decl(v__ast__Table* t, v__ast__FnDecl* node, string cur_mod, Map_string_string m2a, bool needs_wrap);
VV_LOC void v__ast__Table_stringify_fn_after_name(v__ast__Table* t, v__ast__FnDecl* node, strings__Builder* f, string cur_mod, Map_string_string m2a);
VV_LOC void v__ast__write_comments(Array_v__ast__Comment comments, strings__Builder* f);
VV_LOC void v__ast__write_comment(v__ast__Comment node, strings__Builder* f);
VV_LOC string v__ast__shorten_full_name_based_on_aliases(string input, Map_string_string m2a);
string v__ast__StringInterLiteral_get_fspec(v__ast__StringInterLiteral* lit, int i);
string v__ast__Expr_str(v__ast__Expr x);
string v__ast__CallArg_str(v__ast__CallArg a);
string v__ast__args2str(Array_v__ast__CallArg args);
string v__ast__BranchStmt_str(v__ast__BranchStmt* node);
string v__ast__Stmt_str(v__ast__Stmt node);
VV_LOC string v__ast__field_to_string(v__ast__ConstField f);
string v__ast__ComptimeForKind_str(v__ast__ComptimeForKind e);
void v__ast__UsedFeatures_free(v__ast__UsedFeatures* uf);
void v__ast__Table_free(v__ast__Table* t);
VV_LOC void v__ast__default_table_panic_handler(v__ast__Table* _t, string message);
void v__ast__Table_panic(v__ast__Table* t, string message);
v__ast__Table* v__ast__new_table(void);
string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f);
string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func);
_option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name);
bool v__ast__Table_known_fn(v__ast__Table* t, string name);
void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn);
void v__ast__Table_register_interface(v__ast__Table* t, v__ast__InterfaceDecl idecl);
void v__ast__Table_register_sumtype(v__ast__Table* t, v__ast__SumTypeDecl sumtyp);
int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn);
int v__ast__TypeSymbol_update_method(v__ast__TypeSymbol* t, v__ast__Fn f);
_result_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
_result_v__ast__Fn v__ast__Table_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
Array_Array_v__ast__Type v__ast__Table_get_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, v__ast__GetEmbedsOptions options);
_result_multi_return_v__ast__Fn_Array_v__ast__Type v__ast__Table_find_method_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name);
_result_v__ast__Fn v__ast__Table_find_method_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name);
_option_i64 v__ast__Table_find_enum_field_val(v__ast__Table* t, string name, string field_);
Array_string v__ast__Table_get_enum_field_names(v__ast__Table* t, string name);
Array_i64 v__ast__Table_get_enum_field_vals(v__ast__Table* t, string name);
Array_v__ast__Fn v__ast__Table_get_embed_methods(v__ast__Table* t, v__ast__TypeSymbol* sym);
VV_LOC _result_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name);
bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* struct_, string name);
Array_v__ast__StructField v__ast__Table_struct_fields(v__ast__Table* t, v__ast__TypeSymbol* sym);
_result_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name);
_result_multi_return_v__ast__StructField_Array_v__ast__Type v__ast__Table_find_field_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name);
_result_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name);
void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym);
v__ast__Type v__ast__Table_find_type(v__ast__Table* t, string name);
int v__ast__Table_find_type_idx(v__ast__Table* t, string name);
int v__ast__Table_find_type_idx_fn_scoped(v__ast__Table* t, string name, v__ast__Scope* scope);
_option_v__ast__TypeSymbol_ptr v__ast__Table_find_sym(v__ast__Table* t, string name);
multi_return_ref_v__ast__TypeSymbol_int v__ast__Table_find_sym_and_type_idx(v__ast__Table* t, string name);
v__ast__TypeSymbol* v__ast__Table_sym_by_idx(v__ast__Table* t, int idx);
v__ast__TypeSymbol* v__ast__Table_sym(v__ast__Table* t, v__ast__Type typ);
v__ast__TypeSymbol* v__ast__Table_final_sym(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_final_type(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_get_final_type_name(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__Table_unaliased_type(v__ast__Table* t, v__ast__Type typ);
void v__ast__Table_update_sym_by_idx(v__ast__Table* t, int existing_idx, v__ast__TypeSymbol* sym);
VV_LOC int v__ast__Table_rewrite_already_registered_symbol(v__ast__Table* t, v__ast__TypeSymbol typ, int existing_idx);
int v__ast__Table_register_sym(v__ast__Table* t, v__ast__TypeSymbol sym);
void v__ast__Table_register_enum_decl(v__ast__Table* t, v__ast__EnumDecl enum_decl);
void v__ast__Table_register_anon_struct(v__ast__Table* t, string name, int sym_idx);
void v__ast__Table_register_anon_union(v__ast__Table* t, string name, int sym_idx);
bool v__ast__Table_known_type(v__ast__Table* t, string name);
string v__ast__strip_generic_params(string name);
void v__ast__Table_start_parsing_type(v__ast__Table* t, string type_name);
void v__ast__Table_reset_parsing_type(v__ast__Table* t);
bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type);
string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr);
string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size);
string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
string v__ast__Table_promise_name(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_promise_cname(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type);
string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut);
int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type);
int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type);
int v__ast__Table_find_or_register_promise(v__ast__Table* t, v__ast__Type return_type);
int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type);
int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims);
int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr, bool is_fn_ret);
int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs);
int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, v__ast__Fn f, bool is_anon, bool has_decl);
int v__ast__Table_find_or_register_generic_inst(v__ast__Table* t, v__ast__Type parent_typ, Array_v__ast__Type concrete_types);
int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, string cname, v__ast__Language language);
v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ);
void v__ast__Table_register_fn_generic_types(v__ast__Table* t, string fn_name);
bool v__ast__Table_register_fn_concrete_types(v__ast__Table* t, string fn_name, Array_v__ast__Type types);
bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant, bool is_as);
VV_LOC bool v__ast__Table_sumtype_check_function_variant(v__ast__Table* t, v__ast__SumType parent_info, v__ast__Type variant, bool is_as);
VV_LOC bool v__ast__Table_sumtype_check_variant_in_type(v__ast__Table* t, v__ast__SumType parent_info, v__ast__Type variant, bool is_as);
VV_LOC bool v__ast__Table_sumtype_check_aggregate_variant(v__ast__Table* t, v__ast__Type parent_type, v__ast__Type* aggregate_type, bool is_as);
VV_LOC bool v__ast__Table_sumtype_check_alias_variant(v__ast__Table* t, v__ast__Type parent_type, v__ast__Type alias_type, bool is_as);
bool v__ast__Table_is_sumtype_or_in_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type typ);
bool v__ast__Table_is_interface_var(v__ast__Table* t, v__ast__ScopeObject var);
bool v__ast__Table_is_interface_smartcast(v__ast__Table* t, v__ast__ScopeObject var);
Array_string v__ast__Table_known_type_names(v__ast__Table* t);
bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name);
void v__ast__Table_complete_interface_check(v__ast__Table* t);
v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size);
bool v__ast__Table_does_type_implement_interface(v__ast__Table* t, v__ast__Type typ, v__ast__Type inter_typ);
multi_return_v__ast__Type_string v__ast__Table_convert_generic_static_type_name(v__ast__Table* t, string fn_name, Array_string generic_names, Array_v__ast__Type concrete_types);
_option_v__ast__Type v__ast__Table_convert_generic_type(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type to_types);
VV_LOC void v__ast__generic_names_push_with_filter(Array_string* to_names, Array_string from_names);
Array_string v__ast__Table_generic_type_names(v__ast__Table* t, v__ast__Type generic_type);
v__ast__Type v__ast__Table_unwrap_generic_type(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types);
v__ast__Type v__ast__Table_unwrap_generic_type_ex(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types, bool recheck_concrete_types);
VV_LOC void v__ast__Table_unwrap_method_types(v__ast__Table* t, v__ast__TypeSymbol* ts, Array_string generic_names, Array_v__ast__Type concrete_types, Array_v__ast__Type final_concrete_types);
void v__ast__Table_generic_insts_to_concrete(v__ast__Table* t);
Array_string v__ast__Table_get_real_generic_names(v__ast__Table* t, v__ast__Type typ, Array_string generic_names);
Array_string v__ast__Table_get_generic_names(v__ast__Table* t, Array_v__ast__Type generic_types);
bool v__ast__Table_check_if_elements_need_unwrap(v__ast__Table* t, v__ast__Type root_typ, v__ast__Type typ);
Array_string v__ast__Table_dependent_names_in_expr(v__ast__Table* t, v__ast__Expr expr);
Array_string v__ast__Table_dependent_names_in_stmt(v__ast__Table* t, v__ast__Stmt stmt);
multi_return_int_v__ast__Type v__ast__Table_get_array_dims(v__ast__Table* t, v__ast__Array arr);
multi_return_string_string v__ast__Table_get_trace_fn_name(v__ast__Table* t, v__ast__FnDecl cur_fn, v__ast__CallExpr node);
Array_v__ast__Attr v__ast__Table_get_attrs(v__ast__Table* t, v__ast__TypeSymbol sym);
int v__ast__Table_get_veb_result_type_idx(v__ast__Table* t);
void v__ast__Table_register_vls_info(v__ast__Table* t, string key, v__ast__VlsInfo val);
v__ast__Type v__ast__Table_unwrap(v__ast__Table* t, v__ast__Type typ);
v__ast__Type v__ast__idx_to_type(int idx);
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch);
string v__ast__ShareType_str(v__ast__ShareType t);
_option_v__token__Pos v__ast__TypeInfo_get_name_pos(v__ast__TypeInfo ti);
string v__ast__Type_atomic_typename(v__ast__Type t);
v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic);
v__ast__ShareType v__ast__Type_share(v__ast__Type t);
int v__ast__Type_idx(v__ast__Type t);
bool v__ast__Type_is_void(v__ast__Type t);
bool v__ast__Type_is_full(v__ast__Type t);
int v__ast__Type_nr_muls(v__ast__Type t);
bool v__ast__Type_is_ptr(v__ast__Type t);
bool v__ast__Type_is_pointer(v__ast__Type typ);
bool v__ast__Type_is_voidptr(v__ast__Type typ);
bool v__ast__Type_is_any_kind_of_pointer(v__ast__Type t);
v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls);
v__ast__Type v__ast__Type_ref(v__ast__Type t);
v__ast__Type v__ast__Type_deref(v__ast__Type t);
int v__ast__Type_flags(v__ast__Type t);
bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag);
v__ast__Type v__ast__Type_clear_flags(v__ast__Type t, Array_v__ast__TypeFlag flags);
v__ast__Type v__ast__Type_clear_ref(v__ast__Type t);
v__ast__Type v__ast__Type_clear_option_and_result(v__ast__Type t);
bool v__ast__Type_has_option_or_result(v__ast__Type t);
string v__ast__TypeSymbol_scoped_name(v__ast__TypeSymbol* ts);
string v__ast__TypeSymbol_scoped_cname(v__ast__TypeSymbol* ts);
Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts);
Array_string v__ast__TypeSymbol_dbg(v__ast__TypeSymbol* ts);
VV_LOC void v__ast__TypeSymbol_dbg_common(v__ast__TypeSymbol* ts, Array_string* res);
int v__ast__TypeSymbol_nr_dims(v__ast__TypeSymbol* ts);
string v__ast__Type_str(v__ast__Type t);
string v__ast__Table_type_str(v__ast__Table* t, v__ast__Type typ);
Array_string v__ast__Type_debug(v__ast__Type t);
v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from);
v__ast__Type v__ast__Type_derive_add_muls(v__ast__Type t, v__ast__Type t_from);
v__ast__Type v__ast__Type_idx_type(v__ast__Type t);
v__ast__Type v__ast__new_type(int idx);
v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls);
bool v__ast__Type_is_float(v__ast__Type typ);
bool v__ast__Type_is_int(v__ast__Type typ);
bool v__ast__Type_is_int_valptr(v__ast__Type typ);
bool v__ast__Type_is_float_valptr(v__ast__Type typ);
bool v__ast__Type_is_pure_int(v__ast__Type typ);
bool v__ast__Type_is_pure_float(v__ast__Type typ);
bool v__ast__Type_is_signed(v__ast__Type typ);
bool v__ast__Type_is_unsigned(v__ast__Type typ);
v__ast__Type v__ast__Type_flip_signedness(v__ast__Type typ);
bool v__ast__Type_is_int_literal(v__ast__Type typ);
bool v__ast__Type_is_number(v__ast__Type typ);
bool v__ast__Type_is_string(v__ast__Type typ);
bool v__ast__Type_is_bool(v__ast__Type typ);
VV_LOC Array_v__ast__Type v__ast__new_charptr_types(void);
VV_LOC Array_v__ast__Type v__ast__new_byteptr_types(void);
VV_LOC Array_v__ast__Type v__ast__new_voidptr_types(void);
Array_v__ast__Type v__ast__merge_types(Array_Array_v__ast__Type params);
v__ast__Type v__ast__mktyp(v__ast__Type typ);
v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ);
bool v__ast__Table_type_is_for_pointer_arithmetic(v__ast__Table* t, v__ast__Type typ);
string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t);
string v__ast__TypeSymbol_str_with_correct_nr_muls(v__ast__TypeSymbol* t, int n);
VV_LOC void v__ast__TypeSymbol_no_info_panic(v__ast__TypeSymbol* t, string fname);
v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t);
v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t);
v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t);
v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t);
v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t);
v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t);
v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t);
v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t);
v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_heap(v__ast__TypeSymbol* t);
bool v__ast__ArrayFixed_is_compatible(v__ast__ArrayFixed* t, v__ast__ArrayFixed t2);
bool v__ast__TypeSymbol_is_empty_struct_array(v__ast__TypeSymbol* t);
bool v__ast__Struct_is_empty_struct(v__ast__Struct* t);
bool v__ast__Struct_is_unresolved_generic(v__ast__Struct* t);
bool v__ast__TypeSymbol_is_primitive_fixed_array(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_array_fixed(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_c_struct(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_array_fixed_ret(v__ast__TypeSymbol* t);
void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t);
bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_bool(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t);
multi_return_int_int v__ast__Table_type_size(v__ast__Table* t, v__ast__Type typ);
VV_LOC int v__ast__round_up(int n, int multiple);
string v__ast__Kind_str(v__ast__Kind k);
string Array_v__ast__Kind_str(Array_v__ast__Kind kinds);
string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_type_to_code(v__ast__Table* t, v__ast__Type typ);
string v__ast__Table_clean_generics_type_str(v__ast__Table* t, v__ast__Type typ);
VV_LOC string v__ast__strip_extra_struct_types(string name);
void v__ast__Table_delete_cached_type_to_str(v__ast__Table* t, v__ast__Type typ, int import_aliases_len);
string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases);
VV_LOC string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string original_name, Map_string_string import_aliases);
string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts);
string v__ast__Table_fn_signature_using_aliases(v__ast__Table* t, v__ast__Fn* func, Map_string_string import_aliases, v__ast__FnSignatureOpts opts);
string v__ast__TypeSymbol_symbol_name_except_generic(v__ast__TypeSymbol* t);
string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t);
bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name);
bool v__ast__TypeSymbol_has_method_with_generic_parent(v__ast__TypeSymbol* t, string name);
_option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name);
_option_v__ast__Fn v__ast__TypeSymbol_find_method_with_generic_parent(v__ast__TypeSymbol* t, string name);
bool v__ast__TypeSymbol_is_js_compatible(v__ast__TypeSymbol* t);
multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t);
_option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name);
bool v__ast__TypeSymbol_has_field(v__ast__TypeSymbol* t, string name);
VV_LOC _option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name);
_option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name);
_option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name);
bool v__ast__Interface_has_method(v__ast__Interface* i, string name);
_option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct s, string name);
v__ast__StructField v__ast__Struct_get_field(v__ast__Struct s, string name);
_option_v__ast__StructField v__ast__SumType_find_sum_type_field(v__ast__SumType* s, string name);
string v__ast__Table_find_missing_variants(v__ast__Table* t, v__ast__SumType* s, string field_name);
bool v__ast__Interface_defines_method(v__ast__Interface i, string name);
Array_string v__ast__Interface_get_methods(v__ast__Interface i);
Array_v__ast__Fn v__ast__TypeSymbol_get_methods(v__ast__TypeSymbol* t);
VV_LOC _v_Array_fixed_bool_256 v__scanner__get_digit_table(void);
VV_LOC _v_Array_fixed_bool_256 v__scanner__get_letter_table(void);
_result_v__scanner__Scanner_ptr v__scanner__new_scanner_file(string file_path, i16 file_idx, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_);
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_);
VV_LOC v__scanner__Scanner* v__scanner__new_plain_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_);
void v__scanner__Scanner_free(v__scanner__Scanner* s);
VV_LOC bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s);
void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate);
void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx);
VV_LOC v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len);
VV_LOC v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s);
VV_LOC v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line);
VV_LOC string v__scanner__Scanner_ident_name(v__scanner__Scanner* s);
VV_LOC string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end);
VV_LOC string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s);
VV_LOC string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s);
VV_LOC string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s);
VV_LOC string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s);
VV_LOC string v__scanner__Scanner_ident_number(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s);
VV_LOC v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s);
v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n);
VV_LOC u8 v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n);
v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s);
VV_LOC int v__scanner__Scanner_current_column(v__scanner__Scanner* s);
VV_LOC int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, u8 sym);
string v__scanner__Scanner_ident_string(v__scanner__Scanner* s);
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_h_escape_single(v__scanner__Scanner* s, string str, int idx);
VV_LOC string v__scanner__Scanner_decode_h_escapes(v__scanner__Scanner* s, string sinput, int start, Array_int escapes_pos);
VV_LOC string v__scanner__Scanner_decode_o_escapes(v__scanner__Scanner* s, string sinput, int start, Array_int escapes_pos);
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_u16_escape_single(v__scanner__Scanner* s, string str, int idx);
VV_LOC string v__scanner__Scanner_decode_u16erune(v__scanner__Scanner* s, string str);
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_u32_escape_single(v__scanner__Scanner* s, string str, int idx);
VV_LOC string v__scanner__Scanner_decode_u32erune(v__scanner__Scanner* s, string str);
VV_LOC string v__scanner__trim_slash_line_break(string s);
string v__scanner__Scanner_ident_char(v__scanner__Scanner* s);
VV_LOC bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos);
VV_LOC void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s);
VV_LOC void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s);
v__token__Pos v__scanner__Scanner_current_pos(v__scanner__Scanner* s);
void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_add_error_detail(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_add_error_detail_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos);
VV_LOC string v__scanner__Scanner_eat_details(v__scanner__Scanner* s);
void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_warn_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos);
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg);
void v__scanner__Scanner_error_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos);
void v__scanner__Scanner_prepare_for_new_text(v__scanner__Scanner* s, string text);
v__scanner__Scanner* v__scanner__new_silent_scanner(void);
VV_LOC u8 v__scanner__Scanner_str_quote(v__scanner__Scanner s);
VV_LOC u16 v__scanner__u16_col(int col);
v__ast__Expr v__transformer__Transformer_array_init(v__transformer__Transformer* t, v__ast__ArrayInit* node);
void v__transformer__Transformer_find_new_array_len(v__transformer__Transformer* t, v__ast__AssignStmt node);
VV_LOC bool v__transformer__IndexState_safe_access(v__transformer__IndexState* i, string key, int __v_new);
VV_LOC int v__transformer__IndexState_safe_offset(v__transformer__IndexState* i, string key);
VV_LOC void v__transformer__IndexState_indent(v__transformer__IndexState* i, bool is_function);
VV_LOC void v__transformer__IndexState_unindent(v__transformer__IndexState* i);
v__transformer__Transformer* v__transformer__new_transformer(v__pref__Preferences* pref_);
v__transformer__Transformer* v__transformer__new_transformer_with_table(v__ast__Table* table, v__pref__Preferences* pref_);
void v__transformer__Transformer_transform_files(v__transformer__Transformer* t, Array_v__ast__File_ptr ast_files);
void v__transformer__Transformer_transform(v__transformer__Transformer* t, v__ast__File* ast_file);
void v__transformer__Transformer_find_new_range(v__transformer__Transformer* t, v__ast__AssignStmt node);
void v__transformer__Transformer_find_mut_self_assign(v__transformer__Transformer* t, v__ast__AssignStmt node);
void v__transformer__Transformer_check_safe_array(v__transformer__Transformer* t, v__ast__IndexExpr* node);
v__ast__Stmt v__transformer__Transformer_stmt(v__transformer__Transformer* t, v__ast__Stmt* node);
void v__transformer__Transformer_comptime_for(v__transformer__Transformer* t, v__ast__ComptimeFor* node);
void v__transformer__Transformer_assign_stmt(v__transformer__Transformer* t, v__ast__AssignStmt* node);
void v__transformer__Transformer_const_decl(v__transformer__Transformer* t, v__ast__ConstDecl* node);
void v__transformer__Transformer_enum_decl(v__transformer__Transformer* t, v__ast__EnumDecl* node);
void v__transformer__Transformer_global_decl(v__transformer__Transformer* t, v__ast__GlobalDecl* node);
void v__transformer__Transformer_interface_decl(v__transformer__Transformer* t, v__ast__InterfaceDecl* node);
void v__transformer__Transformer_struct_decl(v__transformer__Transformer* t, v__ast__StructDecl* node);
void v__transformer__Transformer_assert_stmt(v__transformer__Transformer* t, v__ast__AssertStmt* node);
v__ast__Expr v__transformer__Transformer_expr_stmt_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* node);
v__ast__Expr v__transformer__Transformer_expr_stmt_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* node);
void v__transformer__Transformer_for_c_stmt(v__transformer__Transformer* t, v__ast__ForCStmt* node);
v__ast__Stmt v__transformer__Transformer_for_stmt(v__transformer__Transformer* t, v__ast__ForStmt* node);
v__ast__Expr v__transformer__Transformer_expr(v__transformer__Transformer* t, v__ast__Expr* node);
void v__transformer__Transformer_call_expr(v__transformer__Transformer* t, v__ast__CallExpr* node);
VV_LOC void v__transformer__Transformer_trans_const_value_to_literal(v__transformer__Transformer* t, v__ast__Expr* expr);
v__ast__Expr v__transformer__Transformer_infix_expr(v__transformer__Transformer* t, v__ast__InfixExpr* node);
v__ast__Expr v__transformer__Transformer_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* node);
v__ast__Expr v__transformer__Transformer_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* node);
v__ast__Expr v__transformer__Transformer_sql_expr(v__transformer__Transformer* t, v__ast__SqlExpr* node);
void v__transformer__Transformer_fn_decl(v__transformer__Transformer* t, v__ast__FnDecl* node);
void v__transformer__Transformer_fn_decl_trace_calls(v__transformer__Transformer* t, v__ast__FnDecl* node);
bool v__transformer__Transformer_simplify_nested_interpolation_in_sb(v__transformer__Transformer* t, v__ast__Stmt* onode, v__ast__CallExpr* nexpr, v__ast__Type ntype);
VV_LOC v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOC v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p);
VV_LOC v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p);
VV_LOC Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output);
VV_LOC v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p);
VV_LOC _result_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_string names, v__ast__Expr val);
VV_LOC bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val);
VV_LOC v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left);
VV_LOC bool v__parser__expr_has_block_or(v__ast__Expr expr);
VV_LOC v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p, bool is_at);
VV_LOC bool v__parser__Parser_is_attributes(v__parser__Parser* p);
VV_LOC void v__parser__Parser_attributes(v__parser__Parser* p);
VV_LOC void v__parser__Parser_check_deprecated_attributes(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_fn_type_decl(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_has_prev_newline(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_has_prev_line_comment_or_label(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_array_type(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_following_concrete_types(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_generic_struct_init(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t);
VV_LOC bool v__parser__Parser_is_generic_call(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_generic_cast(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_generic_name(v__parser__Parser* p);
void v__parser__Parser_codegen(v__parser__Parser* p, string code);
VV_LOC void v__parser__Parser_handle_codegen_for_file(v__parser__Parser* p);
VV_LOC void v__parser__handle_codegen_for_multiple_files(Array_v__ast__File_ptr* files);
VV_LOC v__ast__ComptimeType v__parser__Parser_parse_comptime_type(v__parser__Parser* p);
VV_LOC v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p);
VV_LOC v__ast__ComptimeCall v__parser__Parser_comptime_call(v__parser__Parser* p);
VV_LOC v__ast__ComptimeFor v__parser__Parser_comptime_for(v__parser__Parser* p);
VV_LOC v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left);
VV_LOC v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p, bool is_option, v__ast__Type alias_array_type);
VV_LOC v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p);
VV_LOC void v__parser__Parser_scope_register_index(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_handle_index_variable(v__parser__Parser* p, v__ast__Expr* default_expr);
VV_LOC v__ast__EnumVal v__parser__Parser_enum_val_expr(v__parser__Parser* p, string mod);
VV_LOC v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p);
VV_LOC v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p);
VV_LOC _result_void v__parser__Parser_check_expr_level(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_expr_no_value(v__parser__Parser* p, int precedence);
VV_LOC v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence);
VV_LOC _result_v__ast__Expr v__parser__Parser_check_expr(v__parser__Parser* p, int precedence);
VV_LOC v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident);
VV_LOC v__ast__OrExpr v__parser__Parser_gen_or_block(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOC v__ast__Expr v__parser__Parser_prefix_expr(v__parser__Parser* p);
VV_LOC void v__parser__Parser_recast_as_pointer(v__parser__Parser* p, v__ast__CastExpr* cast_expr, v__token__Pos pos);
VV_LOC void v__parser__Parser_prefix_inc_dec_error(v__parser__Parser* p);
VV_LOC void v__parser__Parser_process_custom_orm_operators(v__parser__Parser* p);
VV_LOC _option_v__ast__LambdaExpr v__parser__Parser_lambda_expr(v__parser__Parser* p);
VV_LOC v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod);
VV_LOC v__ast__CallKind v__parser__Parser_call_kind(v__parser__Parser* p, string fn_name);
VV_LOC Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p);
VV_LOC v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p);
VV_LOC _result_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec);
VV_LOC v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p);
VV_LOC multi_return_Array_v__ast__Param_bool_bool_bool v__parser__Parser_fn_params(v__parser__Parser* p);
VV_LOC v__ast__SpawnExpr v__parser__Parser_spawn_expr(v__parser__Parser* p);
VV_LOC v__ast__GoExpr v__parser__Parser_go_expr(v__parser__Parser* p);
VV_LOC Array_v__ast__Param v__parser__Parser_closure_vars(v__parser__Parser* p);
VV_LOC void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos);
VV_LOC void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos);
VV_LOC void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos);
VV_LOC v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p);
VV_LOC v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime, bool is_expr);
VV_LOC bool v__parser__Parser_is_only_array_type(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_match_sumtype_type(v__parser__Parser* p);
VV_LOC _result_string v__parser__Parser_resolve_at_expr(v__parser__Parser* p, v__ast__AtExpr expr);
VV_LOC v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p, bool is_comptime, bool is_expr);
VV_LOC v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_comptime_if_cond(v__parser__Parser* p, v__ast__Expr* cond);
VV_LOC v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p);
VV_LOC void v__parser__Parser_language_not_allowed_error(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos);
VV_LOC void v__parser__Parser_language_not_allowed_warning(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos);
VV_LOC void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos);
VV_LOC v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s);
VV_LOC void v__parser__Parser_warn(v__parser__Parser* p, string s);
VV_LOC v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Pos pos);
VV_LOC void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error __v_error);
VV_LOC void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Pos pos);
VV_LOC void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Pos pos);
VV_LOC v__ast__NodeError v__parser__Parser_unexpected(v__parser__Parser* p, v__parser__ParamsForUnexpected params);
VV_LOC v__ast__NodeError v__parser__Parser_unexpected_with_pos(v__parser__Parser* p, v__token__Pos pos, v__parser__ParamsForUnexpected params);
VV_LOC void v__parser__Parser_chan_type_error(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_known_import(v__parser__Parser* p, string mod);
VV_LOC string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name);
VV_LOC bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias);
VV_LOC void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias);
VV_LOC void v__parser__Parser_register_used_import_for_symbol_name(v__parser__Parser* p, string sym_name);
VV_LOC void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias);
VV_LOC void v__parser__Parser_register_implied_import(v__parser__Parser* p, string alias);
VV_LOC void v__parser__Parser_check_unused_imports(v__parser__Parser* p);
VV_LOC v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p);
VV_LOC v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p);
VV_LOC void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent);
VV_LOC void v__parser__Parser_rebuild_imported_symbols_matcher(v__parser__Parser* p, string name);
VV_LOC bool v__parser__Parser_is_imported_symbol(v__parser__Parser* p, string name);
VV_LOC v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p);
VV_LOC v__ast__JoinClause v__parser__Parser_parse_sql_join_clause(v__parser__Parser* p);
VV_LOC v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p);
VV_LOC v__ast__OrExpr v__parser__Parser_parse_sql_or_block(v__parser__Parser* p);
VV_LOC v__ast__SqlStmtLine v__parser__Parser_parse_sql_stmt_line(v__parser__Parser* p);
VV_LOC _option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name);
VV_LOC v__ast__Expr v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(v__parser__Parser* p, v__ast__Expr* expr, Array_string unacceptable_variable_names);
VV_LOC multi_return_int_bool v__parser__Parser_eval_array_fixed_sizes(v__parser__Parser* p, v__ast__Expr* size_expr);
VV_LOC v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p, v__token__Kind expecting, bool is_option);
VV_LOC v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name, Array_v__ast__Type generic_types);
VV_LOC v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut);
VV_LOC v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_inline_sum_type(v__parser__Parser* p);
VV_LOC Array_v__ast__TypeNode v__parser__Parser_parse_sum_type_variants(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p);
VV_LOC v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot, bool is_option);
VV_LOC v__ast__Type v__parser__Parser_find_type_or_add_placeholder(v__parser__Parser* p, string name, v__ast__Language language);
VV_LOC v__ast__Type v__parser__Parser_parse_generic_type(v__parser__Parser* p, string name);
VV_LOC v__ast__Type v__parser__Parser_parse_generic_inst_type(v__parser__Parser* p, string name, v__token__Pos name_pos);
VV_LOC _result_Array_string v__parser__Parser_types_to_names(v__parser__Parser* p, Array_v__ast__Type types, v__token__Pos pos, string error_label);
v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope);
v__ast__File* v__parser__parse_comptime(string tmpl_path, string text, v__ast__Table* table, v__pref__Preferences* pref_, v__ast__Scope* scope);
v__ast__File* v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_);
void v__parser__Parser_free(v__parser__Parser* p);
VV_LOC void v__parser__Parser_free_scanner(v__parser__Parser* p);
void v__parser__Parser_set_path(v__parser__Parser* p, string path);
VV_LOC bool v__parser__should_skip_vls_file(v__pref__Preferences* pref_, string path);
v__ast__File* v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_);
v__ast__File* v__parser__Parser_parse(v__parser__Parser* p);
Array_v__ast__File_ptr v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref_);
VV_LOC void v__parser__Parser_init_parse_fns(v__parser__Parser* p);
VV_LOC void v__parser__Parser_read_first_token(v__parser__Parser* p);
VV_LOC v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n);
VV_LOC v__token__Token v__parser__Parser_peek_token_after_var_list(v__parser__Parser* p);
VV_LOC void v__parser__Parser_open_scope(v__parser__Parser* p);
VV_LOC void v__parser__Parser_close_scope(v__parser__Parser* p);
VV_LOC Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_is_in_top_level_comptime(v__parser__Parser* p, bool inside_assign_rhs);
VV_LOC Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level);
VV_LOC void v__parser__Parser_mark_last_call_return_as_used(v__parser__Parser* p, v__ast__Stmt* last_stmt);
VV_LOC void v__parser__Parser_next(v__parser__Parser* p);
VV_LOC void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected);
VV_LOC string v__parser__Parser_check_js_name(v__parser__Parser* p);
VV_LOC bool v__parser__is_ident_name(string name);
VV_LOC string v__parser__Parser_check_name(v__parser__Parser* p);
VV_LOC v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p);
VV_LOC bool v__parser__comptime_if_expr_contains_top_stmt(v__ast__IfExpr if_expr);
VV_LOC v__ast__Stmt v__parser__Parser_other_stmts(v__parser__Parser* p, v__ast__Stmt cur_stmt);
VV_LOC v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p);
VV_LOC v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p);
VV_LOC v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p);
VV_LOC Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg);
VV_LOC void v__parser__Parser_goto_eof(v__parser__Parser* p);
VV_LOC v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level);
VV_LOC v__ast__DebuggerStmt v__parser__Parser_dbg_stmt(v__parser__Parser* p);
VV_LOC v__ast__SemicolonStmt v__parser__Parser_semicolon_stmt(v__parser__Parser* p);
VV_LOC Array_v__ast__Expr v__parser__Parser_expr_list(v__parser__Parser* p, bool expect_value);
VV_LOC v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level);
VV_LOC v__ast__Ident v__parser__Parser_ident(v__parser__Parser* p, v__ast__Language language);
VV_LOC v__ast__Type v__parser__Parser_alias_array_type(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p);
VV_LOC multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope v__parser__Parser_or_block(v__parser__Parser* p, v__parser__OrBlockErrVarMode err_var_mode);
VV_LOC v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left, bool is_gated);
VV_LOC v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left);
VV_LOC multi_return_Array_v__ast__Type_Array_string v__parser__Parser_parse_generic_types(v__parser__Parser* p);
VV_LOC Array_v__ast__Type v__parser__Parser_parse_concrete_types(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p);
VV_LOC v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p);
VV_LOC v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p);
VV_LOC v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p);
VV_LOC string v__parser__source_name(string name);
VV_LOC v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p);
VV_LOC v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p);
VV_LOC void v__parser__Parser_top_level_statement_start(v__parser__Parser* p);
VV_LOC void v__parser__Parser_top_level_statement_end(v__parser__Parser* p);
VV_LOC void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p);
VV_LOC v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p);
VV_LOC bool v__parser__Parser_disallow_declarations_in_script_mode(v__parser__Parser* p);
VV_LOC void v__parser__Parser_add_defer_var(v__parser__Parser* p, v__ast__Ident ident);
VV_LOC void v__parser__Parser_skip_scope(v__parser__Parser* p);
VV_LOC string v__parser__Parser_keyword_comments_to_string(v__parser__Parser* p, string keyword, Array_v__ast__Comment comments);
VV_LOC string v__parser__Parser_comments_to_string(v__parser__Parser* p, Array_v__ast__Comment comments);
VV_LOC v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p, bool is_anon);
VV_LOC v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, string typ_str, v__ast__StructInitKind kind, bool is_option);
VV_LOC v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p);
VV_LOC void v__parser__State_update(v__parser__State* state, string line);
VV_LOC bool v__parser__is_html_open_tag(string name, string s);
VV_LOC string v__parser__insert_template_code(string fn_name, string tmpl_str_start, string line);
VV_LOC string v__parser__IncludeError_msg(v__parser__IncludeError err);
VV_LOC int v__parser__IncludeError_line_nr(v__parser__IncludeError err);
VV_LOC int v__parser__IncludeError_pos(v__parser__IncludeError err);
VV_LOC string v__parser__IncludeError_calling_file(v__parser__IncludeError err);
VV_LOC u16 v__parser__IncludeError_col(v__parser__IncludeError err);
VV_LOC _result_Array_string v__parser__Parser_process_includes(v__parser__Parser* p, string calling_file, int line_number, string line, v__parser__DependencyCache* dc);
string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name);
_result_void vphp__compiler__Compiler_generate_all(vphp__compiler__Compiler* c);
VV_LOC _result_void vphp__compiler__Compiler_generate_c(vphp__compiler__Compiler* c);
VV_LOC _result_void vphp__compiler__Compiler_generate_v_glue(vphp__compiler__Compiler* c);
VV_LOC _result_void vphp__compiler__Compiler_generate_h(vphp__compiler__Compiler* c);
VV_LOC vphp__compiler__PhpClassRepr* vphp__compiler__new_class_repr(void);
VV_LOC bool vphp__compiler__PhpClassRepr_parse(vphp__compiler__PhpClassRepr* r, v__ast__Stmt stmt, v__ast__Table* table);
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_h(vphp__compiler__PhpClassRepr r);
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_c(vphp__compiler__PhpClassRepr r);
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_minit(vphp__compiler__PhpClassRepr r);
void vphp__compiler__PhpClassRepr_add_method(vphp__compiler__PhpClassRepr* r, v__ast__FnDecl stmt, v__ast__Table* table);
void vphp__compiler__PhpClassRepr_add_static_method(vphp__compiler__PhpClassRepr* r, v__ast__FnDecl stmt, v__ast__Table* table, string method_name);
string vphp__compiler__PhpClassRepr_gen_v_property_mapper(vphp__compiler__PhpClassRepr r);
string vphp__compiler__PhpClassRepr_gen_v_sync_mapper(vphp__compiler__PhpClassRepr r);
VV_LOC vphp__compiler__PhpConstRepr* vphp__compiler__new_const_repr(void);
VV_LOC bool vphp__compiler__PhpConstRepr_parse(vphp__compiler__PhpConstRepr* r, v__ast__Stmt stmt, v__ast__Table* table);
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_h(vphp__compiler__PhpConstRepr r);
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_c(vphp__compiler__PhpConstRepr r);
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_minit(vphp__compiler__PhpConstRepr r);
vphp__compiler__PhpFuncRepr* vphp__compiler__new_func_repr(void);
VV_LOC bool vphp__compiler__PhpFuncRepr_parse(vphp__compiler__PhpFuncRepr* r, v__ast__Stmt stmt, v__ast__Table* table);
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_h(vphp__compiler__PhpFuncRepr r);
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_c(vphp__compiler__PhpFuncRepr f);
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_minit(vphp__compiler__PhpFuncRepr r);
vphp__compiler__Compiler vphp__compiler__new(string target_file);
_result_void vphp__compiler__Compiler_compile(vphp__compiler__Compiler* c);
VV_LOC void vphp__compiler__Compiler_set_ext_name(vphp__compiler__Compiler* c, v__ast__File* file_ast);
vphp__compiler__PhpTaskRepr* vphp__compiler__new_task_repr(void);
VV_LOC bool vphp__compiler__PhpTaskRepr_parse(vphp__compiler__PhpTaskRepr* r, v__ast__Stmt stmt, v__ast__Table* table);
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_h(vphp__compiler__PhpTaskRepr r);
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_c(vphp__compiler__PhpTaskRepr r);
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_minit(vphp__compiler__PhpTaskRepr r);
string vphp__compiler__PhpTaskRepr_gen_v_glue(vphp__compiler__PhpTaskRepr r);
VV_LOC void main__vphp_task_auto_startup(void);
VV_LOC vphp__ITask anon_fn_e0873e5963f3179a_40_string__vphp__ITask_154(string s);
VV_EXP void vphp_task_auto_startup(void); // exported fn main.vphp_task_auto_startup
void main__article_get_prop(voidptr ptr, char* name_ptr, int name_len, zval* rv);
VV_EXP void Article_get_prop(voidptr ptr, char* name_ptr, int name_len, zval* rv); // exported fn main.article_get_prop
void main__article_sync_props(voidptr ptr, zval* zv);
VV_EXP void Article_sync_props(voidptr ptr, zval* zv); // exported fn main.article_sync_props
VV_LOC void main__main(void);
VV_LOC void main__v_reverse_string(zend_execute_data* ex, zval* retval);
VV_EXP void v_reverse_string(zend_execute_data* ex, zval* retval); // exported fn main.v_reverse_string
VV_LOC void main__v_logic_main(zend_execute_data* ex, zval* retval);
VV_EXP void v_logic_main(zend_execute_data* ex, zval* retval); // exported fn main.v_logic_main
VV_LOC void main__v_add(zend_execute_data* ex, zval* retval);
VV_EXP void v_add(zend_execute_data* ex, zval* retval); // exported fn main.v_add
VV_LOC void main__v_greet(zend_execute_data* ex, zval* retval);
VV_EXP void v_greet(zend_execute_data* ex, zval* retval); // exported fn main.v_greet
VV_LOC void main__v_process_list(zend_execute_data* ex, zval* retval);
VV_EXP void v_process_list(zend_execute_data* ex, zval* retval); // exported fn main.v_process_list
VV_LOC void main__v_test_map(zend_execute_data* ex, zval* retval);
VV_EXP void v_test_map(zend_execute_data* ex, zval* retval); // exported fn main.v_test_map
VV_LOC void main__v_get_config(zend_execute_data* ex, zval* retval);
VV_EXP void v_get_config(zend_execute_data* ex, zval* retval); // exported fn main.v_get_config
VV_LOC void main__v_get_user(zend_execute_data* ex, zval* retval);
VV_EXP void v_get_user(zend_execute_data* ex, zval* retval); // exported fn main.v_get_user
VV_LOC void main__v_call_back(zend_execute_data* ex, zval* retval);
VV_EXP void v_call_back(zend_execute_data* ex, zval* retval); // exported fn main.v_call_back
VV_LOC void main__v_new_coach(zend_execute_data* ex, zval* retval);
VV_EXP void v_new_coach(zend_execute_data* ex, zval* retval); // exported fn main.v_new_coach
VV_LOC void main__v_new_db(zend_execute_data* ex, zval* retval);
VV_EXP void v_new_db(zend_execute_data* ex, zval* retval); // exported fn main.v_new_db
VV_LOC void main__v_check_res(zend_execute_data* ex, zval* retval);
VV_EXP void v_check_res(zend_execute_data* ex, zval* retval); // exported fn main.v_check_res
VV_LOC void main__v_analyze_fitness_data(zend_execute_data* ex, zval* retval);
VV_EXP void v_analyze_fitness_data(zend_execute_data* ex, zval* retval); // exported fn main.v_analyze_fitness_data
VV_LOC void main__v_get_alerts(zend_execute_data* ex, zval* retval);
VV_EXP void v_get_alerts(zend_execute_data* ex, zval* retval); // exported fn main.v_get_alerts
VV_LOC void main__v_complex_test(zend_execute_data* ex, zval* retval);
VV_EXP void v_complex_test(zend_execute_data* ex, zval* retval); // exported fn main.v_complex_test
VV_LOC void main__v_analyze_user_object(zend_execute_data* ex, zval* retval);
VV_EXP void v_analyze_user_object(zend_execute_data* ex, zval* retval); // exported fn main.v_analyze_user_object
VV_LOC void main__v_trigger_user_action(zend_execute_data* ex, zval* retval);
VV_EXP void v_trigger_user_action(zend_execute_data* ex, zval* retval); // exported fn main.v_trigger_user_action
VV_LOC void main__v_call_php_closure(zend_execute_data* ex, zval* retval);
VV_EXP void v_call_php_closure(zend_execute_data* ex, zval* retval); // exported fn main.v_call_php_closure
VV_LOC Array_f64 main__AnalyzeTask_run(main__AnalyzeTask t);
main__Article* main__Article__static__create(vphp__Context ctx);
VV_EXP main__Article* Article_create(vphp__Context ctx); // exported fn main.Article__static__create
bool main__Article_save(main__Article* a, vphp__Context ctx);
VV_EXP bool Article_save(main__Article* a, vphp__Context ctx); // exported fn save
static string time__FormatTime_str(time__FormatTime it);
static string time__FormatDate_str(time__FormatDate it);
static string v__pref__Arch_str(v__pref__Arch it);
static string v__pref__Backend_str(v__pref__Backend it);
static string v__ast__AttrKind_str(v__ast__AttrKind it);
static string Array_v__ast__Expr_str(Array_v__ast__Expr a);
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count);
static string v__ast__CallExpr_str(v__ast__CallExpr it);
static string indent_v__ast__CallExpr_str(v__ast__CallExpr it, int indent_count);
static string v__ast__TypeInfo_str(v__ast__TypeInfo x);
static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count);
static string v__ast__Fn_str(v__ast__Fn it);
static string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count);
static string v__ast__Language_str(v__ast__Language it);
static string v__pref__CompilerType_str(v__pref__CompilerType it);
static string v__ast__AtExpr_str(v__ast__AtExpr it);
static string indent_v__ast__AtExpr_str(v__ast__AtExpr it, int indent_count);
static string v__ast__Ident_str(v__ast__Ident it);
static string indent_v__ast__Ident_str(v__ast__Ident it, int indent_count);
static string v__ast__StringLiteral_str(v__ast__StringLiteral it);
static string indent_v__ast__StringLiteral_str(v__ast__StringLiteral it, int indent_count);
static string Array_v__ast__Type_str(Array_v__ast__Type a);
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count);
static string v__ast__OrExpr_str(v__ast__OrExpr it);
static string indent_v__ast__OrExpr_str(v__ast__OrExpr it, int indent_count);
static string Array_v__ast__CallArg_str(Array_v__ast__CallArg a);
static string indent_Array_v__ast__CallArg_str(Array_v__ast__CallArg a, int indent_count);
static string Array_v__ast__Comment_str(Array_v__ast__Comment a);
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count);
static string v__token__Pos_str(v__token__Pos it);
static string indent_v__token__Pos_str(v__token__Pos it, int indent_count);
static string v__ast__CallKind_str(v__ast__CallKind it);
static string v__ast__UnknownTypeInfo_str(v__ast__UnknownTypeInfo it);
static string indent_v__ast__UnknownTypeInfo_str(v__ast__UnknownTypeInfo it, int indent_count);
static string v__ast__Aggregate_str(v__ast__Aggregate it);
static string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count);
static string v__ast__Alias_str(v__ast__Alias it);
static string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count);
static string v__ast__Array_str(v__ast__Array it);
static string indent_v__ast__Array_str(v__ast__Array it, int indent_count);
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it);
static string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count);
static string v__ast__Chan_str(v__ast__Chan it);
static string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count);
static string v__ast__Enum_str(v__ast__Enum it);
static string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count);
static string v__ast__FnType_str(v__ast__FnType it);
static string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count);
static string v__ast__GenericInst_str(v__ast__GenericInst it);
static string indent_v__ast__GenericInst_str(v__ast__GenericInst it, int indent_count);
static string v__ast__Interface_str(v__ast__Interface it);
static string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count);
static string v__ast__Map_str(v__ast__Map it);
static string indent_v__ast__Map_str(v__ast__Map it, int indent_count);
static string v__ast__MultiReturn_str(v__ast__MultiReturn it);
static string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count);
static string v__ast__Struct_str(v__ast__Struct it);
static string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count);
static string v__ast__SumType_str(v__ast__SumType it);
static string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count);
static string v__ast__Thread_str(v__ast__Thread it);
static string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count);
static string Array_v__ast__Param_str(Array_v__ast__Param a);
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count);
static string Array_v__ast__Attr_str(Array_v__ast__Attr a);
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count);
static string v__token__AtKind_str(v__token__AtKind it);
static string v__ast__ScopeObject_str(v__ast__ScopeObject x);
static string indent_v__ast__ScopeObject_str(v__ast__ScopeObject x, int indent_count);
static string v__ast__IdentInfo_str(v__ast__IdentInfo x);
static string indent_v__ast__IdentInfo_str(v__ast__IdentInfo x, int indent_count);
static string v__ast__IdentKind_str(v__ast__IdentKind it);
static string v__ast__OrKind_str(v__ast__OrKind it);
static string Array_v__ast__Stmt_str(Array_v__ast__Stmt a);
static string indent_Array_v__ast__Stmt_str(Array_v__ast__Stmt a, int indent_count);
static string v__ast__Comment_str(v__ast__Comment it);
static string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count);
static string Array_v__ast__StructField_str(Array_v__ast__StructField a);
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count);
static string Map_string_Array_v__ast__Attr_str(Map_string_Array_v__ast__Attr m);
static string indent_Map_string_Array_v__ast__Attr_str(Map_string_Array_v__ast__Attr m, int indent_count);
static string Array_v__ast__Fn_str(Array_v__ast__Fn a);
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count);
static string Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m);
static string indent_Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m, int indent_count);
static string v__ast__Param_str(v__ast__Param it);
static string indent_v__ast__Param_str(v__ast__Param it, int indent_count);
static string v__ast__EmptyScopeObject_str(v__ast__EmptyScopeObject it);
static string indent_v__ast__EmptyScopeObject_str(v__ast__EmptyScopeObject it, int indent_count);
static string v__ast__AsmRegister_str(v__ast__AsmRegister it);
static string indent_v__ast__AsmRegister_str(v__ast__AsmRegister it, int indent_count);
static string v__ast__ConstField_str(v__ast__ConstField it);
static string indent_v__ast__ConstField_str(v__ast__ConstField it, int indent_count);
static string v__ast__GlobalField_str(v__ast__GlobalField it);
static string indent_v__ast__GlobalField_str(v__ast__GlobalField it, int indent_count);
static string v__ast__Var_str(v__ast__Var it);
static string indent_v__ast__Var_str(v__ast__Var it, int indent_count);
static string v__ast__IdentFn_str(v__ast__IdentFn it);
static string indent_v__ast__IdentFn_str(v__ast__IdentFn it, int indent_count);
static string v__ast__IdentVar_str(v__ast__IdentVar it);
static string indent_v__ast__IdentVar_str(v__ast__IdentVar it, int indent_count);
static string v__ast__StructField_str(v__ast__StructField it);
static string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count);
static string v__ast__ComptTimeConstValue_str(v__ast__ComptTimeConstValue x);
static string indent_v__ast__ComptTimeConstValue_str(v__ast__ComptTimeConstValue x, int indent_count);
static string v__ast__ComptimeVarKind_str(v__ast__ComptimeVarKind it);
static string v__ast__StructDecl_str(v__ast__StructDecl it);
static string indent_v__ast__StructDecl_str(v__ast__StructDecl it, int indent_count);
static string v__ast__EmptyExpr_str(v__ast__EmptyExpr it);
static string indent_v__ast__EmptyExpr_str(v__ast__EmptyExpr it, int indent_count);
static string Array_v__ast__TypeNode_str(Array_v__ast__TypeNode a);
static string indent_Array_v__ast__TypeNode_str(Array_v__ast__TypeNode a, int indent_count);
static string Array_v__ast__Embed_str(Array_v__ast__Embed a);
static string indent_Array_v__ast__Embed_str(Array_v__ast__Embed a, int indent_count);
static string v__ast__TypeNode_str(v__ast__TypeNode it);
static string indent_v__ast__TypeNode_str(v__ast__TypeNode it, int indent_count);
static string v__ast__Embed_str(v__ast__Embed it);
static string indent_v__ast__Embed_str(v__ast__Embed it, int indent_count);
v__ast__Expr v__ast__EmptyExpr_to_sumtype_v__ast__Expr(v__ast__EmptyExpr* x, bool is_mut);
v__ast__Stmt v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(v__ast__EmptyStmt* x, bool is_mut);
v__ast__Node v__ast__EmptyNode_to_sumtype_v__ast__Node(v__ast__EmptyNode* x, bool is_mut);
v__ast__ScopeObject v__ast__EmptyScopeObject_to_sumtype_v__ast__ScopeObject(v__ast__EmptyScopeObject* x, bool is_mut);
v__ast__ComptTimeConstValue v__ast__EmptyExpr_to_sumtype_v__ast__ComptTimeConstValue(v__ast__EmptyExpr* x, bool is_mut);
v__ast__Node v__ast__Expr_to_sumtype_v__ast__Node(v__ast__Expr* x, bool is_mut);
v__ast__Expr v__ast__Ident_to_sumtype_v__ast__Expr(v__ast__Ident* x, bool is_mut);
v__ast__Node v__ast__Stmt_to_sumtype_v__ast__Node(v__ast__Stmt* x, bool is_mut);
v__ast__Node v__ast__StructInitField_to_sumtype_v__ast__Node(v__ast__StructInitField* x, bool is_mut);
v__ast__Stmt v__ast__FnDecl_to_sumtype_v__ast__Stmt(v__ast__FnDecl* x, bool is_mut);
v__ast__Node v__ast__CallArg_to_sumtype_v__ast__Node(v__ast__CallArg* x, bool is_mut);
v__ast__Expr v__ast__OrExpr_to_sumtype_v__ast__Expr(v__ast__OrExpr* x, bool is_mut);
v__ast__Node v__ast__IfBranch_to_sumtype_v__ast__Node(v__ast__IfBranch* x, bool is_mut);
v__ast__Node v__ast__MatchBranch_to_sumtype_v__ast__Node(v__ast__MatchBranch* x, bool is_mut);
v__ast__Node v__ast__SelectBranch_to_sumtype_v__ast__Node(v__ast__SelectBranch* x, bool is_mut);
v__ast__Node v__ast__StructField_to_sumtype_v__ast__Node(v__ast__StructField* x, bool is_mut);
v__ast__Node v__ast__GlobalField_to_sumtype_v__ast__Node(v__ast__GlobalField* x, bool is_mut);
v__ast__Node v__ast__ConstField_to_sumtype_v__ast__Node(v__ast__ConstField* x, bool is_mut);
v__ast__Node v__ast__EnumField_to_sumtype_v__ast__Node(v__ast__EnumField* x, bool is_mut);
v__ast__Node v__ast__Param_to_sumtype_v__ast__Node(v__ast__Param* x, bool is_mut);
v__ast__Expr v__ast__TypeNode_to_sumtype_v__ast__Expr(v__ast__TypeNode* x, bool is_mut);
v__ast__ScopeObject v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(v__ast__AsmRegister* x, bool is_mut);
v__ast__Expr v__ast__ArrayInit_to_sumtype_v__ast__Expr(v__ast__ArrayInit* x, bool is_mut);
v__ast__Expr v__ast__StringLiteral_to_sumtype_v__ast__Expr(v__ast__StringLiteral* x, bool is_mut);
v__ast__Expr v__ast__MapInit_to_sumtype_v__ast__Expr(v__ast__MapInit* x, bool is_mut);
v__ast__Expr v__ast__StructInit_to_sumtype_v__ast__Expr(v__ast__StructInit* x, bool is_mut);
v__ast__TypeInfo v__ast__SumType_to_sumtype_v__ast__TypeInfo(v__ast__SumType* x, bool is_mut);
v__ast__TypeInfo v__ast__Chan_to_sumtype_v__ast__TypeInfo(v__ast__Chan* x, bool is_mut);
v__ast__TypeInfo v__ast__Map_to_sumtype_v__ast__TypeInfo(v__ast__Map* x, bool is_mut);
v__ast__TypeInfo v__ast__Thread_to_sumtype_v__ast__TypeInfo(v__ast__Thread* x, bool is_mut);
v__ast__TypeInfo v__ast__Struct_to_sumtype_v__ast__TypeInfo(v__ast__Struct* x, bool is_mut);
v__ast__TypeInfo v__ast__Array_to_sumtype_v__ast__TypeInfo(v__ast__Array* x, bool is_mut);
v__ast__TypeInfo v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(v__ast__ArrayFixed* x, bool is_mut);
v__ast__TypeInfo v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(v__ast__MultiReturn* x, bool is_mut);
v__ast__TypeInfo v__ast__FnType_to_sumtype_v__ast__TypeInfo(v__ast__FnType* x, bool is_mut);
v__ast__TypeInfo v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(v__ast__GenericInst* x, bool is_mut);
v__ast__Expr v__ast__None_to_sumtype_v__ast__Expr(v__ast__None* x, bool is_mut);
v__ast__TypeInfo v__ast__Interface_to_sumtype_v__ast__TypeInfo(v__ast__Interface* x, bool is_mut);
v__ast__Expr v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(v__ast__IntegerLiteral* x, bool is_mut);
v__ast__Expr v__ast__SizeOf_to_sumtype_v__ast__Expr(v__ast__SizeOf* x, bool is_mut);
v__ast__Expr v__ast__CastExpr_to_sumtype_v__ast__Expr(v__ast__CastExpr* x, bool is_mut);
v__ast__Expr v__ast__CallExpr_to_sumtype_v__ast__Expr(v__ast__CallExpr* x, bool is_mut);
v__ast__Expr v__ast__IfExpr_to_sumtype_v__ast__Expr(v__ast__IfExpr* x, bool is_mut);
v__ast__Expr v__ast__BoolLiteral_to_sumtype_v__ast__Expr(v__ast__BoolLiteral* x, bool is_mut);
v__ast__Expr v__ast__FloatLiteral_to_sumtype_v__ast__Expr(v__ast__FloatLiteral* x, bool is_mut);
v__ast__Expr v__ast__MatchExpr_to_sumtype_v__ast__Expr(v__ast__MatchExpr* x, bool is_mut);
v__ast__Stmt v__ast__ForStmt_to_sumtype_v__ast__Stmt(v__ast__ForStmt* x, bool is_mut);
v__ast__Expr v__ast__InfixExpr_to_sumtype_v__ast__Expr(v__ast__InfixExpr* x, bool is_mut);
v__ast__Expr v__ast__CharLiteral_to_sumtype_v__ast__Expr(v__ast__CharLiteral* x, bool is_mut);
v__ast__Expr v__ast__SqlExpr_to_sumtype_v__ast__Expr(v__ast__SqlExpr* x, bool is_mut);
v__ast__Stmt v__ast__ExprStmt_to_sumtype_v__ast__Stmt(v__ast__ExprStmt* x, bool is_mut);
v__ast__Stmt v__ast__Block_to_sumtype_v__ast__Stmt(v__ast__Block* x, bool is_mut);
v__ast__AsmArg string_to_sumtype_v__ast__AsmArg(string* x, bool is_mut);
v__ast__AsmArg v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(v__ast__FloatLiteral* x, bool is_mut);
v__ast__AsmArg v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(v__ast__AsmDisp* x, bool is_mut);
v__ast__AsmArg v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(v__ast__IntegerLiteral* x, bool is_mut);
v__ast__AsmArg v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(v__ast__CharLiteral* x, bool is_mut);
v__ast__AsmArg v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(v__ast__AsmAddressing* x, bool is_mut);
v__ast__AsmArg v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(v__ast__AsmRegister* x, bool is_mut);
v__ast__AsmArg v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(v__ast__AsmAlias* x, bool is_mut);
v__ast__Stmt v__ast__NodeError_to_sumtype_v__ast__Stmt(v__ast__NodeError* x, bool is_mut);
v__ast__ScopeObject v__ast__Var_to_sumtype_v__ast__ScopeObject(v__ast__Var* x, bool is_mut);
v__ast__Stmt v__ast__AssignStmt_to_sumtype_v__ast__Stmt(v__ast__AssignStmt* x, bool is_mut);
v__ast__Expr v__ast__ComptimeCall_to_sumtype_v__ast__Expr(v__ast__ComptimeCall* x, bool is_mut);
v__ast__Expr v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(v__ast__ComptimeSelector* x, bool is_mut);
v__ast__TypeInfo v__ast__Enum_to_sumtype_v__ast__TypeInfo(v__ast__Enum* x, bool is_mut);
v__ast__Expr v__ast__NodeError_to_sumtype_v__ast__Expr(v__ast__NodeError* x, bool is_mut);
v__ast__Expr v__ast__Comment_to_sumtype_v__ast__Expr(v__ast__Comment* x, bool is_mut);
v__ast__Expr v__ast__EnumVal_to_sumtype_v__ast__Expr(v__ast__EnumVal* x, bool is_mut);
v__ast__Expr v__ast__AtExpr_to_sumtype_v__ast__Expr(v__ast__AtExpr* x, bool is_mut);
v__ast__Expr v__ast__ComptimeType_to_sumtype_v__ast__Expr(v__ast__ComptimeType* x, bool is_mut);
v__ast__Expr v__ast__GoExpr_to_sumtype_v__ast__Expr(v__ast__GoExpr* x, bool is_mut);
v__ast__Expr v__ast__SpawnExpr_to_sumtype_v__ast__Expr(v__ast__SpawnExpr* x, bool is_mut);
v__ast__Expr v__ast__SelectExpr_to_sumtype_v__ast__Expr(v__ast__SelectExpr* x, bool is_mut);
v__ast__Expr v__ast__Nil_to_sumtype_v__ast__Expr(v__ast__Nil* x, bool is_mut);
v__ast__Expr v__ast__ParExpr_to_sumtype_v__ast__Expr(v__ast__ParExpr* x, bool is_mut);
v__ast__Expr v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(v__ast__UnsafeExpr* x, bool is_mut);
v__ast__Expr v__ast__LambdaExpr_to_sumtype_v__ast__Expr(v__ast__LambdaExpr* x, bool is_mut);
v__ast__Expr v__ast__LockExpr_to_sumtype_v__ast__Expr(v__ast__LockExpr* x, bool is_mut);
v__ast__Expr v__ast__TypeOf_to_sumtype_v__ast__Expr(v__ast__TypeOf* x, bool is_mut);
v__ast__Expr v__ast__IsRefType_to_sumtype_v__ast__Expr(v__ast__IsRefType* x, bool is_mut);
v__ast__Expr v__ast__DumpExpr_to_sumtype_v__ast__Expr(v__ast__DumpExpr* x, bool is_mut);
v__ast__Expr v__ast__OffsetOf_to_sumtype_v__ast__Expr(v__ast__OffsetOf* x, bool is_mut);
v__ast__Expr v__ast__Likely_to_sumtype_v__ast__Expr(v__ast__Likely* x, bool is_mut);
v__ast__Expr v__ast__AnonFn_to_sumtype_v__ast__Expr(v__ast__AnonFn* x, bool is_mut);
v__ast__Stmt v__ast__StructDecl_to_sumtype_v__ast__Stmt(v__ast__StructDecl* x, bool is_mut);
v__ast__Expr v__ast__IndexExpr_to_sumtype_v__ast__Expr(v__ast__IndexExpr* x, bool is_mut);
v__ast__Expr v__ast__AsCast_to_sumtype_v__ast__Expr(v__ast__AsCast* x, bool is_mut);
v__ast__Expr v__ast__PostfixExpr_to_sumtype_v__ast__Expr(v__ast__PostfixExpr* x, bool is_mut);
v__ast__Expr v__ast__RangeExpr_to_sumtype_v__ast__Expr(v__ast__RangeExpr* x, bool is_mut);
v__ast__Expr v__ast__SelectorExpr_to_sumtype_v__ast__Expr(v__ast__SelectorExpr* x, bool is_mut);
v__ast__Expr v__ast__PrefixExpr_to_sumtype_v__ast__Expr(v__ast__PrefixExpr* x, bool is_mut);
v__ast__Expr v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(v__ast__ArrayDecompose* x, bool is_mut);
v__ast__Stmt v__ast__ForCStmt_to_sumtype_v__ast__Stmt(v__ast__ForCStmt* x, bool is_mut);
v__ast__Stmt v__ast__ForInStmt_to_sumtype_v__ast__Stmt(v__ast__ForInStmt* x, bool is_mut);
v__ast__Expr v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(v__ast__IfGuardExpr* x, bool is_mut);
v__ast__Stmt v__ast__Module_to_sumtype_v__ast__Stmt(v__ast__Module* x, bool is_mut);
v__ast__Stmt v__ast__Import_to_sumtype_v__ast__Stmt(v__ast__Import* x, bool is_mut);
v__ast__Stmt v__ast__ConstDecl_to_sumtype_v__ast__Stmt(v__ast__ConstDecl* x, bool is_mut);
v__ast__Stmt v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(v__ast__InterfaceDecl* x, bool is_mut);
v__ast__Stmt v__ast__EnumDecl_to_sumtype_v__ast__Stmt(v__ast__EnumDecl* x, bool is_mut);
v__ast__Stmt v__ast__TypeDecl_to_sumtype_v__ast__Stmt(v__ast__TypeDecl* x, bool is_mut);
v__ast__Stmt v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(v__ast__GlobalDecl* x, bool is_mut);
v__ast__Stmt v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(v__ast__ComptimeFor* x, bool is_mut);
v__ast__Stmt v__ast__DebuggerStmt_to_sumtype_v__ast__Stmt(v__ast__DebuggerStmt* x, bool is_mut);
v__ast__Stmt v__ast__HashStmt_to_sumtype_v__ast__Stmt(v__ast__HashStmt* x, bool is_mut);
v__ast__Stmt v__ast__SemicolonStmt_to_sumtype_v__ast__Stmt(v__ast__SemicolonStmt* x, bool is_mut);
v__ast__Stmt v__ast__AsmStmt_to_sumtype_v__ast__Stmt(v__ast__AsmStmt* x, bool is_mut);
v__ast__Stmt v__ast__SqlStmt_to_sumtype_v__ast__Stmt(v__ast__SqlStmt* x, bool is_mut);
v__ast__Stmt v__ast__GotoLabel_to_sumtype_v__ast__Stmt(v__ast__GotoLabel* x, bool is_mut);
v__ast__Stmt v__ast__Return_to_sumtype_v__ast__Stmt(v__ast__Return* x, bool is_mut);
v__ast__Stmt v__ast__BranchStmt_to_sumtype_v__ast__Stmt(v__ast__BranchStmt* x, bool is_mut);
v__ast__Stmt v__ast__AssertStmt_to_sumtype_v__ast__Stmt(v__ast__AssertStmt* x, bool is_mut);
v__ast__Stmt v__ast__DeferStmt_to_sumtype_v__ast__Stmt(v__ast__DeferStmt* x, bool is_mut);
v__ast__Stmt v__ast__GotoStmt_to_sumtype_v__ast__Stmt(v__ast__GotoStmt* x, bool is_mut);
v__ast__Expr v__ast__ConcatExpr_to_sumtype_v__ast__Expr(v__ast__ConcatExpr* x, bool is_mut);
v__ast__IdentInfo v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(v__ast__IdentVar* x, bool is_mut);
v__ast__Expr v__ast__ChanInit_to_sumtype_v__ast__Expr(v__ast__ChanInit* x, bool is_mut);
v__ast__IdentInfo v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(v__ast__IdentFn* x, bool is_mut);
v__ast__Expr v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(v__ast__StringInterLiteral* x, bool is_mut);
v__ast__ScopeObject v__ast__ConstField_to_sumtype_v__ast__ScopeObject(v__ast__ConstField* x, bool is_mut);
v__ast__ScopeObject v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(v__ast__GlobalField* x, bool is_mut);
v__ast__TypeDecl v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__SumTypeDecl* x, bool is_mut);
v__ast__TypeDecl v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__AliasTypeDecl* x, bool is_mut);
v__ast__TypeDecl v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__FnTypeDecl* x, bool is_mut);
v__ast__TypeInfo v__ast__Alias_to_sumtype_v__ast__TypeInfo(v__ast__Alias* x, bool is_mut);
bool Array_rune_arr_eq(Array_rune a, Array_rune b);
bool Array_string_arr_eq(Array_string a, Array_string b);
bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b);
bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b);
bool v__ast__Stmt_sumtype_eq(v__ast__Stmt a, v__ast__Stmt b);
bool v__ast__AsmStmt_struct_eq(v__ast__AsmStmt a, v__ast__AsmStmt b);
bool Array_v__ast__AsmClobbered_arr_eq(Array_v__ast__AsmClobbered a, Array_v__ast__AsmClobbered b);
bool v__ast__AsmClobbered_struct_eq(v__ast__AsmClobbered a, v__ast__AsmClobbered b);
bool v__ast__AsmRegister_struct_eq(v__ast__AsmRegister a, v__ast__AsmRegister b);
bool Array_v__ast__Comment_arr_eq(Array_v__ast__Comment a, Array_v__ast__Comment b);
bool v__ast__Comment_struct_eq(v__ast__Comment a, v__ast__Comment b);
bool v__token__Pos_struct_eq(v__token__Pos a, v__token__Pos b);
bool Array_v__ast__AsmTemplate_arr_eq(Array_v__ast__AsmTemplate a, Array_v__ast__AsmTemplate b);
bool v__ast__AsmTemplate_struct_eq(v__ast__AsmTemplate a, v__ast__AsmTemplate b);
bool Array_v__ast__AsmArg_arr_eq(Array_v__ast__AsmArg a, Array_v__ast__AsmArg b);
bool v__ast__AsmArg_sumtype_eq(v__ast__AsmArg a, v__ast__AsmArg b);
bool v__ast__AsmAddressing_struct_eq(v__ast__AsmAddressing a, v__ast__AsmAddressing b);
bool v__ast__AsmAlias_struct_eq(v__ast__AsmAlias a, v__ast__AsmAlias b);
bool v__ast__AsmDisp_struct_eq(v__ast__AsmDisp a, v__ast__AsmDisp b);
bool v__ast__BoolLiteral_struct_eq(v__ast__BoolLiteral a, v__ast__BoolLiteral b);
bool v__ast__CharLiteral_struct_eq(v__ast__CharLiteral a, v__ast__CharLiteral b);
bool v__ast__FloatLiteral_struct_eq(v__ast__FloatLiteral a, v__ast__FloatLiteral b);
bool v__ast__IntegerLiteral_struct_eq(v__ast__IntegerLiteral a, v__ast__IntegerLiteral b);
bool Array_v__ast__AsmIO_arr_eq(Array_v__ast__AsmIO a, Array_v__ast__AsmIO b);
bool v__ast__AsmIO_struct_eq(v__ast__AsmIO a, v__ast__AsmIO b);
bool v__ast__Expr_sumtype_eq(v__ast__Expr a, v__ast__Expr b);
bool v__ast__NodeError_struct_eq(v__ast__NodeError a, v__ast__NodeError b);
bool v__ast__AnonFn_struct_eq(v__ast__AnonFn a, v__ast__AnonFn b);
bool v__ast__FnDecl_struct_eq(v__ast__FnDecl a, v__ast__FnDecl b);
bool v__ast__StructField_struct_eq(v__ast__StructField a, v__ast__StructField b);
bool v__ast__StructDecl_struct_eq(v__ast__StructDecl a, v__ast__StructDecl b);
bool Array_v__ast__StructField_arr_eq(Array_v__ast__StructField a, Array_v__ast__StructField b);
bool Array_v__ast__TypeNode_arr_eq(Array_v__ast__TypeNode a, Array_v__ast__TypeNode b);
bool v__ast__TypeNode_struct_eq(v__ast__TypeNode a, v__ast__TypeNode b);
bool Array_v__ast__Embed_arr_eq(Array_v__ast__Embed a, Array_v__ast__Embed b);
bool v__ast__Embed_struct_eq(v__ast__Embed a, v__ast__Embed b);
bool Array_v__ast__Attr_arr_eq(Array_v__ast__Attr a, Array_v__ast__Attr b);
bool v__ast__Attr_struct_eq(v__ast__Attr a, v__ast__Attr b);
bool Map_string_v__ast__FnTrace_map_eq(Map_string_v__ast__FnTrace a, Map_string_v__ast__FnTrace b);
bool v__ast__FnTrace_struct_eq(v__ast__FnTrace a, v__ast__FnTrace b);
bool Array_v__ast__DeferStmt_arr_eq(Array_v__ast__DeferStmt a, Array_v__ast__DeferStmt b);
bool v__ast__DeferStmt_struct_eq(v__ast__DeferStmt a, v__ast__DeferStmt b);
bool Array_v__ast__Stmt_arr_eq(Array_v__ast__Stmt a, Array_v__ast__Stmt b);
bool Array_v__ast__Ident_arr_eq(Array_v__ast__Ident a, Array_v__ast__Ident b);
bool v__ast__Ident_struct_eq(v__ast__Ident a, v__ast__Ident b);
bool v__ast__OrExpr_struct_eq(v__ast__OrExpr a, v__ast__OrExpr b);
bool v__ast__ScopeObject_sumtype_eq(v__ast__ScopeObject a, v__ast__ScopeObject b);
bool v__ast__EmptyScopeObject_struct_eq(v__ast__EmptyScopeObject a, v__ast__EmptyScopeObject b);
bool v__ast__ConstField_struct_eq(v__ast__ConstField a, v__ast__ConstField b);
bool v__ast__ComptTimeConstValue_sumtype_eq(v__ast__ComptTimeConstValue a, v__ast__ComptTimeConstValue b);
bool v__ast__EmptyExpr_alias_eq(v__ast__EmptyExpr a, v__ast__EmptyExpr b);
bool v__ast__GlobalField_struct_eq(v__ast__GlobalField a, v__ast__GlobalField b);
bool v__ast__Var_struct_eq(v__ast__Var a, v__ast__Var b);
bool v__ast__IdentInfo_sumtype_eq(v__ast__IdentInfo a, v__ast__IdentInfo b);
bool v__ast__IdentFn_struct_eq(v__ast__IdentFn a, v__ast__IdentFn b);
bool v__ast__IdentVar_struct_eq(v__ast__IdentVar a, v__ast__IdentVar b);
bool Array_v__ast__Param_arr_eq(Array_v__ast__Param a, Array_v__ast__Param b);
bool v__ast__Param_struct_eq(v__ast__Param a, v__ast__Param b);
bool Map_string_bool_map_eq(Map_string_bool a, Map_string_bool b);
bool v__ast__ArrayDecompose_struct_eq(v__ast__ArrayDecompose a, v__ast__ArrayDecompose b);
bool v__ast__ArrayInit_struct_eq(v__ast__ArrayInit a, v__ast__ArrayInit b);
bool Array_Array_v__ast__Comment_arr_eq(Array_Array_v__ast__Comment a, Array_Array_v__ast__Comment b);
bool Array_v__ast__Expr_arr_eq(Array_v__ast__Expr a, Array_v__ast__Expr b);
bool v__ast__AsCast_struct_eq(v__ast__AsCast a, v__ast__AsCast b);
bool v__ast__Assoc_struct_eq(v__ast__Assoc a, v__ast__Assoc b);
bool v__ast__AtExpr_struct_eq(v__ast__AtExpr a, v__ast__AtExpr b);
bool v__ast__CTempVar_struct_eq(v__ast__CTempVar a, v__ast__CTempVar b);
bool v__ast__CallExpr_struct_eq(v__ast__CallExpr a, v__ast__CallExpr b);
bool Array_v__ast__CallArg_arr_eq(Array_v__ast__CallArg a, Array_v__ast__CallArg b);
bool v__ast__CallArg_struct_eq(v__ast__CallArg a, v__ast__CallArg b);
bool v__ast__CastExpr_struct_eq(v__ast__CastExpr a, v__ast__CastExpr b);
bool v__ast__ChanInit_struct_eq(v__ast__ChanInit a, v__ast__ChanInit b);
bool v__ast__ComptimeCall_struct_eq(v__ast__ComptimeCall a, v__ast__ComptimeCall b);
bool v__ast__File_struct_eq(v__ast__File a, v__ast__File b);
bool v__ast__Module_struct_eq(v__ast__Module a, v__ast__Module b);
bool Array_v__ast__Import_arr_eq(Array_v__ast__Import a, Array_v__ast__Import b);
bool v__ast__Import_struct_eq(v__ast__Import a, v__ast__Import b);
bool Array_v__ast__ImportSymbol_arr_eq(Array_v__ast__ImportSymbol a, Array_v__ast__ImportSymbol b);
bool v__ast__ImportSymbol_struct_eq(v__ast__ImportSymbol a, v__ast__ImportSymbol b);
bool Array_v__ast__EmbeddedFile_arr_eq(Array_v__ast__EmbeddedFile a, Array_v__ast__EmbeddedFile b);
bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b);
bool Array_u8_arr_eq(Array_u8 a, Array_u8 b);
bool Map_string_string_map_eq(Map_string_string a, Map_string_string b);
bool v__token__KeywordsMatcherTrie_struct_eq(v__token__KeywordsMatcherTrie a, v__token__KeywordsMatcherTrie b);
bool Array_v__token__TrieNode_ptr_arr_eq(Array_v__token__TrieNode_ptr a, Array_v__token__TrieNode_ptr b);
bool Array_v__errors__Error_arr_eq(Array_v__errors__Error a, Array_v__errors__Error b);
bool v__errors__Error_struct_eq(v__errors__Error a, v__errors__Error b);
bool v__errors__CompilerMessage_struct_eq(v__errors__CompilerMessage a, v__errors__CompilerMessage b);
bool Array_v__errors__CallStackItem_arr_eq(Array_v__errors__CallStackItem a, Array_v__errors__CallStackItem b);
bool v__errors__CallStackItem_struct_eq(v__errors__CallStackItem a, v__errors__CallStackItem b);
bool Array_v__errors__Warning_arr_eq(Array_v__errors__Warning a, Array_v__errors__Warning b);
bool v__errors__Warning_struct_eq(v__errors__Warning a, v__errors__Warning b);
bool Array_v__errors__Notice_arr_eq(Array_v__errors__Notice a, Array_v__errors__Notice b);
bool v__errors__Notice_struct_eq(v__errors__Notice a, v__errors__Notice b);
bool Array_v__ast__FnDecl_ptr_arr_eq(Array_v__ast__FnDecl_ptr a, Array_v__ast__FnDecl_ptr b);
bool Array_v__ast__TemplateLineInfo_arr_eq(Array_v__ast__TemplateLineInfo a, Array_v__ast__TemplateLineInfo b);
bool v__ast__TemplateLineInfo_struct_eq(v__ast__TemplateLineInfo a, v__ast__TemplateLineInfo b);
bool v__ast__ComptimeSelector_struct_eq(v__ast__ComptimeSelector a, v__ast__ComptimeSelector b);
bool v__ast__ComptimeType_struct_eq(v__ast__ComptimeType a, v__ast__ComptimeType b);
bool v__ast__ConcatExpr_struct_eq(v__ast__ConcatExpr a, v__ast__ConcatExpr b);
bool v__ast__DumpExpr_struct_eq(v__ast__DumpExpr a, v__ast__DumpExpr b);
bool v__ast__EnumVal_struct_eq(v__ast__EnumVal a, v__ast__EnumVal b);
bool v__ast__GoExpr_struct_eq(v__ast__GoExpr a, v__ast__GoExpr b);
bool v__ast__IfExpr_struct_eq(v__ast__IfExpr a, v__ast__IfExpr b);
bool Array_v__ast__IfBranch_arr_eq(Array_v__ast__IfBranch a, Array_v__ast__IfBranch b);
bool v__ast__IfBranch_struct_eq(v__ast__IfBranch a, v__ast__IfBranch b);
bool v__ast__IfGuardExpr_struct_eq(v__ast__IfGuardExpr a, v__ast__IfGuardExpr b);
bool Array_v__ast__IfGuardVar_arr_eq(Array_v__ast__IfGuardVar a, Array_v__ast__IfGuardVar b);
bool v__ast__IfGuardVar_struct_eq(v__ast__IfGuardVar a, v__ast__IfGuardVar b);
bool v__ast__IndexExpr_struct_eq(v__ast__IndexExpr a, v__ast__IndexExpr b);
bool v__ast__InfixExpr_struct_eq(v__ast__InfixExpr a, v__ast__InfixExpr b);
bool v__ast__IsRefType_struct_eq(v__ast__IsRefType a, v__ast__IsRefType b);
bool v__ast__LambdaExpr_struct_eq(v__ast__LambdaExpr a, v__ast__LambdaExpr b);
bool v__ast__Likely_struct_eq(v__ast__Likely a, v__ast__Likely b);
bool v__ast__LockExpr_struct_eq(v__ast__LockExpr a, v__ast__LockExpr b);
bool Array_bool_arr_eq(Array_bool a, Array_bool b);
bool v__ast__MapInit_struct_eq(v__ast__MapInit a, v__ast__MapInit b);
bool v__ast__MatchExpr_struct_eq(v__ast__MatchExpr a, v__ast__MatchExpr b);
bool Array_v__ast__MatchBranch_arr_eq(Array_v__ast__MatchBranch a, Array_v__ast__MatchBranch b);
bool v__ast__MatchBranch_struct_eq(v__ast__MatchBranch a, v__ast__MatchBranch b);
bool v__ast__Nil_struct_eq(v__ast__Nil a, v__ast__Nil b);
bool v__ast__None_struct_eq(v__ast__None a, v__ast__None b);
bool v__ast__OffsetOf_struct_eq(v__ast__OffsetOf a, v__ast__OffsetOf b);
bool v__ast__ParExpr_struct_eq(v__ast__ParExpr a, v__ast__ParExpr b);
bool v__ast__PostfixExpr_struct_eq(v__ast__PostfixExpr a, v__ast__PostfixExpr b);
bool v__ast__PrefixExpr_struct_eq(v__ast__PrefixExpr a, v__ast__PrefixExpr b);
bool v__ast__RangeExpr_struct_eq(v__ast__RangeExpr a, v__ast__RangeExpr b);
bool v__ast__SelectExpr_struct_eq(v__ast__SelectExpr a, v__ast__SelectExpr b);
bool Array_v__ast__SelectBranch_arr_eq(Array_v__ast__SelectBranch a, Array_v__ast__SelectBranch b);
bool v__ast__SelectBranch_struct_eq(v__ast__SelectBranch a, v__ast__SelectBranch b);
bool v__ast__SelectorExpr_struct_eq(v__ast__SelectorExpr a, v__ast__SelectorExpr b);
bool Array_Array_v__ast__Type_arr_eq(Array_Array_v__ast__Type a, Array_Array_v__ast__Type b);
bool v__ast__SizeOf_struct_eq(v__ast__SizeOf a, v__ast__SizeOf b);
bool v__ast__SpawnExpr_struct_eq(v__ast__SpawnExpr a, v__ast__SpawnExpr b);
bool v__ast__SqlExpr_struct_eq(v__ast__SqlExpr a, v__ast__SqlExpr b);
bool Map_int_v__ast__SqlExpr_map_eq(Map_int_v__ast__SqlExpr a, Map_int_v__ast__SqlExpr b);
bool Array_v__ast__JoinClause_arr_eq(Array_v__ast__JoinClause a, Array_v__ast__JoinClause b);
bool v__ast__JoinClause_struct_eq(v__ast__JoinClause a, v__ast__JoinClause b);
bool v__ast__StringInterLiteral_struct_eq(v__ast__StringInterLiteral a, v__ast__StringInterLiteral b);
bool Array_int_arr_eq(Array_int a, Array_int b);
bool Array_v__token__Pos_arr_eq(Array_v__token__Pos a, Array_v__token__Pos b);
bool v__ast__StringLiteral_struct_eq(v__ast__StringLiteral a, v__ast__StringLiteral b);
bool v__ast__StructInit_struct_eq(v__ast__StructInit a, v__ast__StructInit b);
bool Array_v__ast__StructInitField_arr_eq(Array_v__ast__StructInitField a, Array_v__ast__StructInitField b);
bool v__ast__StructInitField_struct_eq(v__ast__StructInitField a, v__ast__StructInitField b);
bool v__ast__TypeOf_struct_eq(v__ast__TypeOf a, v__ast__TypeOf b);
bool v__ast__UnsafeExpr_struct_eq(v__ast__UnsafeExpr a, v__ast__UnsafeExpr b);
bool v__ast__AssertStmt_struct_eq(v__ast__AssertStmt a, v__ast__AssertStmt b);
bool v__ast__AssignStmt_struct_eq(v__ast__AssignStmt a, v__ast__AssignStmt b);
bool v__ast__Block_struct_eq(v__ast__Block a, v__ast__Block b);
bool v__ast__BranchStmt_struct_eq(v__ast__BranchStmt a, v__ast__BranchStmt b);
bool v__ast__ComptimeFor_struct_eq(v__ast__ComptimeFor a, v__ast__ComptimeFor b);
bool v__ast__ConstDecl_struct_eq(v__ast__ConstDecl a, v__ast__ConstDecl b);
bool Array_v__ast__ConstField_arr_eq(Array_v__ast__ConstField a, Array_v__ast__ConstField b);
bool v__ast__DebuggerStmt_struct_eq(v__ast__DebuggerStmt a, v__ast__DebuggerStmt b);
bool v__ast__EmptyStmt_struct_eq(v__ast__EmptyStmt a, v__ast__EmptyStmt b);
bool v__ast__EnumDecl_struct_eq(v__ast__EnumDecl a, v__ast__EnumDecl b);
bool Array_v__ast__EnumField_arr_eq(Array_v__ast__EnumField a, Array_v__ast__EnumField b);
bool v__ast__EnumField_struct_eq(v__ast__EnumField a, v__ast__EnumField b);
bool v__ast__ExprStmt_struct_eq(v__ast__ExprStmt a, v__ast__ExprStmt b);
bool v__ast__ForCStmt_struct_eq(v__ast__ForCStmt a, v__ast__ForCStmt b);
bool v__ast__ForInStmt_struct_eq(v__ast__ForInStmt a, v__ast__ForInStmt b);
bool v__ast__ForStmt_struct_eq(v__ast__ForStmt a, v__ast__ForStmt b);
bool v__ast__GlobalDecl_struct_eq(v__ast__GlobalDecl a, v__ast__GlobalDecl b);
bool Array_v__ast__GlobalField_arr_eq(Array_v__ast__GlobalField a, Array_v__ast__GlobalField b);
bool v__ast__GotoLabel_struct_eq(v__ast__GotoLabel a, v__ast__GotoLabel b);
bool v__ast__GotoStmt_struct_eq(v__ast__GotoStmt a, v__ast__GotoStmt b);
bool v__ast__HashStmt_struct_eq(v__ast__HashStmt a, v__ast__HashStmt b);
bool v__ast__InterfaceDecl_struct_eq(v__ast__InterfaceDecl a, v__ast__InterfaceDecl b);
bool Array_v__ast__InterfaceEmbedding_arr_eq(Array_v__ast__InterfaceEmbedding a, Array_v__ast__InterfaceEmbedding b);
bool v__ast__InterfaceEmbedding_struct_eq(v__ast__InterfaceEmbedding a, v__ast__InterfaceEmbedding b);
bool Array_v__ast__FnDecl_arr_eq(Array_v__ast__FnDecl a, Array_v__ast__FnDecl b);
bool v__ast__Return_struct_eq(v__ast__Return a, v__ast__Return b);
bool v__ast__SemicolonStmt_struct_eq(v__ast__SemicolonStmt a, v__ast__SemicolonStmt b);
bool v__ast__SqlStmt_struct_eq(v__ast__SqlStmt a, v__ast__SqlStmt b);
bool Array_v__ast__SqlStmtLine_arr_eq(Array_v__ast__SqlStmtLine a, Array_v__ast__SqlStmtLine b);
bool v__ast__SqlStmtLine_struct_eq(v__ast__SqlStmtLine a, v__ast__SqlStmtLine b);
bool Map_int_v__ast__SqlStmtLine_map_eq(Map_int_v__ast__SqlStmtLine a, Map_int_v__ast__SqlStmtLine b);
bool v__ast__TypeDecl_sumtype_eq(v__ast__TypeDecl a, v__ast__TypeDecl b);
bool v__ast__AliasTypeDecl_struct_eq(v__ast__AliasTypeDecl a, v__ast__AliasTypeDecl b);
bool v__ast__FnTypeDecl_struct_eq(v__ast__FnTypeDecl a, v__ast__FnTypeDecl b);
bool v__ast__SumTypeDecl_struct_eq(v__ast__SumTypeDecl a, v__ast__SumTypeDecl b);
static void v__ast__TypeSymbol_free(v__ast__TypeSymbol* it);
static void Array_v__ast__Type_free(Array_v__ast__Type* it);
static void Array_v__ast__Fn_free(Array_v__ast__Fn* it);
static void v__ast__Fn_free(v__ast__Fn* it);
static void Array_v__ast__Param_free(Array_v__ast__Param* it);
static void v__ast__Param_free(v__ast__Param* it);
static void Array_v__ast__Attr_free(Array_v__ast__Attr* it);
static void v__ast__Attr_free(v__ast__Attr* it);

// V global/const non-precomputed definitions:
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_strconv__digit_pairs; // a string literal, inited later
string _const_strconv__base_digits; // a string literal, inited later
string _const_digit_pairs; // a string literal, inited later
string _const_si_s_code; // a string literal, inited later
string _const_si_g32_code; // a string literal, inited later
string _const_si_g64_code; // a string literal, inited later
string _const_time__days_string; // a string literal, inited later
string _const_time__months_string; // a string literal, inited later
string _const_flag__space; // a string literal, inited later
string _const_flag__underline; // a string literal, inited later
string _const_semver__comparator_sep; // a string literal, inited later
string _const_semver__comparator_set_sep; // a string literal, inited later
string _const_semver__hyphen_range_sep; // a string literal, inited later
string _const_semver__x_range_symbols; // a string literal, inited later
string _const_os__fslash_str; // a string literal, inited later
string _const_os__dot_dot; // a string literal, inited later
string _const_os__empty_str; // a string literal, inited later
string _const_os__dot_str; // a string literal, inited later
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
string _const_os__path_devnull; // a string literal, inited later
string _const_v__cflag__fexisting_literal; // a string literal, inited later
string _const_v__cflag__wexisting_literal; // a string literal, inited later
string _const_v__pkgconfig__version; // a string literal, inited later
string _const_v__vmod__err_label; // a string literal, inited later
string _const_rand__ulid_encoding; // a string literal, inited later
string _const_rand__english_letters; // a string literal, inited later
string _const_rand__hex_chars; // a string literal, inited later
string _const_rand__ascii_chars; // a string literal, inited later
string _const_v__util__d_sig; // a string literal, inited later
string _const_v__util__double_escape; // a string literal, inited later
string _const_v__util__map_prefix; // a string literal, inited later
string _const_v__ast__result_name; // a string literal, inited later
string _const_v__ast__option_name; // a string literal, inited later
string _const_v__ast__int_type_name; // str inited later
string _const_v__scanner__internally_generated_v_code; // a string literal, inited later
string _const_v__parser__error_msg; // a string literal, inited later
string _const_v__parser__tmpl_str_end; // a string literal, inited later
builtin__closure__Closure g_closure; // global 6

Array_fixed_u8_12 _const_builtin__closure__closure_thunk; // inited later
Array_fixed_u8_8 _const_builtin__closure__closure_get_data_bytes; // inited later
const u32 _const_math__bits__de_bruijn32 = 125613361; // precomputed2
Array_fixed_u8_32 _const_math__bits__de_bruijn32tab = {((u8)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; // fixed array const
const u64 _const_math__bits__de_bruijn64 = 285870213051353865U; // precomputed2
Array_fixed_u8_64 _const_math__bits__de_bruijn64tab = {((u8)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 
62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 
63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 
54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}; // fixed array const
const u64 _const_math__bits__m0 = 6148914691236517205U; // precomputed2
const u64 _const_math__bits__m1 = 3689348814741910323U; // precomputed2
const u64 _const_math__bits__m2 = 1085102592571150095U; // precomputed2
const u64 _const_math__bits__m3 = 71777214294589695U; // precomputed2
const u64 _const_math__bits__m4 = 281470681808895U; // precomputed2
const u8 _const_math__bits__n8 = 8; // precomputed2
const u16 _const_math__bits__n16 = 16; // precomputed2
const u32 _const_math__bits__n32 = 32; // precomputed2
const u64 _const_math__bits__n64 = 64U; // precomputed2
const u64 _const_math__bits__two32 = 4294967296U; // precomputed2
const u64 _const_math__bits__mask32 = 4294967295U; // precomputed2
Array_fixed_u8_256 _const_math__bits__ntz_8_tab = {((u8)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 
0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}; // fixed array const
Array_fixed_u8_256 _const_math__bits__pop_8_tab = {((u8)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 
0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 
0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 
0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 
0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 
0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 
0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 
0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}; // fixed array const
Array_fixed_u8_256 _const_math__bits__rev_8_tab = {((u8)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}; // fixed array const
Array_fixed_u8_256 _const_math__bits__len_8_tab = {((u8)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}; // fixed array const
const u32 _const_strconv__single_plus_zero = 0; // precomputed2
const u32 _const_strconv__single_minus_zero = 2147483648; // precomputed2
const u32 _const_strconv__single_plus_infinity = 2139095040; // precomputed2
const u32 _const_strconv__single_minus_infinity = 4286578688; // precomputed2
const u64 _const_strconv__double_plus_zero = 0U; // precomputed2
const u64 _const_strconv__double_minus_zero = 9223372036854775808U; // precomputed2
const u64 _const_strconv__double_plus_infinity = 9218868437227405312U; // precomputed2
const u64 _const_strconv__double_minus_infinity = 18442240474082181120U; // precomputed2
const u32 _const_strconv__c_ten = 10; // precomputed2
Array_fixed_u64_309 _const_strconv__pos_exp = {((u64)(0x3ff0000000000000LL)), ((u64)(0x4024000000000000LL)), ((u64)(0x4059000000000000LL)), ((u64)(0x408f400000000000LL)), ((u64)(0x40c3880000000000LL)), ((u64)(0x40f86a0000000000LL)), ((u64)(0x412e848000000000LL)), ((u64)(0x416312d000000000LL)), ((u64)(0x4197d78400000000LL)), ((u64)(0x41cdcd6500000000LL)), ((u64)(0x4202a05f20000000LL)), ((u64)(0x42374876e8000000LL)), ((u64)(0x426d1a94a2000000LL)), ((u64)(0x42a2309ce5400000LL)), ((u64)(0x42d6bcc41e900000LL)), ((u64)(0x430c6bf526340000LL)), 
((u64)(0x4341c37937e08000LL)), ((u64)(0x4376345785d8a000LL)), ((u64)(0x43abc16d674ec800LL)), ((u64)(0x43e158e460913d00LL)), ((u64)(0x4415af1d78b58c40LL)), ((u64)(0x444b1ae4d6e2ef50LL)), ((u64)(0x4480f0cf064dd592LL)), ((u64)(0x44b52d02c7e14af6LL)), ((u64)(0x44ea784379d99db4LL)), ((u64)(0x45208b2a2c280291LL)), ((u64)(0x4554adf4b7320335LL)), ((u64)(0x4589d971e4fe8402LL)), ((u64)(0x45c027e72f1f1281LL)), ((u64)(0x45f431e0fae6d721LL)), ((u64)(0x46293e5939a08ceaLL)), ((u64)(0x465f8def8808b024LL)), 
((u64)(0x4693b8b5b5056e17LL)), ((u64)(0x46c8a6e32246c99cLL)), ((u64)(0x46fed09bead87c03LL)), ((u64)(0x4733426172c74d82LL)), ((u64)(0x476812f9cf7920e3LL)), ((u64)(0x479e17b84357691bLL)), ((u64)(0x47d2ced32a16a1b1LL)), ((u64)(0x48078287f49c4a1dLL)), ((u64)(0x483d6329f1c35ca5LL)), ((u64)(0x48725dfa371a19e7LL)), ((u64)(0x48a6f578c4e0a061LL)), ((u64)(0x48dcb2d6f618c879LL)), ((u64)(0x4911efc659cf7d4cLL)), ((u64)(0x49466bb7f0435c9eLL)), ((u64)(0x497c06a5ec5433c6LL)), ((u64)(0x49b18427b3b4a05cLL)), 
((u64)(0x49e5e531a0a1c873LL)), ((u64)(0x4a1b5e7e08ca3a8fLL)), ((u64)(0x4a511b0ec57e649aLL)), ((u64)(0x4a8561d276ddfdc0LL)), ((u64)(0x4ababa4714957d30LL)), ((u64)(0x4af0b46c6cdd6e3eLL)), ((u64)(0x4b24e1878814c9ceLL)), ((u64)(0x4b5a19e96a19fc41LL)), ((u64)(0x4b905031e2503da9LL)), ((u64)(0x4bc4643e5ae44d13LL)), ((u64)(0x4bf97d4df19d6057LL)), ((u64)(0x4c2fdca16e04b86dLL)), ((u64)(0x4c63e9e4e4c2f344LL)), ((u64)(0x4c98e45e1df3b015LL)), ((u64)(0x4ccf1d75a5709c1bLL)), ((u64)(0x4d03726987666191LL)), 
((u64)(0x4d384f03e93ff9f5LL)), ((u64)(0x4d6e62c4e38ff872LL)), ((u64)(0x4da2fdbb0e39fb47LL)), ((u64)(0x4dd7bd29d1c87a19LL)), ((u64)(0x4e0dac74463a989fLL)), ((u64)(0x4e428bc8abe49f64LL)), ((u64)(0x4e772ebad6ddc73dLL)), ((u64)(0x4eacfa698c95390cLL)), ((u64)(0x4ee21c81f7dd43a7LL)), ((u64)(0x4f16a3a275d49491LL)), ((u64)(0x4f4c4c8b1349b9b5LL)), ((u64)(0x4f81afd6ec0e1411LL)), ((u64)(0x4fb61bcca7119916LL)), ((u64)(0x4feba2bfd0d5ff5bLL)), ((u64)(0x502145b7e285bf99LL)), ((u64)(0x50559725db272f7fLL)), 
((u64)(0x508afcef51f0fb5fLL)), ((u64)(0x50c0de1593369d1bLL)), ((u64)(0x50f5159af8044462LL)), ((u64)(0x512a5b01b605557bLL)), ((u64)(0x516078e111c3556dLL)), ((u64)(0x5194971956342ac8LL)), ((u64)(0x51c9bcdfabc1357aLL)), ((u64)(0x5200160bcb58c16cLL)), ((u64)(0x52341b8ebe2ef1c7LL)), ((u64)(0x526922726dbaae39LL)), ((u64)(0x529f6b0f092959c7LL)), ((u64)(0x52d3a2e965b9d81dLL)), ((u64)(0x53088ba3bf284e24LL)), ((u64)(0x533eae8caef261adLL)), ((u64)(0x53732d17ed577d0cLL)), ((u64)(0x53a7f85de8ad5c4fLL)), 
((u64)(0x53ddf67562d8b363LL)), ((u64)(0x5412ba095dc7701eLL)), ((u64)(0x5447688bb5394c25LL)), ((u64)(0x547d42aea2879f2eLL)), ((u64)(0x54b249ad2594c37dLL)), ((u64)(0x54e6dc186ef9f45cLL)), ((u64)(0x551c931e8ab87173LL)), ((u64)(0x5551dbf316b346e8LL)), ((u64)(0x558652efdc6018a2LL)), ((u64)(0x55bbe7abd3781ecaLL)), ((u64)(0x55f170cb642b133fLL)), ((u64)(0x5625ccfe3d35d80eLL)), ((u64)(0x565b403dcc834e12LL)), ((u64)(0x569108269fd210cbLL)), ((u64)(0x56c54a3047c694feLL)), ((u64)(0x56fa9cbc59b83a3dLL)), 
((u64)(0x5730a1f5b8132466LL)), ((u64)(0x5764ca732617ed80LL)), ((u64)(0x5799fd0fef9de8e0LL)), ((u64)(0x57d03e29f5c2b18cLL)), ((u64)(0x58044db473335defLL)), ((u64)(0x583961219000356bLL)), ((u64)(0x586fb969f40042c5LL)), ((u64)(0x58a3d3e2388029bbLL)), ((u64)(0x58d8c8dac6a0342aLL)), ((u64)(0x590efb1178484135LL)), ((u64)(0x59435ceaeb2d28c1LL)), ((u64)(0x59783425a5f872f1LL)), ((u64)(0x59ae412f0f768fadLL)), ((u64)(0x59e2e8bd69aa19ccLL)), ((u64)(0x5a17a2ecc414a03fLL)), ((u64)(0x5a4d8ba7f519c84fLL)), 
((u64)(0x5a827748f9301d32LL)), ((u64)(0x5ab7151b377c247eLL)), ((u64)(0x5aecda62055b2d9eLL)), ((u64)(0x5b22087d4358fc82LL)), ((u64)(0x5b568a9c942f3ba3LL)), ((u64)(0x5b8c2d43b93b0a8cLL)), ((u64)(0x5bc19c4a53c4e697LL)), ((u64)(0x5bf6035ce8b6203dLL)), ((u64)(0x5c2b843422e3a84dLL)), ((u64)(0x5c6132a095ce4930LL)), ((u64)(0x5c957f48bb41db7cLL)), ((u64)(0x5ccadf1aea12525bLL)), ((u64)(0x5d00cb70d24b7379LL)), ((u64)(0x5d34fe4d06de5057LL)), ((u64)(0x5d6a3de04895e46dLL)), ((u64)(0x5da066ac2d5daec4LL)), 
((u64)(0x5dd4805738b51a75LL)), ((u64)(0x5e09a06d06e26112LL)), ((u64)(0x5e400444244d7cabLL)), ((u64)(0x5e7405552d60dbd6LL)), ((u64)(0x5ea906aa78b912ccLL)), ((u64)(0x5edf485516e7577fLL)), ((u64)(0x5f138d352e5096afLL)), ((u64)(0x5f48708279e4bc5bLL)), ((u64)(0x5f7e8ca3185deb72LL)), ((u64)(0x5fb317e5ef3ab327LL)), ((u64)(0x5fe7dddf6b095ff1LL)), ((u64)(0x601dd55745cbb7edLL)), ((u64)(0x6052a5568b9f52f4LL)), ((u64)(0x60874eac2e8727b1LL)), ((u64)(0x60bd22573a28f19dLL)), ((u64)(0x60f2357684599702LL)), 
((u64)(0x6126c2d4256ffcc3LL)), ((u64)(0x615c73892ecbfbf4LL)), ((u64)(0x6191c835bd3f7d78LL)), ((u64)(0x61c63a432c8f5cd6LL)), ((u64)(0x61fbc8d3f7b3340cLL)), ((u64)(0x62315d847ad00087LL)), ((u64)(0x6265b4e5998400a9LL)), ((u64)(0x629b221effe500d4LL)), ((u64)(0x62d0f5535fef2084LL)), ((u64)(0x630532a837eae8a5LL)), ((u64)(0x633a7f5245e5a2cfLL)), ((u64)(0x63708f936baf85c1LL)), ((u64)(0x63a4b378469b6732LL)), ((u64)(0x63d9e056584240feLL)), ((u64)(0x64102c35f729689fLL)), ((u64)(0x6444374374f3c2c6LL)), 
((u64)(0x647945145230b378LL)), ((u64)(0x64af965966bce056LL)), ((u64)(0x64e3bdf7e0360c36LL)), ((u64)(0x6518ad75d8438f43LL)), ((u64)(0x654ed8d34e547314LL)), ((u64)(0x6583478410f4c7ecLL)), ((u64)(0x65b819651531f9e8LL)), ((u64)(0x65ee1fbe5a7e7861LL)), ((u64)(0x6622d3d6f88f0b3dLL)), ((u64)(0x665788ccb6b2ce0cLL)), ((u64)(0x668d6affe45f818fLL)), ((u64)(0x66c262dfeebbb0f9LL)), ((u64)(0x66f6fb97ea6a9d38LL)), ((u64)(0x672cba7de5054486LL)), ((u64)(0x6761f48eaf234ad4LL)), ((u64)(0x679671b25aec1d89LL)), 
((u64)(0x67cc0e1ef1a724ebLL)), ((u64)(0x680188d357087713LL)), ((u64)(0x6835eb082cca94d7LL)), ((u64)(0x686b65ca37fd3a0dLL)), ((u64)(0x68a11f9e62fe4448LL)), ((u64)(0x68d56785fbbdd55aLL)), ((u64)(0x690ac1677aad4ab1LL)), ((u64)(0x6940b8e0acac4eafLL)), ((u64)(0x6974e718d7d7625aLL)), ((u64)(0x69aa20df0dcd3af1LL)), ((u64)(0x69e0548b68a044d6LL)), ((u64)(0x6a1469ae42c8560cLL)), ((u64)(0x6a498419d37a6b8fLL)), ((u64)(0x6a7fe52048590673LL)), ((u64)(0x6ab3ef342d37a408LL)), ((u64)(0x6ae8eb0138858d0aLL)), 
((u64)(0x6b1f25c186a6f04cLL)), ((u64)(0x6b537798f4285630LL)), ((u64)(0x6b88557f31326bbbLL)), ((u64)(0x6bbe6adefd7f06aaLL)), ((u64)(0x6bf302cb5e6f642aLL)), ((u64)(0x6c27c37e360b3d35LL)), ((u64)(0x6c5db45dc38e0c82LL)), ((u64)(0x6c9290ba9a38c7d1LL)), ((u64)(0x6cc734e940c6f9c6LL)), ((u64)(0x6cfd022390f8b837LL)), ((u64)(0x6d3221563a9b7323LL)), ((u64)(0x6d66a9abc9424febLL)), ((u64)(0x6d9c5416bb92e3e6LL)), ((u64)(0x6dd1b48e353bce70LL)), ((u64)(0x6e0621b1c28ac20cLL)), ((u64)(0x6e3baa1e332d728fLL)), 
((u64)(0x6e714a52dffc6799LL)), ((u64)(0x6ea59ce797fb817fLL)), ((u64)(0x6edb04217dfa61dfLL)), ((u64)(0x6f10e294eebc7d2cLL)), ((u64)(0x6f451b3a2a6b9c76LL)), ((u64)(0x6f7a6208b5068394LL)), ((u64)(0x6fb07d457124123dLL)), ((u64)(0x6fe49c96cd6d16ccLL)), ((u64)(0x7019c3bc80c85c7fLL)), ((u64)(0x70501a55d07d39cfLL)), ((u64)(0x708420eb449c8843LL)), ((u64)(0x70b9292615c3aa54LL)), ((u64)(0x70ef736f9b3494e9LL)), ((u64)(0x7123a825c100dd11LL)), ((u64)(0x7158922f31411456LL)), ((u64)(0x718eb6bafd91596bLL)), 
((u64)(0x71c33234de7ad7e3LL)), ((u64)(0x71f7fec216198ddcLL)), ((u64)(0x722dfe729b9ff153LL)), ((u64)(0x7262bf07a143f6d4LL)), ((u64)(0x72976ec98994f489LL)), ((u64)(0x72cd4a7bebfa31abLL)), ((u64)(0x73024e8d737c5f0bLL)), ((u64)(0x7336e230d05b76cdLL)), ((u64)(0x736c9abd04725481LL)), ((u64)(0x73a1e0b622c774d0LL)), ((u64)(0x73d658e3ab795204LL)), ((u64)(0x740bef1c9657a686LL)), ((u64)(0x74417571ddf6c814LL)), ((u64)(0x7475d2ce55747a18LL)), ((u64)(0x74ab4781ead1989eLL)), ((u64)(0x74e10cb132c2ff63LL)), 
((u64)(0x75154fdd7f73bf3cLL)), ((u64)(0x754aa3d4df50af0bLL)), ((u64)(0x7580a6650b926d67LL)), ((u64)(0x75b4cffe4e7708c0LL)), ((u64)(0x75ea03fde214caf1LL)), ((u64)(0x7620427ead4cfed6LL)), ((u64)(0x7654531e58a03e8cLL)), ((u64)(0x768967e5eec84e2fLL)), ((u64)(0x76bfc1df6a7a61bbLL)), ((u64)(0x76f3d92ba28c7d15LL)), ((u64)(0x7728cf768b2f9c5aLL)), ((u64)(0x775f03542dfb8370LL)), ((u64)(0x779362149cbd3226LL)), ((u64)(0x77c83a99c3ec7eb0LL)), ((u64)(0x77fe494034e79e5cLL)), ((u64)(0x7832edc82110c2f9LL)), 
((u64)(0x7867a93a2954f3b8LL)), ((u64)(0x789d9388b3aa30a5LL)), ((u64)(0x78d27c35704a5e67LL)), ((u64)(0x79071b42cc5cf601LL)), ((u64)(0x793ce2137f743382LL)), ((u64)(0x79720d4c2fa8a031LL)), ((u64)(0x79a6909f3b92c83dLL)), ((u64)(0x79dc34c70a777a4dLL)), ((u64)(0x7a11a0fc668aac70LL)), ((u64)(0x7a46093b802d578cLL)), ((u64)(0x7a7b8b8a6038ad6fLL)), ((u64)(0x7ab137367c236c65LL)), ((u64)(0x7ae585041b2c477fLL)), ((u64)(0x7b1ae64521f7595eLL)), ((u64)(0x7b50cfeb353a97dbLL)), ((u64)(0x7b8503e602893dd2LL)), 
((u64)(0x7bba44df832b8d46LL)), ((u64)(0x7bf06b0bb1fb384cLL)), ((u64)(0x7c2485ce9e7a065fLL)), ((u64)(0x7c59a742461887f6LL)), ((u64)(0x7c9008896bcf54faLL)), ((u64)(0x7cc40aabc6c32a38LL)), ((u64)(0x7cf90d56b873f4c7LL)), ((u64)(0x7d2f50ac6690f1f8LL)), ((u64)(0x7d63926bc01a973bLL)), ((u64)(0x7d987706b0213d0aLL)), ((u64)(0x7dce94c85c298c4cLL)), ((u64)(0x7e031cfd3999f7b0LL)), ((u64)(0x7e37e43c8800759cLL)), ((u64)(0x7e6ddd4baa009303LL)), ((u64)(0x7ea2aa4f4a405be2LL)), ((u64)(0x7ed754e31cd072daLL)), ((u64)(0x7f0d2a1be4048f90LL)), ((u64)(0x7f423a516e82d9baLL)), ((u64)(0x7f76c8e5ca239029LL)), ((u64)(0x7fac7b1f3cac7433LL)), ((u64)(0x7fe1ccf385ebc8a0LL))}; // fixed array const
Array_fixed_u64_324 _const_strconv__neg_exp = {((u64)(0x3ff0000000000000LL)), ((u64)(0x3fb999999999999aLL)), ((u64)(0x3f847ae147ae147bLL)), ((u64)(0x3f50624dd2f1a9fcLL)), ((u64)(0x3f1a36e2eb1c432dLL)), ((u64)(0x3ee4f8b588e368f1LL)), ((u64)(0x3eb0c6f7a0b5ed8dLL)), ((u64)(0x3e7ad7f29abcaf48LL)), ((u64)(0x3e45798ee2308c3aLL)), ((u64)(0x3e112e0be826d695LL)), ((u64)(0x3ddb7cdfd9d7bdbbLL)), ((u64)(0x3da5fd7fe1796495LL)), ((u64)(0x3d719799812dea11LL)), ((u64)(0x3d3c25c268497682LL)), ((u64)(0x3d06849b86a12b9bLL)), ((u64)(0x3cd203af9ee75616LL)), 
((u64)(0x3c9cd2b297d889bcLL)), ((u64)(0x3c670ef54646d497LL)), ((u64)(0x3c32725dd1d243acLL)), ((u64)(0x3bfd83c94fb6d2acLL)), ((u64)(0x3bc79ca10c924223LL)), ((u64)(0x3b92e3b40a0e9b4fLL)), ((u64)(0x3b5e392010175ee6LL)), ((u64)(0x3b282db34012b251LL)), ((u64)(0x3af357c299a88ea7LL)), ((u64)(0x3abef2d0f5da7dd9LL)), ((u64)(0x3a88c240c4aecb14LL)), ((u64)(0x3a53ce9a36f23c10LL)), ((u64)(0x3a1fb0f6be506019LL)), ((u64)(0x39e95a5efea6b347LL)), ((u64)(0x39b4484bfeebc2a0LL)), ((u64)(0x398039d665896880LL)), 
((u64)(0x3949f623d5a8a733LL)), ((u64)(0x3914c4e977ba1f5cLL)), ((u64)(0x38e09d8792fb4c49LL)), ((u64)(0x38aa95a5b7f87a0fLL)), ((u64)(0x38754484932d2e72LL)), ((u64)(0x3841039d428a8b8fLL)), ((u64)(0x380b38fb9daa78e4LL)), ((u64)(0x37d5c72fb1552d83LL)), ((u64)(0x37a16c262777579cLL)), ((u64)(0x376be03d0bf225c7LL)), ((u64)(0x37364cfda3281e39LL)), ((u64)(0x3701d7314f534b61LL)), ((u64)(0x36cc8b8218854567LL)), ((u64)(0x3696d601ad376ab9LL)), ((u64)(0x366244ce242c5561LL)), ((u64)(0x362d3ae36d13bbceLL)), 
((u64)(0x35f7624f8a762fd8LL)), ((u64)(0x35c2b50c6ec4f313LL)), ((u64)(0x358dee7a4ad4b81fLL)), ((u64)(0x3557f1fb6f10934cLL)), ((u64)(0x352327fc58da0f70LL)), ((u64)(0x34eea6608e29b24dLL)), ((u64)(0x34b8851a0b548ea4LL)), ((u64)(0x34839dae6f76d883LL)), ((u64)(0x344f62b0b257c0d2LL)), ((u64)(0x34191bc08eac9a41LL)), ((u64)(0x33e41633a556e1ceLL)), ((u64)(0x33b011c2eaabe7d8LL)), ((u64)(0x3379b604aaaca626LL)), ((u64)(0x3344919d5556eb52LL)), ((u64)(0x3310747ddddf22a8LL)), ((u64)(0x32da53fc9631d10dLL)), 
((u64)(0x32a50ffd44f4a73dLL)), ((u64)(0x3270d9976a5d5297LL)), ((u64)(0x323af5bf109550f2LL)), ((u64)(0x32059165a6ddda5bLL)), ((u64)(0x31d1411e1f17e1e3LL)), ((u64)(0x319b9b6364f30304LL)), ((u64)(0x316615e91d8f359dLL)), ((u64)(0x3131ab20e472914aLL)), ((u64)(0x30fc45016d841baaLL)), ((u64)(0x30c69d9abe034955LL)), ((u64)(0x309217aefe690777LL)), ((u64)(0x305cf2b1970e7258LL)), ((u64)(0x3027288e1271f513LL)), ((u64)(0x2ff286d80ec190dcLL)), ((u64)(0x2fbda48ce468e7c7LL)), ((u64)(0x2f87b6d71d20b96cLL)), 
((u64)(0x2f52f8ac174d6123LL)), ((u64)(0x2f1e5aacf2156838LL)), ((u64)(0x2ee8488a5b445360LL)), ((u64)(0x2eb36d3b7c36a91aLL)), ((u64)(0x2e7f152bf9f10e90LL)), ((u64)(0x2e48ddbcc7f40ba6LL)), ((u64)(0x2e13e497065cd61fLL)), ((u64)(0x2ddfd424d6faf031LL)), ((u64)(0x2da97683df2f268dLL)), ((u64)(0x2d745ecfe5bf520bLL)), ((u64)(0x2d404bd984990e6fLL)), ((u64)(0x2d0a12f5a0f4e3e5LL)), ((u64)(0x2cd4dbf7b3f71cb7LL)), ((u64)(0x2ca0aff95cc5b092LL)), ((u64)(0x2c6ab328946f80eaLL)), ((u64)(0x2c355c2076bf9a55LL)), 
((u64)(0x2c0116805effaeaaLL)), ((u64)(0x2bcb5733cb32b111LL)), ((u64)(0x2b95df5ca28ef40dLL)), ((u64)(0x2b617f7d4ed8c33eLL)), ((u64)(0x2b2bff2ee48e0530LL)), ((u64)(0x2af665bf1d3e6a8dLL)), ((u64)(0x2ac1eaff4a98553dLL)), ((u64)(0x2a8cab3210f3bb95LL)), ((u64)(0x2a56ef5b40c2fc77LL)), ((u64)(0x2a225915cd68c9f9LL)), ((u64)(0x29ed5b561574765bLL)), ((u64)(0x29b77c44ddf6c516LL)), ((u64)(0x2982c9d0b1923745LL)), ((u64)(0x294e0fb44f50586eLL)), ((u64)(0x29180c903f7379f2LL)), ((u64)(0x28e33d4032c2c7f5LL)), 
((u64)(0x28aec866b79e0cbaLL)), ((u64)(0x2878a0522c7e7095LL)), ((u64)(0x2843b374f06526deLL)), ((u64)(0x280f8587e7083e30LL)), ((u64)(0x27d9379fec069826LL)), ((u64)(0x27a42c7ff0054685LL)), ((u64)(0x277023998cd10537LL)), ((u64)(0x2739d28f47b4d525LL)), ((u64)(0x2704a8729fc3ddb7LL)), ((u64)(0x26d086c219697e2cLL)), ((u64)(0x269a71368f0f3047LL)), ((u64)(0x2665275ed8d8f36cLL)), ((u64)(0x2630ec4be0ad8f89LL)), ((u64)(0x25fb13ac9aaf4c0fLL)), ((u64)(0x25c5a956e225d672LL)), ((u64)(0x2591544581b7dec2LL)), 
((u64)(0x255bba08cf8c979dLL)), ((u64)(0x25262e6d72d6dfb0LL)), ((u64)(0x24f1bebdf578b2f4LL)), ((u64)(0x24bc6463225ab7ecLL)), ((u64)(0x2486b6b5b5155ff0LL)), ((u64)(0x24522bc490dde65aLL)), ((u64)(0x241d12d41afca3c3LL)), ((u64)(0x23e7424348ca1c9cLL)), ((u64)(0x23b29b69070816e3LL)), ((u64)(0x237dc574d80cf16bLL)), ((u64)(0x2347d12a4670c123LL)), ((u64)(0x23130dbb6b8d674fLL)), ((u64)(0x22de7c5f127bd87eLL)), ((u64)(0x22a8637f41fcad32LL)), ((u64)(0x227382cc34ca2428LL)), ((u64)(0x223f37ad21436d0cLL)), 
((u64)(0x2208f9574dcf8a70LL)), ((u64)(0x21d3faac3e3fa1f3LL)), ((u64)(0x219ff779fd329cb9LL)), ((u64)(0x216992c7fdc216faLL)), ((u64)(0x2134756ccb01abfbLL)), ((u64)(0x21005df0a267bcc9LL)), ((u64)(0x20ca2fe76a3f9475LL)), ((u64)(0x2094f31f8832dd2aLL)), ((u64)(0x2060c27fa028b0efLL)), ((u64)(0x202ad0cc33744e4bLL)), ((u64)(0x1ff573d68f903ea2LL)), ((u64)(0x1fc1297872d9cbb5LL)), ((u64)(0x1f8b758d848fac55LL)), ((u64)(0x1f55f7a46a0c89ddLL)), ((u64)(0x1f2192e9ee706e4bLL)), ((u64)(0x1eec1e43171a4a11LL)), 
((u64)(0x1eb67e9c127b6e74LL)), ((u64)(0x1e81fee341fc585dLL)), ((u64)(0x1e4ccb0536608d61LL)), ((u64)(0x1e1708d0f84d3de7LL)), ((u64)(0x1de26d73f9d764b9LL)), ((u64)(0x1dad7becc2f23ac2LL)), ((u64)(0x1d779657025b6235LL)), ((u64)(0x1d42deac01e2b4f7LL)), ((u64)(0x1d0e3113363787f2LL)), ((u64)(0x1cd8274291c6065bLL)), ((u64)(0x1ca3529ba7d19eafLL)), ((u64)(0x1c6eea92a61c3118LL)), ((u64)(0x1c38bba884e35a7aLL)), ((u64)(0x1c03c9539d82aec8LL)), ((u64)(0x1bcfa885c8d117a6LL)), ((u64)(0x1b99539e3a40dfb8LL)), 
((u64)(0x1b6442e4fb671960LL)), ((u64)(0x1b303583fc527ab3LL)), ((u64)(0x1af9ef3993b72ab8LL)), ((u64)(0x1ac4bf6142f8eefaLL)), ((u64)(0x1a90991a9bfa58c8LL)), ((u64)(0x1a5a8e90f9908e0dLL)), ((u64)(0x1a253eda614071a4LL)), ((u64)(0x19f0ff151a99f483LL)), ((u64)(0x19bb31bb5dc320d2LL)), ((u64)(0x1985c162b168e70eLL)), ((u64)(0x1951678227871f3eLL)), ((u64)(0x191bd8d03f3e9864LL)), ((u64)(0x18e6470cff6546b6LL)), ((u64)(0x18b1d270cc51055fLL)), ((u64)(0x187c83e7ad4e6efeLL)), ((u64)(0x1846cfec8aa52598LL)), 
((u64)(0x18123ff06eea847aLL)), ((u64)(0x17dd331a4b10d3f6LL)), ((u64)(0x17a75c1508da432bLL)), ((u64)(0x1772b010d3e1cf56LL)), ((u64)(0x173de6815302e556LL)), ((u64)(0x1707eb9aa8cf1ddeLL)), ((u64)(0x16d322e220a5b17eLL)), ((u64)(0x169e9e369aa2b597LL)), ((u64)(0x16687e92154ef7acLL)), ((u64)(0x16339874ddd8c623LL)), ((u64)(0x15ff5a549627a36cLL)), ((u64)(0x15c91510781fb5f0LL)), ((u64)(0x159410d9f9b2f7f3LL)), ((u64)(0x15600d7b2e28c65cLL)), ((u64)(0x1529af2b7d0e0a2dLL)), ((u64)(0x14f48c22ca71a1bdLL)), 
((u64)(0x14c0701bd527b498LL)), ((u64)(0x148a4cf9550c5426LL)), ((u64)(0x14550a6110d6a9b8LL)), ((u64)(0x1420d51a73deee2dLL)), ((u64)(0x13eaee90b964b047LL)), ((u64)(0x13b58ba6fab6f36cLL)), ((u64)(0x13813c85955f2923LL)), ((u64)(0x134b9408eefea839LL)), ((u64)(0x1316100725988694LL)), ((u64)(0x12e1a66c1e139eddLL)), ((u64)(0x12ac3d79c9b8fe2eLL)), ((u64)(0x12769794a160cb58LL)), ((u64)(0x124212dd4de70913LL)), ((u64)(0x120ceafbafd80e85LL)), ((u64)(0x11d72262f3133ed1LL)), ((u64)(0x11a281e8c275cbdaLL)), 
((u64)(0x116d9ca79d89462aLL)), ((u64)(0x1137b08617a104eeLL)), ((u64)(0x1102f39e794d9d8bLL)), ((u64)(0x10ce5297287c2f45LL)), ((u64)(0x1098421286c9bf6bLL)), ((u64)(0x1063680ed23aff89LL)), ((u64)(0x102f0ce4839198dbLL)), ((u64)(0x0ff8d71d360e13e2LL)), ((u64)(0x0fc3df4a91a4dcb5LL)), ((u64)(0x0f8fcbaa82a16121LL)), ((u64)(0x0f596fbb9bb44db4LL)), ((u64)(0x0f245962e2f6a490LL)), ((u64)(0x0ef047824f2bb6daLL)), ((u64)(0x0eba0c03b1df8af6LL)), ((u64)(0x0e84d6695b193bf8LL)), ((u64)(0x0e50ab877c142ffaLL)), 
((u64)(0x0e1aac0bf9b9e65cLL)), ((u64)(0x0de5566ffafb1eb0LL)), ((u64)(0x0db111f32f2f4bc0LL)), ((u64)(0x0d7b4feb7eb212cdLL)), ((u64)(0x0d45d98932280f0aLL)), ((u64)(0x0d117ad428200c08LL)), ((u64)(0x0cdbf7b9d9cce00dLL)), ((u64)(0x0ca65fc7e170b33eLL)), ((u64)(0x0c71e6398126f5cbLL)), ((u64)(0x0c3ca38f350b22dfLL)), ((u64)(0x0c06e93f5da2824cLL)), ((u64)(0x0bd25432b14ecea3LL)), ((u64)(0x0b9d53844ee47dd1LL)), ((u64)(0x0b677603725064a8LL)), ((u64)(0x0b32c4cf8ea6b6ecLL)), ((u64)(0x0afe07b27dd78b14LL)), 
((u64)(0x0ac8062864ac6f43LL)), ((u64)(0x0a9338205089f29cLL)), ((u64)(0x0a5ec033b40fea93LL)), ((u64)(0x0a2899c2f6732210LL)), ((u64)(0x09f3ae3591f5b4d9LL)), ((u64)(0x09bf7d228322baf5LL)), ((u64)(0x098930e868e89591LL)), ((u64)(0x0954272053ed4474LL)), ((u64)(0x09201f4d0ff10390LL)), ((u64)(0x08e9cbae7fe805b3LL)), ((u64)(0x08b4a2f1ffecd15cLL)), ((u64)(0x0880825b3323dab0LL)), ((u64)(0x084a6a2b85062ab3LL)), ((u64)(0x081521bc6a6b555cLL)), ((u64)(0x07e0e7c9eebc444aLL)), ((u64)(0x07ab0c764ac6d3a9LL)), 
((u64)(0x0775a391d56bdc87LL)), ((u64)(0x07414fa7ddefe3a0LL)), ((u64)(0x070bb2a62fe638ffLL)), ((u64)(0x06d62884f31e93ffLL)), ((u64)(0x06a1ba03f5b21000LL)), ((u64)(0x066c5cd322b67fffLL)), ((u64)(0x0636b0a8e891ffffLL)), ((u64)(0x060226ed86db3333LL)), ((u64)(0x05cd0b15a491eb84LL)), ((u64)(0x05973c115074bc6aLL)), ((u64)(0x05629674405d6388LL)), ((u64)(0x052dbd86cd6238d9LL)), ((u64)(0x04f7cad23de82d7bLL)), ((u64)(0x04c308a831868ac9LL)), ((u64)(0x048e74404f3daadbLL)), ((u64)(0x04585d003f6488afLL)), 
((u64)(0x04237d99cc506d59LL)), ((u64)(0x03ef2f5c7a1a488eLL)), ((u64)(0x03b8f2b061aea072LL)), ((u64)(0x0383f559e7bee6c1LL)), ((u64)(0x034feef63f97d79cLL)), ((u64)(0x03198bf832dfdfb0LL)), ((u64)(0x02e46ff9c24cb2f3LL)), ((u64)(0x02b059949b708f29LL)), ((u64)(0x027a28edc580e50eLL)), ((u64)(0x0244ed8b04671da5LL)), ((u64)(0x0210be08d0527e1dLL)), ((u64)(0x01dac9a7b3b7302fLL)), ((u64)(0x01a56e1fc2f8f359LL)), ((u64)(0x017124e63593f5e1LL)), ((u64)(0x013b6e3d22865634LL)), ((u64)(0x0105f1ca820511c3LL)), 
((u64)(0x00d18e3b9b374169LL)), ((u64)(0x009c16c5c5253575LL)), ((u64)(0x0066789e3750f791LL)), ((u64)(0x0031fa182c40c60dLL)), ((u64)(0x000730d67819e8d2LL)), ((u64)(0x0000b8157268fdafLL)), ((u64)(0x000012688b70e62bLL)), ((u64)(0x000001d74124e3d1LL)), ((u64)(0x0000002f201d49fbLL)), ((u64)(0x00000004b6695433LL)), ((u64)(0x0000000078a42205)), ((u64)(0x000000000c1069cd)), ((u64)(0x000000000134d761)), ((u64)(0x00000000001ee257)), ((u64)(0x00000000000316a2)), ((u64)(0x0000000000004f10)), ((u64)(0x00000000000007e8)), ((u64)(0x00000000000000ca)), ((u64)(0x0000000000000014)), ((u64)(0x0000000000000002))}; // fixed array const
i64 _const_strconv__i64_min_int32; // inited later
i64 _const_strconv__i64_max_int32; // inited later
Array_fixed_u32_10 _const_strconv__ten_pow_table_32 = {((u32)(1)), ((u32)(10)), ((u32)(100)), ((u32)(1000)), ((u32)(10000)), ((u32)(100000)), ((u32)(1000000)), ((u32)(10000000)), ((u32)(100000000)), ((u32)(1000000000))}; // fixed array const
const u32 _const_strconv__mantbits32 = 23; // precomputed2
const u32 _const_strconv__expbits32 = 8; // precomputed2
Array_fixed_u64_20 _const_strconv__ten_pow_table_64 = {((u64)(1)), ((u64)(10)), ((u64)(100)), ((u64)(1000)), ((u64)(10000)), ((u64)(100000)), ((u64)(1000000)), ((u64)(10000000)), ((u64)(100000000)), ((u64)(1000000000)), ((u64)(10000000000LL)), ((u64)(100000000000LL)), ((u64)(1000000000000LL)), ((u64)(10000000000000LL)), ((u64)(100000000000000LL)), ((u64)(1000000000000000LL)), ((u64)(10000000000000000LL)), ((u64)(100000000000000000LL)), ((u64)(1000000000000000000LL)), ((u64)(10000000000000000000ULL))}; // fixed array const
const u32 _const_strconv__mantbits64 = 52; // precomputed2
const u32 _const_strconv__expbits64 = 11; // precomputed2
Array_fixed_f64_36 _const_strconv__dec_round = {((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005, 0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 
0.00000000000000005, 0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005, 0.000000000000000000005, 0.0000000000000000000005, 0.00000000000000000000005, 0.000000000000000000000005, 0.0000000000000000000000005, 0.00000000000000000000000005, 0.000000000000000000000000005, 0.0000000000000000000000000005, 0.00000000000000000000000000005, 0.000000000000000000000000000005, 0.0000000000000000000000000000005, 0.00000000000000000000000000000005, 0.000000000000000000000000000000005, 0.0000000000000000000000000000000005, 0.00000000000000000000000000000000005, 0.000000000000000000000000000000000005}; // fixed array const
Array_fixed_u64_47 _const_strconv__pow5_split_32 = {((u64)(1152921504606846976LL)), ((u64)(1441151880758558720LL)), ((u64)(1801439850948198400LL)), ((u64)(2251799813685248000LL)), ((u64)(1407374883553280000LL)), ((u64)(1759218604441600000LL)), ((u64)(2199023255552000000LL)), ((u64)(1374389534720000000LL)), ((u64)(1717986918400000000LL)), ((u64)(2147483648000000000LL)), ((u64)(1342177280000000000LL)), ((u64)(1677721600000000000LL)), ((u64)(2097152000000000000LL)), ((u64)(1310720000000000000LL)), ((u64)(1638400000000000000LL)), ((u64)(2048000000000000000LL)), 
((u64)(1280000000000000000LL)), ((u64)(1600000000000000000LL)), ((u64)(2000000000000000000LL)), ((u64)(1250000000000000000LL)), ((u64)(1562500000000000000LL)), ((u64)(1953125000000000000LL)), ((u64)(1220703125000000000LL)), ((u64)(1525878906250000000LL)), ((u64)(1907348632812500000LL)), ((u64)(1192092895507812500LL)), ((u64)(1490116119384765625LL)), ((u64)(1862645149230957031LL)), ((u64)(1164153218269348144LL)), ((u64)(1455191522836685180LL)), ((u64)(1818989403545856475LL)), ((u64)(2273736754432320594LL)), 
((u64)(1421085471520200371LL)), ((u64)(1776356839400250464LL)), ((u64)(2220446049250313080LL)), ((u64)(1387778780781445675LL)), ((u64)(1734723475976807094LL)), ((u64)(2168404344971008868LL)), ((u64)(1355252715606880542LL)), ((u64)(1694065894508600678LL)), ((u64)(2117582368135750847LL)), ((u64)(1323488980084844279LL)), ((u64)(1654361225106055349LL)), ((u64)(2067951531382569187LL)), ((u64)(1292469707114105741LL)), ((u64)(1615587133892632177LL)), ((u64)(2019483917365790221LL))}; // fixed array const
Array_fixed_u64_31 _const_strconv__pow5_inv_split_32 = {((u64)(576460752303423489LL)), ((u64)(461168601842738791LL)), ((u64)(368934881474191033LL)), ((u64)(295147905179352826LL)), ((u64)(472236648286964522LL)), ((u64)(377789318629571618LL)), ((u64)(302231454903657294LL)), ((u64)(483570327845851670LL)), ((u64)(386856262276681336LL)), ((u64)(309485009821345069LL)), ((u64)(495176015714152110LL)), ((u64)(396140812571321688LL)), ((u64)(316912650057057351LL)), ((u64)(507060240091291761LL)), ((u64)(405648192073033409LL)), ((u64)(324518553658426727LL)), 
((u64)(519229685853482763LL)), ((u64)(415383748682786211LL)), ((u64)(332306998946228969LL)), ((u64)(531691198313966350LL)), ((u64)(425352958651173080LL)), ((u64)(340282366920938464LL)), ((u64)(544451787073501542LL)), ((u64)(435561429658801234LL)), ((u64)(348449143727040987LL)), ((u64)(557518629963265579LL)), ((u64)(446014903970612463LL)), ((u64)(356811923176489971LL)), ((u64)(570899077082383953LL)), ((u64)(456719261665907162LL)), ((u64)(365375409332725730LL))}; // fixed array const
Array_fixed_u64_652 _const_strconv__pow5_split_64_x = {((u64)(0x0000000000000000)), ((u64)(0x0100000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0140000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0190000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01f4000000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0138800000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0186a00000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01e8480000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01312d0000000000LL)), 
((u64)(0x0000000000000000)), ((u64)(0x017d784000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01dcd65000000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x012a05f200000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x0174876e80000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01d1a94a20000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x012309ce54000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x016bcc41e9000000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01c6bf5263400000LL)), 
((u64)(0x0000000000000000)), ((u64)(0x011c37937e080000LL)), ((u64)(0x0000000000000000)), ((u64)(0x016345785d8a0000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01bc16d674ec8000LL)), ((u64)(0x0000000000000000)), ((u64)(0x01158e460913d000LL)), ((u64)(0x0000000000000000)), ((u64)(0x015af1d78b58c400LL)), ((u64)(0x0000000000000000)), ((u64)(0x01b1ae4d6e2ef500LL)), ((u64)(0x0000000000000000)), ((u64)(0x010f0cf064dd5920LL)), ((u64)(0x0000000000000000)), ((u64)(0x0152d02c7e14af68LL)), 
((u64)(0x0000000000000000)), ((u64)(0x01a784379d99db42LL)), ((u64)(0x4000000000000000LL)), ((u64)(0x0108b2a2c2802909LL)), ((u64)(0x9000000000000000ULL)), ((u64)(0x014adf4b7320334bLL)), ((u64)(0x7400000000000000LL)), ((u64)(0x019d971e4fe8401eLL)), ((u64)(0x0880000000000000LL)), ((u64)(0x01027e72f1f12813LL)), ((u64)(0xcaa0000000000000ULL)), ((u64)(0x01431e0fae6d7217LL)), ((u64)(0xbd48000000000000ULL)), ((u64)(0x0193e5939a08ce9dLL)), ((u64)(0x2c9a000000000000LL)), ((u64)(0x01f8def8808b0245LL)), 
((u64)(0x3be0400000000000LL)), ((u64)(0x013b8b5b5056e16bLL)), ((u64)(0x0ad8500000000000LL)), ((u64)(0x018a6e32246c99c6LL)), ((u64)(0x8d8e640000000000ULL)), ((u64)(0x01ed09bead87c037LL)), ((u64)(0xb878fe8000000000ULL)), ((u64)(0x013426172c74d822LL)), ((u64)(0x66973e2000000000LL)), ((u64)(0x01812f9cf7920e2bLL)), ((u64)(0x403d0da800000000LL)), ((u64)(0x01e17b84357691b6LL)), ((u64)(0xe826288900000000ULL)), ((u64)(0x012ced32a16a1b11LL)), ((u64)(0x622fb2ab40000000LL)), ((u64)(0x0178287f49c4a1d6LL)), 
((u64)(0xfabb9f5610000000ULL)), ((u64)(0x01d6329f1c35ca4bLL)), ((u64)(0x7cb54395ca000000LL)), ((u64)(0x0125dfa371a19e6fLL)), ((u64)(0x5be2947b3c800000LL)), ((u64)(0x016f578c4e0a060bLL)), ((u64)(0x32db399a0ba00000LL)), ((u64)(0x01cb2d6f618c878eLL)), ((u64)(0xdfc9040047440000ULL)), ((u64)(0x011efc659cf7d4b8LL)), ((u64)(0x17bb450059150000LL)), ((u64)(0x0166bb7f0435c9e7LL)), ((u64)(0xddaa16406f5a4000ULL)), ((u64)(0x01c06a5ec5433c60LL)), ((u64)(0x8a8a4de845986800ULL)), ((u64)(0x0118427b3b4a05bcLL)), 
((u64)(0xad2ce16256fe8200ULL)), ((u64)(0x015e531a0a1c872bLL)), ((u64)(0x987819baecbe2280ULL)), ((u64)(0x01b5e7e08ca3a8f6LL)), ((u64)(0x1f4b1014d3f6d590LL)), ((u64)(0x0111b0ec57e6499aLL)), ((u64)(0xa71dd41a08f48af4ULL)), ((u64)(0x01561d276ddfdc00LL)), ((u64)(0xd0e549208b31adb1ULL)), ((u64)(0x01aba4714957d300LL)), ((u64)(0x828f4db456ff0c8eULL)), ((u64)(0x010b46c6cdd6e3e0LL)), ((u64)(0xa33321216cbecfb2ULL)), ((u64)(0x014e1878814c9cd8LL)), ((u64)(0xcbffe969c7ee839eULL)), ((u64)(0x01a19e96a19fc40eLL)), 
((u64)(0x3f7ff1e21cf51243LL)), ((u64)(0x0105031e2503da89LL)), ((u64)(0x8f5fee5aa43256d4ULL)), ((u64)(0x014643e5ae44d12bLL)), ((u64)(0x7337e9f14d3eec89LL)), ((u64)(0x0197d4df19d60576LL)), ((u64)(0x1005e46da08ea7abLL)), ((u64)(0x01fdca16e04b86d4LL)), ((u64)(0x8a03aec4845928cbULL)), ((u64)(0x013e9e4e4c2f3444LL)), ((u64)(0xac849a75a56f72fdULL)), ((u64)(0x018e45e1df3b0155LL)), ((u64)(0x17a5c1130ecb4fbdLL)), ((u64)(0x01f1d75a5709c1abLL)), ((u64)(0xeec798abe93f11d6ULL)), ((u64)(0x013726987666190aLL)), 
((u64)(0xaa797ed6e38ed64bULL)), ((u64)(0x0184f03e93ff9f4dLL)), ((u64)(0x1517de8c9c728bdeLL)), ((u64)(0x01e62c4e38ff8721LL)), ((u64)(0xad2eeb17e1c7976bULL)), ((u64)(0x012fdbb0e39fb474LL)), ((u64)(0xd87aa5ddda397d46ULL)), ((u64)(0x017bd29d1c87a191LL)), ((u64)(0x4e994f5550c7dc97LL)), ((u64)(0x01dac74463a989f6LL)), ((u64)(0xf11fd195527ce9deULL)), ((u64)(0x0128bc8abe49f639LL)), ((u64)(0x6d67c5faa71c2456LL)), ((u64)(0x0172ebad6ddc73c8LL)), ((u64)(0x88c1b77950e32d6cULL)), ((u64)(0x01cfa698c95390baLL)), 
((u64)(0x957912abd28dfc63ULL)), ((u64)(0x0121c81f7dd43a74LL)), ((u64)(0xbad75756c7317b7cULL)), ((u64)(0x016a3a275d494911LL)), ((u64)(0x298d2d2c78fdda5bLL)), ((u64)(0x01c4c8b1349b9b56LL)), ((u64)(0xd9f83c3bcb9ea879ULL)), ((u64)(0x011afd6ec0e14115LL)), ((u64)(0x50764b4abe865297LL)), ((u64)(0x0161bcca7119915bLL)), ((u64)(0x2493de1d6e27e73dLL)), ((u64)(0x01ba2bfd0d5ff5b2LL)), ((u64)(0x56dc6ad264d8f086LL)), ((u64)(0x01145b7e285bf98fLL)), ((u64)(0x2c938586fe0f2ca8LL)), ((u64)(0x0159725db272f7f3LL)), 
((u64)(0xf7b866e8bd92f7d2ULL)), ((u64)(0x01afcef51f0fb5efLL)), ((u64)(0xfad34051767bdae3ULL)), ((u64)(0x010de1593369d1b5LL)), ((u64)(0x79881065d41ad19cLL)), ((u64)(0x015159af80444623LL)), ((u64)(0x57ea147f49218603LL)), ((u64)(0x01a5b01b605557acLL)), ((u64)(0xb6f24ccf8db4f3c1ULL)), ((u64)(0x01078e111c3556cbLL)), ((u64)(0xa4aee003712230b2ULL)), ((u64)(0x014971956342ac7eLL)), ((u64)(0x4dda98044d6abcdfLL)), ((u64)(0x019bcdfabc13579eLL)), ((u64)(0xf0a89f02b062b60bULL)), ((u64)(0x010160bcb58c16c2LL)), 
((u64)(0xacd2c6c35c7b638eULL)), ((u64)(0x0141b8ebe2ef1c73LL)), ((u64)(0x98077874339a3c71ULL)), ((u64)(0x01922726dbaae390LL)), ((u64)(0xbe0956914080cb8eULL)), ((u64)(0x01f6b0f092959c74LL)), ((u64)(0xf6c5d61ac8507f38ULL)), ((u64)(0x013a2e965b9d81c8LL)), ((u64)(0x34774ba17a649f07LL)), ((u64)(0x0188ba3bf284e23bLL)), ((u64)(0x01951e89d8fdc6c8LL)), ((u64)(0x01eae8caef261acaLL)), ((u64)(0x40fd3316279e9c3dLL)), ((u64)(0x0132d17ed577d0beLL)), ((u64)(0xd13c7fdbb186434cULL)), ((u64)(0x017f85de8ad5c4edLL)), 
((u64)(0x458b9fd29de7d420LL)), ((u64)(0x01df67562d8b3629LL)), ((u64)(0xcb7743e3a2b0e494ULL)), ((u64)(0x012ba095dc7701d9LL)), ((u64)(0x3e5514dc8b5d1db9LL)), ((u64)(0x017688bb5394c250LL)), ((u64)(0x4dea5a13ae346527LL)), ((u64)(0x01d42aea2879f2e4LL)), ((u64)(0xb0b2784c4ce0bf38ULL)), ((u64)(0x01249ad2594c37ceLL)), ((u64)(0x5cdf165f6018ef06LL)), ((u64)(0x016dc186ef9f45c2LL)), ((u64)(0xf416dbf7381f2ac8ULL)), ((u64)(0x01c931e8ab871732LL)), ((u64)(0xd88e497a83137abdULL)), ((u64)(0x011dbf316b346e7fLL)), 
((u64)(0xceb1dbd923d8596cULL)), ((u64)(0x01652efdc6018a1fLL)), ((u64)(0xc25e52cf6cce6fc7ULL)), ((u64)(0x01be7abd3781eca7LL)), ((u64)(0xd97af3c1a40105dcULL)), ((u64)(0x01170cb642b133e8LL)), ((u64)(0x0fd9b0b20d014754LL)), ((u64)(0x015ccfe3d35d80e3LL)), ((u64)(0xd3d01cde90419929ULL)), ((u64)(0x01b403dcc834e11bLL)), ((u64)(0x6462120b1a28ffb9LL)), ((u64)(0x01108269fd210cb1LL)), ((u64)(0xbd7a968de0b33fa8ULL)), ((u64)(0x0154a3047c694fddLL)), ((u64)(0x2cd93c3158e00f92LL)), ((u64)(0x01a9cbc59b83a3d5LL)), 
((u64)(0x3c07c59ed78c09bbLL)), ((u64)(0x010a1f5b81324665LL)), ((u64)(0x8b09b7068d6f0c2aULL)), ((u64)(0x014ca732617ed7feLL)), ((u64)(0x2dcc24c830cacf34LL)), ((u64)(0x019fd0fef9de8dfeLL)), ((u64)(0xdc9f96fd1e7ec180ULL)), ((u64)(0x0103e29f5c2b18beLL)), ((u64)(0x93c77cbc661e71e1ULL)), ((u64)(0x0144db473335deeeLL)), ((u64)(0x38b95beb7fa60e59LL)), ((u64)(0x01961219000356aaLL)), ((u64)(0xc6e7b2e65f8f91efULL)), ((u64)(0x01fb969f40042c54LL)), ((u64)(0xfc50cfcffbb9bb35ULL)), ((u64)(0x013d3e2388029bb4LL)), 
((u64)(0x3b6503c3faa82a03LL)), ((u64)(0x018c8dac6a0342a2LL)), ((u64)(0xca3e44b4f9523484ULL)), ((u64)(0x01efb1178484134aLL)), ((u64)(0xbe66eaf11bd360d2ULL)), ((u64)(0x0135ceaeb2d28c0eLL)), ((u64)(0x6e00a5ad62c83907LL)), ((u64)(0x0183425a5f872f12LL)), ((u64)(0x0980cf18bb7a4749LL)), ((u64)(0x01e412f0f768fad7LL)), ((u64)(0x65f0816f752c6c8dLL)), ((u64)(0x012e8bd69aa19cc6LL)), ((u64)(0xff6ca1cb527787b1ULL)), ((u64)(0x017a2ecc414a03f7LL)), ((u64)(0xff47ca3e2715699dULL)), ((u64)(0x01d8ba7f519c84f5LL)), 
((u64)(0xbf8cde66d86d6202ULL)), ((u64)(0x0127748f9301d319LL)), ((u64)(0x2f7016008e88ba83LL)), ((u64)(0x017151b377c247e0LL)), ((u64)(0x3b4c1b80b22ae923LL)), ((u64)(0x01cda62055b2d9d8LL)), ((u64)(0x250f91306f5ad1b6LL)), ((u64)(0x012087d4358fc827LL)), ((u64)(0xee53757c8b318623ULL)), ((u64)(0x0168a9c942f3ba30LL)), ((u64)(0x29e852dbadfde7acLL)), ((u64)(0x01c2d43b93b0a8bdLL)), ((u64)(0x3a3133c94cbeb0ccLL)), ((u64)(0x0119c4a53c4e6976LL)), ((u64)(0xc8bd80bb9fee5cffULL)), ((u64)(0x016035ce8b6203d3LL)), 
((u64)(0xbaece0ea87e9f43eULL)), ((u64)(0x01b843422e3a84c8LL)), ((u64)(0x74d40c9294f238a7LL)), ((u64)(0x01132a095ce492fdLL)), ((u64)(0xd2090fb73a2ec6d1ULL)), ((u64)(0x0157f48bb41db7bcLL)), ((u64)(0x068b53a508ba7885LL)), ((u64)(0x01adf1aea12525acLL)), ((u64)(0x8417144725748b53ULL)), ((u64)(0x010cb70d24b7378bLL)), ((u64)(0x651cd958eed1ae28LL)), ((u64)(0x014fe4d06de5056eLL)), ((u64)(0xfe640faf2a8619b2ULL)), ((u64)(0x01a3de04895e46c9LL)), ((u64)(0x3efe89cd7a93d00fLL)), ((u64)(0x01066ac2d5daec3eLL)), 
((u64)(0xcebe2c40d938c413ULL)), ((u64)(0x014805738b51a74dLL)), ((u64)(0x426db7510f86f518LL)), ((u64)(0x019a06d06e261121LL)), ((u64)(0xc9849292a9b4592fULL)), ((u64)(0x0100444244d7cab4LL)), ((u64)(0xfbe5b73754216f7aULL)), ((u64)(0x01405552d60dbd61LL)), ((u64)(0x7adf25052929cb59LL)), ((u64)(0x01906aa78b912cbaLL)), ((u64)(0x1996ee4673743e2fLL)), ((u64)(0x01f485516e7577e9LL)), ((u64)(0xaffe54ec0828a6ddULL)), ((u64)(0x0138d352e5096af1LL)), ((u64)(0x1bfdea270a32d095LL)), ((u64)(0x018708279e4bc5aeLL)), 
((u64)(0xa2fd64b0ccbf84baULL)), ((u64)(0x01e8ca3185deb719LL)), ((u64)(0x05de5eee7ff7b2f4LL)), ((u64)(0x01317e5ef3ab3270LL)), ((u64)(0x0755f6aa1ff59fb1LL)), ((u64)(0x017dddf6b095ff0cLL)), ((u64)(0x092b7454a7f3079eLL)), ((u64)(0x01dd55745cbb7ecfLL)), ((u64)(0x65bb28b4e8f7e4c3LL)), ((u64)(0x012a5568b9f52f41LL)), ((u64)(0xbf29f2e22335ddf3ULL)), ((u64)(0x0174eac2e8727b11LL)), ((u64)(0x2ef46f9aac035570LL)), ((u64)(0x01d22573a28f19d6LL)), ((u64)(0xdd58c5c0ab821566ULL)), ((u64)(0x0123576845997025LL)), 
((u64)(0x54aef730d6629ac0LL)), ((u64)(0x016c2d4256ffcc2fLL)), ((u64)(0x29dab4fd0bfb4170LL)), ((u64)(0x01c73892ecbfbf3bLL)), ((u64)(0xfa28b11e277d08e6ULL)), ((u64)(0x011c835bd3f7d784LL)), ((u64)(0x38b2dd65b15c4b1fLL)), ((u64)(0x0163a432c8f5cd66LL)), ((u64)(0xc6df94bf1db35de7ULL)), ((u64)(0x01bc8d3f7b3340bfLL)), ((u64)(0xdc4bbcf772901ab0ULL)), ((u64)(0x0115d847ad000877LL)), ((u64)(0xd35eac354f34215cULL)), ((u64)(0x015b4e5998400a95LL)), ((u64)(0x48365742a30129b4LL)), ((u64)(0x01b221effe500d3bLL)), 
((u64)(0x0d21f689a5e0ba10LL)), ((u64)(0x010f5535fef20845LL)), ((u64)(0x506a742c0f58e894LL)), ((u64)(0x01532a837eae8a56LL)), ((u64)(0xe4851137132f22b9ULL)), ((u64)(0x01a7f5245e5a2cebLL)), ((u64)(0x6ed32ac26bfd75b4LL)), ((u64)(0x0108f936baf85c13LL)), ((u64)(0x4a87f57306fcd321LL)), ((u64)(0x014b378469b67318LL)), ((u64)(0x5d29f2cfc8bc07e9LL)), ((u64)(0x019e056584240fdeLL)), ((u64)(0xfa3a37c1dd7584f1ULL)), ((u64)(0x0102c35f729689eaLL)), ((u64)(0xb8c8c5b254d2e62eULL)), ((u64)(0x014374374f3c2c65LL)), 
((u64)(0x26faf71eea079fb9LL)), ((u64)(0x01945145230b377fLL)), ((u64)(0xf0b9b4e6a48987a8ULL)), ((u64)(0x01f965966bce055eLL)), ((u64)(0x5674111026d5f4c9LL)), ((u64)(0x013bdf7e0360c35bLL)), ((u64)(0x2c111554308b71fbLL)), ((u64)(0x018ad75d8438f432LL)), ((u64)(0xb7155aa93cae4e7aULL)), ((u64)(0x01ed8d34e547313eLL)), ((u64)(0x326d58a9c5ecf10cLL)), ((u64)(0x013478410f4c7ec7LL)), ((u64)(0xff08aed437682d4fULL)), ((u64)(0x01819651531f9e78LL)), ((u64)(0x3ecada89454238a3LL)), ((u64)(0x01e1fbe5a7e78617LL)), 
((u64)(0x873ec895cb496366ULL)), ((u64)(0x012d3d6f88f0b3ceLL)), ((u64)(0x290e7abb3e1bbc3fLL)), ((u64)(0x01788ccb6b2ce0c2LL)), ((u64)(0xb352196a0da2ab4fULL)), ((u64)(0x01d6affe45f818f2LL)), ((u64)(0xb0134fe24885ab11ULL)), ((u64)(0x01262dfeebbb0f97LL)), ((u64)(0x9c1823dadaa715d6ULL)), ((u64)(0x016fb97ea6a9d37dLL)), ((u64)(0x031e2cd19150db4bLL)), ((u64)(0x01cba7de5054485dLL)), ((u64)(0x21f2dc02fad2890fLL)), ((u64)(0x011f48eaf234ad3aLL)), ((u64)(0xaa6f9303b9872b53ULL)), ((u64)(0x01671b25aec1d888LL)), 
((u64)(0xd50b77c4a7e8f628ULL)), ((u64)(0x01c0e1ef1a724eaaLL)), ((u64)(0xc5272adae8f199d9ULL)), ((u64)(0x01188d357087712aLL)), ((u64)(0x7670f591a32e004fLL)), ((u64)(0x015eb082cca94d75LL)), ((u64)(0xd40d32f60bf98063ULL)), ((u64)(0x01b65ca37fd3a0d2LL)), ((u64)(0xc4883fd9c77bf03eULL)), ((u64)(0x0111f9e62fe44483LL)), ((u64)(0xb5aa4fd0395aec4dULL)), ((u64)(0x0156785fbbdd55a4LL)), ((u64)(0xe314e3c447b1a760ULL)), ((u64)(0x01ac1677aad4ab0dLL)), ((u64)(0xaded0e5aaccf089cULL)), ((u64)(0x010b8e0acac4eae8LL)), 
((u64)(0xd96851f15802cac3ULL)), ((u64)(0x014e718d7d7625a2LL)), ((u64)(0x8fc2666dae037d74ULL)), ((u64)(0x01a20df0dcd3af0bLL)), ((u64)(0x39d980048cc22e68LL)), ((u64)(0x010548b68a044d67LL)), ((u64)(0x084fe005aff2ba03LL)), ((u64)(0x01469ae42c8560c1LL)), ((u64)(0x4a63d8071bef6883LL)), ((u64)(0x0198419d37a6b8f1LL)), ((u64)(0x9cfcce08e2eb42a4ULL)), ((u64)(0x01fe52048590672dLL)), ((u64)(0x821e00c58dd309a7ULL)), ((u64)(0x013ef342d37a407cLL)), ((u64)(0xa2a580f6f147cc10ULL)), ((u64)(0x018eb0138858d09bLL)), 
((u64)(0x8b4ee134ad99bf15ULL)), ((u64)(0x01f25c186a6f04c2LL)), ((u64)(0x97114cc0ec80176dULL)), ((u64)(0x0137798f428562f9LL)), ((u64)(0xfcd59ff127a01d48ULL)), ((u64)(0x018557f31326bbb7LL)), ((u64)(0xfc0b07ed7188249aULL)), ((u64)(0x01e6adefd7f06aa5LL)), ((u64)(0xbd86e4f466f516e0ULL)), ((u64)(0x01302cb5e6f642a7LL)), ((u64)(0xace89e3180b25c98ULL)), ((u64)(0x017c37e360b3d351LL)), ((u64)(0x1822c5bde0def3beLL)), ((u64)(0x01db45dc38e0c826LL)), ((u64)(0xcf15bb96ac8b5857ULL)), ((u64)(0x01290ba9a38c7d17LL)), 
((u64)(0xc2db2a7c57ae2e6dULL)), ((u64)(0x01734e940c6f9c5dLL)), ((u64)(0x3391f51b6d99ba08LL)), ((u64)(0x01d022390f8b8375LL)), ((u64)(0x403b393124801445LL)), ((u64)(0x01221563a9b73229LL)), ((u64)(0x904a077d6da01956ULL)), ((u64)(0x016a9abc9424feb3LL)), ((u64)(0x745c895cc9081facLL)), ((u64)(0x01c5416bb92e3e60LL)), ((u64)(0x48b9d5d9fda513cbLL)), ((u64)(0x011b48e353bce6fcLL)), ((u64)(0x5ae84b507d0e58beLL)), ((u64)(0x01621b1c28ac20bbLL)), ((u64)(0x31a25e249c51eeeeLL)), ((u64)(0x01baa1e332d728eaLL)), 
((u64)(0x5f057ad6e1b33554LL)), ((u64)(0x0114a52dffc67992LL)), ((u64)(0xf6c6d98c9a2002aaULL)), ((u64)(0x0159ce797fb817f6LL)), ((u64)(0xb4788fefc0a80354ULL)), ((u64)(0x01b04217dfa61df4LL)), ((u64)(0xf0cb59f5d8690214ULL)), ((u64)(0x010e294eebc7d2b8LL)), ((u64)(0x2cfe30734e83429aLL)), ((u64)(0x0151b3a2a6b9c767LL)), ((u64)(0xf83dbc9022241340ULL)), ((u64)(0x01a6208b50683940LL)), ((u64)(0x9b2695da15568c08ULL)), ((u64)(0x0107d457124123c8LL)), ((u64)(0xc1f03b509aac2f0aULL)), ((u64)(0x0149c96cd6d16cbaLL)), 
((u64)(0x726c4a24c1573acdLL)), ((u64)(0x019c3bc80c85c7e9LL)), ((u64)(0xe783ae56f8d684c0ULL)), ((u64)(0x0101a55d07d39cf1LL)), ((u64)(0x616499ecb70c25f0LL)), ((u64)(0x01420eb449c8842eLL)), ((u64)(0xf9bdc067e4cf2f6cULL)), ((u64)(0x019292615c3aa539LL)), ((u64)(0x782d3081de02fb47LL)), ((u64)(0x01f736f9b3494e88LL)), ((u64)(0x4b1c3e512ac1dd0cLL)), ((u64)(0x013a825c100dd115LL)), ((u64)(0x9de34de57572544fULL)), ((u64)(0x018922f31411455aLL)), ((u64)(0x455c215ed2cee963LL)), ((u64)(0x01eb6bafd91596b1LL)), 
((u64)(0xcb5994db43c151deULL)), ((u64)(0x0133234de7ad7e2eLL)), ((u64)(0x7e2ffa1214b1a655LL)), ((u64)(0x017fec216198ddbaLL)), ((u64)(0x1dbbf89699de0febLL)), ((u64)(0x01dfe729b9ff1529LL)), ((u64)(0xb2957b5e202ac9f3ULL)), ((u64)(0x012bf07a143f6d39LL)), ((u64)(0x1f3ada35a8357c6fLL)), ((u64)(0x0176ec98994f4888LL)), ((u64)(0x270990c31242db8bLL)), ((u64)(0x01d4a7bebfa31aaaLL)), ((u64)(0x5865fa79eb69c937LL)), ((u64)(0x0124e8d737c5f0aaLL)), ((u64)(0xee7f791866443b85ULL)), ((u64)(0x016e230d05b76cd4LL)), 
((u64)(0x2a1f575e7fd54a66LL)), ((u64)(0x01c9abd04725480aLL)), ((u64)(0x5a53969b0fe54e80LL)), ((u64)(0x011e0b622c774d06LL)), ((u64)(0xf0e87c41d3dea220ULL)), ((u64)(0x01658e3ab7952047LL)), ((u64)(0xed229b5248d64aa8ULL)), ((u64)(0x01bef1c9657a6859LL)), ((u64)(0x3435a1136d85eea9LL)), ((u64)(0x0117571ddf6c8138LL)), ((u64)(0x4143095848e76a53LL)), ((u64)(0x015d2ce55747a186LL)), ((u64)(0xd193cbae5b2144e8ULL)), ((u64)(0x01b4781ead1989e7LL)), ((u64)(0xe2fc5f4cf8f4cb11ULL)), ((u64)(0x0110cb132c2ff630LL)), 
((u64)(0x1bbb77203731fdd5LL)), ((u64)(0x0154fdd7f73bf3bdLL)), ((u64)(0x62aa54e844fe7d4aLL)), ((u64)(0x01aa3d4df50af0acLL)), ((u64)(0xbdaa75112b1f0e4eULL)), ((u64)(0x010a6650b926d66bLL)), ((u64)(0xad15125575e6d1e2ULL)), ((u64)(0x014cffe4e7708c06LL)), ((u64)(0x585a56ead360865bLL)), ((u64)(0x01a03fde214caf08LL)), ((u64)(0x37387652c41c53f8LL)), ((u64)(0x010427ead4cfed65LL)), ((u64)(0x850693e7752368f7ULL)), ((u64)(0x014531e58a03e8beLL)), ((u64)(0x264838e1526c4334LL)), ((u64)(0x01967e5eec84e2eeLL)), 
((u64)(0xafda4719a7075402ULL)), ((u64)(0x01fc1df6a7a61ba9LL)), ((u64)(0x0de86c7008649481LL)), ((u64)(0x013d92ba28c7d14aLL)), ((u64)(0x9162878c0a7db9a1ULL)), ((u64)(0x018cf768b2f9c59cLL)), ((u64)(0xb5bb296f0d1d280aULL)), ((u64)(0x01f03542dfb83703LL)), ((u64)(0x5194f9e568323906LL)), ((u64)(0x01362149cbd32262LL)), ((u64)(0xe5fa385ec23ec747ULL)), ((u64)(0x0183a99c3ec7eafaLL)), ((u64)(0x9f78c67672ce7919ULL)), ((u64)(0x01e494034e79e5b9LL)), ((u64)(0x03ab7c0a07c10bb0LL)), ((u64)(0x012edc82110c2f94LL)), 
((u64)(0x04965b0c89b14e9cLL)), ((u64)(0x017a93a2954f3b79LL)), ((u64)(0x45bbf1cfac1da243LL)), ((u64)(0x01d9388b3aa30a57LL)), ((u64)(0x8b957721cb92856aULL)), ((u64)(0x0127c35704a5e676LL)), ((u64)(0x2e7ad4ea3e7726c4LL)), ((u64)(0x0171b42cc5cf6014LL)), ((u64)(0x3a198a24ce14f075LL)), ((u64)(0x01ce2137f7433819LL)), ((u64)(0xc44ff65700cd1649ULL)), ((u64)(0x0120d4c2fa8a030fLL)), ((u64)(0xb563f3ecc1005bdbULL)), ((u64)(0x016909f3b92c83d3LL)), ((u64)(0xa2bcf0e7f14072d2ULL)), ((u64)(0x01c34c70a777a4c8LL)), 
((u64)(0x65b61690f6c847c3LL)), ((u64)(0x011a0fc668aac6fdLL)), ((u64)(0xbf239c35347a59b4ULL)), ((u64)(0x016093b802d578bcLL)), ((u64)(0xeeec83428198f021ULL)), ((u64)(0x01b8b8a6038ad6ebLL)), ((u64)(0x7553d20990ff9615LL)), ((u64)(0x01137367c236c653LL)), ((u64)(0x52a8c68bf53f7b9aLL)), ((u64)(0x01585041b2c477e8LL)), ((u64)(0x6752f82ef28f5a81LL)), ((u64)(0x01ae64521f7595e2LL)), ((u64)(0x8093db1d57999890ULL)), ((u64)(0x010cfeb353a97dadLL)), ((u64)(0xe0b8d1e4ad7ffeb4ULL)), ((u64)(0x01503e602893dd18LL)), 
((u64)(0x18e7065dd8dffe62LL)), ((u64)(0x01a44df832b8d45fLL)), ((u64)(0x6f9063faa78bfefdLL)), ((u64)(0x0106b0bb1fb384bbLL)), ((u64)(0x4b747cf9516efebcLL)), ((u64)(0x01485ce9e7a065eaLL)), ((u64)(0xde519c37a5cabe6bULL)), ((u64)(0x019a742461887f64LL)), ((u64)(0x0af301a2c79eb703LL)), ((u64)(0x01008896bcf54f9fLL)), ((u64)(0xcdafc20b798664c4ULL)), ((u64)(0x0140aabc6c32a386LL)), ((u64)(0x811bb28e57e7fdf5ULL)), ((u64)(0x0190d56b873f4c68LL)), ((u64)(0xa1629f31ede1fd72ULL)), ((u64)(0x01f50ac6690f1f82LL)), 
((u64)(0xa4dda37f34ad3e67ULL)), ((u64)(0x013926bc01a973b1LL)), ((u64)(0x0e150c5f01d88e01LL)), ((u64)(0x0187706b0213d09eLL)), ((u64)(0x919a4f76c24eb181ULL)), ((u64)(0x01e94c85c298c4c5LL)), ((u64)(0x7b0071aa39712ef1LL)), ((u64)(0x0131cfd3999f7afbLL)), ((u64)(0x59c08e14c7cd7aadLL)), ((u64)(0x017e43c8800759baLL)), ((u64)(0xf030b199f9c0d958ULL)), ((u64)(0x01ddd4baa0093028LL)), ((u64)(0x961e6f003c1887d7ULL)), ((u64)(0x012aa4f4a405be19LL)), ((u64)(0xfba60ac04b1ea9cdULL)), ((u64)(0x01754e31cd072d9fLL)), 
((u64)(0xfa8f8d705de65440ULL)), ((u64)(0x01d2a1be4048f907LL)), ((u64)(0xfc99b8663aaff4a8ULL)), ((u64)(0x0123a516e82d9ba4LL)), ((u64)(0x3bc0267fc95bf1d2LL)), ((u64)(0x016c8e5ca239028eLL)), ((u64)(0xcab0301fbbb2ee47ULL)), ((u64)(0x01c7b1f3cac74331LL)), ((u64)(0x1eae1e13d54fd4ecLL)), ((u64)(0x011ccf385ebc89ffLL)), ((u64)(0xe659a598caa3ca27ULL)), ((u64)(0x01640306766bac7eLL)), ((u64)(0x9ff00efefd4cbcb1ULL)), ((u64)(0x01bd03c81406979eLL)), ((u64)(0x23f6095f5e4ff5efLL)), ((u64)(0x0116225d0c841ec3LL)), 
((u64)(0xecf38bb735e3f36aULL)), ((u64)(0x015baaf44fa52673LL)), ((u64)(0xe8306ea5035cf045ULL)), ((u64)(0x01b295b1638e7010LL)), ((u64)(0x911e4527221a162bULL)), ((u64)(0x010f9d8ede39060aLL)), ((u64)(0x3565d670eaa09bb6LL)), ((u64)(0x015384f295c7478dLL)), ((u64)(0x82bf4c0d2548c2a3ULL)), ((u64)(0x01a8662f3b391970LL)), ((u64)(0x51b78f88374d79a6LL)), ((u64)(0x01093fdd8503afe6LL)), ((u64)(0xe625736a4520d810ULL)), ((u64)(0x014b8fd4e6449bdfLL)), ((u64)(0xdfaed044d6690e14ULL)), ((u64)(0x019e73ca1fd5c2d7LL)), ((u64)(0xebcd422b0601a8ccULL)), ((u64)(0x0103085e53e599c6LL)), ((u64)(0xa6c092b5c78212ffULL)), ((u64)(0x0143ca75e8df0038LL)), ((u64)(0xd070b763396297bfULL)), ((u64)(0x0194bd136316c046LL)), ((u64)(0x848ce53c07bb3dafULL)), ((u64)(0x01f9ec583bdc7058LL)), ((u64)(0x52d80f4584d5068dLL)), ((u64)(0x013c33b72569c637LL)), ((u64)(0x278e1316e60a4831LL)), ((u64)(0x018b40a4eec437c5LL))}; // fixed array const
Array_fixed_u64_584 _const_strconv__pow5_inv_split_64_x = {((u64)(0x0000000000000001)), ((u64)(0x0400000000000000LL)), ((u64)(0x3333333333333334LL)), ((u64)(0x0333333333333333LL)), ((u64)(0x28f5c28f5c28f5c3LL)), ((u64)(0x028f5c28f5c28f5cLL)), ((u64)(0xed916872b020c49cULL)), ((u64)(0x020c49ba5e353f7cLL)), ((u64)(0xaf4f0d844d013a93ULL)), ((u64)(0x0346dc5d63886594LL)), ((u64)(0x8c3f3e0370cdc876ULL)), ((u64)(0x029f16b11c6d1e10LL)), ((u64)(0xd698fe69270b06c5ULL)), ((u64)(0x0218def416bdb1a6LL)), ((u64)(0xf0f4ca41d811a46eULL)), ((u64)(0x035afe535795e90aLL)), 
((u64)(0xf3f70834acdae9f1ULL)), ((u64)(0x02af31dc4611873bLL)), ((u64)(0x5cc5a02a23e254c1LL)), ((u64)(0x0225c17d04dad296LL)), ((u64)(0xfad5cd10396a2135ULL)), ((u64)(0x036f9bfb3af7b756LL)), ((u64)(0xfbde3da69454e75eULL)), ((u64)(0x02bfaffc2f2c92abLL)), ((u64)(0x2fe4fe1edd10b918LL)), ((u64)(0x0232f33025bd4223LL)), ((u64)(0x4ca19697c81ac1bfLL)), ((u64)(0x0384b84d092ed038LL)), ((u64)(0x3d4e1213067bce33LL)), ((u64)(0x02d09370d4257360LL)), ((u64)(0x643e74dc052fd829LL)), ((u64)(0x024075f3dceac2b3LL)), 
((u64)(0x6d30baf9a1e626a7LL)), ((u64)(0x039a5652fb113785LL)), ((u64)(0x2426fbfae7eb5220LL)), ((u64)(0x02e1dea8c8da92d1LL)), ((u64)(0x1cebfcc8b9890e80LL)), ((u64)(0x024e4bba3a487574LL)), ((u64)(0x94acc7a78f41b0ccULL)), ((u64)(0x03b07929f6da5586LL)), ((u64)(0xaa23d2ec729af3d7ULL)), ((u64)(0x02f394219248446bLL)), ((u64)(0xbb4fdbf05baf2979ULL)), ((u64)(0x025c768141d369efLL)), ((u64)(0xc54c931a2c4b758dULL)), ((u64)(0x03c7240202ebdcb2LL)), ((u64)(0x9dd6dc14f03c5e0bULL)), ((u64)(0x0305b66802564a28LL)), 
((u64)(0x4b1249aa59c9e4d6LL)), ((u64)(0x026af8533511d4edLL)), ((u64)(0x44ea0f76f60fd489LL)), ((u64)(0x03de5a1ebb4fbb15LL)), ((u64)(0x6a54d92bf80caa07LL)), ((u64)(0x0318481895d96277LL)), ((u64)(0x21dd7a89933d54d2LL)), ((u64)(0x0279d346de4781f9LL)), ((u64)(0x362f2a75b8622150LL)), ((u64)(0x03f61ed7ca0c0328LL)), ((u64)(0xf825bb91604e810dULL)), ((u64)(0x032b4bdfd4d668ecLL)), ((u64)(0xc684960de6a5340bULL)), ((u64)(0x0289097fdd7853f0LL)), ((u64)(0xd203ab3e521dc33cULL)), ((u64)(0x02073accb12d0ff3LL)), 
((u64)(0xe99f7863b696052cULL)), ((u64)(0x033ec47ab514e652LL)), ((u64)(0x87b2c6b62bab3757ULL)), ((u64)(0x02989d2ef743eb75LL)), ((u64)(0xd2f56bc4efbc2c45ULL)), ((u64)(0x0213b0f25f69892aLL)), ((u64)(0x1e55793b192d13a2LL)), ((u64)(0x0352b4b6ff0f41deLL)), ((u64)(0x4b77942f475742e8LL)), ((u64)(0x02a8909265a5ce4bLL)), ((u64)(0xd5f9435905df68baULL)), ((u64)(0x022073a8515171d5LL)), ((u64)(0x565b9ef4d6324129LL)), ((u64)(0x03671f73b54f1c89LL)), ((u64)(0xdeafb25d78283421ULL)), ((u64)(0x02b8e5f62aa5b06dLL)), 
((u64)(0x188c8eb12cecf681LL)), ((u64)(0x022d84c4eeeaf38bLL)), ((u64)(0x8dadb11b7b14bd9bULL)), ((u64)(0x037c07a17e44b8deLL)), ((u64)(0x7157c0e2c8dd647cLL)), ((u64)(0x02c99fb46503c718LL)), ((u64)(0x8ddfcd823a4ab6caULL)), ((u64)(0x023ae629ea696c13LL)), ((u64)(0x1632e269f6ddf142LL)), ((u64)(0x0391704310a8acecLL)), ((u64)(0x44f581ee5f17f435LL)), ((u64)(0x02dac035a6ed5723LL)), ((u64)(0x372ace584c1329c4LL)), ((u64)(0x024899c4858aac1cLL)), ((u64)(0xbeaae3c079b842d3ULL)), ((u64)(0x03a75c6da27779c6LL)), 
((u64)(0x6555830061603576LL)), ((u64)(0x02ec49f14ec5fb05LL)), ((u64)(0xb7779c004de6912bULL)), ((u64)(0x0256a18dd89e626aLL)), ((u64)(0xf258f99a163db512ULL)), ((u64)(0x03bdcf495a9703ddLL)), ((u64)(0x5b7a614811caf741LL)), ((u64)(0x02fe3f6de212697eLL)), ((u64)(0xaf951aa00e3bf901ULL)), ((u64)(0x0264ff8b1b41edfeLL)), ((u64)(0x7f54f7667d2cc19bLL)), ((u64)(0x03d4cc11c5364997LL)), ((u64)(0x32aa5f8530f09ae3LL)), ((u64)(0x0310a3416a91d479LL)), ((u64)(0xf55519375a5a1582ULL)), ((u64)(0x0273b5cdeedb1060LL)), 
((u64)(0xbbbb5b8bc3c3559dULL)), ((u64)(0x03ec56164af81a34LL)), ((u64)(0x2fc916096969114aLL)), ((u64)(0x03237811d593482aLL)), ((u64)(0x596dab3ababa743cLL)), ((u64)(0x0282c674aadc39bbLL)), ((u64)(0x478aef622efb9030LL)), ((u64)(0x0202385d557cfafcLL)), ((u64)(0xd8de4bd04b2c19e6ULL)), ((u64)(0x0336c0955594c4c6LL)), ((u64)(0xad7ea30d08f014b8ULL)), ((u64)(0x029233aaaadd6a38LL)), ((u64)(0x24654f3da0c01093LL)), ((u64)(0x020e8fbbbbe454faLL)), ((u64)(0x3a3bb1fc346680ebLL)), ((u64)(0x034a7f92c63a2190LL)), 
((u64)(0x94fc8e635d1ecd89ULL)), ((u64)(0x02a1ffa89e94e7a6LL)), ((u64)(0xaa63a51c4a7f0ad4ULL)), ((u64)(0x021b32ed4baa52ebLL)), ((u64)(0xdd6c3b607731aaedULL)), ((u64)(0x035eb7e212aa1e45LL)), ((u64)(0x1789c919f8f488bdLL)), ((u64)(0x02b22cb4dbbb4b6bLL)), ((u64)(0xac6e3a7b2d906d64ULL)), ((u64)(0x022823c3e2fc3c55LL)), ((u64)(0x13e390c515b3e23aLL)), ((u64)(0x03736c6c9e606089LL)), ((u64)(0xdcb60d6a77c31b62ULL)), ((u64)(0x02c2bd23b1e6b3a0LL)), ((u64)(0x7d5e7121f968e2b5LL)), ((u64)(0x0235641c8e52294dLL)), 
((u64)(0xc8971b698f0e3787ULL)), ((u64)(0x0388a02db0837548LL)), ((u64)(0xa078e2bad8d82c6cULL)), ((u64)(0x02d3b357c0692aa0LL)), ((u64)(0xe6c71bc8ad79bd24ULL)), ((u64)(0x0242f5dfcd20eee6LL)), ((u64)(0x0ad82c7448c2c839LL)), ((u64)(0x039e5632e1ce4b0bLL)), ((u64)(0x3be023903a356cfaLL)), ((u64)(0x02e511c24e3ea26fLL)), ((u64)(0x2fe682d9c82abd95LL)), ((u64)(0x0250db01d8321b8cLL)), ((u64)(0x4ca4048fa6aac8eeLL)), ((u64)(0x03b4919c8d1cf8e0LL)), ((u64)(0x3d5003a61eef0725LL)), ((u64)(0x02f6dae3a4172d80LL)), 
((u64)(0x9773361e7f259f51ULL)), ((u64)(0x025f1582e9ac2466LL)), ((u64)(0x8beb89ca6508fee8ULL)), ((u64)(0x03cb559e42ad070aLL)), ((u64)(0x6fefa16eb73a6586LL)), ((u64)(0x0309114b688a6c08LL)), ((u64)(0xf3261abef8fb846bULL)), ((u64)(0x026da76f86d52339LL)), ((u64)(0x51d691318e5f3a45LL)), ((u64)(0x03e2a57f3e21d1f6LL)), ((u64)(0x0e4540f471e5c837LL)), ((u64)(0x031bb798fe8174c5LL)), ((u64)(0xd8376729f4b7d360ULL)), ((u64)(0x027c92e0cb9ac3d0LL)), ((u64)(0xf38bd84321261effULL)), ((u64)(0x03fa849adf5e061aLL)), 
((u64)(0x293cad0280eb4bffLL)), ((u64)(0x032ed07be5e4d1afLL)), ((u64)(0xedca240200bc3cccULL)), ((u64)(0x028bd9fcb7ea4158LL)), ((u64)(0xbe3b50019a3030a4ULL)), ((u64)(0x02097b309321cde0LL)), ((u64)(0xc9f88002904d1a9fULL)), ((u64)(0x03425eb41e9c7c9aLL)), ((u64)(0x3b2d3335403daee6LL)), ((u64)(0x029b7ef67ee396e2LL)), ((u64)(0x95bdc291003158b8ULL)), ((u64)(0x0215ff2b98b6124eLL)), ((u64)(0x892f9db4cd1bc126ULL)), ((u64)(0x035665128df01d4aLL)), ((u64)(0x07594af70a7c9a85LL)), ((u64)(0x02ab840ed7f34aa2LL)), 
((u64)(0x6c476f2c0863aed1LL)), ((u64)(0x0222d00bdff5d54eLL)), ((u64)(0x13a57eacda3917b4LL)), ((u64)(0x036ae67966562217LL)), ((u64)(0x0fb7988a482dac90LL)), ((u64)(0x02bbeb9451de81acLL)), ((u64)(0xd95fad3b6cf156daULL)), ((u64)(0x022fefa9db1867bcLL)), ((u64)(0xf565e1f8ae4ef15cULL)), ((u64)(0x037fe5dc91c0a5faLL)), ((u64)(0x911e4e608b725ab0ULL)), ((u64)(0x02ccb7e3a7cd5195LL)), ((u64)(0xda7ea51a0928488dULL)), ((u64)(0x023d5fe9530aa7aaLL)), ((u64)(0xf7310829a8407415ULL)), ((u64)(0x039566421e7772aaLL)), 
((u64)(0x2c2739baed005cdeLL)), ((u64)(0x02ddeb68185f8eefLL)), ((u64)(0xbcec2e2f24004a4bULL)), ((u64)(0x024b22b9ad193f25LL)), ((u64)(0x94ad16b1d333aa11ULL)), ((u64)(0x03ab6ac2ae8ecb6fLL)), ((u64)(0xaa241227dc2954dbULL)), ((u64)(0x02ef889bbed8a2bfLL)), ((u64)(0x54e9a81fe35443e2LL)), ((u64)(0x02593a163246e899LL)), ((u64)(0x2175d9cc9eed396aLL)), ((u64)(0x03c1f689ea0b0dc2LL)), ((u64)(0xe7917b0a18bdc788ULL)), ((u64)(0x03019207ee6f3e34LL)), ((u64)(0xb9412f3b46fe393aULL)), ((u64)(0x0267a8065858fe90LL)), 
((u64)(0xf535185ed7fd285cULL)), ((u64)(0x03d90cd6f3c1974dLL)), ((u64)(0xc42a79e57997537dULL)), ((u64)(0x03140a458fce12a4LL)), ((u64)(0x03552e512e12a931LL)), ((u64)(0x02766e9e0ca4dbb7LL)), ((u64)(0x9eeeb081e3510eb4ULL)), ((u64)(0x03f0b0fce107c5f1LL)), ((u64)(0x4bf226ce4f740bc3LL)), ((u64)(0x0326f3fd80d304c1LL)), ((u64)(0xa3281f0b72c33c9cULL)), ((u64)(0x02858ffe00a8d09aLL)), ((u64)(0x1c2018d5f568fd4aLL)), ((u64)(0x020473319a20a6e2LL)), ((u64)(0xf9ccf48988a7fba9ULL)), ((u64)(0x033a51e8f69aa49cLL)), 
((u64)(0xfb0a5d3ad3b99621ULL)), ((u64)(0x02950e53f87bb6e3LL)), ((u64)(0x2f3b7dc8a96144e7LL)), ((u64)(0x0210d8432d2fc583LL)), ((u64)(0xe52bfc7442353b0cULL)), ((u64)(0x034e26d1e1e608d1LL)), ((u64)(0xb756639034f76270ULL)), ((u64)(0x02a4ebdb1b1e6d74LL)), ((u64)(0x2c451c735d92b526LL)), ((u64)(0x021d897c15b1f12aLL)), ((u64)(0x13a1c71efc1deea3LL)), ((u64)(0x0362759355e981ddLL)), ((u64)(0x761b05b2634b2550LL)), ((u64)(0x02b52adc44bace4aLL)), ((u64)(0x91af37c1e908eaa6ULL)), ((u64)(0x022a88b036fbd83bLL)), 
((u64)(0x82b1f2cfdb417770ULL)), ((u64)(0x03774119f192f392LL)), ((u64)(0xcef4c23fe29ac5f3ULL)), ((u64)(0x02c5cdae5adbf60eLL)), ((u64)(0x3f2a34ffe87bd190LL)), ((u64)(0x0237d7beaf165e72LL)), ((u64)(0x984387ffda5fb5b2ULL)), ((u64)(0x038c8c644b56fd83LL)), ((u64)(0xe0360666484c915bULL)), ((u64)(0x02d6d6b6a2abfe02LL)), ((u64)(0x802b3851d3707449ULL)), ((u64)(0x024578921bbccb35LL)), ((u64)(0x99dec082ebe72075ULL)), ((u64)(0x03a25a835f947855LL)), ((u64)(0xae4bcd358985b391ULL)), ((u64)(0x02e8486919439377LL)), 
((u64)(0xbea30a913ad15c74ULL)), ((u64)(0x02536d20e102dc5fLL)), ((u64)(0xfdd1aa81f7b560b9ULL)), ((u64)(0x03b8ae9b019e2d65LL)), ((u64)(0x97daeece5fc44d61ULL)), ((u64)(0x02fa2548ce182451LL)), ((u64)(0xdfe258a51969d781ULL)), ((u64)(0x0261b76d71ace9daLL)), ((u64)(0x996a276e8f0fbf34ULL)), ((u64)(0x03cf8be24f7b0fc4LL)), ((u64)(0xe121b9253f3fcc2aULL)), ((u64)(0x030c6fe83f95a636LL)), ((u64)(0xb41afa8432997022ULL)), ((u64)(0x02705986994484f8LL)), ((u64)(0xecf7f739ea8f19cfULL)), ((u64)(0x03e6f5a4286da18dLL)), 
((u64)(0x23f99294bba5ae40LL)), ((u64)(0x031f2ae9b9f14e0bLL)), ((u64)(0x4ffadbaa2fb7be99LL)), ((u64)(0x027f5587c7f43e6fLL)), ((u64)(0x7ff7c5dd1925fdc2LL)), ((u64)(0x03feef3fa6539718LL)), ((u64)(0xccc637e4141e649bULL)), ((u64)(0x033258ffb842df46LL)), ((u64)(0xd704f983434b83afULL)), ((u64)(0x028ead9960357f6bLL)), ((u64)(0x126a6135cf6f9c8cLL)), ((u64)(0x020bbe144cf79923LL)), ((u64)(0x83dd685618b29414ULL)), ((u64)(0x0345fced47f28e9eLL)), ((u64)(0x9cb12044e08edcddULL)), ((u64)(0x029e63f1065ba54bLL)), 
((u64)(0x16f419d0b3a57d7dLL)), ((u64)(0x02184ff405161dd6LL)), ((u64)(0x8b20294dec3bfbfbULL)), ((u64)(0x035a19866e89c956LL)), ((u64)(0x3c19baa4bcfcc996LL)), ((u64)(0x02ae7ad1f207d445LL)), ((u64)(0xc9ae2eea30ca3adfULL)), ((u64)(0x02252f0e5b39769dLL)), ((u64)(0x0f7d17dd1add2afdLL)), ((u64)(0x036eb1b091f58a96LL)), ((u64)(0x3f97464a7be42264LL)), ((u64)(0x02bef48d41913babLL)), ((u64)(0xcc790508631ce850ULL)), ((u64)(0x02325d3dce0dc955LL)), ((u64)(0xe0c1a1a704fb0d4dULL)), ((u64)(0x0383c862e3494222LL)), 
((u64)(0x4d67b4859d95a43eLL)), ((u64)(0x02cfd3824f6dce82LL)), ((u64)(0x711fc39e17aae9cbLL)), ((u64)(0x023fdc683f8b0b9bLL)), ((u64)(0xe832d2968c44a945ULL)), ((u64)(0x039960a6cc11ac2bLL)), ((u64)(0xecf575453d03ba9eULL)), ((u64)(0x02e11a1f09a7bcefLL)), ((u64)(0x572ac4376402fbb1LL)), ((u64)(0x024dae7f3aec9726LL)), ((u64)(0x58446d256cd192b5LL)), ((u64)(0x03af7d985e47583dLL)), ((u64)(0x79d0575123dadbc4LL)), ((u64)(0x02f2cae04b6c4697LL)), ((u64)(0x94a6ac40e97be303ULL)), ((u64)(0x025bd5803c569edfLL)), 
((u64)(0x8771139b0f2c9e6cULL)), ((u64)(0x03c62266c6f0fe32LL)), ((u64)(0x9f8da948d8f07ebdULL)), ((u64)(0x0304e85238c0cb5bLL)), ((u64)(0xe60aedd3e0c06564ULL)), ((u64)(0x026a5374fa33d5e2LL)), ((u64)(0xa344afb9679a3bd2ULL)), ((u64)(0x03dd5254c3862304LL)), ((u64)(0xe903bfc78614fca8ULL)), ((u64)(0x031775109c6b4f36LL)), ((u64)(0xba6966393810ca20ULL)), ((u64)(0x02792a73b055d8f8LL)), ((u64)(0x2a423d2859b4769aLL)), ((u64)(0x03f510b91a22f4c1LL)), ((u64)(0xee9b642047c39215ULL)), ((u64)(0x032a73c7481bf700LL)), 
((u64)(0xbee2b680396941aaULL)), ((u64)(0x02885c9f6ce32c00LL)), ((u64)(0xff1bc53361210155ULL)), ((u64)(0x0206b07f8a4f5666LL)), ((u64)(0x31c6085235019bbbLL)), ((u64)(0x033de73276e5570bLL)), ((u64)(0x27d1a041c4014963LL)), ((u64)(0x0297ec285f1ddf3cLL)), ((u64)(0xeca7b367d0010782ULL)), ((u64)(0x021323537f4b18fcLL)), ((u64)(0xadd91f0c8001a59dULL)), ((u64)(0x0351d21f3211c194LL)), ((u64)(0xf17a7f3d3334847eULL)), ((u64)(0x02a7db4c280e3476LL)), ((u64)(0x279532975c2a0398LL)), ((u64)(0x021fe2a3533e905fLL)), 
((u64)(0xd8eeb75893766c26ULL)), ((u64)(0x0366376bb8641a31LL)), ((u64)(0x7a5892ad42c52352LL)), ((u64)(0x02b82c562d1ce1c1LL)), ((u64)(0xfb7a0ef102374f75ULL)), ((u64)(0x022cf044f0e3e7cdLL)), ((u64)(0xc59017e8038bb254ULL)), ((u64)(0x037b1a07e7d30c7cLL)), ((u64)(0x37a67986693c8eaaLL)), ((u64)(0x02c8e19feca8d6caLL)), ((u64)(0xf951fad1edca0bbbULL)), ((u64)(0x023a4e198a20abd4LL)), ((u64)(0x28832ae97c76792bLL)), ((u64)(0x03907cf5a9cddfbbLL)), ((u64)(0x2068ef21305ec756LL)), ((u64)(0x02d9fd9154a4b2fcLL)), 
((u64)(0x19ed8c1a8d189f78LL)), ((u64)(0x0247fe0ddd508f30LL)), ((u64)(0x5caf4690e1c0ff26LL)), ((u64)(0x03a66349621a7eb3LL)), ((u64)(0x4a25d20d81673285LL)), ((u64)(0x02eb82a11b48655cLL)), ((u64)(0x3b5174d79ab8f537LL)), ((u64)(0x0256021a7c39eab0LL)), ((u64)(0x921bee25c45b21f1ULL)), ((u64)(0x03bcd02a605caab3LL)), ((u64)(0xdb498b5169e2818eULL)), ((u64)(0x02fd735519e3bbc2LL)), ((u64)(0x15d46f7454b53472LL)), ((u64)(0x02645c4414b62fcfLL)), ((u64)(0xefba4bed545520b6ULL)), ((u64)(0x03d3c6d35456b2e4LL)), 
((u64)(0xf2fb6ff110441a2bULL)), ((u64)(0x030fd242a9def583LL)), ((u64)(0x8f2f8cc0d9d014efULL)), ((u64)(0x02730e9bbb18c469LL)), ((u64)(0xb1e5ae015c80217fULL)), ((u64)(0x03eb4a92c4f46d75LL)), ((u64)(0xc1848b344a001accULL)), ((u64)(0x0322a20f03f6bdf7LL)), ((u64)(0xce03a2903b3348a3ULL)), ((u64)(0x02821b3f365efe5fLL)), ((u64)(0xd802e873628f6d4fULL)), ((u64)(0x0201af65c518cb7fLL)), ((u64)(0x599e40b89db2487fLL)), ((u64)(0x0335e56fa1c14599LL)), ((u64)(0xe14b66fa17c1d399ULL)), ((u64)(0x029184594e3437adLL)), 
((u64)(0x81091f2e7967dc7aULL)), ((u64)(0x020e037aa4f692f1LL)), ((u64)(0x9b41cb7d8f0c93f6ULL)), ((u64)(0x03499f2aa18a84b5LL)), ((u64)(0xaf67d5fe0c0a0ff8ULL)), ((u64)(0x02a14c221ad536f7LL)), ((u64)(0xf2b977fe70080cc7ULL)), ((u64)(0x021aa34e7bddc592LL)), ((u64)(0x1df58cca4cd9ae0bLL)), ((u64)(0x035dd2172c9608ebLL)), ((u64)(0xe4c470a1d7148b3cULL)), ((u64)(0x02b174df56de6d88LL)), ((u64)(0x83d05a1b1276d5caULL)), ((u64)(0x022790b2abe5246dLL)), ((u64)(0x9fb3c35e83f1560fULL)), ((u64)(0x0372811ddfd50715LL)), 
((u64)(0xb2f635e5365aab3fULL)), ((u64)(0x02c200e4b310d277LL)), ((u64)(0xf591c4b75eaeef66ULL)), ((u64)(0x0234cd83c273db92LL)), ((u64)(0xef4fa125644b18a3ULL)), ((u64)(0x0387af39371fc5b7LL)), ((u64)(0x8c3fb41de9d5ad4fULL)), ((u64)(0x02d2f2942c196af9LL)), ((u64)(0x3cffc34b2177bdd9LL)), ((u64)(0x02425ba9bce12261LL)), ((u64)(0x94cc6bab68bf9628ULL)), ((u64)(0x039d5f75fb01d09bLL)), ((u64)(0x10a38955ed6611b9LL)), ((u64)(0x02e44c5e6267da16LL)), ((u64)(0xda1c6dde5784dafbULL)), ((u64)(0x02503d184eb97b44LL)), 
((u64)(0xf693e2fd58d49191ULL)), ((u64)(0x03b394f3b128c53aLL)), ((u64)(0xc5431bfde0aa0e0eULL)), ((u64)(0x02f610c2f4209dc8LL)), ((u64)(0x6a9c1664b3bb3e72LL)), ((u64)(0x025e73cf29b3b16dLL)), ((u64)(0x10f9bd6dec5eca4fLL)), ((u64)(0x03ca52e50f85e8afLL)), ((u64)(0xda616457f04bd50cULL)), ((u64)(0x03084250d937ed58LL)), ((u64)(0xe1e783798d09773dULL)), ((u64)(0x026d01da475ff113LL)), ((u64)(0x030c058f480f252eLL)), ((u64)(0x03e19c9072331b53LL)), ((u64)(0x68d66ad906728425LL)), ((u64)(0x031ae3a6c1c27c42LL)), 
((u64)(0x8711ef14052869b7ULL)), ((u64)(0x027be952349b969bLL)), ((u64)(0x0b4fe4ecd50d75f2LL)), ((u64)(0x03f97550542c242cLL)), ((u64)(0xa2a650bd773df7f5ULL)), ((u64)(0x032df7737689b689LL)), ((u64)(0xb551da312c31932aULL)), ((u64)(0x028b2c5c5ed49207LL)), ((u64)(0x5ddb14f4235adc22LL)), ((u64)(0x0208f049e576db39LL)), ((u64)(0x2fc4ee536bc49369LL)), ((u64)(0x034180763bf15ec2LL)), ((u64)(0xbfd0bea92303a921ULL)), ((u64)(0x029acd2b63277f01LL)), ((u64)(0x9973cbba8269541aULL)), ((u64)(0x021570ef8285ff34LL)), 
((u64)(0x5bec792a6a42202aLL)), ((u64)(0x0355817f373ccb87LL)), ((u64)(0xe3239421ee9b4cefULL)), ((u64)(0x02aacdff5f63d605LL)), ((u64)(0xb5b6101b25490a59ULL)), ((u64)(0x02223e65e5e97804LL)), ((u64)(0x22bce691d541aa27LL)), ((u64)(0x0369fd6fd64259a1LL)), ((u64)(0xb563eba7ddce21b9ULL)), ((u64)(0x02bb31264501e14dLL)), ((u64)(0xf78322ecb171b494ULL)), ((u64)(0x022f5a850401810aLL)), ((u64)(0x259e9e47824f8753LL)), ((u64)(0x037ef73b399c01abLL)), ((u64)(0x1e187e9f9b72d2a9LL)), ((u64)(0x02cbf8fc2e1667bcLL)), 
((u64)(0x4b46cbb2e2c24221LL)), ((u64)(0x023cc73024deb963LL)), ((u64)(0x120adf849e039d01LL)), ((u64)(0x039471e6a1645bd2LL)), ((u64)(0xdb3be603b19c7d9aULL)), ((u64)(0x02dd27ebb4504974LL)), ((u64)(0x7c2feb3627b0647cLL)), ((u64)(0x024a865629d9d45dLL)), ((u64)(0x2d197856a5e7072cLL)), ((u64)(0x03aa7089dc8fba2fLL)), ((u64)(0x8a7ac6abb7ec05bdULL)), ((u64)(0x02eec06e4a0c94f2LL)), ((u64)(0xd52f05562cbcd164ULL)), ((u64)(0x025899f1d4d6dd8eLL)), ((u64)(0x21e4d556adfae8a0LL)), ((u64)(0x03c0f64fbaf1627eLL)), 
((u64)(0xe7ea444557fbed4dULL)), ((u64)(0x0300c50c958de864LL)), ((u64)(0xecbb69d1132ff10aULL)), ((u64)(0x0267040a113e5383LL)), ((u64)(0xadf8a94e851981aaULL)), ((u64)(0x03d8067681fd526cLL)), ((u64)(0x8b2d543ed0e13488ULL)), ((u64)(0x0313385ece6441f0LL)), ((u64)(0xd5bddcff0d80f6d3ULL)), ((u64)(0x0275c6b23eb69b26LL)), ((u64)(0x892fc7fe7c018aebULL)), ((u64)(0x03efa45064575ea4LL)), ((u64)(0x3a8c9ffec99ad589LL)), ((u64)(0x03261d0d1d12b21dLL)), ((u64)(0xc8707fff07af113bULL)), ((u64)(0x0284e40a7da88e7dLL)), 
((u64)(0x39f39998d2f2742fLL)), ((u64)(0x0203e9a1fe2071feLL)), ((u64)(0x8fec28f484b7204bULL)), ((u64)(0x033975cffd00b663LL)), ((u64)(0xd989ba5d36f8e6a2ULL)), ((u64)(0x02945e3ffd9a2b82LL)), ((u64)(0x47a161e42bfa521cLL)), ((u64)(0x02104b66647b5602LL)), ((u64)(0x0c35696d132a1cf9LL)), ((u64)(0x034d4570a0c5566aLL)), ((u64)(0x09c454574288172dLL)), ((u64)(0x02a4378d4d6aab88LL)), ((u64)(0xa169dd129ba0128bULL)), ((u64)(0x021cf93dd7888939LL)), ((u64)(0x0242fb50f9001dabLL)), ((u64)(0x03618ec958da7529LL)), 
((u64)(0x9b68c90d940017bcULL)), ((u64)(0x02b4723aad7b90edLL)), ((u64)(0x4920a0d7a999ac96LL)), ((u64)(0x0229f4fbbdfc73f1LL)), ((u64)(0x750101590f5c4757LL)), ((u64)(0x037654c5fcc71fe8LL)), ((u64)(0x2a6734473f7d05dfLL)), ((u64)(0x02c5109e63d27fedLL)), ((u64)(0xeeb8f69f65fd9e4cULL)), ((u64)(0x0237407eb641fff0LL)), ((u64)(0xe45b24323cc8fd46ULL)), ((u64)(0x038b9a6456cfffe7LL)), ((u64)(0xb6af502830a0ca9fULL)), ((u64)(0x02d6151d123fffecLL)), ((u64)(0xf88c402026e7087fULL)), ((u64)(0x0244ddb0db666656LL)), 
((u64)(0x2746cd003e3e73feLL)), ((u64)(0x03a162b4923d708bLL)), ((u64)(0x1f6bd73364fec332LL)), ((u64)(0x02e7822a0e978d3cLL)), ((u64)(0xe5efdf5c50cbcf5bULL)), ((u64)(0x0252ce880bac70fcLL)), ((u64)(0x3cb2fefa1adfb22bLL)), ((u64)(0x03b7b0d9ac471b2eLL)), ((u64)(0x308f3261af195b56LL)), ((u64)(0x02f95a47bd05af58LL)), ((u64)(0x5a0c284e25ade2abLL)), ((u64)(0x0261150630d15913LL)), ((u64)(0x29ad0d49d5e30445LL)), ((u64)(0x03ce8809e7b55b52LL)), ((u64)(0x548a7107de4f369dLL)), ((u64)(0x030ba007ec9115dbLL)), ((u64)(0xdd3b8d9fe50c2bb1ULL)), ((u64)(0x026fb3398a0dab15LL)), ((u64)(0x952c15cca1ad12b5ULL)), ((u64)(0x03e5eb8f434911bcLL)), ((u64)(0x775677d6e7bda891LL)), ((u64)(0x031e560c35d40e30LL)), ((u64)(0xc5dec645863153a7ULL)), ((u64)(0x027eab3cf7dcd826LL))}; // fixed array const
bool v_memory_panic = false; // global 6

int g_main_argc = ((int)(0)); // global 6

voidptr g_main_argv = ((void*)0); // global 6

voidptr g_live_reload_info; // global 6

Array_VCastTypeIndexName as_cast_type_indexes; // global 6

IError _const_none__; // inited later
const i8 _const_min_i8 = -128; // precomputed2
const i8 _const_max_i8 = 127; // precomputed2
const i16 _const_min_i16 = -32768; // precomputed2
const i16 _const_max_i16 = 32767; // precomputed2
const i32 _const_min_i32 = -2147483648; // precomputed2
const i32 _const_max_i32 = 2147483647; // precomputed2
i64 _const_min_i64; // inited later
i64 _const_max_i64; // inited later
const u8 _const_min_u8 = 0; // precomputed2
const u8 _const_max_u8 = 255; // precomputed2
const u16 _const_min_u16 = 0; // precomputed2
const u16 _const_max_u16 = 65535; // precomputed2
const u32 _const_min_u32 = 0; // precomputed2
const u32 _const_max_u32 = 4294967295; // precomputed2
const u64 _const_min_u64 = 0U; // precomputed2
const u64 _const_max_u64 = 18446744073709551615U; // precomputed2
const f64 _const_max_load_factor = 0.8; // precomputed2
const u32 _const_hash_mask = 16777215; // precomputed2
const u32 _const_probe_inc = 16777216; // precomputed2
Array_fixed_i32_1264 _const_rune_maps = {((i32)(0xB5)), 0xB5, 743, 0, 0xC0, 0xD6, 0, 32, 0xD8, 0xDE, 0, 32, 0xE0, 0xF6, -32, 0, 
0xF8, 0xFE, -32, 0, 0xFF, 0xFF, 121, 0, 0x100, 0x12F, -3, -3, 0x130, 0x130, 0, -199, 
0x131, 0x131, -232, 0, 0x132, 0x137, -3, -3, 0x139, 0x148, -3, -3, 0x14A, 0x177, -3, -3, 
0x178, 0x178, 0, -121, 0x179, 0x17E, -3, -3, 0x17F, 0x17F, -300, 0, 0x180, 0x180, 195, 0, 
0x181, 0x181, 0, 210, 0x182, 0x185, -3, -3, 0x186, 0x186, 0, 206, 0x187, 0x188, -3, -3, 
0x189, 0x18A, 0, 205, 0x18B, 0x18C, -3, -3, 0x18E, 0x18E, 0, 79, 0x18F, 0x18F, 0, 202, 
0x190, 0x190, 0, 203, 0x191, 0x192, -3, -3, 0x193, 0x193, 0, 205, 0x194, 0x194, 0, 207, 
0x195, 0x195, 97, 0, 0x196, 0x196, 0, 211, 0x197, 0x197, 0, 209, 0x198, 0x199, -3, -3, 
0x19A, 0x19A, 163, 0, 0x19C, 0x19C, 0, 211, 0x19D, 0x19D, 0, 213, 0x19E, 0x19E, 130, 0, 
0x19F, 0x19F, 0, 214, 0x1A0, 0x1A5, -3, -3, 0x1A6, 0x1A6, 0, 218, 0x1A7, 0x1A8, -3, -3, 
0x1A9, 0x1A9, 0, 218, 0x1AC, 0x1AD, -3, -3, 0x1AE, 0x1AE, 0, 218, 0x1AF, 0x1B0, -3, -3, 
0x1B1, 0x1B2, 0, 217, 0x1B3, 0x1B6, -3, -3, 0x1B7, 0x1B7, 0, 219, 0x1B8, 0x1B9, -3, -3, 
0x1BC, 0x1BD, -3, -3, 0x1BF, 0x1BF, 56, 0, 0x1C4, 0x1CC, -2, -2, 0x1CD, 0x1DC, -3, -3, 
0x1DD, 0x1DD, -79, 0, 0x1DE, 0x1EF, -3, -3, 0x1F1, 0x1F3, -2, -2, 0x1F4, 0x1F5, -3, -3, 
0x1F6, 0x1F6, 0, -97, 0x1F7, 0x1F7, 0, -56, 0x1F8, 0x21F, -3, -3, 0x220, 0x220, 0, -130, 
0x222, 0x233, -3, -3, 0x23A, 0x23A, 0, 10795, 0x23B, 0x23C, -3, -3, 0x23D, 0x23D, 0, -163, 
0x23E, 0x23E, 0, 10792, 0x23F, 0x240, 10815, 0, 0x241, 0x242, -3, -3, 0x243, 0x243, 0, -195, 
0x244, 0x244, 0, 69, 0x245, 0x245, 0, 71, 0x246, 0x24F, -3, -3, 0x250, 0x250, 10783, 0, 
0x251, 0x251, 10780, 0, 0x252, 0x252, 10782, 0, 0x253, 0x253, -210, 0, 0x254, 0x254, -206, 0, 
0x256, 0x257, -205, 0, 0x259, 0x259, -202, 0, 0x25B, 0x25B, -203, 0, 0x25C, 0x25C, 42319, 0, 
0x260, 0x260, -205, 0, 0x261, 0x261, 42315, 0, 0x263, 0x263, -207, 0, 0x265, 0x265, 42280, 0, 
0x266, 0x266, 42308, 0, 0x268, 0x268, -209, 0, 0x269, 0x269, -211, 0, 0x26A, 0x26A, 42308, 0, 
0x26B, 0x26B, 10743, 0, 0x26C, 0x26C, 42305, 0, 0x26F, 0x26F, -211, 0, 0x271, 0x271, 10749, 0, 
0x272, 0x272, -213, 0, 0x275, 0x275, -214, 0, 0x27D, 0x27D, 10727, 0, 0x280, 0x280, -218, 0, 
0x282, 0x282, 42307, 0, 0x283, 0x283, -218, 0, 0x287, 0x287, 42282, 0, 0x288, 0x288, -218, 0, 
0x289, 0x289, -69, 0, 0x28A, 0x28B, -217, 0, 0x28C, 0x28C, -71, 0, 0x292, 0x292, -219, 0, 
0x29D, 0x29D, 42261, 0, 0x29E, 0x29E, 42258, 0, 0x345, 0x345, 84, 0, 0x370, 0x373, -3, -3, 
0x376, 0x377, -3, -3, 0x37B, 0x37D, 130, 0, 0x37F, 0x37F, 0, 116, 0x386, 0x386, 0, 38, 
0x388, 0x38A, 0, 37, 0x38C, 0x38C, 0, 64, 0x38E, 0x38F, 0, 63, 0x391, 0x3A1, 0, 32, 
0x3A3, 0x3AB, 0, 32, 0x3AC, 0x3AC, -38, 0, 0x3AD, 0x3AF, -37, 0, 0x3B1, 0x3C1, -32, 0, 
0x3C2, 0x3C2, -31, 0, 0x3C3, 0x3CB, -32, 0, 0x3CC, 0x3CC, -64, 0, 0x3CD, 0x3CE, -63, 0, 
0x3CF, 0x3CF, 0, 8, 0x3D0, 0x3D0, -62, 0, 0x3D1, 0x3D1, -57, 0, 0x3D5, 0x3D5, -47, 0, 
0x3D6, 0x3D6, -54, 0, 0x3D7, 0x3D7, -8, 0, 0x3D8, 0x3EF, -3, -3, 0x3F0, 0x3F0, -86, 0, 
0x3F1, 0x3F1, -80, 0, 0x3F2, 0x3F2, 7, 0, 0x3F3, 0x3F3, -116, 0, 0x3F4, 0x3F4, 0, -60, 
0x3F5, 0x3F5, -96, 0, 0x3F7, 0x3F8, -3, -3, 0x3F9, 0x3F9, 0, -7, 0x3FA, 0x3FB, -3, -3, 
0x3FD, 0x3FF, 0, -130, 0x400, 0x40F, 0, 80, 0x410, 0x42F, 0, 32, 0x430, 0x44F, -32, 0, 
0x450, 0x45F, -80, 0, 0x460, 0x481, -3, -3, 0x48A, 0x4BF, -3, -3, 0x4C0, 0x4C0, 0, 15, 
0x4C1, 0x4CE, -3, -3, 0x4CF, 0x4CF, -15, 0, 0x4D0, 0x52F, -3, -3, 0x531, 0x556, 0, 48, 
0x561, 0x586, -48, 0, 0x10A0, 0x10C5, 0, 7264, 0x10C7, 0x10C7, 0, 7264, 0x10CD, 0x10CD, 0, 7264, 
0x10D0, 0x10FA, 3008, 0, 0x10FD, 0x10FF, 3008, 0, 0x13A0, 0x13EF, 0, 38864, 0x13F0, 0x13F5, 0, 8, 
0x13F8, 0x13FD, -8, 0, 0x1C80, 0x1C80, -6254, 0, 0x1C81, 0x1C81, -6253, 0, 0x1C82, 0x1C82, -6244, 0, 
0x1C83, 0x1C84, -6242, 0, 0x1C85, 0x1C85, -6243, 0, 0x1C86, 0x1C86, -6236, 0, 0x1C87, 0x1C87, -6181, 0, 
0x1C88, 0x1C88, 35266, 0, 0x1C90, 0x1CBA, 0, -3008, 0x1CBD, 0x1CBF, 0, -3008, 0x1D79, 0x1D79, 35332, 0, 
0x1D7D, 0x1D7D, 3814, 0, 0x1D8E, 0x1D8E, 35384, 0, 0x1E00, 0x1E95, -3, -3, 0x1E9B, 0x1E9B, -59, 0, 
0x1E9E, 0x1E9E, 0, -7615, 0x1EA0, 0x1EFF, -3, -3, 0x1F00, 0x1F07, 8, 0, 0x1F08, 0x1F0F, 0, -8, 
0x1F10, 0x1F15, 8, 0, 0x1F18, 0x1F1D, 0, -8, 0x1F20, 0x1F27, 8, 0, 0x1F28, 0x1F2F, 0, -8, 
0x1F30, 0x1F37, 8, 0, 0x1F38, 0x1F3F, 0, -8, 0x1F40, 0x1F45, 8, 0, 0x1F48, 0x1F4D, 0, -8, 
0x1F51, 0x1F51, 8, 0, 0x1F53, 0x1F53, 8, 0, 0x1F55, 0x1F55, 8, 0, 0x1F57, 0x1F57, 8, 0, 
0x1F59, 0x1F59, 0, -8, 0x1F5B, 0x1F5B, 0, -8, 0x1F5D, 0x1F5D, 0, -8, 0x1F5F, 0x1F5F, 0, -8, 
0x1F60, 0x1F67, 8, 0, 0x1F68, 0x1F6F, 0, -8, 0x1F70, 0x1F71, 74, 0, 0x1F72, 0x1F75, 86, 0, 
0x1F76, 0x1F77, 100, 0, 0x1F78, 0x1F79, 128, 0, 0x1F7A, 0x1F7B, 112, 0, 0x1F7C, 0x1F7D, 126, 0, 
0x1F80, 0x1F87, 8, 0, 0x1F88, 0x1F8F, 0, -8, 0x1F90, 0x1F97, 8, 0, 0x1F98, 0x1F9F, 0, -8, 
0x1FA0, 0x1FA7, 8, 0, 0x1FA8, 0x1FAF, 0, -8, 0x1FB0, 0x1FB1, 8, 0, 0x1FB3, 0x1FB3, 9, 0, 
0x1FB8, 0x1FB9, 0, -8, 0x1FBA, 0x1FBB, 0, -74, 0x1FBC, 0x1FBC, 0, -9, 0x1FBE, 0x1FBE, -7205, 0, 
0x1FC3, 0x1FC3, 9, 0, 0x1FC8, 0x1FCB, 0, -86, 0x1FCC, 0x1FCC, 0, -9, 0x1FD0, 0x1FD1, 8, 0, 
0x1FD8, 0x1FD9, 0, -8, 0x1FDA, 0x1FDB, 0, -100, 0x1FE0, 0x1FE1, 8, 0, 0x1FE5, 0x1FE5, 7, 0, 
0x1FE8, 0x1FE9, 0, -8, 0x1FEA, 0x1FEB, 0, -112, 0x1FEC, 0x1FEC, 0, -7, 0x1FF3, 0x1FF3, 9, 0, 
0x1FF8, 0x1FF9, 0, -128, 0x1FFA, 0x1FFB, 0, -126, 0x1FFC, 0x1FFC, 0, -9, 0x2126, 0x2126, 0, -7517, 
0x212A, 0x212A, 0, -8383, 0x212B, 0x212B, 0, -8262, 0x2132, 0x2132, 0, 28, 0x214E, 0x214E, -28, 0, 
0x2160, 0x216F, 0, 16, 0x2170, 0x217F, -16, 0, 0x2183, 0x2184, -3, -3, 0x24B6, 0x24CF, 0, 26, 
0x24D0, 0x24E9, -26, 0, 0x2C00, 0x2C2F, 0, 48, 0x2C30, 0x2C5F, -48, 0, 0x2C60, 0x2C61, -3, -3, 
0x2C62, 0x2C62, 0, -10743, 0x2C63, 0x2C63, 0, -3814, 0x2C64, 0x2C64, 0, -10727, 0x2C65, 0x2C65, -10795, 0, 
0x2C66, 0x2C66, -10792, 0, 0x2C67, 0x2C6C, -3, -3, 0x2C6D, 0x2C6D, 0, -10780, 0x2C6E, 0x2C6E, 0, -10749, 
0x2C6F, 0x2C6F, 0, -10783, 0x2C70, 0x2C70, 0, -10782, 0x2C72, 0x2C73, -3, -3, 0x2C75, 0x2C76, -3, -3, 
0x2C7E, 0x2C7F, 0, -10815, 0x2C80, 0x2CE3, -3, -3, 0x2CEB, 0x2CEE, -3, -3, 0x2CF2, 0x2CF3, -3, -3, 
0x2D00, 0x2D25, -7264, 0, 0x2D27, 0x2D27, -7264, 0, 0x2D2D, 0x2D2D, -7264, 0, 0xA640, 0xA66D, -3, -3, 
0xA680, 0xA69B, -3, -3, 0xA722, 0xA72F, -3, -3, 0xA732, 0xA76F, -3, -3, 0xA779, 0xA77C, -3, -3, 
0xA77D, 0xA77D, 0, -35332, 0xA77E, 0xA787, -3, -3, 0xA78B, 0xA78C, -3, -3, 0xA78D, 0xA78D, 0, -42280, 
0xA790, 0xA793, -3, -3, 0xA794, 0xA794, 48, 0, 0xA796, 0xA7A9, -3, -3, 0xA7AA, 0xA7AA, 0, -42308, 
0xA7AB, 0xA7AB, 0, -42319, 0xA7AC, 0xA7AC, 0, -42315, 0xA7AD, 0xA7AD, 0, -42305, 0xA7AE, 0xA7AE, 0, -42308, 
0xA7B0, 0xA7B0, 0, -42258, 0xA7B1, 0xA7B1, 0, -42282, 0xA7B2, 0xA7B2, 0, -42261, 0xA7B3, 0xA7B3, 0, 928, 
0xA7B4, 0xA7C3, -3, -3, 0xA7C4, 0xA7C4, 0, -48, 0xA7C5, 0xA7C5, 0, -42307, 0xA7C6, 0xA7C6, 0, -35384, 
0xA7C7, 0xA7CA, -3, -3, 0xA7D0, 0xA7D1, -3, -3, 0xA7D6, 0xA7D9, -3, -3, 0xA7F5, 0xA7F6, -3, -3, 
0xAB53, 0xAB53, -928, 0, 0xAB70, 0xABBF, -38864, 0, 0xFF21, 0xFF3A, 0, 32, 0xFF41, 0xFF5A, -32, 0, 
0x10400, 0x10427, 0, 40, 0x10428, 0x1044F, -40, 0, 0x104B0, 0x104D3, 0, 40, 0x104D8, 0x104FB, -40, 0, 
0x10570, 0x1057A, 0, 39, 0x1057C, 0x1058A, 0, 39, 0x1058C, 0x10592, 0, 39, 0x10594, 0x10595, 0, 39, 
0x10597, 0x105A1, -39, 0, 0x105A3, 0x105B1, -39, 0, 0x105B3, 0x105B9, -39, 0, 0x105BB, 0x105BC, -39, 0, 
0x10C80, 0x10CB2, 0, 64, 0x10CC0, 0x10CF2, -64, 0, 0x118A0, 0x118BF, 0, 32, 0x118C0, 0x118DF, -32, 0, 
0x16E40, 0x16E5F, 0, 32, 0x16E60, 0x16E7F, -32, 0, 0x1E900, 0x1E921, 0, 34, 0x1E922, 0x1E943, -34, 0}; // fixed array const
Array_string _const_v__token__orm_custom_operators; // inited later
Array_v__token__Kind _const_v__token__assign_tokens; // inited later
Array_string _const_v__token__valid_at_tokens; // inited later
Array_string _const_v__token__token_str; // inited later
Array_v__token__Precedence _const_v__token__precedences; // inited later
const u64 _const_hash__fnv1a__fnv64_prime = 1099511628211U; // precomputed2
const u64 _const_hash__fnv1a__fnv64_offset_basis = 14695981039346656037U; // precomputed2
const u32 _const_hash__fnv1a__fnv32_offset_basis = 2166136261; // precomputed2
const u32 _const_hash__fnv1a__fnv32_prime = 16777619; // precomputed2
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__infinite; // inited later
Array_string _const_time__tokens_2; // inited later
Array_string _const_time__tokens_3; // inited later
Array_string _const_time__tokens_4; // inited later
Array_fixed_u8_10 _const_time__date_format_buffer = {((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0', '0'}; // fixed array const
Array_fixed_u8_8 _const_time__time_format_buffer = {((u8)('0')), '0', ':', '0', '0', ':', '0', '0'}; // fixed array const
Array_fixed_string_7 _const_time__long_days = {_S("Monday"), _S("Tuesday"), _S("Wednesday"), _S("Thursday"), _S("Friday"), _S("Saturday"), _S("Sunday")}; // fixed array const
Array_fixed_int_12 _const_time__month_days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // fixed array const
Array_string _const_time__long_months; // inited later
i64 _const_time__absolute_zero_year; // inited later
Array_fixed_int_13 _const_time__days_before = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; // fixed array const
u64 _const_time__start_time; // inited later
mach_timebase_info_data_t _const_time__time_base; // inited later
vphp__TaskRegistry* g_registry; // global 6

int _const_os__o_rdonly; // inited later
int _const_os__o_wronly; // inited later
int _const_os__o_rdwr; // inited later
int _const_os__o_create; // inited later
int _const_os__o_noctty; // inited later
int _const_os__o_trunc; // inited later
int _const_os__o_append; // inited later
int _const_os__o_nonblock; // inited later
int _const_os__o_sync; // inited later
string _const_os__wd_at_startup; // inited later
Array_string _const_os__executable_suffixes; // inited later
int _const_os__fd_stdout; // inited later
int _const_os__fd_stderr; // inited later
u64 g_main_thread_id; // global 6

Array_string _const_v__pkgconfig__default_paths; // inited later
int_literal can_show_color_on_stdout_cache = 0; // global 6

int_literal can_show_color_on_stderr_cache = 0; // global 6

Array_string _const_v__vmod__mod_file_stop_paths; // inited later
v__vmod__ModFileCacher* _const_v__vmod__private_file_cacher; // inited later
const u64 _const_rand__wyrand__wyp0 = 3257665815644502181U; // precomputed2
const u64 _const_rand__wyrand__wyp1 = 10067880064238660809U; // precomputed2
const f64 _const_rand__sqrt2 = 1.4142135623730951; // precomputed2
rand__PRNG* default_rng; // global 6

f64 _const_rand__reciprocal_2_23rd; // inited later
f64 _const_rand__reciprocal_2_52nd; // inited later
u32 _const_rand__ieee754_mantissa_f32_mask; // inited later
const u64 _const_rand__ieee754_mantissa_f64_mask = 4503599627370495U; // precomputed2
Array_string _const_v__pref__supported_test_runners; // inited later
const u32 _const_sync__spinloops = 750; // precomputed2
const u32 _const_sync__spinloops_sem = 4000; // precomputed2
bool _const_v__util__verror_paths_absolute; // inited later
v__util__LinesCache* lines_cache; // global 6

Array_u8 _const_v__util__invalid_escapes; // inited later
Array_fixed_bool_256 _const_v__util__name_char_table; // inited later
Array_fixed_bool_256 _const_v__util__func_char_table; // inited later
Array_fixed_bool_256 _const_v__util__non_whitespace_table; // inited later
i64 _const_v__util__max_suggestions_limit; // inited later
v__util__Timers* g_timers; // global 6

Array_string _const_v__util__builtin_module_parts; // inited later
Array_fixed_string_9 _const_v__util__bundle_modules = {_S("clipboard"), _S("fontstash"), _S("gg"), _S("gx"), _S("sokol"), _S("szip"), _S("ui"), _S("builtin.closure"), _S("builtin.overflow")}; // fixed array const
Map_string_Array_string _const_v__util__external_module_dependencies_for_tool; // inited later
Array_fixed_string_11 _const_v__util__const_tabs = {_S(""), _S("\t"), _S("\t\t"), _S("\t\t\t"), _S("\t\t\t\t"), _S("\t\t\t\t\t"), _S("\t\t\t\t\t\t"), _S("\t\t\t\t\t\t\t"), _S("\t\t\t\t\t\t\t\t"), _S("\t\t\t\t\t\t\t\t\t"), _S("\t\t\t\t\t\t\t\t\t\t")}; // fixed array const
int _const_v__util__nr_jobs; // inited later
Array_string _const_v__ast__global_reserved_type_names; // inited later
v__ast__Expr _const_v__ast__empty_expr; // inited later
v__ast__Stmt _const_v__ast__empty_stmt; // inited later
v__ast__Node _const_v__ast__empty_node; // inited later
v__ast__ScopeObject _const_v__ast__empty_scope_object; // inited later
v__ast__ComptTimeConstValue _const_v__ast__empty_comptime_const_value; // inited later
Map_int_Array_string _const_v__ast__x86_no_number_register_list; // inited later
Map_int_Map_string_int _const_v__ast__x86_with_number_register_list; // inited later
Array_string _const_v__ast__arm_no_number_register_list; // inited later
Map_string_int _const_v__ast__arm_with_number_register_list; // inited later
Array_string _const_v__ast__riscv_no_number_register_list; // inited later
Map_string_int _const_v__ast__riscv_with_number_register_list; // inited later
Array_string _const_v__ast__s390x_no_number_register_list; // inited later
Map_string_int _const_v__ast__s390x_with_number_register_list; // inited later
Array_string _const_v__ast__ppc64le_no_number_register_list; // inited later
Map_string_int _const_v__ast__ppc64le_with_number_register_list; // inited later
Array_string _const_v__ast__loongarch64_no_number_register_list; // inited later
Map_string_int _const_v__ast__loongarch64_with_number_register_list; // inited later
i64 nested_expr_pos_calls = ((i64)(0)); // global 6

Array_string _const_v__ast__valid_comptime_if_os; // inited later
Array_string _const_v__ast__valid_comptime_if_compilers; // inited later
Array_string _const_v__ast__valid_comptime_if_platforms; // inited later
Array_string _const_v__ast__valid_comptime_if_cpu_features; // inited later
Array_string _const_v__ast__valid_comptime_if_other; // inited later
Array_string _const_v__ast__valid_comptime_compression_types; // inited later
Map_string_string _const_v__ast__system_ident_map; // inited later
Array_string _const_v__ast__native_builtins; // inited later
v__ast__Scope* _const_v__ast__empty_scope; // inited later
i64 nested_expr_str_calls = ((i64)(0)); // global 6

Array_string _const_v__ast__fn_type_escape_seq; // inited later
Array_string _const_v__ast__map_cname_escape_seq; // inited later
v__ast__Table* global_table; // global 6

Array_string _const_v__ast__builtin_type_names; // inited later
Array_string _const_v__ast__builtin_array_generic_methods; // inited later
Array_string _const_v__ast__builtin_array_generic_methods_no_sort; // inited later
Map_string_int _const_v__scanner__workaround_markused_bug; // inited later
Array_fixed_bool_256 _const_v__scanner__digit_table; // inited later
Array_fixed_bool_256 _const_v__scanner__letter_table; // inited later
Array_string _const_v__parser__allowed_lock_prefix_ins; // inited later
Array_v__token__Kind _const_v__parser__valid_tokens_inside_types; // inited later
Array_v__ast__File_ptr codegen_files; // global 6

Array_string _const_v__parser__supported_comptime_calls; // inited later
Array_string _const_v__parser__comptime_types; // inited later
u32 _const_builtin__closure__closure_size_1; // inited later
Map_string_v__token__Kind _const_v__token__keywords; // inited later
time__Duration _const_time__microsecond; // inited later
Array_int _const_semver__versions; // inited later
Array_string _const_os__args; // inited later
string _const_v__pref__default_module_path; // inited later
v__util__EManager* _const_v__util__emanager; // inited later
string _const_v__util__normalised_workdir; // inited later
time__Time _const_v__util__stable_build_time; // inited later
Array_string _const_v__ast__builtins; // inited later
Array_string _const_v__ast__valid_comptime_not_user_defined; // inited later
v__ast__TypeSymbol* _const_v__ast__invalid_type_symbol; // inited later
v__token__KeywordsMatcherTrie _const_v__ast__builtin_type_names_matcher; // inited later
Array_int _const_v__ast__integer_type_idxs; // inited later
Array_int _const_v__ast__signed_integer_type_idxs; // inited later
Array_int _const_v__ast__unsigned_integer_type_idxs; // inited later
Array_int _const_v__ast__int_promoted_type_idxs; // inited later
Array_int _const_v__ast__float_type_idxs; // inited later
Array_int _const_v__ast__number_type_idxs; // inited later
Array_int _const_v__ast__pointer_type_idxs; // inited later
v__ast__Type _const_v__ast__invalid_type; // inited later
v__ast__Type _const_v__ast__no_type; // inited later
v__ast__Type _const_v__ast__void_type; // inited later
v__ast__Type _const_v__ast__ovoid_type; // inited later
v__ast__Type _const_v__ast__rvoid_type; // inited later
v__ast__Type _const_v__ast__voidptr_type; // inited later
v__ast__Type _const_v__ast__byteptr_type; // inited later
v__ast__Type _const_v__ast__charptr_type; // inited later
v__ast__Type _const_v__ast__i8_type; // inited later
v__ast__Type _const_v__ast__i16_type; // inited later
v__ast__Type _const_v__ast__i32_type; // inited later
v__ast__Type _const_v__ast__int_type; // inited later
v__ast__Type _const_v__ast__i64_type; // inited later
v__ast__Type _const_v__ast__isize_type; // inited later
v__ast__Type _const_v__ast__u8_type; // inited later
v__ast__Type _const_v__ast__u16_type; // inited later
v__ast__Type _const_v__ast__u32_type; // inited later
v__ast__Type _const_v__ast__u64_type; // inited later
v__ast__Type _const_v__ast__usize_type; // inited later
v__ast__Type _const_v__ast__f32_type; // inited later
v__ast__Type _const_v__ast__f64_type; // inited later
v__ast__Type _const_v__ast__char_type; // inited later
v__ast__Type _const_v__ast__bool_type; // inited later
v__ast__Type _const_v__ast__none_type; // inited later
v__ast__Type _const_v__ast__string_type; // inited later
v__ast__Type _const_v__ast__rune_type; // inited later
v__ast__Type _const_v__ast__array_type; // inited later
v__ast__Type _const_v__ast__map_type; // inited later
v__ast__Type _const_v__ast__chan_type; // inited later
v__ast__Type _const_v__ast__any_type; // inited later
v__ast__Type _const_v__ast__float_literal_type; // inited later
v__ast__Type _const_v__ast__int_literal_type; // inited later
v__ast__Type _const_v__ast__thread_type; // inited later
v__ast__Type _const_v__ast__error_type; // inited later
v__ast__Type _const_v__ast__nil_type; // inited later
v__token__KeywordsMatcherTrie _const_v__ast__builtin_array_generic_methods_matcher; // inited later
v__token__KeywordsMatcherTrie _const_v__ast__builtin_array_generic_methods_no_sort_matcher; // inited later
string _const_v__parser__normalised_working_folder; // inited later
int _const_builtin__closure__closure_size; // inited later
v__token__KeywordsMatcherTrie _const_v__token__scanner_matcher; // inited later
time__Duration _const_time__millisecond; // inited later
Array_v__ast__Type _const_v__ast__charptr_types; // inited later
Array_v__ast__Type _const_v__ast__byteptr_types; // inited later
Array_v__ast__Type _const_v__ast__voidptr_types; // inited later
time__Duration _const_time__second; // inited later
Array_v__ast__Type _const_v__ast__cptr_types; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
const u32 _IError_None___index = 0;
static IError I_voidptr_to_Interface_IError(voidptr* x);
const u32 _IError_voidptr_index = 1;
static IError I_Error_to_Interface_IError(Error* x);
const u32 _IError_Error_index = 2;
static IError I_MessageError_to_Interface_IError(MessageError* x);
const u32 _IError_MessageError_index = 3;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
const u32 _IError_time__TimeParseError_index = 4;
static IError I_flag__UnknownFlagError_to_Interface_IError(flag__UnknownFlagError* x);
const u32 _IError_flag__UnknownFlagError_index = 5;
static IError I_flag__ArgsCountError_to_Interface_IError(flag__ArgsCountError* x);
const u32 _IError_flag__ArgsCountError_index = 6;
static IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x);
const u32 _IError_semver__InvalidComparatorFormatError_index = 7;
static IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x);
const u32 _IError_semver__EmptyInputError_index = 8;
static IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x);
const u32 _IError_semver__InvalidVersionFormatError_index = 9;
static IError I_os__Eof_to_Interface_IError(os__Eof* x);
const u32 _IError_os__Eof_index = 10;
static IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x);
const u32 _IError_os__NotExpected_index = 11;
static IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x);
const u32 _IError_os__FileNotOpenedError_index = 12;
static IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x);
const u32 _IError_os__SizeOfTypeIs0Error_index = 13;
static IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x);
const u32 _IError_os__ExecutableNotFoundError_index = 14;
static IError I_v__parser__IncludeError_to_Interface_IError(v__parser__IncludeError* x);
const u32 _IError_v__parser__IncludeError_index = 15;
// ^^^ number of types for interface IError: 16

// Methods wrapper for interface "IError"
static inline int builtin__None___code_Interface_IError_method_wrapper(None__* err) {
	return builtin__Error_code(err->Error);
}
static inline string builtin__None___msg_Interface_IError_method_wrapper(None__* err) {
	return builtin__Error_msg(err->Error);
}
static inline int builtin__Error_code_Interface_IError_method_wrapper(Error* err) {
	return builtin__Error_code(*err);
}
static inline string builtin__Error_msg_Interface_IError_method_wrapper(Error* err) {
	return builtin__Error_msg(*err);
}
static inline int builtin__MessageError_code_Interface_IError_method_wrapper(MessageError* err) {
	return builtin__MessageError_code(*err);
}
static inline string builtin__MessageError_msg_Interface_IError_method_wrapper(MessageError* err) {
	return builtin__MessageError_msg(*err);
}
static inline int builtin__time__TimeParseError_code_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return builtin__Error_code(err->Error);
}
static inline string time__TimeParseError_msg_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return time__TimeParseError_msg(*err);
}
static inline int builtin__flag__UnknownFlagError_code_Interface_IError_method_wrapper(flag__UnknownFlagError* err) {
	return builtin__Error_code(err->Error);
}
static inline string flag__UnknownFlagError_msg_Interface_IError_method_wrapper(flag__UnknownFlagError* err) {
	return flag__UnknownFlagError_msg(*err);
}
static inline int builtin__flag__ArgsCountError_code_Interface_IError_method_wrapper(flag__ArgsCountError* err) {
	return builtin__Error_code(err->Error);
}
static inline string flag__ArgsCountError_msg_Interface_IError_method_wrapper(flag__ArgsCountError* err) {
	return flag__ArgsCountError_msg(*err);
}
static inline int builtin__semver__InvalidComparatorFormatError_code_Interface_IError_method_wrapper(semver__InvalidComparatorFormatError* err) {
	return builtin__MessageError_code(err->MessageError);
}
static inline string builtin__semver__InvalidComparatorFormatError_msg_Interface_IError_method_wrapper(semver__InvalidComparatorFormatError* err) {
	return builtin__MessageError_msg(err->MessageError);
}
static inline int builtin__semver__EmptyInputError_code_Interface_IError_method_wrapper(semver__EmptyInputError* err) {
	return builtin__Error_code(err->Error);
}
static inline string semver__EmptyInputError_msg_Interface_IError_method_wrapper(semver__EmptyInputError* err) {
	return semver__EmptyInputError_msg(*err);
}
static inline int builtin__semver__InvalidVersionFormatError_code_Interface_IError_method_wrapper(semver__InvalidVersionFormatError* err) {
	return builtin__Error_code(err->Error);
}
static inline string semver__InvalidVersionFormatError_msg_Interface_IError_method_wrapper(semver__InvalidVersionFormatError* err) {
	return semver__InvalidVersionFormatError_msg(*err);
}
static inline int builtin__os__Eof_code_Interface_IError_method_wrapper(os__Eof* err) {
	return builtin__Error_code(err->Error);
}
static inline string builtin__os__Eof_msg_Interface_IError_method_wrapper(os__Eof* err) {
	return builtin__Error_msg(err->Error);
}
static inline int os__NotExpected_code_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_code(*err);
}
static inline string os__NotExpected_msg_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_msg(*err);
}
static inline int builtin__os__FileNotOpenedError_code_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__FileNotOpenedError_msg_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return os__FileNotOpenedError_msg(*err);
}
static inline int builtin__os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return os__SizeOfTypeIs0Error_msg(*err);
}
static inline int builtin__os__ExecutableNotFoundError_code_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return builtin__Error_code(err->Error);
}
static inline string os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return os__ExecutableNotFoundError_msg(*err);
}
static inline int builtin__v__parser__IncludeError_code_Interface_IError_method_wrapper(v__parser__IncludeError* err) {
	return builtin__Error_code(err->Error);
}
static inline string v__parser__IncludeError_msg_Interface_IError_method_wrapper(v__parser__IncludeError* err) {
	return v__parser__IncludeError_msg(*err);
}

struct _IError_interface_methods {
	int (*_method_code)(void* _);
	string (*_method_msg)(void* _);
};

struct _IError_interface_methods IError_name_table[16] = {
	{
		._method_code = (void*) builtin__None___code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__None___msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) 0,
		._method_msg = (void*) 0,
	},
	{
		._method_code = (void*) builtin__Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__MessageError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__MessageError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__time__TimeParseError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) time__TimeParseError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__flag__UnknownFlagError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) flag__UnknownFlagError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__flag__ArgsCountError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) flag__ArgsCountError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__semver__InvalidComparatorFormatError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__semver__InvalidComparatorFormatError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__semver__EmptyInputError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) semver__EmptyInputError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__semver__InvalidVersionFormatError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) semver__InvalidVersionFormatError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__Eof_code_Interface_IError_method_wrapper,
		._method_msg = (void*) builtin__os__Eof_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) os__NotExpected_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__NotExpected_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__FileNotOpenedError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__FileNotOpenedError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__os__ExecutableNotFoundError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) builtin__v__parser__IncludeError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) v__parser__IncludeError_msg_Interface_IError_method_wrapper,
	},
};


// Casting functions for converting "None__" to interface "IError"

static inline IError I_None___to_Interface_IError(None__* x) {
return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
	};
}

// Casting functions for converting "voidptr" to interface "IError"

static inline IError I_voidptr_to_Interface_IError(voidptr* x) {
return (IError) {
		._voidptr = x,
		._typ = _IError_voidptr_index,
	};
}

// Casting functions for converting "Error" to interface "IError"

static inline IError I_Error_to_Interface_IError(Error* x) {
return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
	};
}

// Casting functions for converting "MessageError" to interface "IError"

static inline IError I_MessageError_to_Interface_IError(MessageError* x) {
return (IError) {
		._MessageError = x,
		._typ = _IError_MessageError_index,
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"

static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
	};
}

// Casting functions for converting "flag__UnknownFlagError" to interface "IError"

static inline IError I_flag__UnknownFlagError_to_Interface_IError(flag__UnknownFlagError* x) {
return (IError) {
		._flag__UnknownFlagError = x,
		._typ = _IError_flag__UnknownFlagError_index,
	};
}

// Casting functions for converting "flag__ArgsCountError" to interface "IError"

static inline IError I_flag__ArgsCountError_to_Interface_IError(flag__ArgsCountError* x) {
return (IError) {
		._flag__ArgsCountError = x,
		._typ = _IError_flag__ArgsCountError_index,
	};
}

// Casting functions for converting "semver__InvalidComparatorFormatError" to interface "IError"

static inline IError I_semver__InvalidComparatorFormatError_to_Interface_IError(semver__InvalidComparatorFormatError* x) {
return (IError) {
		._semver__InvalidComparatorFormatError = x,
		._typ = _IError_semver__InvalidComparatorFormatError_index,
	};
}

// Casting functions for converting "semver__EmptyInputError" to interface "IError"

static inline IError I_semver__EmptyInputError_to_Interface_IError(semver__EmptyInputError* x) {
return (IError) {
		._semver__EmptyInputError = x,
		._typ = _IError_semver__EmptyInputError_index,
	};
}

// Casting functions for converting "semver__InvalidVersionFormatError" to interface "IError"

static inline IError I_semver__InvalidVersionFormatError_to_Interface_IError(semver__InvalidVersionFormatError* x) {
return (IError) {
		._semver__InvalidVersionFormatError = x,
		._typ = _IError_semver__InvalidVersionFormatError_index,
	};
}

// Casting functions for converting "os__Eof" to interface "IError"

static inline IError I_os__Eof_to_Interface_IError(os__Eof* x) {
return (IError) {
		._os__Eof = x,
		._typ = _IError_os__Eof_index,
	};
}

// Casting functions for converting "os__NotExpected" to interface "IError"

static inline IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x) {
return (IError) {
		._os__NotExpected = x,
		._typ = _IError_os__NotExpected_index,
	};
}

// Casting functions for converting "os__FileNotOpenedError" to interface "IError"

static inline IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x) {
return (IError) {
		._os__FileNotOpenedError = x,
		._typ = _IError_os__FileNotOpenedError_index,
	};
}

// Casting functions for converting "os__SizeOfTypeIs0Error" to interface "IError"

static inline IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x) {
return (IError) {
		._os__SizeOfTypeIs0Error = x,
		._typ = _IError_os__SizeOfTypeIs0Error_index,
	};
}

// Casting functions for converting "os__ExecutableNotFoundError" to interface "IError"

static inline IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x) {
return (IError) {
		._os__ExecutableNotFoundError = x,
		._typ = _IError_os__ExecutableNotFoundError_index,
	};
}

// Casting functions for converting "v__parser__IncludeError" to interface "IError"

static inline IError I_v__parser__IncludeError_to_Interface_IError(v__parser__IncludeError* x) {
return (IError) {
		._v__parser__IncludeError = x,
		._typ = _IError_v__parser__IncludeError_index,
	};
}

static vphp__ITask I_main__AnalyzeTask_to_Interface_vphp__ITask(main__AnalyzeTask* x);
const u32 _vphp__ITask_main__AnalyzeTask_index = 0;
static vphp__ITask I_voidptr_to_Interface_vphp__ITask(voidptr* x);
const u32 _vphp__ITask_voidptr_index = 1;
// ^^^ number of types for interface vphp__ITask: 2

// Methods wrapper for interface "vphp__ITask"
static inline Array_f64 main__AnalyzeTask_run_Interface_vphp__ITask_method_wrapper(main__AnalyzeTask* t) {
	return main__AnalyzeTask_run(*t);
}

struct _vphp__ITask_interface_methods {
	Array_f64 (*_method_run)(void* _);
};

struct _vphp__ITask_interface_methods vphp__ITask_name_table[2] = {
	{
		._method_run = (void*) main__AnalyzeTask_run_Interface_vphp__ITask_method_wrapper,
	},
	{
		._method_run = (void*) 0,
	},
};


// Casting functions for converting "main__AnalyzeTask" to interface "vphp__ITask"

static inline vphp__ITask I_main__AnalyzeTask_to_Interface_vphp__ITask(main__AnalyzeTask* x) {
return (vphp__ITask) {
		._main__AnalyzeTask = x,
		._typ = _vphp__ITask_main__AnalyzeTask_index,
		.json_data = (string*)((char*)x + __offsetof_ptr(x, main__AnalyzeTask, json_data)),
	};
}

// Casting functions for converting "voidptr" to interface "vphp__ITask"

static inline vphp__ITask I_voidptr_to_Interface_vphp__ITask(voidptr* x) {
return (vphp__ITask) {
		._voidptr = x,
		._typ = _vphp__ITask_voidptr_index,
		.json_data = (string*)((char*)x),
	};
}

static vphp__compiler__PhpRepr I_vphp__compiler__PhpFuncRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpFuncRepr* x);
const u32 _vphp__compiler__PhpRepr_vphp__compiler__PhpFuncRepr_index = 0;
static vphp__compiler__PhpRepr I_voidptr_to_Interface_vphp__compiler__PhpRepr(voidptr* x);
const u32 _vphp__compiler__PhpRepr_voidptr_index = 1;
static vphp__compiler__PhpRepr I_vphp__compiler__PhpTaskRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpTaskRepr* x);
const u32 _vphp__compiler__PhpRepr_vphp__compiler__PhpTaskRepr_index = 2;
static vphp__compiler__PhpRepr I_vphp__compiler__PhpClassRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpClassRepr* x);
const u32 _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index = 3;
static vphp__compiler__PhpRepr I_vphp__compiler__PhpConstRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpConstRepr* x);
const u32 _vphp__compiler__PhpRepr_vphp__compiler__PhpConstRepr_index = 4;
// ^^^ number of types for interface vphp__compiler__PhpRepr: 5

// Methods wrapper for interface "vphp__compiler__PhpRepr"
static inline Array_string vphp__compiler__PhpFuncRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpFuncRepr* f) {
	return vphp__compiler__PhpFuncRepr_gen_c(*f);
}
static inline Array_string vphp__compiler__PhpFuncRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpFuncRepr* r) {
	return vphp__compiler__PhpFuncRepr_gen_h(*r);
}
static inline Array_string vphp__compiler__PhpFuncRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpFuncRepr* r) {
	return vphp__compiler__PhpFuncRepr_gen_minit(*r);
}
static inline Array_string vphp__compiler__PhpTaskRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpTaskRepr* r) {
	return vphp__compiler__PhpTaskRepr_gen_c(*r);
}
static inline Array_string vphp__compiler__PhpTaskRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpTaskRepr* r) {
	return vphp__compiler__PhpTaskRepr_gen_h(*r);
}
static inline Array_string vphp__compiler__PhpTaskRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpTaskRepr* r) {
	return vphp__compiler__PhpTaskRepr_gen_minit(*r);
}
static inline Array_string vphp__compiler__PhpClassRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpClassRepr* r) {
	return vphp__compiler__PhpClassRepr_gen_c(*r);
}
static inline Array_string vphp__compiler__PhpClassRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpClassRepr* r) {
	return vphp__compiler__PhpClassRepr_gen_h(*r);
}
static inline Array_string vphp__compiler__PhpClassRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpClassRepr* r) {
	return vphp__compiler__PhpClassRepr_gen_minit(*r);
}
static inline Array_string vphp__compiler__PhpConstRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpConstRepr* r) {
	return vphp__compiler__PhpConstRepr_gen_c(*r);
}
static inline Array_string vphp__compiler__PhpConstRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpConstRepr* r) {
	return vphp__compiler__PhpConstRepr_gen_h(*r);
}
static inline Array_string vphp__compiler__PhpConstRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper(vphp__compiler__PhpConstRepr* r) {
	return vphp__compiler__PhpConstRepr_gen_minit(*r);
}

struct _vphp__compiler__PhpRepr_interface_methods {
	Array_string (*_method_gen_c)(void* _);
	Array_string (*_method_gen_h)(void* _);
	Array_string (*_method_gen_minit)(void* _);
	bool (*_method_parse)(void* _, v__ast__Stmt stmt, v__ast__Table* table);
};

struct _vphp__compiler__PhpRepr_interface_methods vphp__compiler__PhpRepr_name_table[5] = {
	{
		._method_gen_c = (void*) vphp__compiler__PhpFuncRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_h = (void*) vphp__compiler__PhpFuncRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_minit = (void*) vphp__compiler__PhpFuncRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_parse = (void*) vphp__compiler__PhpFuncRepr_parse,
	},
	{
		._method_gen_c = (void*) 0,
		._method_gen_h = (void*) 0,
		._method_gen_minit = (void*) 0,
		._method_parse = (void*) 0,
	},
	{
		._method_gen_c = (void*) vphp__compiler__PhpTaskRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_h = (void*) vphp__compiler__PhpTaskRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_minit = (void*) vphp__compiler__PhpTaskRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_parse = (void*) vphp__compiler__PhpTaskRepr_parse,
	},
	{
		._method_gen_c = (void*) vphp__compiler__PhpClassRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_h = (void*) vphp__compiler__PhpClassRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_minit = (void*) vphp__compiler__PhpClassRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_parse = (void*) vphp__compiler__PhpClassRepr_parse,
	},
	{
		._method_gen_c = (void*) vphp__compiler__PhpConstRepr_gen_c_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_h = (void*) vphp__compiler__PhpConstRepr_gen_h_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_gen_minit = (void*) vphp__compiler__PhpConstRepr_gen_minit_Interface_vphp__compiler__PhpRepr_method_wrapper,
		._method_parse = (void*) vphp__compiler__PhpConstRepr_parse,
	},
};


// Casting functions for converting "vphp__compiler__PhpFuncRepr" to interface "vphp__compiler__PhpRepr"

static inline vphp__compiler__PhpRepr I_vphp__compiler__PhpFuncRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpFuncRepr* x) {
return (vphp__compiler__PhpRepr) {
		._vphp__compiler__PhpFuncRepr = x,
		._typ = _vphp__compiler__PhpRepr_vphp__compiler__PhpFuncRepr_index,
	};
}

// Casting functions for converting "voidptr" to interface "vphp__compiler__PhpRepr"

static inline vphp__compiler__PhpRepr I_voidptr_to_Interface_vphp__compiler__PhpRepr(voidptr* x) {
return (vphp__compiler__PhpRepr) {
		._voidptr = x,
		._typ = _vphp__compiler__PhpRepr_voidptr_index,
	};
}

// Casting functions for converting "vphp__compiler__PhpTaskRepr" to interface "vphp__compiler__PhpRepr"

static inline vphp__compiler__PhpRepr I_vphp__compiler__PhpTaskRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpTaskRepr* x) {
return (vphp__compiler__PhpRepr) {
		._vphp__compiler__PhpTaskRepr = x,
		._typ = _vphp__compiler__PhpRepr_vphp__compiler__PhpTaskRepr_index,
	};
}

// Casting functions for converting "vphp__compiler__PhpClassRepr" to interface "vphp__compiler__PhpRepr"

static inline vphp__compiler__PhpRepr I_vphp__compiler__PhpClassRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpClassRepr* x) {
return (vphp__compiler__PhpRepr) {
		._vphp__compiler__PhpClassRepr = x,
		._typ = _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index,
	};
}

// Casting functions for converting "vphp__compiler__PhpConstRepr" to interface "vphp__compiler__PhpRepr"

static inline vphp__compiler__PhpRepr I_vphp__compiler__PhpConstRepr_to_Interface_vphp__compiler__PhpRepr(vphp__compiler__PhpConstRepr* x) {
return (vphp__compiler__PhpRepr) {
		._vphp__compiler__PhpConstRepr = x,
		._typ = _vphp__compiler__PhpRepr_vphp__compiler__PhpConstRepr_index,
	};
}

static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
const u32 _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
static rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x);
const u32 _rand__PRNG_voidptr_index = 1;
// ^^^ number of types for interface rand__PRNG: 2

// Methods wrapper for interface "rand__PRNG"

struct _rand__PRNG_interface_methods {
	int (*_method_block_size)(void* _);
	void (*_method__v_free)(void* _);
	void (*_method_seed)(void* _, Array_u32 seed_data);
	u16 (*_method_u16)(void* _);
	u32 (*_method_u32)(void* _);
	u64 (*_method_u64)(void* _);
	u8 (*_method_u8)(void* _);
};

struct _rand__PRNG_interface_methods rand__PRNG_name_table[2] = {
	{
		._method_block_size = (void*) rand__wyrand__WyRandRNG_block_size,
		._method__v_free = (void*) rand__wyrand__WyRandRNG_free,
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u16 = (void*) rand__wyrand__WyRandRNG_u16,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_u8 = (void*) rand__wyrand__WyRandRNG_u8,
	},
	{
		._method_block_size = (void*) 0,
		._method__v_free = (void*) 0,
		._method_seed = (void*) 0,
		._method_u16 = (void*) 0,
		._method_u32 = (void*) 0,
		._method_u64 = (void*) 0,
		._method_u8 = (void*) 0,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"

static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}

// Casting functions for converting "voidptr" to interface "rand__PRNG"

static inline rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x) {
return (rand__PRNG) {
		._voidptr = x,
		._typ = _rand__PRNG_voidptr_index,
	};
}


// V sort fn definitions:
VV_LOC  int compare_11835712493692648452_RepIndex_by_idx(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) return -1;
	else return 1;
}

VV_LOC  int compare_1065768667300548517_string(string* a, string* b) {
	if (builtin__string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOC  int compare_8913308454256331878_string(string* a, string* b) {
	if (builtin__string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOC  int compare_3952967824979149813_string(string* a, string* b) {
	if (builtin__string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOC  int compare_9574989068970878465_string(string* a, string* b) {
	if (builtin__string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOC  int compare_5516636134126562804_v__util__Possibility_by_similarity(v__util__Possibility* a, v__util__Possibility* b) {
	if (a->similarity < b->similarity) return -1;
	else return 1;
}

VV_LOC  int compare_5516636134126562804_string(string* a, string* b) {
	if (builtin__string__lt(*a, *b)) return -1;
	else return 1;
}

VV_LOC  int compare_15770755226076705614_v__ast__StringifyModReplacement_by_weight_reverse(v__ast__StringifyModReplacement* a, v__ast__StringifyModReplacement* b) {
	if (b->weight < a->weight) return -1;
	else return 1;
}

VV_LOC  int compare_6896267785627929237_int(int* a, int* b) {
	if (*a < *b) return -1;
	else return 1;
}


// V shared type functions:

static inline voidptr __dup__shared__Map_u64_string(voidptr src, int sz) {
	__shared__Map_u64_string* dest = builtin__memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline voidptr __dup__shared__Map_string_time__StopWatch(voidptr src, int sz) {
	__shared__Map_string_time__StopWatch* dest = builtin__memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline voidptr __dup__shared__Map_int_Array_v__ast__Type(voidptr src, int sz) {
	__shared__Map_int_Array_v__ast__Type* dest = builtin__memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}

typedef struct __shared_map __shared_map;
struct __shared_map {
	sync__RwMutex mtx;
	map val;
};
static inline voidptr __dup_shared_map(voidptr src, int sz) {
	__shared_map* dest = builtin__memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
typedef struct __shared_array __shared_array;
struct __shared_array {
	sync__RwMutex mtx;
	array val;
};
static inline voidptr __dup_shared_array(voidptr src, int sz) {
	__shared_array* dest = builtin__memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline void __sort_ptr(uintptr_t a[], bool b[], int l) {
	for (int i=1; i<l; i++) {
		uintptr_t ins = a[i];
		bool insb = b[i];
		int j = i;
		while(j>0 && a[j-1] > ins) {
			a[j] = a[j-1];
			b[j] = b[j-1];
			j--;
		}
		a[j] = ins;
		b[j] = insb;
	}
}

// V channel code:

static inline bool __chan_bool_popval(chan_bool ch) {
	bool val;
	sync__Channel_try_pop_priv(ch, &val, false);
	return val;
}

static inline void __chan_bool_pushval(chan_bool ch, bool val) {
	sync__Channel_try_push_priv(ch, &val, false);
}

// end of V out (header)

// V gowrappers waiter fns:
Array_f64 __v_thread_Array_f64_wait(__v_thread_Array_f64 thread);
void* vphp__ITask_run_thread_wrapper(thread_arg_vphp__ITask_run *arg);
void* anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731_thread_wrapper(thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731 *arg);

// V auto str functions:
static string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime__hhmm12: return _S("hhmm12");
		case time__FormatTime__hhmm24: return _S("hhmm24");
		case time__FormatTime__hhmmss12: return _S("hhmmss12");
		case time__FormatTime__hhmmss24: return _S("hhmmss24");
		case time__FormatTime__hhmmss24_milli: return _S("hhmmss24_milli");
		case time__FormatTime__hhmmss24_micro: return _S("hhmmss24_micro");
		case time__FormatTime__hhmmss24_nano: return _S("hhmmss24_nano");
		case time__FormatTime__no_time: return _S("no_time");
		default: return _S("unknown enum value");
	}
}
static string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate__ddmmyy: return _S("ddmmyy");
		case time__FormatDate__ddmmyyyy: return _S("ddmmyyyy");
		case time__FormatDate__mmddyy: return _S("mmddyy");
		case time__FormatDate__mmddyyyy: return _S("mmddyyyy");
		case time__FormatDate__mmmd: return _S("mmmd");
		case time__FormatDate__mmmdd: return _S("mmmdd");
		case time__FormatDate__mmmddyy: return _S("mmmddyy");
		case time__FormatDate__mmmddyyyy: return _S("mmmddyyyy");
		case time__FormatDate__no_date: return _S("no_date");
		case time__FormatDate__yyyymmdd: return _S("yyyymmdd");
		case time__FormatDate__yymmdd: return _S("yymmdd");
		default: return _S("unknown enum value");
	}
}
static string v__pref__Arch_str(v__pref__Arch it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Arch___auto: return _S("_auto");
		case v__pref__Arch__amd64: return _S("amd64");
		case v__pref__Arch__arm64: return _S("arm64");
		case v__pref__Arch__arm32: return _S("arm32");
		case v__pref__Arch__rv64: return _S("rv64");
		case v__pref__Arch__rv32: return _S("rv32");
		case v__pref__Arch__i386: return _S("i386");
		case v__pref__Arch__s390x: return _S("s390x");
		case v__pref__Arch__ppc64le: return _S("ppc64le");
		case v__pref__Arch__loongarch64: return _S("loongarch64");
		case v__pref__Arch__js_node: return _S("js_node");
		case v__pref__Arch__js_browser: return _S("js_browser");
		case v__pref__Arch__js_freestanding: return _S("js_freestanding");
		case v__pref__Arch__wasm32: return _S("wasm32");
		case v__pref__Arch___max: return _S("_max");
		default: return _S("unknown enum value");
	}
}
static string v__pref__Backend_str(v__pref__Backend it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__Backend__c: return _S("c");
		case v__pref__Backend__golang: return _S("golang");
		case v__pref__Backend__interpret: return _S("interpret");
		case v__pref__Backend__js_node: return _S("js_node");
		case v__pref__Backend__js_browser: return _S("js_browser");
		case v__pref__Backend__js_freestanding: return _S("js_freestanding");
		case v__pref__Backend__native: return _S("native");
		case v__pref__Backend__wasm: return _S("wasm");
		default: return _S("unknown enum value");
	}
}
static string v__ast__AttrKind_str(v__ast__AttrKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__AttrKind__plain: return _S("plain");
		case v__ast__AttrKind__string: return _S("string");
		case v__ast__AttrKind__number: return _S("number");
		case v__ast__AttrKind__bool: return _S("bool");
		case v__ast__AttrKind__comptime_define: return _S("comptime_define");
		default: return _S("unknown enum value");
	}
}
static string Array_v__ast__Expr_str(Array_v__ast__Expr a) { return indent_Array_v__ast__Expr_str(a, 0);}
static string indent_Array_v__ast__Expr_str(Array_v__ast__Expr a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Expr it = *(v__ast__Expr*)builtin__array_get(a, i);
		strings__Builder_write_string(&sb, _S(""));
		string x = v__ast__Expr_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__CallExpr_str(v__ast__CallExpr it) { return indent_v__ast__CallExpr_str(it, 0);}
static string v__ast__TypeInfo_str(v__ast__TypeInfo x) { return indent_v__ast__TypeInfo_str(x, 0); }
static string v__ast__Fn_str(v__ast__Fn it) { return indent_v__ast__Fn_str(it, 0);}
static string v__ast__Language_str(v__ast__Language it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__Language__v: return _S("v");
		case v__ast__Language__c: return _S("c");
		case v__ast__Language__js: return _S("js");
		case v__ast__Language__wasm: return _S("wasm");
		case v__ast__Language__amd64: return _S("amd64");
		case v__ast__Language__i386: return _S("i386");
		case v__ast__Language__arm64: return _S("arm64");
		case v__ast__Language__arm32: return _S("arm32");
		case v__ast__Language__rv64: return _S("rv64");
		case v__ast__Language__rv32: return _S("rv32");
		case v__ast__Language__s390x: return _S("s390x");
		case v__ast__Language__ppc64le: return _S("ppc64le");
		case v__ast__Language__loongarch64: return _S("loongarch64");
		case v__ast__Language__wasm32: return _S("wasm32");
		default: return _S("unknown enum value");
	}
}
static string v__pref__CompilerType_str(v__pref__CompilerType it) { /* gen_str_for_enum */
	switch(it) {
		case v__pref__CompilerType__gcc: return _S("gcc");
		case v__pref__CompilerType__tinyc: return _S("tinyc");
		case v__pref__CompilerType__clang: return _S("clang");
		case v__pref__CompilerType__emcc: return _S("emcc");
		case v__pref__CompilerType__mingw: return _S("mingw");
		case v__pref__CompilerType__msvc: return _S("msvc");
		case v__pref__CompilerType__cplusplus: return _S("cplusplus");
		default: return _S("unknown enum value");
	}
}
static string v__ast__AtExpr_str(v__ast__AtExpr it) { return indent_v__ast__AtExpr_str(it, 0);}
static string v__ast__Ident_str(v__ast__Ident it) { return indent_v__ast__Ident_str(it, 0);}
static string v__ast__StringLiteral_str(v__ast__StringLiteral it) { return indent_v__ast__StringLiteral_str(it, 0);}
static string Array_v__ast__Type_str(Array_v__ast__Type a) { return indent_Array_v__ast__Type_str(a, 0);}
static string indent_Array_v__ast__Type_str(Array_v__ast__Type a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		u32 it = *(u32*)builtin__array_get(a, i);
		strings__Builder_write_string(&sb, _S(""));
		string x = builtin__u32_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__OrExpr_str(v__ast__OrExpr it) { return indent_v__ast__OrExpr_str(it, 0);}
static string Array_v__ast__CallArg_str(Array_v__ast__CallArg a) { return indent_Array_v__ast__CallArg_str(a, 0);}
static string indent_Array_v__ast__CallArg_str(Array_v__ast__CallArg a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__CallArg it = *(v__ast__CallArg*)builtin__array_get(a, i);
		strings__Builder_write_string(&sb, _S(""));
		string x = v__ast__CallArg_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Comment_str(Array_v__ast__Comment a) { return indent_Array_v__ast__Comment_str(a, 0);}
static string indent_Array_v__ast__Comment_str(Array_v__ast__Comment a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Comment it = *(v__ast__Comment*)builtin__array_get(a, i);
		string x = indent_v__ast__Comment_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__token__Pos_str(v__token__Pos it) { return indent_v__token__Pos_str(it, 0);}
static string v__ast__CallKind_str(v__ast__CallKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__CallKind__unknown: return _S("unknown");
		case v__ast__CallKind__str: return _S("str");
		case v__ast__CallKind__wait: return _S("wait");
		case v__ast__CallKind__free: return _S("free");
		case v__ast__CallKind__try_push: return _S("try_push");
		case v__ast__CallKind__try_pop: return _S("try_pop");
		case v__ast__CallKind__keys: return _S("keys");
		case v__ast__CallKind__values: return _S("values");
		case v__ast__CallKind__slice: return _S("slice");
		case v__ast__CallKind__map: return _S("map");
		case v__ast__CallKind__insert: return _S("insert");
		case v__ast__CallKind__prepend: return _S("prepend");
		case v__ast__CallKind__sort_with_compare: return _S("sort_with_compare");
		case v__ast__CallKind__sorted_with_compare: return _S("sorted_with_compare");
		case v__ast__CallKind__sort: return _S("sort");
		case v__ast__CallKind__sorted: return _S("sorted");
		case v__ast__CallKind__filter: return _S("filter");
		case v__ast__CallKind__any: return _S("any");
		case v__ast__CallKind__all: return _S("all");
		case v__ast__CallKind__count: return _S("count");
		case v__ast__CallKind__clone: return _S("clone");
		case v__ast__CallKind__clone_to_depth: return _S("clone_to_depth");
		case v__ast__CallKind__trim: return _S("trim");
		case v__ast__CallKind__contains: return _S("contains");
		case v__ast__CallKind__index: return _S("index");
		case v__ast__CallKind__last_index: return _S("last_index");
		case v__ast__CallKind__first: return _S("first");
		case v__ast__CallKind__last: return _S("last");
		case v__ast__CallKind__pop_left: return _S("pop_left");
		case v__ast__CallKind__pop: return _S("pop");
		case v__ast__CallKind__delete: return _S("delete");
		case v__ast__CallKind__delete_many: return _S("delete_many");
		case v__ast__CallKind__delete_last: return _S("delete_last");
		case v__ast__CallKind__drop: return _S("drop");
		case v__ast__CallKind__reverse: return _S("reverse");
		case v__ast__CallKind__reverse_in_place: return _S("reverse_in_place");
		case v__ast__CallKind__panic: return _S("panic");
		case v__ast__CallKind__json_decode: return _S("json_decode");
		case v__ast__CallKind__json_encode: return _S("json_encode");
		case v__ast__CallKind__json_encode_pretty: return _S("json_encode_pretty");
		case v__ast__CallKind__repeat: return _S("repeat");
		case v__ast__CallKind__type_name: return _S("type_name");
		case v__ast__CallKind__type_idx: return _S("type_idx");
		case v__ast__CallKind__clear: return _S("clear");
		case v__ast__CallKind__reserve: return _S("reserve");
		case v__ast__CallKind__move: return _S("move");
		case v__ast__CallKind__main_main: return _S("main_main");
		case v__ast__CallKind__va_arg: return _S("va_arg");
		case v__ast__CallKind__addr: return _S("addr");
		case v__ast__CallKind__main: return _S("main");
		case v__ast__CallKind__jsawait: return _S("jsawait");
		case v__ast__CallKind__error: return _S("error");
		case v__ast__CallKind__grow_cap: return _S("grow_cap");
		case v__ast__CallKind__grow_len: return _S("grow_len");
		case v__ast__CallKind__eprint: return _S("eprint");
		case v__ast__CallKind__eprintln: return _S("eprintln");
		case v__ast__CallKind__print: return _S("print");
		case v__ast__CallKind__println: return _S("println");
		case v__ast__CallKind__close: return _S("close");
		case v__ast__CallKind__pointers: return _S("pointers");
		case v__ast__CallKind__push_many: return _S("push_many");
		case v__ast__CallKind__malloc: return _S("malloc");
		case v__ast__CallKind__writeln: return _S("writeln");
		default: return _S("unknown enum value");
	}
}
static string v__ast__UnknownTypeInfo_str(v__ast__UnknownTypeInfo it) { return indent_v__ast__UnknownTypeInfo_str(it, 0);}
static string v__ast__Aggregate_str(v__ast__Aggregate it) { return indent_v__ast__Aggregate_str(it, 0);}
static string v__ast__Alias_str(v__ast__Alias it) { return indent_v__ast__Alias_str(it, 0);}
static string v__ast__Array_str(v__ast__Array it) { return indent_v__ast__Array_str(it, 0);}
static string v__ast__ArrayFixed_str(v__ast__ArrayFixed it) { return indent_v__ast__ArrayFixed_str(it, 0);}
static string v__ast__Chan_str(v__ast__Chan it) { return indent_v__ast__Chan_str(it, 0);}
static string v__ast__Enum_str(v__ast__Enum it) { return indent_v__ast__Enum_str(it, 0);}
static string v__ast__FnType_str(v__ast__FnType it) { return indent_v__ast__FnType_str(it, 0);}
static string v__ast__GenericInst_str(v__ast__GenericInst it) { return indent_v__ast__GenericInst_str(it, 0);}
static string v__ast__Interface_str(v__ast__Interface it) { return indent_v__ast__Interface_str(it, 0);}
static string v__ast__Map_str(v__ast__Map it) { return indent_v__ast__Map_str(it, 0);}
static string v__ast__MultiReturn_str(v__ast__MultiReturn it) { return indent_v__ast__MultiReturn_str(it, 0);}
static string v__ast__Struct_str(v__ast__Struct it) { return indent_v__ast__Struct_str(it, 0);}
static string v__ast__SumType_str(v__ast__SumType it) { return indent_v__ast__SumType_str(it, 0);}
static string v__ast__Thread_str(v__ast__Thread it) { return indent_v__ast__Thread_str(it, 0);}
static string Array_v__ast__Param_str(Array_v__ast__Param a) { return indent_Array_v__ast__Param_str(a, 0);}
static string indent_Array_v__ast__Param_str(Array_v__ast__Param a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Param it = *(v__ast__Param*)builtin__array_get(a, i);
		string x = indent_v__ast__Param_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Attr_str(Array_v__ast__Attr a) { return indent_Array_v__ast__Attr_str(a, 0);}
static string indent_Array_v__ast__Attr_str(Array_v__ast__Attr a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Attr it = *(v__ast__Attr*)builtin__array_get(a, i);
		strings__Builder_write_string(&sb, _S(""));
		string x = v__ast__Attr_str(&it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__token__AtKind_str(v__token__AtKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__token__AtKind__unknown: return _S("unknown");
		case v__token__AtKind__fn_name: return _S("fn_name");
		case v__token__AtKind__method_name: return _S("method_name");
		case v__token__AtKind__mod_name: return _S("mod_name");
		case v__token__AtKind__struct_name: return _S("struct_name");
		case v__token__AtKind__vexe_path: return _S("vexe_path");
		case v__token__AtKind__file_path: return _S("file_path");
		case v__token__AtKind__file_dir: return _S("file_dir");
		case v__token__AtKind__line_nr: return _S("line_nr");
		case v__token__AtKind__column_nr: return _S("column_nr");
		case v__token__AtKind__vhash: return _S("vhash");
		case v__token__AtKind__v_current_hash: return _S("v_current_hash");
		case v__token__AtKind__vmod_file: return _S("vmod_file");
		case v__token__AtKind__vmodroot_path: return _S("vmodroot_path");
		case v__token__AtKind__vmod_hash: return _S("vmod_hash");
		case v__token__AtKind__vroot_path: return _S("vroot_path");
		case v__token__AtKind__vexeroot_path: return _S("vexeroot_path");
		case v__token__AtKind__file_path_line_nr: return _S("file_path_line_nr");
		case v__token__AtKind__location: return _S("location");
		case v__token__AtKind__build_date: return _S("build_date");
		case v__token__AtKind__build_time: return _S("build_time");
		case v__token__AtKind__build_timestamp: return _S("build_timestamp");
		case v__token__AtKind__os: return _S("os");
		case v__token__AtKind__ccompiler: return _S("ccompiler");
		case v__token__AtKind__backend: return _S("backend");
		case v__token__AtKind__platform: return _S("platform");
		default: return _S("unknown enum value");
	}
}
static string v__ast__ScopeObject_str(v__ast__ScopeObject x) { return indent_v__ast__ScopeObject_str(x, 0); }
static string v__ast__IdentInfo_str(v__ast__IdentInfo x) { return indent_v__ast__IdentInfo_str(x, 0); }
static string v__ast__IdentKind_str(v__ast__IdentKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__IdentKind__unresolved: return _S("unresolved");
		case v__ast__IdentKind__blank_ident: return _S("blank_ident");
		case v__ast__IdentKind__variable: return _S("variable");
		case v__ast__IdentKind__constant: return _S("constant");
		case v__ast__IdentKind__global: return _S("global");
		case v__ast__IdentKind__function: return _S("function");
		default: return _S("unknown enum value");
	}
}
static string v__ast__OrKind_str(v__ast__OrKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__OrKind__absent: return _S("absent");
		case v__ast__OrKind__block: return _S("block");
		case v__ast__OrKind__propagate_option: return _S("propagate_option");
		case v__ast__OrKind__propagate_result: return _S("propagate_result");
		default: return _S("unknown enum value");
	}
}
static string Array_v__ast__Stmt_str(Array_v__ast__Stmt a) { return indent_Array_v__ast__Stmt_str(a, 0);}
static string indent_Array_v__ast__Stmt_str(Array_v__ast__Stmt a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Stmt it = *(v__ast__Stmt*)builtin__array_get(a, i);
		strings__Builder_write_string(&sb, _S(""));
		string x = v__ast__Stmt_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Comment_str(v__ast__Comment it) { return indent_v__ast__Comment_str(it, 0);}
static string Array_v__ast__StructField_str(Array_v__ast__StructField a) { return indent_Array_v__ast__StructField_str(a, 0);}
static string indent_Array_v__ast__StructField_str(Array_v__ast__StructField a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__StructField it = *(v__ast__StructField*)builtin__array_get(a, i);
		string x = indent_v__ast__StructField_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Map_string_Array_v__ast__Attr_str(Map_string_Array_v__ast__Attr m) { return indent_Map_string_Array_v__ast__Attr_str(m, 0);}
static string indent_Map_string_Array_v__ast__Attr_str(Map_string_Array_v__ast__Attr m, int indent_count) { /* gen_str_for_map */
	strings__Builder sb = strings__new_builder(2 + m.key_values.len * 10);
	strings__Builder_write_string(&sb, _S("{"));
	bool is_first = true;
	for (int i = 0; i < m.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&m.key_values, i)) { continue; }
		else if (!is_first) { strings__Builder_write_string(&sb, _S(", ")); }
		string key = *(string*)builtin__DenseArray_key(&m.key_values, i);
		strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("'"), 0xfe10, {.d_s = key}},{_S("'"), 0, {.d_c = 0 }}})));
		strings__Builder_write_string(&sb, _S(": "));
		strings__Builder_write_string(&sb, indent_Array_v__ast__Attr_str(*(Array_v__ast__Attr*)builtin__DenseArray_value(&m.key_values, i), indent_count));
		is_first = false;
	}
	strings__Builder_write_string(&sb, _S("}"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Fn_str(Array_v__ast__Fn a) { return indent_Array_v__ast__Fn_str(a, 0);}
static string indent_Array_v__ast__Fn_str(Array_v__ast__Fn a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Fn it = *(v__ast__Fn*)builtin__array_get(a, i);
		string x = indent_v__ast__Fn_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m) { return indent_Map_int_Array_v__ast__Type_str(m, 0);}
static string indent_Map_int_Array_v__ast__Type_str(Map_int_Array_v__ast__Type m, int indent_count) { /* gen_str_for_map */
	strings__Builder sb = strings__new_builder(2 + m.key_values.len * 10);
	strings__Builder_write_string(&sb, _S("{"));
	bool is_first = true;
	for (int i = 0; i < m.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&m.key_values, i)) { continue; }
		else if (!is_first) { strings__Builder_write_string(&sb, _S(", ")); }
		int key = *(int*)builtin__DenseArray_key(&m.key_values, i);
		strings__Builder_write_string(&sb, builtin__int_str(key));
		strings__Builder_write_string(&sb, _S(": "));
		strings__Builder_write_string(&sb, indent_Array_v__ast__Type_str(*(Array_v__ast__Type*)builtin__DenseArray_value(&m.key_values, i), indent_count));
		is_first = false;
	}
	strings__Builder_write_string(&sb, _S("}"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__Param_str(v__ast__Param it) { return indent_v__ast__Param_str(it, 0);}
static string v__ast__EmptyScopeObject_str(v__ast__EmptyScopeObject it) { return indent_v__ast__EmptyScopeObject_str(it, 0);}
static string v__ast__AsmRegister_str(v__ast__AsmRegister it) { return indent_v__ast__AsmRegister_str(it, 0);}
static string v__ast__ConstField_str(v__ast__ConstField it) { return indent_v__ast__ConstField_str(it, 0);}
static string v__ast__GlobalField_str(v__ast__GlobalField it) { return indent_v__ast__GlobalField_str(it, 0);}
static string v__ast__Var_str(v__ast__Var it) { return indent_v__ast__Var_str(it, 0);}
static string v__ast__IdentFn_str(v__ast__IdentFn it) { return indent_v__ast__IdentFn_str(it, 0);}
static string v__ast__IdentVar_str(v__ast__IdentVar it) { return indent_v__ast__IdentVar_str(it, 0);}
static string v__ast__StructField_str(v__ast__StructField it) { return indent_v__ast__StructField_str(it, 0);}
static string v__ast__ComptTimeConstValue_str(v__ast__ComptTimeConstValue x) { return indent_v__ast__ComptTimeConstValue_str(x, 0); }
static string v__ast__ComptimeVarKind_str(v__ast__ComptimeVarKind it) { /* gen_str_for_enum */
	switch(it) {
		case v__ast__ComptimeVarKind__no_comptime: return _S("no_comptime");
		case v__ast__ComptimeVarKind__key_var: return _S("key_var");
		case v__ast__ComptimeVarKind__value_var: return _S("value_var");
		case v__ast__ComptimeVarKind__field_var: return _S("field_var");
		case v__ast__ComptimeVarKind__generic_param: return _S("generic_param");
		case v__ast__ComptimeVarKind__generic_var: return _S("generic_var");
		case v__ast__ComptimeVarKind__smartcast: return _S("smartcast");
		case v__ast__ComptimeVarKind__aggregate: return _S("aggregate");
		default: return _S("unknown enum value");
	}
}
static string v__ast__StructDecl_str(v__ast__StructDecl it) { return indent_v__ast__StructDecl_str(it, 0);}
static string v__ast__EmptyExpr_str(v__ast__EmptyExpr it) { return indent_v__ast__EmptyExpr_str(it, 0); }
static string indent_v__ast__EmptyExpr_str(v__ast__EmptyExpr it, int indent_count) {
	string tmp_ds = builtin__u8_str(it);
	string res = builtin__str_intp(2, _MOV((StrIntpData[]){
		{_S("v.ast.EmptyExpr("), 0xfe10, {.d_s = tmp_ds }},
		{_S(")"), 0, {.d_c = 0 }}
	}));
	builtin__string_free(&tmp_ds);
	return res;
}
static string Array_v__ast__TypeNode_str(Array_v__ast__TypeNode a) { return indent_Array_v__ast__TypeNode_str(a, 0);}
static string indent_Array_v__ast__TypeNode_str(Array_v__ast__TypeNode a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__TypeNode it = *(v__ast__TypeNode*)builtin__array_get(a, i);
		string x = indent_v__ast__TypeNode_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_v__ast__Embed_str(Array_v__ast__Embed a) { return indent_Array_v__ast__Embed_str(a, 0);}
static string indent_Array_v__ast__Embed_str(Array_v__ast__Embed a, int indent_count) {
	strings__Builder sb = strings__new_builder(2 + a.len * 10);
	strings__Builder_write_string(&sb, _S("["));
	for (int i = 0; i < a.len; ++i) {
		v__ast__Embed it = *(v__ast__Embed*)builtin__array_get(a, i);
		string x = indent_v__ast__Embed_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_string(&sb, _S("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string v__ast__TypeNode_str(v__ast__TypeNode it) { return indent_v__ast__TypeNode_str(it, 0);}
static string v__ast__Embed_str(v__ast__Embed it) { return indent_v__ast__Embed_str(it, 0);}

// V auto functions:
string indent_v__ast__CallExpr_str(v__ast__CallExpr it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__ast__OrExpr_str(it.or_block, indent_count + 1);
	string _t2 = indent_Array_v__ast__Type_str(it.expected_arg_types, indent_count + 1);
	string _t3 = indent_Array_v__ast__CallArg_str(it.args, indent_count + 1);
	string _t4 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t5 = indent_Array_v__ast__Type_str(it.raw_concrete_types, indent_count + 1);
	string _t6 = indent_Array_v__ast__Type_str(it.from_embed_types, indent_count + 1);
	string _t7 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string _t8 = v__ast__Expr_str(it.left);
	string _t9 = builtin__isnil(it.scope) ? _S("nil") : (indent_count > 25)? _S("<probably circular>") : v__ast__Scope_str(it.scope);
	string _t10 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t11 = indent_v__token__Pos_str(it.concrete_list_pos, indent_count + 1);
	string _t12 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t13 = v__ast__Type_str(it.receiver_type);
	string _t14 = v__ast__Type_str(it.return_type);
	string _t15 = v__ast__Type_str(it.return_type_generic);
	string _t16 = v__ast__Type_str(it.fn_var_type);
	string _t17 = v__ast__Type_str(it.left_type);
	string _t18 = v__ast__Type_str(it.receiver_concrete_type);
	string _t19 = v__ast__CallKind_str((it.kind));
	string _t20 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 167, _MOV((StrIntpData[]){
		{_S("ast.CallExpr{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    or_block: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    expected_arg_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    args: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    raw_concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    from_embed_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    const_name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.const_name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    left: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    mod: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.mod}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    scope: &"), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t10}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_list_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t11}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t12}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    receiver_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t13}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    return_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t14}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    return_type_generic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t15}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    nr_ret_values: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.nr_ret_values}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    fn_var_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t16}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    left_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t17}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    receiver_concrete_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t18}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    kind: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t19}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t20}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_unwrapped_fn_selector: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_unwrapped_fn_selector ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_method: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_method ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_field: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_field ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_fn_var: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_fn_var ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_fn_a_const: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_fn_a_const ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_keep_alive: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_keep_alive ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_noreturn: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_noreturn ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_ctor_new: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_ctor_new ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_file_translated: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_file_translated ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_static_method: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_static_method ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_variadic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_variadic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_c_variadic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_c_variadic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comptime_ret_val: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.comptime_ret_val ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    should_be_skipped: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.should_be_skipped ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    free_receiver: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.free_receiver ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_return_used: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_return_used ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_expand_simple_interpolation: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_expand_simple_interpolation ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t20);
	builtin__string_free(&_t19);
	builtin__string_free(&_t18);
	builtin__string_free(&_t17);
	builtin__string_free(&_t16);
	builtin__string_free(&_t15);
	builtin__string_free(&_t14);
	builtin__string_free(&_t13);
	builtin__string_free(&_t12);
	builtin__string_free(&_t11);
	builtin__string_free(&_t10);
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

static string indent_v__ast__TypeInfo_str(v__ast__TypeInfo x, int indent_count) {
	switch(x._typ) {
		case 498: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__UnknownTypeInfo_str(*(v__ast__UnknownTypeInfo*)x._v__ast__UnknownTypeInfo, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 480: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Aggregate_str(*(v__ast__Aggregate*)x._v__ast__Aggregate, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 482: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Alias_str(*(v__ast__Alias*)x._v__ast__Alias, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 452: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Array_str(*(v__ast__Array*)x._v__ast__Array, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 491: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__ArrayFixed_str(*(v__ast__ArrayFixed*)x._v__ast__ArrayFixed, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 492: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Chan_str(*(v__ast__Chan*)x._v__ast__Chan, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 490: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Enum_str(*(v__ast__Enum*)x._v__ast__Enum, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 495: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__FnType_str(*(v__ast__FnType*)x._v__ast__FnType, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 496: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__GenericInst_str(*(v__ast__GenericInst*)x._v__ast__GenericInst, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 485: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Interface_str(*(v__ast__Interface*)x._v__ast__Interface, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 453: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Map_str(*(v__ast__Map*)x._v__ast__Map, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 494: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__MultiReturn_str(*(v__ast__MultiReturn*)x._v__ast__MultiReturn, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 457: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Struct_str(*(v__ast__Struct*)x._v__ast__Struct, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 486: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__SumType_str(*(v__ast__SumType*)x._v__ast__SumType, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 493: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.TypeInfo("), 0xfe10, {.d_s = indent_v__ast__Thread_str(*(v__ast__Thread*)x._v__ast__Thread, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		default: return _S("unknown sum type value");
	}
}

string indent_v__ast__Fn_str(v__ast__Fn it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Param_str(it.params, indent_count + 1);
	string _t2 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t3 = Array_string_str(it.dep_names);
	string _t4 = Array_string_str(it.generic_names);
	string _t5 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t6 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t7 = indent_v__token__Pos_str(it.return_type_pos, indent_count + 1);
	string _t8 = v__ast__Type_str(it.receiver_type);
	string _t9 = v__ast__Type_str(it.return_type);
	string _t10 = v__ast__Type_str(it.from_embedded_type);
	string _t11 = v__ast__Language_str((it.file_mode));
	string _t12 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 147, _MOV((StrIntpData[]){
		{_S("ast.Fn{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    params: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    dep_names: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    generic_names: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    file: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.file}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    mod: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.mod}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    source_fn: "), 0, {.d_c=0}}, {_S(""), 17, {.d_p=(voidptr) it.source_fn}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    return_type_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    receiver_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    usages: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.usages}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    return_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    from_embedded_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t10}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    ctdefine_idx: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.ctdefine_idx}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    file_mode: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t11}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t12}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_expand_simple_interpolation: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_expand_simple_interpolation ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_c_variadic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_c_variadic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_pub: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_pub ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_ctor_new: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_ctor_new ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_deprecated: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_deprecated ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_noreturn: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_noreturn ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_unsafe: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_unsafe ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_must_use: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_must_use ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_placeholder: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_placeholder ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_main: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_main ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_test: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_test ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_keep_alive: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_keep_alive ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_method: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_method ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_static_type_method: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_static_type_method ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    no_body: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.no_body ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_file_translated: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_file_translated ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_conditional: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_conditional ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_variadic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_variadic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t12);
	builtin__string_free(&_t11);
	builtin__string_free(&_t10);
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__AtExpr_str(v__ast__AtExpr it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t2 = v__token__AtKind_str((it.kind));
	string res = builtin__str_intp( 19, _MOV((StrIntpData[]){
		{_S("ast.AtExpr{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    kind: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    val: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.val}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Ident_str(v__ast__Ident it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__ast__OrExpr_str(it.or_expr, indent_count + 1);
	string _t2 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t3 = indent_v__ast__ScopeObject_str(it.obj, indent_count + 1);
	string _t4 = indent_v__ast__IdentInfo_str(it.info, indent_count + 1);
	string _t5 = builtin__isnil(it.scope) ? _S("nil") : (indent_count > 25)? _S("<probably circular>") : v__ast__Scope_str(it.scope);
	string _t6 = indent_v__token__Pos_str(it.mut_pos, indent_count + 1);
	string _t7 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t8 = v__token__Kind_str((it.tok_kind));
	string _t9 = v__ast__Language_str((it.language));
	string _t10 = v__ast__IdentKind_str((it.kind));
	string res = builtin__str_intp( 71, _MOV((StrIntpData[]){
		{_S("ast.Ident{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    or_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    obj: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    mod: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.mod}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    full_name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.full_name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    cached_name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.cached_name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    info: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    scope: &"), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    mut_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    tok_kind: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    kind: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t10}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comptime: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.comptime ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    ct_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.ct_expr ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t10);
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__StringLiteral_str(v__ast__StringLiteral it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t2 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 19, _MOV((StrIntpData[]){
		{_S("ast.StringLiteral{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    val: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.val}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_raw: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_raw ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__OrExpr_str(v__ast__OrExpr it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__OrKind_str((it.kind));
	string _t2 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t3 = builtin__isnil(it.scope) ? _S("nil") : (indent_count > 25)? _S("<probably circular>") : v__ast__Scope_str(it.scope);
	string _t4 = indent_Array_v__ast__Stmt_str(it.stmts, indent_count + 1);
	string res = builtin__str_intp( 23, _MOV((StrIntpData[]){
		{_S("ast.OrExpr{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    kind: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    scope: &"), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    err_used: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.err_used ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    stmts: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__token__Pos_str(v__token__Pos it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string res = builtin__str_intp( 27, _MOV((StrIntpData[]){
		{_S("token.Pos{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    len: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.len}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    line_nr: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.line_nr}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    col: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.col}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    file_idx: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.file_idx}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    last_line: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.last_line}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__UnknownTypeInfo_str(v__ast__UnknownTypeInfo it, int indent_count) {
	return _S("ast.UnknownTypeInfo{}");
}

string indent_v__ast__Aggregate_str(v__ast__Aggregate it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t2 = v__ast__Type_str(it.sum_type);
	string _t3 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.Aggregate{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    sum_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Alias_str(v__ast__Alias it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t2 = v__ast__Type_str(it.parent_type);
	string _t3 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 19, _MOV((StrIntpData[]){
		{_S("ast.Alias{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    parent_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_import: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_import ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Array_str(v__ast__Array it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.elem_type);
	string res = builtin__str_intp( 11, _MOV((StrIntpData[]){
		{_S("ast.Array{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    nr_dims: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.nr_dims}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    elem_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__ArrayFixed_str(v__ast__ArrayFixed it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Expr_str(it.size_expr);
	string _t2 = v__ast__Type_str(it.elem_type);
	string res = builtin__str_intp( 19, _MOV((StrIntpData[]){
		{_S("ast.ArrayFixed{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    size_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    size: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.size}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    elem_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_fn_ret: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_fn_ret ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Chan_str(v__ast__Chan it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.elem_type);
	string res = builtin__str_intp( 11, _MOV((StrIntpData[]){
		{_S("ast.Chan{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    elem_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Enum_str(v__ast__Enum it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = Array_string_str(it.vals);
	string _t2 = v__ast__Type_str(it.typ);
	string _t3 = indent_Map_string_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t4 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string res = builtin__str_intp( 31, _MOV((StrIntpData[]){
		{_S("ast.Enum{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    vals: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_flag: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_flag ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_multi_allowed: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_multi_allowed ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    uses_exprs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.uses_exprs ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__FnType_str(v__ast__FnType it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__ast__Fn_str(it.func, indent_count + 1);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.FnType{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    is_anon: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_anon ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_decl: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_decl ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    func: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__GenericInst_str(v__ast__GenericInst it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string res = builtin__str_intp( 11, _MOV((StrIntpData[]){
		{_S("ast.GenericInst{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    parent_idx: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.parent_idx}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Interface_str(v__ast__Interface it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t2 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t3 = indent_Array_v__ast__Fn_str(it.methods, indent_count + 1);
	string _t4 = indent_Array_v__ast__Type_str(it.embeds, indent_count + 1);
	string _t5 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string _t6 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t7 = indent_Map_int_Array_v__ast__Type_str(it.conversions->val, indent_count + 1);
	string _t8 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t9 = v__ast__Type_str(it.parent_type);
	string res = builtin__str_intp( 47, _MOV((StrIntpData[]){
		{_S("ast.Interface{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    generic_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    methods: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    embeds: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    conversions: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    parent_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_markused: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_markused ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_generic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_generic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Map_str(v__ast__Map it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.key_type);
	string _t2 = v__ast__Type_str(it.value_type);
	string _t3 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.Map{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    key_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    value_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__MultiReturn_str(v__ast__MultiReturn it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Type_str(it.types, indent_count + 1);
	string res = builtin__str_intp( 7, _MOV((StrIntpData[]){
		{_S("ast.MultiReturn{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Struct_str(v__ast__Struct it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t2 = indent_Array_v__ast__Type_str(it.embeds, indent_count + 1);
	string _t3 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t4 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t5 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t6 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t7 = v__ast__Type_str(it.parent_type);
	string res = builtin__str_intp( 71, _MOV((StrIntpData[]){
		{_S("ast.Struct{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    generic_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    embeds: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    scoped_name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.scoped_name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    parent_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_anon: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_anon ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_generic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_generic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_shared: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_shared ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_markused: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_markused ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_option: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_option ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_heap: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_heap ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_union: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_union ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_minify: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_minify ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_typedef: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_typedef ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__SumType_str(v__ast__SumType it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t2 = indent_Array_v__ast__Type_str(it.variants, indent_count + 1);
	string _t3 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t4 = indent_Array_v__ast__Type_str(it.concrete_types, indent_count + 1);
	string _t5 = indent_v__token__Pos_str(it.name_pos, indent_count + 1);
	string _t6 = v__ast__Type_str(it.parent_type);
	string res = builtin__str_intp( 39, _MOV((StrIntpData[]){
		{_S("ast.SumType{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    variants: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    generic_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    concrete_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    parent_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    found_fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.found_fields ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_anon: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_anon ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_generic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_generic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Thread_str(v__ast__Thread it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.return_type);
	string res = builtin__str_intp( 7, _MOV((StrIntpData[]){
		{_S("ast.Thread{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    return_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

static string indent_v__ast__ScopeObject_str(v__ast__ScopeObject x, int indent_count) {
	switch(x._typ) {
		case 337: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ScopeObject("), 0xfe10, {.d_s = indent_v__ast__EmptyScopeObject_str(*(v__ast__EmptyScopeObject*)x._v__ast__EmptyScopeObject, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 338: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ScopeObject("), 0xfe10, {.d_s = indent_v__ast__AsmRegister_str(*(v__ast__AsmRegister*)x._v__ast__AsmRegister, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 339: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ScopeObject("), 0xfe10, {.d_s = indent_v__ast__ConstField_str(*(v__ast__ConstField*)x._v__ast__ConstField, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 340: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ScopeObject("), 0xfe10, {.d_s = indent_v__ast__GlobalField_str(*(v__ast__GlobalField*)x._v__ast__GlobalField, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 341: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ScopeObject("), 0xfe10, {.d_s = indent_v__ast__Var_str(*(v__ast__Var*)x._v__ast__Var, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		default: return _S("unknown sum type value");
	}
}

static string indent_v__ast__IdentInfo_str(v__ast__IdentInfo x, int indent_count) {
	switch(x._typ) {
		case 407: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.IdentInfo("), 0xfe10, {.d_s = indent_v__ast__IdentFn_str(*(v__ast__IdentFn*)x._v__ast__IdentFn, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 408: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.IdentInfo("), 0xfe10, {.d_s = indent_v__ast__IdentVar_str(*(v__ast__IdentVar*)x._v__ast__IdentVar, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		default: return _S("unknown sum type value");
	}
}

string indent_v__ast__Comment_str(v__ast__Comment it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.Comment{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    text: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.text}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_multi: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_multi ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Param_str(v__ast__Param it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.type_pos, indent_count + 1);
	string _t2 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t3 = v__ast__Type_str(it.typ);
	string res = builtin__str_intp( 39, _MOV((StrIntpData[]){
		{_S("ast.Param{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    type_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_atomic: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_atomic ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_shared: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_shared ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_hidden: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_hidden ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    on_newline: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.on_newline ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__EmptyScopeObject_str(v__ast__EmptyScopeObject it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.typ);
	string res = builtin__str_intp( 11, _MOV((StrIntpData[]){
		{_S("ast.EmptyScopeObject{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__AsmRegister_str(v__ast__AsmRegister it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.typ);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.AsmRegister{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    size: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.size}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__ConstField_str(v__ast__ConstField it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t2 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t3 = v__ast__Expr_str(it.expr);
	string _t4 = v__ast__Type_str(it.typ);
	string _t5 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string _t6 = indent_Array_v__ast__Comment_str(it.end_comments, indent_count + 1);
	string _t7 = indent_v__ast__ComptTimeConstValue_str(it.comptime_expr_value, indent_count + 1);
	string res = builtin__str_intp( 55, _MOV((StrIntpData[]){
		{_S("ast.ConstField{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    mod: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.mod}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_pub: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_pub ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_markused: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_markused ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_exported: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_exported ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_virtual_c: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_virtual_c ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    end_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comptime_expr_value: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__GlobalField_str(v__ast__GlobalField it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string _t2 = v__ast__Expr_str(it.expr);
	string _t3 = indent_v__token__Pos_str(it.typ_pos, indent_count + 1);
	string _t4 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t5 = v__ast__Type_str(it.typ);
	string _t6 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 59, _MOV((StrIntpData[]){
		{_S("ast.GlobalField{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_weak: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_weak ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_hidden: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_hidden ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_extern: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_extern ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_expr ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_volatile: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_volatile ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_markused: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_markused ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_exported: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_exported ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Var_str(v__ast__Var it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__Type_str(it.smartcasts, indent_count + 1);
	string _t2 = v__ast__Expr_str(it.expr);
	string _t3 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t4 = v__ast__Type_str(it.typ);
	string _t5 = v__ast__Type_str(it.orig_type);
	string _t6 = v__ast__ComptimeVarKind_str((it.ct_type_var));
	string _t7 = v__ast__ShareType_str((it.share));
	string res = builtin__str_intp( 107, _MOV((StrIntpData[]){
		{_S("ast.Var{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    smartcasts: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    orig_type: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    ct_type_var: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    share: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_arg: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_arg ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_auto_deref: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_auto_deref ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_unwrapped: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_unwrapped ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_index_var: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_index_var ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_volatile: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_volatile ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_static: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_static ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_special: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_special ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_used: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_used ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_changed: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_changed ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    ct_type_unwrapped: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.ct_type_unwrapped ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_or: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_or ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_tmp: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_tmp ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_auto_heap: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_auto_heap ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_stack_obj: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_stack_obj ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_inherited: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_inherited ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_autofree_tmp: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_autofree_tmp ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_inherited: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_inherited ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__IdentFn_str(v__ast__IdentFn it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.typ);
	string res = builtin__str_intp( 7, _MOV((StrIntpData[]){
		{_S("ast.IdentFn{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__IdentVar_str(v__ast__IdentVar it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.typ);
	string _t2 = v__ast__ShareType_str((it.share));
	string res = builtin__str_intp( 27, _MOV((StrIntpData[]){
		{_S("ast.IdentVar{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    share: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_static: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_static ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_volatile: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_volatile ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_option: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_option ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__StructField_str(v__ast__StructField it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__ast__StructDecl_str(it.anon_struct_decl, indent_count + 1);
	string _t2 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t3 = indent_Array_v__ast__Comment_str(it.pre_comments, indent_count + 1);
	string _t4 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string _t5 = indent_Array_v__ast__Comment_str(it.next_comments, indent_count + 1);
	string _t6 = v__ast__Expr_str(it.default_expr);
	string _t7 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t8 = indent_v__token__Pos_str(it.type_pos, indent_count + 1);
	string _t9 = indent_v__token__Pos_str(it.option_pos, indent_count + 1);
	string _t10 = v__ast__Type_str(it.default_expr_typ);
	string _t11 = v__ast__Type_str(it.container_typ);
	string _t12 = v__ast__Type_str(it.typ);
	string _t13 = v__ast__Type_str(it.unaliased_typ);
	string res = builtin__str_intp( 111, _MOV((StrIntpData[]){
		{_S("ast.StructField{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    anon_struct_decl: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pre_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    next_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    default_val: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.default_val}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    default_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    type_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    option_pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    default_expr_typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t10}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    container_typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t11}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t12}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    unaliased_typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t13}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    i: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.i}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_pub: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_pub ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_break_line: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_break_line ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_recursive: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_recursive ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_mut: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_mut ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_prev_newline: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_prev_newline ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    has_default_expr: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.has_default_expr ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_part_of_union: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_part_of_union ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_global: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_global ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_volatile: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_volatile ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_deprecated: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_deprecated ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_embed: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_embed ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t13);
	builtin__string_free(&_t12);
	builtin__string_free(&_t11);
	builtin__string_free(&_t10);
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

static string indent_v__ast__ComptTimeConstValue_str(v__ast__ComptTimeConstValue x, int indent_count) {
	switch(x._typ) {
		case 277: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = indent_v__ast__EmptyExpr_str(*(v__ast__EmptyExpr*)x._v__ast__EmptyExpr, indent_count)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 16: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__f32_str(*(f32*)x._f32)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 17: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__f64_str(*(f64*)x._f64)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 6: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__i16_str(*(i16*)x._i16)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 7: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__i32_str(*(i32*)x._i32)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 9: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__i64_str(*(i64*)x._i64)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 5: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__i8_str(*(i8*)x._i8)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 22: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__rune_str(*(rune*)x._rune)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 21: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue('"), 0xfe10, {.d_s = builtin__string_str(*(string*)x._string)}},
				{_S("')"), 0, {.d_c = 0 }}
			}));
		case 12: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__u16_str(*(u16*)x._u16)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 13: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__u32_str(*(u32*)x._u32)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 14: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__u64_str(*(u64*)x._u64)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 11: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__u8_str(*(u8*)x._u8)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		case 2: return builtin__str_intp(2, _MOV((StrIntpData[]){
				{_S("ast.ComptTimeConstValue("), 0xfe10, {.d_s = builtin__voidptr_str(*(voidptr*)x._voidptr)}},
				{_S(")"), 0, {.d_c = 0 }}
			}));
		default: return _S("unknown sum type value");
	}
}

string indent_v__ast__StructDecl_str(v__ast__StructDecl it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_Array_v__ast__StructField_str(it.fields, indent_count + 1);
	string _t2 = indent_Array_v__ast__TypeNode_str(it.implements_types, indent_count + 1);
	string _t3 = indent_Array_v__ast__Embed_str(it.embeds, indent_count + 1);
	string _t4 = indent_Array_v__ast__Attr_str(it.attrs, indent_count + 1);
	string _t5 = indent_Array_v__ast__Comment_str(it.pre_comments, indent_count + 1);
	string _t6 = indent_Array_v__ast__Comment_str(it.end_comments, indent_count + 1);
	string _t7 = indent_Array_v__ast__Type_str(it.generic_types, indent_count + 1);
	string _t8 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t9 = v__ast__Language_str((it.language));
	string res = builtin__str_intp( 91, _MOV((StrIntpData[]){
		{_S("ast.StructDecl{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    fields: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    implements_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    embeds: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    attrs: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pre_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t5}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    end_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t6}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    generic_types: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t7}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    scoped_name: "), 0, {.d_c=0}}, {_S("'"), 16, {.d_s=it.scoped_name}}, {_S("'"), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t8}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    idx: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.idx}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    mut_pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.mut_pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pub_pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.pub_pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pub_mut_pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.pub_mut_pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    global_pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.global_pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    module_pos: "), 0, {.d_c=0}}, {_S(""), 7, {.d_i32=it.module_pos}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    language: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t9}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_aligned: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_aligned ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_implements: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_implements ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_option: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_option ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_union: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_union ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    is_pub: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=it.is_pub ? _S("true") : _S("false")}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t9);
	builtin__string_free(&_t8);
	builtin__string_free(&_t7);
	builtin__string_free(&_t6);
	builtin__string_free(&_t5);
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__TypeNode_str(v__ast__TypeNode it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t2 = v__ast__Type_str(it.typ);
	string _t3 = v__ast__Stmt_str(it.stmt);
	string _t4 = indent_Array_v__ast__Comment_str(it.end_comments, indent_count + 1);
	string res = builtin__str_intp( 19, _MOV((StrIntpData[]){
		{_S("ast.TypeNode{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    stmt: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    end_comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t4}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t4);
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

string indent_v__ast__Embed_str(v__ast__Embed it, int indent_count) {
	string indents = builtin__string_repeat(_S("    "), indent_count);
	string _t1 = v__ast__Type_str(it.typ);
	string _t2 = indent_v__token__Pos_str(it.pos, indent_count + 1);
	string _t3 = indent_Array_v__ast__Comment_str(it.comments, indent_count + 1);
	string res = builtin__str_intp( 15, _MOV((StrIntpData[]){
		{_S("ast.Embed{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_S("    typ: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t1}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    pos: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t2}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("    comments: "), 0, {.d_c=0}}, {_S(""), 16, {.d_s=_t3}}, {_S(""), 0, {.d_c=0}},
		{_S("\n"), 0xfe10, {.d_s=indents}}, {_S("}"), 0, {.d_c=0}},
	}));
	builtin__string_free(&_t3);
	builtin__string_free(&_t2);
	builtin__string_free(&_t1);
	builtin__string_free(&indents);
	return res;
}

v__ast__Expr v__ast__EmptyExpr_to_sumtype_v__ast__Expr(v__ast__EmptyExpr* x, bool is_mut) {
	v__ast__EmptyExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EmptyExpr)); }
	return (v__ast__Expr){ ._v__ast__EmptyExpr = ptr, ._typ = 277};
}

v__ast__Stmt v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(v__ast__EmptyStmt* x, bool is_mut) {
	v__ast__EmptyStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EmptyStmt)); }
	return (v__ast__Stmt){ ._v__ast__EmptyStmt = ptr, ._typ = 319, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EmptyStmt, pos))};
}

v__ast__Node v__ast__EmptyNode_to_sumtype_v__ast__Node(v__ast__EmptyNode* x, bool is_mut) {
	v__ast__EmptyNode* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EmptyNode)); }
	return (v__ast__Node){ ._v__ast__EmptyNode = ptr, ._typ = 344};
}

v__ast__ScopeObject v__ast__EmptyScopeObject_to_sumtype_v__ast__ScopeObject(v__ast__EmptyScopeObject* x, bool is_mut) {
	v__ast__EmptyScopeObject* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EmptyScopeObject)); }
	return (v__ast__ScopeObject){ ._v__ast__EmptyScopeObject = ptr, ._typ = 337, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EmptyScopeObject, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EmptyScopeObject, typ))};
}

v__ast__ComptTimeConstValue v__ast__EmptyExpr_to_sumtype_v__ast__ComptTimeConstValue(v__ast__EmptyExpr* x, bool is_mut) {
	v__ast__EmptyExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EmptyExpr)); }
	return (v__ast__ComptTimeConstValue){ ._v__ast__EmptyExpr = ptr, ._typ = 277};
}

v__ast__Node v__ast__Expr_to_sumtype_v__ast__Node(v__ast__Expr* x, bool is_mut) {
	v__ast__Expr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Expr)); }
	return (v__ast__Node){ ._v__ast__Expr = ptr, ._typ = 310};
}

v__ast__Expr v__ast__Ident_to_sumtype_v__ast__Expr(v__ast__Ident* x, bool is_mut) {
	v__ast__Ident* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Ident)); }
	return (v__ast__Expr){ ._v__ast__Ident = ptr, ._typ = 281};
}

v__ast__Node v__ast__Stmt_to_sumtype_v__ast__Node(v__ast__Stmt* x, bool is_mut) {
	v__ast__Stmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Stmt)); }
	return (v__ast__Node){ ._v__ast__Stmt = ptr, ._typ = 226};
}

v__ast__Node v__ast__StructInitField_to_sumtype_v__ast__Node(v__ast__StructInitField* x, bool is_mut) {
	v__ast__StructInitField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StructInitField)); }
	return (v__ast__Node){ ._v__ast__StructInitField = ptr, ._typ = 351};
}

v__ast__Stmt v__ast__FnDecl_to_sumtype_v__ast__Stmt(v__ast__FnDecl* x, bool is_mut) {
	v__ast__FnDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__FnDecl)); }
	return (v__ast__Stmt){ ._v__ast__FnDecl = ptr, ._typ = 229, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnDecl, pos))};
}

v__ast__Node v__ast__CallArg_to_sumtype_v__ast__Node(v__ast__CallArg* x, bool is_mut) {
	v__ast__CallArg* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__CallArg)); }
	return (v__ast__Node){ ._v__ast__CallArg = ptr, ._typ = 343};
}

v__ast__Expr v__ast__OrExpr_to_sumtype_v__ast__Expr(v__ast__OrExpr* x, bool is_mut) {
	v__ast__OrExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__OrExpr)); }
	return (v__ast__Expr){ ._v__ast__OrExpr = ptr, ._typ = 296};
}

v__ast__Node v__ast__IfBranch_to_sumtype_v__ast__Node(v__ast__IfBranch* x, bool is_mut) {
	v__ast__IfBranch* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IfBranch)); }
	return (v__ast__Node){ ._v__ast__IfBranch = ptr, ._typ = 346};
}

v__ast__Node v__ast__MatchBranch_to_sumtype_v__ast__Node(v__ast__MatchBranch* x, bool is_mut) {
	v__ast__MatchBranch* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__MatchBranch)); }
	return (v__ast__Node){ ._v__ast__MatchBranch = ptr, ._typ = 347};
}

v__ast__Node v__ast__SelectBranch_to_sumtype_v__ast__Node(v__ast__SelectBranch* x, bool is_mut) {
	v__ast__SelectBranch* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SelectBranch)); }
	return (v__ast__Node){ ._v__ast__SelectBranch = ptr, ._typ = 349};
}

v__ast__Node v__ast__StructField_to_sumtype_v__ast__Node(v__ast__StructField* x, bool is_mut) {
	v__ast__StructField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StructField)); }
	return (v__ast__Node){ ._v__ast__StructField = ptr, ._typ = 350};
}

v__ast__Node v__ast__GlobalField_to_sumtype_v__ast__Node(v__ast__GlobalField* x, bool is_mut) {
	v__ast__GlobalField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GlobalField)); }
	return (v__ast__Node){ ._v__ast__GlobalField = ptr, ._typ = 340};
}

v__ast__Node v__ast__ConstField_to_sumtype_v__ast__Node(v__ast__ConstField* x, bool is_mut) {
	v__ast__ConstField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ConstField)); }
	return (v__ast__Node){ ._v__ast__ConstField = ptr, ._typ = 339};
}

v__ast__Node v__ast__EnumField_to_sumtype_v__ast__Node(v__ast__EnumField* x, bool is_mut) {
	v__ast__EnumField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EnumField)); }
	return (v__ast__Node){ ._v__ast__EnumField = ptr, ._typ = 345};
}

v__ast__Node v__ast__Param_to_sumtype_v__ast__Node(v__ast__Param* x, bool is_mut) {
	v__ast__Param* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Param)); }
	return (v__ast__Node){ ._v__ast__Param = ptr, ._typ = 348};
}

v__ast__Expr v__ast__TypeNode_to_sumtype_v__ast__Expr(v__ast__TypeNode* x, bool is_mut) {
	v__ast__TypeNode* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__TypeNode)); }
	return (v__ast__Expr){ ._v__ast__TypeNode = ptr, ._typ = 307};
}

v__ast__ScopeObject v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(v__ast__AsmRegister* x, bool is_mut) {
	v__ast__AsmRegister* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmRegister)); }
	return (v__ast__ScopeObject){ ._v__ast__AsmRegister = ptr, ._typ = 338, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmRegister, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmRegister, typ))};
}

v__ast__Expr v__ast__ArrayInit_to_sumtype_v__ast__Expr(v__ast__ArrayInit* x, bool is_mut) {
	v__ast__ArrayInit* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ArrayInit)); }
	return (v__ast__Expr){ ._v__ast__ArrayInit = ptr, ._typ = 261};
}

v__ast__Expr v__ast__StringLiteral_to_sumtype_v__ast__Expr(v__ast__StringLiteral* x, bool is_mut) {
	v__ast__StringLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StringLiteral)); }
	return (v__ast__Expr){ ._v__ast__StringLiteral = ptr, ._typ = 237};
}

v__ast__Expr v__ast__MapInit_to_sumtype_v__ast__Expr(v__ast__MapInit* x, bool is_mut) {
	v__ast__MapInit* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__MapInit)); }
	return (v__ast__Expr){ ._v__ast__MapInit = ptr, ._typ = 291};
}

v__ast__Expr v__ast__StructInit_to_sumtype_v__ast__Expr(v__ast__StructInit* x, bool is_mut) {
	v__ast__StructInit* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StructInit)); }
	return (v__ast__Expr){ ._v__ast__StructInit = ptr, ._typ = 236};
}

v__ast__TypeInfo v__ast__SumType_to_sumtype_v__ast__TypeInfo(v__ast__SumType* x, bool is_mut) {
	v__ast__SumType* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SumType)); }
	return (v__ast__TypeInfo){ ._v__ast__SumType = ptr, ._typ = 486};
}

v__ast__TypeInfo v__ast__Chan_to_sumtype_v__ast__TypeInfo(v__ast__Chan* x, bool is_mut) {
	v__ast__Chan* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Chan)); }
	return (v__ast__TypeInfo){ ._v__ast__Chan = ptr, ._typ = 492};
}

v__ast__TypeInfo v__ast__Map_to_sumtype_v__ast__TypeInfo(v__ast__Map* x, bool is_mut) {
	v__ast__Map* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Map)); }
	return (v__ast__TypeInfo){ ._v__ast__Map = ptr, ._typ = 453};
}

v__ast__TypeInfo v__ast__Thread_to_sumtype_v__ast__TypeInfo(v__ast__Thread* x, bool is_mut) {
	v__ast__Thread* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Thread)); }
	return (v__ast__TypeInfo){ ._v__ast__Thread = ptr, ._typ = 493};
}

v__ast__TypeInfo v__ast__Struct_to_sumtype_v__ast__TypeInfo(v__ast__Struct* x, bool is_mut) {
	v__ast__Struct* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Struct)); }
	return (v__ast__TypeInfo){ ._v__ast__Struct = ptr, ._typ = 457};
}

v__ast__TypeInfo v__ast__Array_to_sumtype_v__ast__TypeInfo(v__ast__Array* x, bool is_mut) {
	v__ast__Array* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Array)); }
	return (v__ast__TypeInfo){ ._v__ast__Array = ptr, ._typ = 452};
}

v__ast__TypeInfo v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(v__ast__ArrayFixed* x, bool is_mut) {
	v__ast__ArrayFixed* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ArrayFixed)); }
	return (v__ast__TypeInfo){ ._v__ast__ArrayFixed = ptr, ._typ = 491};
}

v__ast__TypeInfo v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(v__ast__MultiReturn* x, bool is_mut) {
	v__ast__MultiReturn* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__MultiReturn)); }
	return (v__ast__TypeInfo){ ._v__ast__MultiReturn = ptr, ._typ = 494};
}

v__ast__TypeInfo v__ast__FnType_to_sumtype_v__ast__TypeInfo(v__ast__FnType* x, bool is_mut) {
	v__ast__FnType* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__FnType)); }
	return (v__ast__TypeInfo){ ._v__ast__FnType = ptr, ._typ = 495};
}

v__ast__TypeInfo v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(v__ast__GenericInst* x, bool is_mut) {
	v__ast__GenericInst* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GenericInst)); }
	return (v__ast__TypeInfo){ ._v__ast__GenericInst = ptr, ._typ = 496};
}

v__ast__Expr v__ast__None_to_sumtype_v__ast__Expr(v__ast__None* x, bool is_mut) {
	v__ast__None* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__None)); }
	return (v__ast__Expr){ ._v__ast__None = ptr, ._typ = 294};
}

v__ast__TypeInfo v__ast__Interface_to_sumtype_v__ast__TypeInfo(v__ast__Interface* x, bool is_mut) {
	v__ast__Interface* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Interface)); }
	return (v__ast__TypeInfo){ ._v__ast__Interface = ptr, ._typ = 485};
}

v__ast__Expr v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(v__ast__IntegerLiteral* x, bool is_mut) {
	v__ast__IntegerLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IntegerLiteral)); }
	return (v__ast__Expr){ ._v__ast__IntegerLiteral = ptr, ._typ = 286};
}

v__ast__Expr v__ast__SizeOf_to_sumtype_v__ast__Expr(v__ast__SizeOf* x, bool is_mut) {
	v__ast__SizeOf* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SizeOf)); }
	return (v__ast__Expr){ ._v__ast__SizeOf = ptr, ._typ = 303};
}

v__ast__Expr v__ast__CastExpr_to_sumtype_v__ast__Expr(v__ast__CastExpr* x, bool is_mut) {
	v__ast__CastExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__CastExpr)); }
	return (v__ast__Expr){ ._v__ast__CastExpr = ptr, ._typ = 268};
}

v__ast__Expr v__ast__CallExpr_to_sumtype_v__ast__Expr(v__ast__CallExpr* x, bool is_mut) {
	v__ast__CallExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__CallExpr)); }
	return (v__ast__Expr){ ._v__ast__CallExpr = ptr, ._typ = 267};
}

v__ast__Expr v__ast__IfExpr_to_sumtype_v__ast__Expr(v__ast__IfExpr* x, bool is_mut) {
	v__ast__IfExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IfExpr)); }
	return (v__ast__Expr){ ._v__ast__IfExpr = ptr, ._typ = 282};
}

v__ast__Expr v__ast__BoolLiteral_to_sumtype_v__ast__Expr(v__ast__BoolLiteral* x, bool is_mut) {
	v__ast__BoolLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__BoolLiteral)); }
	return (v__ast__Expr){ ._v__ast__BoolLiteral = ptr, ._typ = 265};
}

v__ast__Expr v__ast__FloatLiteral_to_sumtype_v__ast__Expr(v__ast__FloatLiteral* x, bool is_mut) {
	v__ast__FloatLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__FloatLiteral)); }
	return (v__ast__Expr){ ._v__ast__FloatLiteral = ptr, ._typ = 279};
}

v__ast__Expr v__ast__MatchExpr_to_sumtype_v__ast__Expr(v__ast__MatchExpr* x, bool is_mut) {
	v__ast__MatchExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__MatchExpr)); }
	return (v__ast__Expr){ ._v__ast__MatchExpr = ptr, ._typ = 292};
}

v__ast__Stmt v__ast__ForStmt_to_sumtype_v__ast__Stmt(v__ast__ForStmt* x, bool is_mut) {
	v__ast__ForStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ForStmt)); }
	return (v__ast__Stmt){ ._v__ast__ForStmt = ptr, ._typ = 324, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForStmt, pos))};
}

v__ast__Expr v__ast__InfixExpr_to_sumtype_v__ast__Expr(v__ast__InfixExpr* x, bool is_mut) {
	v__ast__InfixExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__InfixExpr)); }
	return (v__ast__Expr){ ._v__ast__InfixExpr = ptr, ._typ = 285};
}

v__ast__Expr v__ast__CharLiteral_to_sumtype_v__ast__Expr(v__ast__CharLiteral* x, bool is_mut) {
	v__ast__CharLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__CharLiteral)); }
	return (v__ast__Expr){ ._v__ast__CharLiteral = ptr, ._typ = 270};
}

v__ast__Expr v__ast__SqlExpr_to_sumtype_v__ast__Expr(v__ast__SqlExpr* x, bool is_mut) {
	v__ast__SqlExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SqlExpr)); }
	return (v__ast__Expr){ ._v__ast__SqlExpr = ptr, ._typ = 305};
}

v__ast__Stmt v__ast__ExprStmt_to_sumtype_v__ast__Stmt(v__ast__ExprStmt* x, bool is_mut) {
	v__ast__ExprStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ExprStmt)); }
	return (v__ast__Stmt){ ._v__ast__ExprStmt = ptr, ._typ = 321, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ExprStmt, pos))};
}

v__ast__Stmt v__ast__Block_to_sumtype_v__ast__Stmt(v__ast__Block* x, bool is_mut) {
	v__ast__Block* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Block)); }
	return (v__ast__Stmt){ ._v__ast__Block = ptr, ._typ = 314, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Block, pos))};
}

v__ast__AsmArg string_to_sumtype_v__ast__AsmArg(string* x, bool is_mut) {
	string* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(string)); }
	return (v__ast__AsmArg){ ._string = ptr, ._typ = 21};
}

v__ast__AsmArg v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(v__ast__FloatLiteral* x, bool is_mut) {
	v__ast__FloatLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__FloatLiteral)); }
	return (v__ast__AsmArg){ ._v__ast__FloatLiteral = ptr, ._typ = 279};
}

v__ast__AsmArg v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(v__ast__AsmDisp* x, bool is_mut) {
	v__ast__AsmDisp* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmDisp)); }
	return (v__ast__AsmArg){ ._v__ast__AsmDisp = ptr, ._typ = 431};
}

v__ast__AsmArg v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(v__ast__IntegerLiteral* x, bool is_mut) {
	v__ast__IntegerLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IntegerLiteral)); }
	return (v__ast__AsmArg){ ._v__ast__IntegerLiteral = ptr, ._typ = 286};
}

v__ast__AsmArg v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(v__ast__CharLiteral* x, bool is_mut) {
	v__ast__CharLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__CharLiteral)); }
	return (v__ast__AsmArg){ ._v__ast__CharLiteral = ptr, ._typ = 270};
}

v__ast__AsmArg v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(v__ast__AsmAddressing* x, bool is_mut) {
	v__ast__AsmAddressing* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmAddressing)); }
	return (v__ast__AsmArg){ ._v__ast__AsmAddressing = ptr, ._typ = 429};
}

v__ast__AsmArg v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(v__ast__AsmRegister* x, bool is_mut) {
	v__ast__AsmRegister* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmRegister)); }
	return (v__ast__AsmArg){ ._v__ast__AsmRegister = ptr, ._typ = 338};
}

v__ast__AsmArg v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(v__ast__AsmAlias* x, bool is_mut) {
	v__ast__AsmAlias* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmAlias)); }
	return (v__ast__AsmArg){ ._v__ast__AsmAlias = ptr, ._typ = 430};
}

v__ast__Stmt v__ast__NodeError_to_sumtype_v__ast__Stmt(v__ast__NodeError* x, bool is_mut) {
	v__ast__NodeError* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__NodeError)); }
	return (v__ast__Stmt){ ._v__ast__NodeError = ptr, ._typ = 258, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__NodeError, pos))};
}

v__ast__ScopeObject v__ast__Var_to_sumtype_v__ast__ScopeObject(v__ast__Var* x, bool is_mut) {
	v__ast__Var* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Var)); }
	return (v__ast__ScopeObject){ ._v__ast__Var = ptr, ._typ = 341, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Var, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Var, typ))};
}

v__ast__Stmt v__ast__AssignStmt_to_sumtype_v__ast__Stmt(v__ast__AssignStmt* x, bool is_mut) {
	v__ast__AssignStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AssignStmt)); }
	return (v__ast__Stmt){ ._v__ast__AssignStmt = ptr, ._typ = 313, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssignStmt, pos))};
}

v__ast__Expr v__ast__ComptimeCall_to_sumtype_v__ast__Expr(v__ast__ComptimeCall* x, bool is_mut) {
	v__ast__ComptimeCall* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ComptimeCall)); }
	return (v__ast__Expr){ ._v__ast__ComptimeCall = ptr, ._typ = 272};
}

v__ast__Expr v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(v__ast__ComptimeSelector* x, bool is_mut) {
	v__ast__ComptimeSelector* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ComptimeSelector)); }
	return (v__ast__Expr){ ._v__ast__ComptimeSelector = ptr, ._typ = 273};
}

v__ast__TypeInfo v__ast__Enum_to_sumtype_v__ast__TypeInfo(v__ast__Enum* x, bool is_mut) {
	v__ast__Enum* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Enum)); }
	return (v__ast__TypeInfo){ ._v__ast__Enum = ptr, ._typ = 490};
}

v__ast__Expr v__ast__NodeError_to_sumtype_v__ast__Expr(v__ast__NodeError* x, bool is_mut) {
	v__ast__NodeError* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__NodeError)); }
	return (v__ast__Expr){ ._v__ast__NodeError = ptr, ._typ = 258};
}

v__ast__Expr v__ast__Comment_to_sumtype_v__ast__Expr(v__ast__Comment* x, bool is_mut) {
	v__ast__Comment* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Comment)); }
	return (v__ast__Expr){ ._v__ast__Comment = ptr, ._typ = 271};
}

v__ast__Expr v__ast__EnumVal_to_sumtype_v__ast__Expr(v__ast__EnumVal* x, bool is_mut) {
	v__ast__EnumVal* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EnumVal)); }
	return (v__ast__Expr){ ._v__ast__EnumVal = ptr, ._typ = 278};
}

v__ast__Expr v__ast__AtExpr_to_sumtype_v__ast__Expr(v__ast__AtExpr* x, bool is_mut) {
	v__ast__AtExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AtExpr)); }
	return (v__ast__Expr){ ._v__ast__AtExpr = ptr, ._typ = 264};
}

v__ast__Expr v__ast__ComptimeType_to_sumtype_v__ast__Expr(v__ast__ComptimeType* x, bool is_mut) {
	v__ast__ComptimeType* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ComptimeType)); }
	return (v__ast__Expr){ ._v__ast__ComptimeType = ptr, ._typ = 274};
}

v__ast__Expr v__ast__GoExpr_to_sumtype_v__ast__Expr(v__ast__GoExpr* x, bool is_mut) {
	v__ast__GoExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GoExpr)); }
	return (v__ast__Expr){ ._v__ast__GoExpr = ptr, ._typ = 280};
}

v__ast__Expr v__ast__SpawnExpr_to_sumtype_v__ast__Expr(v__ast__SpawnExpr* x, bool is_mut) {
	v__ast__SpawnExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SpawnExpr)); }
	return (v__ast__Expr){ ._v__ast__SpawnExpr = ptr, ._typ = 304};
}

v__ast__Expr v__ast__SelectExpr_to_sumtype_v__ast__Expr(v__ast__SelectExpr* x, bool is_mut) {
	v__ast__SelectExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SelectExpr)); }
	return (v__ast__Expr){ ._v__ast__SelectExpr = ptr, ._typ = 301};
}

v__ast__Expr v__ast__Nil_to_sumtype_v__ast__Expr(v__ast__Nil* x, bool is_mut) {
	v__ast__Nil* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Nil)); }
	return (v__ast__Expr){ ._v__ast__Nil = ptr, ._typ = 293};
}

v__ast__Expr v__ast__ParExpr_to_sumtype_v__ast__Expr(v__ast__ParExpr* x, bool is_mut) {
	v__ast__ParExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ParExpr)); }
	return (v__ast__Expr){ ._v__ast__ParExpr = ptr, ._typ = 297};
}

v__ast__Expr v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(v__ast__UnsafeExpr* x, bool is_mut) {
	v__ast__UnsafeExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__UnsafeExpr)); }
	return (v__ast__Expr){ ._v__ast__UnsafeExpr = ptr, ._typ = 309};
}

v__ast__Expr v__ast__LambdaExpr_to_sumtype_v__ast__Expr(v__ast__LambdaExpr* x, bool is_mut) {
	v__ast__LambdaExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__LambdaExpr)); }
	return (v__ast__Expr){ ._v__ast__LambdaExpr = ptr, ._typ = 288};
}

v__ast__Expr v__ast__LockExpr_to_sumtype_v__ast__Expr(v__ast__LockExpr* x, bool is_mut) {
	v__ast__LockExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__LockExpr)); }
	return (v__ast__Expr){ ._v__ast__LockExpr = ptr, ._typ = 290};
}

v__ast__Expr v__ast__TypeOf_to_sumtype_v__ast__Expr(v__ast__TypeOf* x, bool is_mut) {
	v__ast__TypeOf* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__TypeOf)); }
	return (v__ast__Expr){ ._v__ast__TypeOf = ptr, ._typ = 308};
}

v__ast__Expr v__ast__IsRefType_to_sumtype_v__ast__Expr(v__ast__IsRefType* x, bool is_mut) {
	v__ast__IsRefType* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IsRefType)); }
	return (v__ast__Expr){ ._v__ast__IsRefType = ptr, ._typ = 287};
}

v__ast__Expr v__ast__DumpExpr_to_sumtype_v__ast__Expr(v__ast__DumpExpr* x, bool is_mut) {
	v__ast__DumpExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__DumpExpr)); }
	return (v__ast__Expr){ ._v__ast__DumpExpr = ptr, ._typ = 276};
}

v__ast__Expr v__ast__OffsetOf_to_sumtype_v__ast__Expr(v__ast__OffsetOf* x, bool is_mut) {
	v__ast__OffsetOf* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__OffsetOf)); }
	return (v__ast__Expr){ ._v__ast__OffsetOf = ptr, ._typ = 295};
}

v__ast__Expr v__ast__Likely_to_sumtype_v__ast__Expr(v__ast__Likely* x, bool is_mut) {
	v__ast__Likely* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Likely)); }
	return (v__ast__Expr){ ._v__ast__Likely = ptr, ._typ = 289};
}

v__ast__Expr v__ast__AnonFn_to_sumtype_v__ast__Expr(v__ast__AnonFn* x, bool is_mut) {
	v__ast__AnonFn* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AnonFn)); }
	return (v__ast__Expr){ ._v__ast__AnonFn = ptr, ._typ = 259};
}

v__ast__Stmt v__ast__StructDecl_to_sumtype_v__ast__Stmt(v__ast__StructDecl* x, bool is_mut) {
	v__ast__StructDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StructDecl)); }
	return (v__ast__Stmt){ ._v__ast__StructDecl = ptr, ._typ = 228, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__StructDecl, pos))};
}

v__ast__Expr v__ast__IndexExpr_to_sumtype_v__ast__Expr(v__ast__IndexExpr* x, bool is_mut) {
	v__ast__IndexExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IndexExpr)); }
	return (v__ast__Expr){ ._v__ast__IndexExpr = ptr, ._typ = 284};
}

v__ast__Expr v__ast__AsCast_to_sumtype_v__ast__Expr(v__ast__AsCast* x, bool is_mut) {
	v__ast__AsCast* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsCast)); }
	return (v__ast__Expr){ ._v__ast__AsCast = ptr, ._typ = 262};
}

v__ast__Expr v__ast__PostfixExpr_to_sumtype_v__ast__Expr(v__ast__PostfixExpr* x, bool is_mut) {
	v__ast__PostfixExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__PostfixExpr)); }
	return (v__ast__Expr){ ._v__ast__PostfixExpr = ptr, ._typ = 298};
}

v__ast__Expr v__ast__RangeExpr_to_sumtype_v__ast__Expr(v__ast__RangeExpr* x, bool is_mut) {
	v__ast__RangeExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__RangeExpr)); }
	return (v__ast__Expr){ ._v__ast__RangeExpr = ptr, ._typ = 300};
}

v__ast__Expr v__ast__SelectorExpr_to_sumtype_v__ast__Expr(v__ast__SelectorExpr* x, bool is_mut) {
	v__ast__SelectorExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SelectorExpr)); }
	return (v__ast__Expr){ ._v__ast__SelectorExpr = ptr, ._typ = 302};
}

v__ast__Expr v__ast__PrefixExpr_to_sumtype_v__ast__Expr(v__ast__PrefixExpr* x, bool is_mut) {
	v__ast__PrefixExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__PrefixExpr)); }
	return (v__ast__Expr){ ._v__ast__PrefixExpr = ptr, ._typ = 299};
}

v__ast__Expr v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(v__ast__ArrayDecompose* x, bool is_mut) {
	v__ast__ArrayDecompose* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ArrayDecompose)); }
	return (v__ast__Expr){ ._v__ast__ArrayDecompose = ptr, ._typ = 260};
}

v__ast__Stmt v__ast__ForCStmt_to_sumtype_v__ast__Stmt(v__ast__ForCStmt* x, bool is_mut) {
	v__ast__ForCStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ForCStmt)); }
	return (v__ast__Stmt){ ._v__ast__ForCStmt = ptr, ._typ = 322, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForCStmt, pos))};
}

v__ast__Stmt v__ast__ForInStmt_to_sumtype_v__ast__Stmt(v__ast__ForInStmt* x, bool is_mut) {
	v__ast__ForInStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ForInStmt)); }
	return (v__ast__Stmt){ ._v__ast__ForInStmt = ptr, ._typ = 323, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ForInStmt, pos))};
}

v__ast__Expr v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(v__ast__IfGuardExpr* x, bool is_mut) {
	v__ast__IfGuardExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IfGuardExpr)); }
	return (v__ast__Expr){ ._v__ast__IfGuardExpr = ptr, ._typ = 283};
}

v__ast__Stmt v__ast__Module_to_sumtype_v__ast__Stmt(v__ast__Module* x, bool is_mut) {
	v__ast__Module* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Module)); }
	return (v__ast__Stmt){ ._v__ast__Module = ptr, ._typ = 331, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Module, pos))};
}

v__ast__Stmt v__ast__Import_to_sumtype_v__ast__Stmt(v__ast__Import* x, bool is_mut) {
	v__ast__Import* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Import)); }
	return (v__ast__Stmt){ ._v__ast__Import = ptr, ._typ = 329, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Import, pos))};
}

v__ast__Stmt v__ast__ConstDecl_to_sumtype_v__ast__Stmt(v__ast__ConstDecl* x, bool is_mut) {
	v__ast__ConstDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ConstDecl)); }
	return (v__ast__Stmt){ ._v__ast__ConstDecl = ptr, ._typ = 231, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstDecl, pos))};
}

v__ast__Stmt v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(v__ast__InterfaceDecl* x, bool is_mut) {
	v__ast__InterfaceDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__InterfaceDecl)); }
	return (v__ast__Stmt){ ._v__ast__InterfaceDecl = ptr, ._typ = 330, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__InterfaceDecl, pos))};
}

v__ast__Stmt v__ast__EnumDecl_to_sumtype_v__ast__Stmt(v__ast__EnumDecl* x, bool is_mut) {
	v__ast__EnumDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__EnumDecl)); }
	return (v__ast__Stmt){ ._v__ast__EnumDecl = ptr, ._typ = 320, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__EnumDecl, pos))};
}

v__ast__Stmt v__ast__TypeDecl_to_sumtype_v__ast__Stmt(v__ast__TypeDecl* x, bool is_mut) {
	v__ast__TypeDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__TypeDecl)); }
	return (v__ast__Stmt){ ._v__ast__TypeDecl = ptr, ._typ = 257, .pos = ptr->pos};
}

v__ast__Stmt v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(v__ast__GlobalDecl* x, bool is_mut) {
	v__ast__GlobalDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GlobalDecl)); }
	return (v__ast__Stmt){ ._v__ast__GlobalDecl = ptr, ._typ = 325, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalDecl, pos))};
}

v__ast__Stmt v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(v__ast__ComptimeFor* x, bool is_mut) {
	v__ast__ComptimeFor* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ComptimeFor)); }
	return (v__ast__Stmt){ ._v__ast__ComptimeFor = ptr, ._typ = 316, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ComptimeFor, pos))};
}

v__ast__Stmt v__ast__DebuggerStmt_to_sumtype_v__ast__Stmt(v__ast__DebuggerStmt* x, bool is_mut) {
	v__ast__DebuggerStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__DebuggerStmt)); }
	return (v__ast__Stmt){ ._v__ast__DebuggerStmt = ptr, ._typ = 317, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__DebuggerStmt, pos))};
}

v__ast__Stmt v__ast__HashStmt_to_sumtype_v__ast__Stmt(v__ast__HashStmt* x, bool is_mut) {
	v__ast__HashStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__HashStmt)); }
	return (v__ast__Stmt){ ._v__ast__HashStmt = ptr, ._typ = 328, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__HashStmt, pos))};
}

v__ast__Stmt v__ast__SemicolonStmt_to_sumtype_v__ast__Stmt(v__ast__SemicolonStmt* x, bool is_mut) {
	v__ast__SemicolonStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SemicolonStmt)); }
	return (v__ast__Stmt){ ._v__ast__SemicolonStmt = ptr, ._typ = 333, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SemicolonStmt, pos))};
}

v__ast__Stmt v__ast__AsmStmt_to_sumtype_v__ast__Stmt(v__ast__AsmStmt* x, bool is_mut) {
	v__ast__AsmStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AsmStmt)); }
	return (v__ast__Stmt){ ._v__ast__AsmStmt = ptr, ._typ = 311, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AsmStmt, pos))};
}

v__ast__Stmt v__ast__SqlStmt_to_sumtype_v__ast__Stmt(v__ast__SqlStmt* x, bool is_mut) {
	v__ast__SqlStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SqlStmt)); }
	return (v__ast__Stmt){ ._v__ast__SqlStmt = ptr, ._typ = 334, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SqlStmt, pos))};
}

v__ast__Stmt v__ast__GotoLabel_to_sumtype_v__ast__Stmt(v__ast__GotoLabel* x, bool is_mut) {
	v__ast__GotoLabel* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GotoLabel)); }
	return (v__ast__Stmt){ ._v__ast__GotoLabel = ptr, ._typ = 326, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoLabel, pos))};
}

v__ast__Stmt v__ast__Return_to_sumtype_v__ast__Stmt(v__ast__Return* x, bool is_mut) {
	v__ast__Return* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Return)); }
	return (v__ast__Stmt){ ._v__ast__Return = ptr, ._typ = 332, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__Return, pos))};
}

v__ast__Stmt v__ast__BranchStmt_to_sumtype_v__ast__Stmt(v__ast__BranchStmt* x, bool is_mut) {
	v__ast__BranchStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__BranchStmt)); }
	return (v__ast__Stmt){ ._v__ast__BranchStmt = ptr, ._typ = 315, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__BranchStmt, pos))};
}

v__ast__Stmt v__ast__AssertStmt_to_sumtype_v__ast__Stmt(v__ast__AssertStmt* x, bool is_mut) {
	v__ast__AssertStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AssertStmt)); }
	return (v__ast__Stmt){ ._v__ast__AssertStmt = ptr, ._typ = 312, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AssertStmt, pos))};
}

v__ast__Stmt v__ast__DeferStmt_to_sumtype_v__ast__Stmt(v__ast__DeferStmt* x, bool is_mut) {
	v__ast__DeferStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__DeferStmt)); }
	return (v__ast__Stmt){ ._v__ast__DeferStmt = ptr, ._typ = 318, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__DeferStmt, pos))};
}

v__ast__Stmt v__ast__GotoStmt_to_sumtype_v__ast__Stmt(v__ast__GotoStmt* x, bool is_mut) {
	v__ast__GotoStmt* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GotoStmt)); }
	return (v__ast__Stmt){ ._v__ast__GotoStmt = ptr, ._typ = 327, .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GotoStmt, pos))};
}

v__ast__Expr v__ast__ConcatExpr_to_sumtype_v__ast__Expr(v__ast__ConcatExpr* x, bool is_mut) {
	v__ast__ConcatExpr* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ConcatExpr)); }
	return (v__ast__Expr){ ._v__ast__ConcatExpr = ptr, ._typ = 275};
}

v__ast__IdentInfo v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(v__ast__IdentVar* x, bool is_mut) {
	v__ast__IdentVar* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IdentVar)); }
	return (v__ast__IdentInfo){ ._v__ast__IdentVar = ptr, ._typ = 408, .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__IdentVar, typ))};
}

v__ast__Expr v__ast__ChanInit_to_sumtype_v__ast__Expr(v__ast__ChanInit* x, bool is_mut) {
	v__ast__ChanInit* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ChanInit)); }
	return (v__ast__Expr){ ._v__ast__ChanInit = ptr, ._typ = 269};
}

v__ast__IdentInfo v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(v__ast__IdentFn* x, bool is_mut) {
	v__ast__IdentFn* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__IdentFn)); }
	return (v__ast__IdentInfo){ ._v__ast__IdentFn = ptr, ._typ = 407, .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__IdentFn, typ))};
}

v__ast__Expr v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(v__ast__StringInterLiteral* x, bool is_mut) {
	v__ast__StringInterLiteral* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__StringInterLiteral)); }
	return (v__ast__Expr){ ._v__ast__StringInterLiteral = ptr, ._typ = 306};
}

v__ast__ScopeObject v__ast__ConstField_to_sumtype_v__ast__ScopeObject(v__ast__ConstField* x, bool is_mut) {
	v__ast__ConstField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__ConstField)); }
	return (v__ast__ScopeObject){ ._v__ast__ConstField = ptr, ._typ = 339, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstField, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__ConstField, typ))};
}

v__ast__ScopeObject v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(v__ast__GlobalField* x, bool is_mut) {
	v__ast__GlobalField* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__GlobalField)); }
	return (v__ast__ScopeObject){ ._v__ast__GlobalField = ptr, ._typ = 340, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalField, name)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__GlobalField, typ))};
}

v__ast__TypeDecl v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__SumTypeDecl* x, bool is_mut) {
	v__ast__SumTypeDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__SumTypeDecl)); }
	return (v__ast__TypeDecl){ ._v__ast__SumTypeDecl = ptr, ._typ = 256, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, name)), .mod = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, mod)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, is_pub)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, typ)), .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, pos)), .attrs = (Array_v__ast__Attr*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, attrs)), .is_markused = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__SumTypeDecl, is_markused))};
}

v__ast__TypeDecl v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__AliasTypeDecl* x, bool is_mut) {
	v__ast__AliasTypeDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__AliasTypeDecl)); }
	return (v__ast__TypeDecl){ ._v__ast__AliasTypeDecl = ptr, ._typ = 254, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, name)), .mod = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, mod)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, is_pub)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, typ)), .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, pos)), .attrs = (Array_v__ast__Attr*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, attrs)), .is_markused = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__AliasTypeDecl, is_markused))};
}

v__ast__TypeDecl v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(v__ast__FnTypeDecl* x, bool is_mut) {
	v__ast__FnTypeDecl* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__FnTypeDecl)); }
	return (v__ast__TypeDecl){ ._v__ast__FnTypeDecl = ptr, ._typ = 255, .name = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, name)), .mod = (string*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, mod)), .is_pub = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, is_pub)), .typ = (v__ast__Type*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, typ)), .pos = (v__token__Pos*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, pos)), .attrs = (Array_v__ast__Attr*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, attrs)), .is_markused = (bool*)((char*)ptr + __offsetof_ptr(ptr, v__ast__FnTypeDecl, is_markused))};
}

v__ast__TypeInfo v__ast__Alias_to_sumtype_v__ast__TypeInfo(v__ast__Alias* x, bool is_mut) {
	v__ast__Alias* ptr = x;
	if (!is_mut) { ptr = builtin__memdup(x, sizeof(v__ast__Alias)); }
	return (v__ast__TypeInfo){ ._v__ast__Alias = ptr, ._typ = 482};
}

static bool Array_u8_contains(Array_u8 a, u8 v) {
	for (int i = 0; i < a.len; ++i) {
		if (((u8*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (builtin__fast_string_eq(((string*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__token__Kind_contains(Array_v__token__Kind a, v__token__Kind v) {
	for (int i = 0; i < a.len; ++i) {
		if (((v__token__Kind*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_fixed_string_9_contains(Array_fixed_string_9 a, string v) {
	for (int i = 0; i < 9; ++i) {
		if (builtin__fast_string_eq(a[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_Array_v__ast__Type_contains(Array_Array_v__ast__Type a, Array_v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if (Array_v__ast__Type_arr_eq(((Array_v__ast__Type*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__Type_contains(Array_v__ast__Type a, v__ast__Type v) {
	for (int i = 0; i < a.len; ++i) {
		if (((v__ast__Type*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_v__ast__Kind_contains(Array_v__ast__Kind a, v__ast__Kind v) {
	for (int i = 0; i < a.len; ++i) {
		if (((v__ast__Kind*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if (((int*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_rune_contains(Array_rune a, rune v) {
	for (int i = 0; i < a.len; ++i) {
		if (((rune*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static int Array_string_index(Array_string a, string v) {
	string* pelem = a.data;
	for (int i = 0; i < a.len; ++i, ++pelem) {
		if (builtin__fast_string_eq(*pelem, v)) {
			return i;
		}
	}
	return -1;
}

inline bool Array_rune_arr_eq(Array_rune a, Array_rune b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((rune*)((byte*)a.data+(i*a.element_size))) != *((rune*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool Array_string_arr_eq(Array_string a, Array_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!builtin__string__eq(*((string*)((byte*)a.data+(i*a.element_size))), *((string*)((byte*)b.data+(i*b.element_size))))) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__Type_alias_eq(v__ast__Type a, v__ast__Type b) {
	return a == b;
}

inline bool Array_v__ast__Type_arr_eq(Array_v__ast__Type a, Array_v__ast__Type b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (((v__ast__Type*)a.data)[i] != ((v__ast__Type*)b.data)[i]) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AsmRegister_struct_eq(v__ast__AsmRegister a, v__ast__AsmRegister b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.typ == b.typ
		&& a.size == b.size;
}

inline bool v__token__Pos_struct_eq(v__token__Pos a, v__token__Pos b) {
	return a.len == b.len
		&& a.line_nr == b.line_nr
		&& a.pos == b.pos
		&& a.col == b.col
		&& a.file_idx == b.file_idx
		&& a.last_line == b.last_line;
}

inline bool v__ast__Comment_struct_eq(v__ast__Comment a, v__ast__Comment b) {
	return (((a.text).len == (b.text).len && (a.text).len == 0) || builtin__fast_string_eq(a.text, b.text))
		&& a.is_multi == b.is_multi
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool Array_v__ast__Comment_arr_eq(Array_v__ast__Comment a, Array_v__ast__Comment b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Comment_struct_eq(((v__ast__Comment*)a.data)[i], ((v__ast__Comment*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AsmClobbered_struct_eq(v__ast__AsmClobbered a, v__ast__AsmClobbered b) {
	return v__ast__AsmRegister_struct_eq(a.reg, b.reg)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments);
}

inline bool Array_v__ast__AsmClobbered_arr_eq(Array_v__ast__AsmClobbered a, Array_v__ast__AsmClobbered b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__AsmClobbered_struct_eq(((v__ast__AsmClobbered*)a.data)[i], ((v__ast__AsmClobbered*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AsmAddressing_struct_eq(v__ast__AsmAddressing a, v__ast__AsmAddressing b) {
	return a.scale == b.scale
		&& a.mode == b.mode
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& (((a.segment).len == (b.segment).len && (a.segment).len == 0) || builtin__fast_string_eq(a.segment, b.segment))
		&& v__ast__AsmArg_sumtype_eq(a.displacement, b.displacement)
		&& v__ast__AsmArg_sumtype_eq(a.base, b.base)
		&& v__ast__AsmArg_sumtype_eq(a.index, b.index);
}

inline bool v__ast__AsmAlias_struct_eq(v__ast__AsmAlias a, v__ast__AsmAlias b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name));
}

inline bool v__ast__AsmDisp_struct_eq(v__ast__AsmDisp a, v__ast__AsmDisp b) {
	return (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__BoolLiteral_struct_eq(v__ast__BoolLiteral a, v__ast__BoolLiteral b) {
	return a.val == b.val
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__CharLiteral_struct_eq(v__ast__CharLiteral a, v__ast__CharLiteral b) {
	return (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__FloatLiteral_struct_eq(v__ast__FloatLiteral a, v__ast__FloatLiteral b) {
	return (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__IntegerLiteral_struct_eq(v__ast__IntegerLiteral a, v__ast__IntegerLiteral b) {
	return (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__AsmArg_sumtype_eq(v__ast__AsmArg a, v__ast__AsmArg b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 429) {
		return v__ast__AsmAddressing_struct_eq(*a._v__ast__AsmAddressing, *b._v__ast__AsmAddressing);
	}
	if (a._typ == 430) {
		return v__ast__AsmAlias_struct_eq(*a._v__ast__AsmAlias, *b._v__ast__AsmAlias);
	}
	if (a._typ == 431) {
		return v__ast__AsmDisp_struct_eq(*a._v__ast__AsmDisp, *b._v__ast__AsmDisp);
	}
	if (a._typ == 338) {
		return v__ast__AsmRegister_struct_eq(*a._v__ast__AsmRegister, *b._v__ast__AsmRegister);
	}
	if (a._typ == 265) {
		return v__ast__BoolLiteral_struct_eq(*a._v__ast__BoolLiteral, *b._v__ast__BoolLiteral);
	}
	if (a._typ == 270) {
		return v__ast__CharLiteral_struct_eq(*a._v__ast__CharLiteral, *b._v__ast__CharLiteral);
	}
	if (a._typ == 279) {
		return v__ast__FloatLiteral_struct_eq(*a._v__ast__FloatLiteral, *b._v__ast__FloatLiteral);
	}
	if (a._typ == 286) {
		return v__ast__IntegerLiteral_struct_eq(*a._v__ast__IntegerLiteral, *b._v__ast__IntegerLiteral);
	}
	if (a._typ == 21) {
		return builtin__string__eq(*a._string, *b._string);
	}
	return false;
}

inline bool Array_v__ast__AsmArg_arr_eq(Array_v__ast__AsmArg a, Array_v__ast__AsmArg b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__AsmArg_sumtype_eq(((v__ast__AsmArg*)a.data)[i], ((v__ast__AsmArg*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AsmTemplate_struct_eq(v__ast__AsmTemplate a, v__ast__AsmTemplate b) {
	return Array_v__ast__AsmArg_arr_eq(a.args, b.args)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_label == b.is_label
		&& a.is_directive == b.is_directive;
}

inline bool Array_v__ast__AsmTemplate_arr_eq(Array_v__ast__AsmTemplate a, Array_v__ast__AsmTemplate b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__AsmTemplate_struct_eq(((v__ast__AsmTemplate*)a.data)[i], ((v__ast__AsmTemplate*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__NodeError_struct_eq(v__ast__NodeError a, v__ast__NodeError b) {
	return a.idx == b.idx
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool Array_v__ast__StructField_arr_eq(Array_v__ast__StructField a, Array_v__ast__StructField b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__StructField_struct_eq(((v__ast__StructField*)a.data)[i], ((v__ast__StructField*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__TypeNode_struct_eq(v__ast__TypeNode a, v__ast__TypeNode b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& v__ast__Stmt_sumtype_eq(a.stmt, b.stmt)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments);
}

inline bool Array_v__ast__TypeNode_arr_eq(Array_v__ast__TypeNode a, Array_v__ast__TypeNode b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__TypeNode_struct_eq(((v__ast__TypeNode*)a.data)[i], ((v__ast__TypeNode*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__Embed_struct_eq(v__ast__Embed a, v__ast__Embed b) {
	return a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments);
}

inline bool Array_v__ast__Embed_arr_eq(Array_v__ast__Embed a, Array_v__ast__Embed b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Embed_struct_eq(((v__ast__Embed*)a.data)[i], ((v__ast__Embed*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__Attr_struct_eq(v__ast__Attr a, v__ast__Attr b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__ast__Expr_sumtype_eq(a.ct_expr, b.ct_expr)
		&& (((a.arg).len == (b.arg).len && (a.arg).len == 0) || builtin__fast_string_eq(a.arg, b.arg))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.kind == b.kind
		&& a.ct_opt == b.ct_opt
		&& a.has_at == b.has_at
		&& a.has_arg == b.has_arg
		&& a.ct_evaled == b.ct_evaled
		&& a.ct_skip == b.ct_skip;
}

inline bool Array_v__ast__Attr_arr_eq(Array_v__ast__Attr a, Array_v__ast__Attr b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Attr_struct_eq(((v__ast__Attr*)a.data)[i], ((v__ast__Attr*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__StructDecl_struct_eq(v__ast__StructDecl a, v__ast__StructDecl b) {
	return Array_v__ast__StructField_arr_eq(a.fields, b.fields)
		&& Array_v__ast__TypeNode_arr_eq(a.implements_types, b.implements_types)
		&& Array_v__ast__Embed_arr_eq(a.embeds, b.embeds)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& Array_v__ast__Type_arr_eq(a.generic_types, b.generic_types)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.scoped_name).len == (b.scoped_name).len && (a.scoped_name).len == 0) || builtin__fast_string_eq(a.scoped_name, b.scoped_name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.idx == b.idx
		&& a.mut_pos == b.mut_pos
		&& a.pub_pos == b.pub_pos
		&& a.pub_mut_pos == b.pub_mut_pos
		&& a.global_pos == b.global_pos
		&& a.module_pos == b.module_pos
		&& a.language == b.language
		&& a.is_aligned == b.is_aligned
		&& a.is_implements == b.is_implements
		&& a.is_option == b.is_option
		&& a.is_union == b.is_union
		&& a.is_pub == b.is_pub;
}

inline bool v__ast__StructField_struct_eq(v__ast__StructField a, v__ast__StructField b) {
	return v__ast__StructDecl_struct_eq(a.anon_struct_decl, b.anon_struct_decl)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Comment_arr_eq(a.next_comments, b.next_comments)
		&& (((a.default_val).len == (b.default_val).len && (a.default_val).len == 0) || builtin__fast_string_eq(a.default_val, b.default_val))
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__ast__Expr_sumtype_eq(a.default_expr, b.default_expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.type_pos, b.type_pos)
		&& v__token__Pos_struct_eq(a.option_pos, b.option_pos)
		&& a.default_expr_typ == b.default_expr_typ
		&& a.container_typ == b.container_typ
		&& a.typ == b.typ
		&& a.unaliased_typ == b.unaliased_typ
		&& a.i == b.i
		&& a.is_pub == b.is_pub
		&& a.has_break_line == b.has_break_line
		&& a.is_recursive == b.is_recursive
		&& a.is_mut == b.is_mut
		&& a.has_prev_newline == b.has_prev_newline
		&& a.has_default_expr == b.has_default_expr
		&& a.is_part_of_union == b.is_part_of_union
		&& a.is_global == b.is_global
		&& a.is_volatile == b.is_volatile
		&& a.is_deprecated == b.is_deprecated
		&& a.is_embed == b.is_embed;
}

inline bool v__ast__FnTrace_struct_eq(v__ast__FnTrace a, v__ast__FnTrace b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.file).len == (b.file).len && (a.file).len == 0) || builtin__fast_string_eq(a.file, b.file))
		&& a.line == b.line
		&& a.func == b.func
		&& a.return_type == b.return_type
		&& a.is_fn_var == b.is_fn_var;
}

inline bool Map_string_v__ast__FnTrace_map_eq(Map_string_v__ast__FnTrace a, Map_string_v__ast__FnTrace b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = builtin__DenseArray_key(&a.key_values, i);
		if (!builtin__map_exists(&b, k)) return false;
		v__ast__FnTrace v = *(v__ast__FnTrace*)builtin__map_get(&a, k, &(v__ast__FnTrace[]){ 0 });
		if (!v__ast__FnTrace_struct_eq(*(v__ast__FnTrace*)builtin__map_get(&b, k, &(v__ast__FnTrace[]){ 0 }), v)) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__ast__Stmt_arr_eq(Array_v__ast__Stmt a, Array_v__ast__Stmt b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Stmt_sumtype_eq(((v__ast__Stmt*)a.data)[i], ((v__ast__Stmt*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__OrExpr_struct_eq(v__ast__OrExpr a, v__ast__OrExpr b) {
	return a.kind == b.kind
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.scope == b.scope
		&& a.err_used == b.err_used
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts);
}

inline bool v__ast__EmptyScopeObject_struct_eq(v__ast__EmptyScopeObject a, v__ast__EmptyScopeObject b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.typ == b.typ;
}

inline bool v__ast__EmptyExpr_alias_eq(v__ast__EmptyExpr a, v__ast__EmptyExpr b) {
	return a == b;
}

inline bool v__ast__ComptTimeConstValue_sumtype_eq(v__ast__ComptTimeConstValue a, v__ast__ComptTimeConstValue b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 277) {
		return v__ast__EmptyExpr_alias_eq(*a._v__ast__EmptyExpr, *b._v__ast__EmptyExpr);
	}
	if (a._typ == 16) {
		return *a._f32 == *b._f32;
	}
	if (a._typ == 17) {
		return *a._f64 == *b._f64;
	}
	if (a._typ == 6) {
		return *a._i16 == *b._i16;
	}
	if (a._typ == 7) {
		return *a._i32 == *b._i32;
	}
	if (a._typ == 9) {
		return *a._i64 == *b._i64;
	}
	if (a._typ == 5) {
		return *a._i8 == *b._i8;
	}
	if (a._typ == 22) {
		return *a._rune == *b._rune;
	}
	if (a._typ == 21) {
		return builtin__string__eq(*a._string, *b._string);
	}
	if (a._typ == 12) {
		return *a._u16 == *b._u16;
	}
	if (a._typ == 13) {
		return *a._u32 == *b._u32;
	}
	if (a._typ == 14) {
		return *a._u64 == *b._u64;
	}
	if (a._typ == 11) {
		return *a._u8 == *b._u8;
	}
	if (a._typ == 2) {
		return *a._voidptr == *b._voidptr;
	}
	return false;
}

inline bool v__ast__ConstField_struct_eq(v__ast__ConstField a, v__ast__ConstField b) {
	return (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.is_pub == b.is_pub
		&& a.is_markused == b.is_markused
		&& a.is_exported == b.is_exported
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& a.is_virtual_c == b.is_virtual_c
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.typ == b.typ
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& v__ast__ComptTimeConstValue_sumtype_eq(a.comptime_expr_value, b.comptime_expr_value);
}

inline bool v__ast__GlobalField_struct_eq(v__ast__GlobalField a, v__ast__GlobalField b) {
	return Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& v__token__Pos_struct_eq(a.typ_pos, b.typ_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.language == b.language
		&& a.is_weak == b.is_weak
		&& a.is_hidden == b.is_hidden
		&& a.is_extern == b.is_extern
		&& a.has_expr == b.has_expr
		&& a.is_volatile == b.is_volatile
		&& a.is_markused == b.is_markused
		&& a.is_exported == b.is_exported;
}

inline bool v__ast__Var_struct_eq(v__ast__Var a, v__ast__Var b) {
	return Array_v__ast__Type_arr_eq(a.smartcasts, b.smartcasts)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.orig_type == b.orig_type
		&& a.ct_type_var == b.ct_type_var
		&& a.share == b.share
		&& a.is_arg == b.is_arg
		&& a.is_auto_deref == b.is_auto_deref
		&& a.is_unwrapped == b.is_unwrapped
		&& a.is_index_var == b.is_index_var
		&& a.is_volatile == b.is_volatile
		&& a.is_static == b.is_static
		&& a.is_special == b.is_special
		&& a.is_mut == b.is_mut
		&& a.is_used == b.is_used
		&& a.is_changed == b.is_changed
		&& a.ct_type_unwrapped == b.ct_type_unwrapped
		&& a.is_or == b.is_or
		&& a.is_tmp == b.is_tmp
		&& a.is_auto_heap == b.is_auto_heap
		&& a.is_stack_obj == b.is_stack_obj
		&& a.is_inherited == b.is_inherited
		&& a.is_autofree_tmp == b.is_autofree_tmp
		&& a.has_inherited == b.has_inherited;
}

inline bool v__ast__ScopeObject_sumtype_eq(v__ast__ScopeObject a, v__ast__ScopeObject b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 337) {
		return v__ast__EmptyScopeObject_struct_eq(*a._v__ast__EmptyScopeObject, *b._v__ast__EmptyScopeObject);
	}
	if (a._typ == 338) {
		return v__ast__AsmRegister_struct_eq(*a._v__ast__AsmRegister, *b._v__ast__AsmRegister);
	}
	if (a._typ == 339) {
		return v__ast__ConstField_struct_eq(*a._v__ast__ConstField, *b._v__ast__ConstField);
	}
	if (a._typ == 340) {
		return v__ast__GlobalField_struct_eq(*a._v__ast__GlobalField, *b._v__ast__GlobalField);
	}
	if (a._typ == 341) {
		return v__ast__Var_struct_eq(*a._v__ast__Var, *b._v__ast__Var);
	}
	return false;
}

inline bool v__ast__IdentFn_struct_eq(v__ast__IdentFn a, v__ast__IdentFn b) {
	return a.typ == b.typ;
}

inline bool v__ast__IdentVar_struct_eq(v__ast__IdentVar a, v__ast__IdentVar b) {
	return a.typ == b.typ
		&& a.share == b.share
		&& a.is_mut == b.is_mut
		&& a.is_static == b.is_static
		&& a.is_volatile == b.is_volatile
		&& a.is_option == b.is_option;
}

inline bool v__ast__IdentInfo_sumtype_eq(v__ast__IdentInfo a, v__ast__IdentInfo b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 407) {
		return v__ast__IdentFn_struct_eq(*a._v__ast__IdentFn, *b._v__ast__IdentFn);
	}
	if (a._typ == 408) {
		return v__ast__IdentVar_struct_eq(*a._v__ast__IdentVar, *b._v__ast__IdentVar);
	}
	return false;
}

inline bool v__ast__Ident_struct_eq(v__ast__Ident a, v__ast__Ident b) {
	return v__ast__OrExpr_struct_eq(a.or_expr, b.or_expr)
		&& Array_v__ast__Type_arr_eq(a.concrete_types, b.concrete_types)
		&& v__ast__ScopeObject_sumtype_eq(a.obj, b.obj)
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.full_name).len == (b.full_name).len && (a.full_name).len == 0) || builtin__fast_string_eq(a.full_name, b.full_name))
		&& (((a.cached_name).len == (b.cached_name).len && (a.cached_name).len == 0) || builtin__fast_string_eq(a.cached_name, b.cached_name))
		&& v__ast__IdentInfo_sumtype_eq(a.info, b.info)
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.mut_pos, b.mut_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.tok_kind == b.tok_kind
		&& a.language == b.language
		&& a.kind == b.kind
		&& a.is_mut == b.is_mut
		&& a.comptime == b.comptime
		&& a.ct_expr == b.ct_expr;
}

inline bool Array_v__ast__Ident_arr_eq(Array_v__ast__Ident a, Array_v__ast__Ident b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Ident_struct_eq(((v__ast__Ident*)a.data)[i], ((v__ast__Ident*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__DeferStmt_struct_eq(v__ast__DeferStmt a, v__ast__DeferStmt b) {
	return Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Ident_arr_eq(a.defer_vars, b.defer_vars)
		&& (((a.ifdef).len == (b.ifdef).len && (a.ifdef).len == 0) || builtin__fast_string_eq(a.ifdef, b.ifdef))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.idx_in_fn == b.idx_in_fn
		&& a.mode == b.mode;
}

inline bool Array_v__ast__DeferStmt_arr_eq(Array_v__ast__DeferStmt a, Array_v__ast__DeferStmt b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__DeferStmt_struct_eq(((v__ast__DeferStmt*)a.data)[i], ((v__ast__DeferStmt*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__Param_struct_eq(v__ast__Param a, v__ast__Param b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.type_pos, b.type_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.is_atomic == b.is_atomic
		&& a.is_shared == b.is_shared
		&& a.is_hidden == b.is_hidden
		&& a.on_newline == b.on_newline
		&& a.is_mut == b.is_mut;
}

inline bool Array_v__ast__Param_arr_eq(Array_v__ast__Param a, Array_v__ast__Param b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Param_struct_eq(((v__ast__Param*)a.data)[i], ((v__ast__Param*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__FnDecl_struct_eq(v__ast__FnDecl a, v__ast__FnDecl b) {
	return v__ast__StructField_struct_eq(a.receiver, b.receiver)
		&& Map_string_v__ast__FnTrace_map_eq(a.trace_fns, b.trace_fns)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_string_arr_eq(a.label_names, b.label_names)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& Array_v__ast__DeferStmt_arr_eq(a.defer_stmts, b.defer_stmts)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Param_arr_eq(a.params, b.params)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_string_arr_eq(a.generic_names, b.generic_names)
		&& Array_v__ast__Comment_arr_eq(a.next_comments, b.next_comments)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.file).len == (b.file).len && (a.file).len == 0) || builtin__fast_string_eq(a.file, b.file))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& (((a.short_name).len == (b.short_name).len && (a.short_name).len == 0) || builtin__fast_string_eq(a.short_name, b.short_name))
		&& a.scope == b.scope
		&& a.source_file == b.source_file
		&& v__token__Pos_struct_eq(a.receiver_pos, b.receiver_pos)
		&& v__token__Pos_struct_eq(a.static_type_pos, b.static_type_pos)
		&& v__token__Pos_struct_eq(a.method_type_pos, b.method_type_pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& v__token__Pos_struct_eq(a.body_pos, b.body_pos)
		&& v__token__Pos_struct_eq(a.return_type_pos, b.return_type_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.end_pos, b.end_pos)
		&& a.ninstances == b.ninstances
		&& a.return_type == b.return_type
		&& a.idx == b.idx
		&& a.ctdefine_idx == b.ctdefine_idx
		&& a.method_idx == b.method_idx
		&& a.kind == b.kind
		&& a.language == b.language
		&& a.file_mode == b.file_mode
		&& a.rec_share == b.rec_share
		&& a.is_exported == b.is_exported
		&& a.is_keep_alive == b.is_keep_alive
		&& a.no_body == b.no_body
		&& a.is_builtin == b.is_builtin
		&& a.is_deprecated == b.is_deprecated
		&& a.rec_mut == b.rec_mut
		&& a.is_conditional == b.is_conditional
		&& a.is_test == b.is_test
		&& a.is_direct_arr == b.is_direct_arr
		&& a.is_main == b.is_main
		&& a.is_pub == b.is_pub
		&& a.is_c_variadic == b.is_c_variadic
		&& a.is_manualfree == b.is_manualfree
		&& a.is_noreturn == b.is_noreturn
		&& a.is_weak == b.is_weak
		&& a.is_anon == b.is_anon
		&& a.is_static_type_method == b.is_static_type_method
		&& a.is_expand_simple_interpolation == b.is_expand_simple_interpolation
		&& a.has_return == b.has_return
		&& a.should_be_skipped == b.should_be_skipped
		&& a.is_method == b.is_method
		&& a.has_await == b.has_await
		&& a.is_variadic == b.is_variadic
		&& a.is_c_extern == b.is_c_extern
		&& a.is_unsafe == b.is_unsafe
		&& a.is_must_use == b.is_must_use
		&& a.is_markused == b.is_markused
		&& a.is_ignore_overflow == b.is_ignore_overflow
		&& a.is_file_translated == b.is_file_translated
		&& a.is_closure == b.is_closure
		&& a.has_break_line == b.has_break_line
		&& a.has_prev_newline == b.has_prev_newline;
}

inline bool Map_string_bool_map_eq(Map_string_bool a, Map_string_bool b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = builtin__DenseArray_key(&a.key_values, i);
		if (!builtin__map_exists(&b, k)) return false;
		bool v = *(bool*)builtin__map_get(&a, k, &(bool[]){ 0 });
		if (*(bool*)builtin__map_get(&b, k, &(bool[]){ 0 }) != v) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AnonFn_struct_eq(v__ast__AnonFn a, v__ast__AnonFn b) {
	return v__ast__FnDecl_struct_eq(a.decl, b.decl)
		&& Array_v__ast__Param_arr_eq(a.inherited_vars, b.inherited_vars)
		&& a.has_ct_var == b.has_ct_var
		&& a.typ == b.typ
		&& Map_string_bool_map_eq(a.has_gen, b.has_gen);
}

inline bool v__ast__ArrayDecompose_struct_eq(v__ast__ArrayDecompose a, v__ast__ArrayDecompose b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.expr_type == b.expr_type
		&& a.arg_type == b.arg_type;
}

inline bool Array_Array_v__ast__Comment_arr_eq(Array_Array_v__ast__Comment a, Array_Array_v__ast__Comment b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!Array_v__ast__Comment_arr_eq(((Array_v__ast__Comment*)a.data)[i], ((Array_v__ast__Comment*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__ast__Expr_arr_eq(Array_v__ast__Expr a, Array_v__ast__Expr b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Expr_sumtype_eq(((v__ast__Expr*)a.data)[i], ((v__ast__Expr*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__ArrayInit_struct_eq(v__ast__ArrayInit a, v__ast__ArrayInit b) {
	return Array_v__ast__Comment_arr_eq(a.pre_cmnts, b.pre_cmnts)
		&& Array_Array_v__ast__Comment_arr_eq(a.ecmnts, b.ecmnts)
		&& Array_v__ast__Type_arr_eq(a.expr_types, b.expr_types)
		&& Array_v__ast__Expr_arr_eq(a.exprs, b.exprs)
		&& v__ast__Expr_sumtype_eq(a.cap_expr, b.cap_expr)
		&& v__ast__Expr_sumtype_eq(a.init_expr, b.init_expr)
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& v__ast__Expr_sumtype_eq(a.len_expr, b.len_expr)
		&& v__token__Pos_struct_eq(a.elem_type_pos, b.elem_type_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.init_type == b.init_type
		&& a.elem_type == b.elem_type
		&& a.alias_type == b.alias_type
		&& a.has_callexpr == b.has_callexpr
		&& a.is_fixed == b.is_fixed
		&& a.is_option == b.is_option
		&& a.has_val == b.has_val
		&& a.has_len == b.has_len
		&& a.has_cap == b.has_cap
		&& a.has_init == b.has_init
		&& a.has_index == b.has_index;
}

inline bool v__ast__AsCast_struct_eq(v__ast__AsCast a, v__ast__AsCast b) {
	return a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.expr_type == b.expr_type;
}

inline bool v__ast__Assoc_struct_eq(v__ast__Assoc a, v__ast__Assoc b) {
	return Array_string_arr_eq(a.fields, b.fields)
		&& Array_v__ast__Expr_arr_eq(a.exprs, b.exprs)
		&& (((a.var_name).len == (b.var_name).len && (a.var_name).len == 0) || builtin__fast_string_eq(a.var_name, b.var_name))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ;
}

inline bool v__ast__AtExpr_struct_eq(v__ast__AtExpr a, v__ast__AtExpr b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.kind == b.kind
		&& (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val));
}

inline bool v__ast__CTempVar_struct_eq(v__ast__CTempVar a, v__ast__CTempVar b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.typ == b.typ
		&& a.is_ptr == b.is_ptr
		&& v__ast__Expr_sumtype_eq(a.orig, b.orig)
		&& a.is_fixed_ret == b.is_fixed_ret;
}

inline bool v__ast__CallArg_struct_eq(v__ast__CallArg a, v__ast__CallArg b) {
	return Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.share == b.share
		&& a.ct_expr == b.ct_expr
		&& a.is_tmp_autofree == b.is_tmp_autofree
		&& a.should_be_ptr == b.should_be_ptr
		&& a.is_mut == b.is_mut;
}

inline bool Array_v__ast__CallArg_arr_eq(Array_v__ast__CallArg a, Array_v__ast__CallArg b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__CallArg_struct_eq(((v__ast__CallArg*)a.data)[i], ((v__ast__CallArg*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__CallExpr_struct_eq(v__ast__CallExpr a, v__ast__CallExpr b) {
	return v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& Array_v__ast__Type_arr_eq(a.expected_arg_types, b.expected_arg_types)
		&& Array_v__ast__CallArg_arr_eq(a.args, b.args)
		&& Array_v__ast__Type_arr_eq(a.concrete_types, b.concrete_types)
		&& Array_v__ast__Type_arr_eq(a.raw_concrete_types, b.raw_concrete_types)
		&& Array_v__ast__Type_arr_eq(a.from_embed_types, b.from_embed_types)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.const_name).len == (b.const_name).len && (a.const_name).len == 0) || builtin__fast_string_eq(a.const_name, b.const_name))
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.concrete_list_pos, b.concrete_list_pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& a.receiver_type == b.receiver_type
		&& a.return_type == b.return_type
		&& a.return_type_generic == b.return_type_generic
		&& a.nr_ret_values == b.nr_ret_values
		&& a.fn_var_type == b.fn_var_type
		&& a.left_type == b.left_type
		&& a.receiver_concrete_type == b.receiver_concrete_type
		&& a.kind == b.kind
		&& a.language == b.language
		&& a.is_unwrapped_fn_selector == b.is_unwrapped_fn_selector
		&& a.is_method == b.is_method
		&& a.is_field == b.is_field
		&& a.is_fn_var == b.is_fn_var
		&& a.is_fn_a_const == b.is_fn_a_const
		&& a.is_keep_alive == b.is_keep_alive
		&& a.is_noreturn == b.is_noreturn
		&& a.is_ctor_new == b.is_ctor_new
		&& a.is_file_translated == b.is_file_translated
		&& a.is_static_method == b.is_static_method
		&& a.is_variadic == b.is_variadic
		&& a.is_c_variadic == b.is_c_variadic
		&& a.comptime_ret_val == b.comptime_ret_val
		&& a.should_be_skipped == b.should_be_skipped
		&& a.free_receiver == b.free_receiver
		&& a.is_return_used == b.is_return_used
		&& a.is_expand_simple_interpolation == b.is_expand_simple_interpolation;
}

inline bool v__ast__CastExpr_struct_eq(v__ast__CastExpr a, v__ast__CastExpr b) {
	return v__ast__Expr_sumtype_eq(a.arg, b.arg)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& (((a.typname).len == (b.typname).len && (a.typname).len == 0) || builtin__fast_string_eq(a.typname, b.typname))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.expr_type == b.expr_type
		&& a.has_arg == b.has_arg;
}

inline bool v__ast__ChanInit_struct_eq(v__ast__ChanInit a, v__ast__ChanInit b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.elem_type_pos, b.elem_type_pos)
		&& a.has_cap == b.has_cap
		&& v__ast__Expr_sumtype_eq(a.cap_expr, b.cap_expr)
		&& a.typ == b.typ
		&& a.elem_type == b.elem_type;
}

inline bool v__ast__Module_struct_eq(v__ast__Module a, v__ast__Module b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.short_name).len == (b.short_name).len && (a.short_name).len == 0) || builtin__fast_string_eq(a.short_name, b.short_name))
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& a.is_skipped == b.is_skipped;
}

inline bool v__ast__ImportSymbol_struct_eq(v__ast__ImportSymbol a, v__ast__ImportSymbol b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name));
}

inline bool Array_v__ast__ImportSymbol_arr_eq(Array_v__ast__ImportSymbol a, Array_v__ast__ImportSymbol b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__ImportSymbol_struct_eq(((v__ast__ImportSymbol*)a.data)[i], ((v__ast__ImportSymbol*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__Import_struct_eq(v__ast__Import a, v__ast__Import b) {
	return (((a.source_name).len == (b.source_name).len && (a.source_name).len == 0) || builtin__fast_string_eq(a.source_name, b.source_name))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& (((a.alias).len == (b.alias).len && (a.alias).len == 0) || builtin__fast_string_eq(a.alias, b.alias))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.mod_pos, b.mod_pos)
		&& v__token__Pos_struct_eq(a.alias_pos, b.alias_pos)
		&& v__token__Pos_struct_eq(a.syms_pos, b.syms_pos)
		&& Array_v__ast__ImportSymbol_arr_eq(a.syms, b.syms)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Comment_arr_eq(a.next_comments, b.next_comments);
}

inline bool Array_v__ast__Import_arr_eq(Array_v__ast__Import a, Array_v__ast__Import b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__Import_struct_eq(((v__ast__Import*)a.data)[i], ((v__ast__Import*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool Array_u8_arr_eq(Array_u8 a, Array_u8 b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((u8*)((byte*)a.data+(i*a.element_size))) != *((u8*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__EmbeddedFile_struct_eq(v__ast__EmbeddedFile a, v__ast__EmbeddedFile b) {
	return Array_u8_arr_eq(a.bytes, b.bytes)
		&& (((a.compression_type).len == (b.compression_type).len && (a.compression_type).len == 0) || builtin__fast_string_eq(a.compression_type, b.compression_type))
		&& (((a.rpath).len == (b.rpath).len && (a.rpath).len == 0) || builtin__fast_string_eq(a.rpath, b.rpath))
		&& (((a.apath).len == (b.apath).len && (a.apath).len == 0) || builtin__fast_string_eq(a.apath, b.apath))
		&& a.len == b.len
		&& a.is_compressed == b.is_compressed;
}

inline bool Array_v__ast__EmbeddedFile_arr_eq(Array_v__ast__EmbeddedFile a, Array_v__ast__EmbeddedFile b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__EmbeddedFile_struct_eq(((v__ast__EmbeddedFile*)a.data)[i], ((v__ast__EmbeddedFile*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool Map_string_string_map_eq(Map_string_string a, Map_string_string b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = builtin__DenseArray_key(&a.key_values, i);
		if (!builtin__map_exists(&b, k)) return false;
		string v = *(string*)builtin__map_get(&a, k, &(string[]){ 0 });
		if (!builtin__fast_string_eq(*(string*)builtin__map_get(&b, k, &(string[]){_S("")}), v)) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__token__TrieNode_ptr_arr_eq(Array_v__token__TrieNode_ptr a, Array_v__token__TrieNode_ptr b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((v__token__TrieNode**)((byte*)a.data+(i*a.element_size))) != *((v__token__TrieNode**)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool v__token__KeywordsMatcherTrie_struct_eq(v__token__KeywordsMatcherTrie a, v__token__KeywordsMatcherTrie b) {
	return Array_v__token__TrieNode_ptr_arr_eq(a.nodes, b.nodes)
		&& a.min_len == b.min_len
		&& a.max_len == b.max_len;
}

inline bool v__errors__CallStackItem_struct_eq(v__errors__CallStackItem a, v__errors__CallStackItem b) {
	return (((a.file_path).len == (b.file_path).len && (a.file_path).len == 0) || builtin__fast_string_eq(a.file_path, b.file_path))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool Array_v__errors__CallStackItem_arr_eq(Array_v__errors__CallStackItem a, Array_v__errors__CallStackItem b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__errors__CallStackItem_struct_eq(((v__errors__CallStackItem*)a.data)[i], ((v__errors__CallStackItem*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__errors__CompilerMessage_struct_eq(v__errors__CompilerMessage a, v__errors__CompilerMessage b) {
	return (((a.message).len == (b.message).len && (a.message).len == 0) || builtin__fast_string_eq(a.message, b.message))
		&& (((a.details).len == (b.details).len && (a.details).len == 0) || builtin__fast_string_eq(a.details, b.details))
		&& (((a.file_path).len == (b.file_path).len && (a.file_path).len == 0) || builtin__fast_string_eq(a.file_path, b.file_path))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.reporter == b.reporter
		&& Array_v__errors__CallStackItem_arr_eq(a.call_stack, b.call_stack);
}

inline bool v__errors__Error_struct_eq(v__errors__Error a, v__errors__Error b) {
	return v__errors__CompilerMessage_struct_eq(a.CompilerMessage, b.CompilerMessage);
}

inline bool Array_v__errors__Error_arr_eq(Array_v__errors__Error a, Array_v__errors__Error b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__errors__Error_struct_eq(((v__errors__Error*)a.data)[i], ((v__errors__Error*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__errors__Warning_struct_eq(v__errors__Warning a, v__errors__Warning b) {
	return v__errors__CompilerMessage_struct_eq(a.CompilerMessage, b.CompilerMessage);
}

inline bool Array_v__errors__Warning_arr_eq(Array_v__errors__Warning a, Array_v__errors__Warning b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__errors__Warning_struct_eq(((v__errors__Warning*)a.data)[i], ((v__errors__Warning*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__errors__Notice_struct_eq(v__errors__Notice a, v__errors__Notice b) {
	return v__errors__CompilerMessage_struct_eq(a.CompilerMessage, b.CompilerMessage);
}

inline bool Array_v__errors__Notice_arr_eq(Array_v__errors__Notice a, Array_v__errors__Notice b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__errors__Notice_struct_eq(((v__errors__Notice*)a.data)[i], ((v__errors__Notice*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__ast__FnDecl_ptr_arr_eq(Array_v__ast__FnDecl_ptr a, Array_v__ast__FnDecl_ptr b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((v__ast__FnDecl**)((byte*)a.data+(i*a.element_size))) != *((v__ast__FnDecl**)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__TemplateLineInfo_struct_eq(v__ast__TemplateLineInfo a, v__ast__TemplateLineInfo b) {
	return (((a.tmpl_path).len == (b.tmpl_path).len && (a.tmpl_path).len == 0) || builtin__fast_string_eq(a.tmpl_path, b.tmpl_path))
		&& a.tmpl_line == b.tmpl_line;
}

inline bool Array_v__ast__TemplateLineInfo_arr_eq(Array_v__ast__TemplateLineInfo a, Array_v__ast__TemplateLineInfo b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__TemplateLineInfo_struct_eq(((v__ast__TemplateLineInfo*)a.data)[i], ((v__ast__TemplateLineInfo*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__File_struct_eq(v__ast__File a, v__ast__File b) {
	return a.nr_lines == b.nr_lines
		&& a.nr_bytes == b.nr_bytes
		&& a.nr_tokens == b.nr_tokens
		&& v__ast__Module_struct_eq(a.mod, b.mod)
		&& a.global_scope == b.global_scope
		&& a.is_test == b.is_test
		&& a.is_generated == b.is_generated
		&& a.is_translated == b.is_translated
		&& a.language == b.language
		&& a.idx == b.idx
		&& (((a.path).len == (b.path).len && (a.path).len == 0) || builtin__fast_string_eq(a.path, b.path))
		&& (((a.path_base).len == (b.path_base).len && (a.path_base).len == 0) || builtin__fast_string_eq(a.path_base, b.path_base))
		&& a.scope == b.scope
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Import_arr_eq(a.imports, b.imports)
		&& Array_string_arr_eq(a.auto_imports, b.auto_imports)
		&& Array_string_arr_eq(a.used_imports, b.used_imports)
		&& Array_string_arr_eq(a.implied_imports, b.implied_imports)
		&& Array_v__ast__EmbeddedFile_arr_eq(a.embedded_files, b.embedded_files)
		&& Map_string_string_map_eq(a.imported_symbols, b.imported_symbols)
		&& v__token__KeywordsMatcherTrie_struct_eq(a.imported_symbols_trie, b.imported_symbols_trie)
		&& Map_string_bool_map_eq(a.imported_symbols_used, b.imported_symbols_used)
		&& Array_v__errors__Error_arr_eq(a.errors, b.errors)
		&& Array_v__errors__Warning_arr_eq(a.warnings, b.warnings)
		&& Array_v__errors__Notice_arr_eq(a.notices, b.notices)
		&& Array_v__errors__CallStackItem_arr_eq(a.call_stack, b.call_stack)
		&& Array_v__ast__FnDecl_ptr_arr_eq(a.generic_fns, b.generic_fns)
		&& Array_string_arr_eq(a.global_labels, b.global_labels)
		&& Array_string_arr_eq(a.template_paths, b.template_paths)
		&& Array_v__ast__TemplateLineInfo_arr_eq(a.template_line_map, b.template_line_map)
		&& (((a.unique_prefix).len == (b.unique_prefix).len && (a.unique_prefix).len == 0) || builtin__fast_string_eq(a.unique_prefix, b.unique_prefix))
		&& a.is_parse_text == b.is_parse_text
		&& a.is_template_text == b.is_template_text;
}

inline bool v__ast__ComptimeCall_struct_eq(v__ast__ComptimeCall a, v__ast__ComptimeCall b) {
	return v__ast__File_struct_eq(a.veb_tmpl, b.veb_tmpl)
		&& v__ast__EmbeddedFile_struct_eq(a.embed_file, b.embed_file)
		&& v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& Array_v__ast__CallArg_arr_eq(a.args, b.args)
		&& (((a.method_name).len == (b.method_name).len && (a.method_name).len == 0) || builtin__fast_string_eq(a.method_name, b.method_name))
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& (((a.env_value).len == (b.env_value).len && (a.env_value).len == 0) || builtin__fast_string_eq(a.env_value, b.env_value))
		&& (((a.args_var).len == (b.args_var).len && (a.args_var).len == 0) || builtin__fast_string_eq(a.args_var, b.args_var))
		&& (((a.compile_value).len == (b.compile_value).len && (a.compile_value).len == 0) || builtin__fast_string_eq(a.compile_value, b.compile_value))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.method_pos, b.method_pos)
		&& v__token__Pos_struct_eq(a.env_pos, b.env_pos)
		&& a.result_type == b.result_type
		&& a.left_type == b.left_type
		&& a.kind == b.kind
		&& a.is_d_resolved == b.is_d_resolved
		&& a.is_veb == b.is_veb
		&& a.is_vweb == b.is_vweb
		&& a.has_parens == b.has_parens;
}

inline bool v__ast__ComptimeSelector_struct_eq(v__ast__ComptimeSelector a, v__ast__ComptimeSelector b) {
	return v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& v__ast__Expr_sumtype_eq(a.field_expr, b.field_expr)
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& (((a.typ_key).len == (b.typ_key).len && (a.typ_key).len == 0) || builtin__fast_string_eq(a.typ_key, b.typ_key))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.left_type == b.left_type
		&& a.typ == b.typ
		&& a.is_name == b.is_name
		&& a.has_parens == b.has_parens;
}

inline bool v__ast__ComptimeType_struct_eq(v__ast__ComptimeType a, v__ast__ComptimeType b) {
	return a.kind == b.kind
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__ConcatExpr_struct_eq(v__ast__ConcatExpr a, v__ast__ConcatExpr b) {
	return Array_v__ast__Expr_arr_eq(a.vals, b.vals)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.return_type == b.return_type;
}

inline bool v__ast__DumpExpr_struct_eq(v__ast__DumpExpr a, v__ast__DumpExpr b) {
	return v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& (((a.cname).len == (b.cname).len && (a.cname).len == 0) || builtin__fast_string_eq(a.cname, b.cname))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.expr_type == b.expr_type;
}

inline bool v__ast__EnumVal_struct_eq(v__ast__EnumVal a, v__ast__EnumVal b) {
	return (((a.enum_name).len == (b.enum_name).len && (a.enum_name).len == 0) || builtin__fast_string_eq(a.enum_name, b.enum_name))
		&& (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ;
}

inline bool v__ast__GoExpr_struct_eq(v__ast__GoExpr a, v__ast__GoExpr b) {
	return v__ast__CallExpr_struct_eq(a.call_expr, b.call_expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_expr == b.is_expr;
}

inline bool v__ast__IfBranch_struct_eq(v__ast__IfBranch a, v__ast__IfBranch b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.body_pos, b.body_pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.cond, b.cond)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& a.scope == b.scope
		&& a.id == b.id;
}

inline bool Array_v__ast__IfBranch_arr_eq(Array_v__ast__IfBranch a, Array_v__ast__IfBranch b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__IfBranch_struct_eq(((v__ast__IfBranch*)a.data)[i], ((v__ast__IfBranch*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__IfExpr_struct_eq(v__ast__IfExpr a, v__ast__IfExpr b) {
	return Array_v__ast__Comment_arr_eq(a.post_comments, b.post_comments)
		&& Array_v__ast__IfBranch_arr_eq(a.branches, b.branches)
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.tok_kind == b.tok_kind
		&& a.has_else == b.has_else
		&& a.is_expr == b.is_expr
		&& a.is_comptime == b.is_comptime;
}

inline bool v__ast__IfGuardVar_struct_eq(v__ast__IfGuardVar a, v__ast__IfGuardVar b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.is_mut == b.is_mut
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool Array_v__ast__IfGuardVar_arr_eq(Array_v__ast__IfGuardVar a, Array_v__ast__IfGuardVar b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__IfGuardVar_struct_eq(((v__ast__IfGuardVar*)a.data)[i], ((v__ast__IfGuardVar*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__IfGuardExpr_struct_eq(v__ast__IfGuardExpr a, v__ast__IfGuardExpr b) {
	return Array_v__ast__IfGuardVar_arr_eq(a.vars, b.vars)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.expr_type == b.expr_type;
}

inline bool v__ast__IndexExpr_struct_eq(v__ast__IndexExpr a, v__ast__IndexExpr b) {
	return v__ast__OrExpr_struct_eq(a.or_expr, b.or_expr)
		&& v__ast__Expr_sumtype_eq(a.index, b.index)
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.left_type == b.left_type
		&& a.is_map == b.is_map
		&& a.is_array == b.is_array
		&& a.is_farray == b.is_farray
		&& a.is_option == b.is_option
		&& a.is_direct == b.is_direct
		&& a.is_gated == b.is_gated
		&& a.is_setter == b.is_setter;
}

inline bool v__ast__InfixExpr_struct_eq(v__ast__InfixExpr a, v__ast__InfixExpr b) {
	return v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& Array_v__ast__Comment_arr_eq(a.after_op_comments, b.after_op_comments)
		&& Array_v__ast__Comment_arr_eq(a.before_op_comments, b.before_op_comments)
		&& v__ast__Expr_sumtype_eq(a.right, b.right)
		&& v__ast__ComptTimeConstValue_sumtype_eq(a.ct_right_value, b.ct_right_value)
		&& v__ast__ComptTimeConstValue_sumtype_eq(a.ct_left_value, b.ct_left_value)
		&& v__ast__Expr_sumtype_eq(a.left, b.left)
		&& (((a.auto_locked).len == (b.auto_locked).len && (a.auto_locked).len == 0) || builtin__fast_string_eq(a.auto_locked, b.auto_locked))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.left_type == b.left_type
		&& a.promoted_type == b.promoted_type
		&& a.right_type == b.right_type
		&& a.op == b.op
		&& a.is_stmt == b.is_stmt
		&& a.ct_left_value_evaled == b.ct_left_value_evaled
		&& a.left_ct_expr == b.left_ct_expr
		&& a.ct_right_value_evaled == b.ct_right_value_evaled
		&& a.right_ct_expr == b.right_ct_expr;
}

inline bool v__ast__IsRefType_struct_eq(v__ast__IsRefType a, v__ast__IsRefType b) {
	return a.guessed_type == b.guessed_type
		&& a.is_type == b.is_type
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.typ == b.typ;
}

inline bool v__ast__LambdaExpr_struct_eq(v__ast__LambdaExpr a, v__ast__LambdaExpr b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Ident_arr_eq(a.params, b.params)
		&& v__token__Pos_struct_eq(a.pos_expr, b.pos_expr)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& v__token__Pos_struct_eq(a.pos_end, b.pos_end)
		&& a.scope == b.scope
		&& a.func == b.func
		&& a.is_checked == b.is_checked
		&& a.typ == b.typ
		&& a.call_ctx == b.call_ctx;
}

inline bool v__ast__Likely_struct_eq(v__ast__Likely a, v__ast__Likely b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_likely == b.is_likely
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr);
}

inline bool Array_bool_arr_eq(Array_bool a, Array_bool b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((bool*)((byte*)a.data+(i*a.element_size))) != *((bool*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__LockExpr_struct_eq(v__ast__LockExpr a, v__ast__LockExpr b) {
	return Array_bool_arr_eq(a.is_rlock, b.is_rlock)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Expr_arr_eq(a.lockeds, b.lockeds)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& a.is_expr == b.is_expr
		&& a.typ == b.typ
		&& a.scope == b.scope;
}

inline bool v__ast__MapInit_struct_eq(v__ast__MapInit a, v__ast__MapInit b) {
	return Array_Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Comment_arr_eq(a.pre_cmnts, b.pre_cmnts)
		&& Array_v__ast__Expr_arr_eq(a.keys, b.keys)
		&& Array_v__ast__Expr_arr_eq(a.vals, b.vals)
		&& Array_v__ast__Type_arr_eq(a.val_types, b.val_types)
		&& Array_v__ast__Comment_arr_eq(a.update_expr_comments, b.update_expr_comments)
		&& v__ast__Expr_sumtype_eq(a.update_expr, b.update_expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.update_expr_pos, b.update_expr_pos)
		&& a.key_type == b.key_type
		&& a.typ == b.typ
		&& a.value_type == b.value_type
		&& a.has_update_expr == b.has_update_expr;
}

inline bool v__ast__MatchBranch_struct_eq(v__ast__MatchBranch a, v__ast__MatchBranch b) {
	return Array_Array_v__ast__Comment_arr_eq(a.ecmnts, b.ecmnts)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_else == b.is_else
		&& Array_v__ast__Comment_arr_eq(a.post_comments, b.post_comments)
		&& v__token__Pos_struct_eq(a.branch_pos, b.branch_pos)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Expr_arr_eq(a.exprs, b.exprs)
		&& a.scope == b.scope
		&& a.id == b.id
		&& a.is_comptime_err == b.is_comptime_err;
}

inline bool Array_v__ast__MatchBranch_arr_eq(Array_v__ast__MatchBranch a, Array_v__ast__MatchBranch b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__MatchBranch_struct_eq(((v__ast__MatchBranch*)a.data)[i], ((v__ast__MatchBranch*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__MatchExpr_struct_eq(v__ast__MatchExpr a, v__ast__MatchExpr b) {
	return Array_v__ast__MatchBranch_arr_eq(a.branches, b.branches)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.cond, b.cond)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.return_type == b.return_type
		&& a.expected_type == b.expected_type
		&& a.cond_type == b.cond_type
		&& a.tok_kind == b.tok_kind
		&& a.is_sum_type == b.is_sum_type
		&& a.is_expr == b.is_expr
		&& a.is_comptime == b.is_comptime;
}

inline bool v__ast__Nil_struct_eq(v__ast__Nil a, v__ast__Nil b) {
	return v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__None_struct_eq(v__ast__None a, v__ast__None b) {
	return v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__OffsetOf_struct_eq(v__ast__OffsetOf a, v__ast__OffsetOf b) {
	return (((a.field).len == (b.field).len && (a.field).len == 0) || builtin__fast_string_eq(a.field, b.field))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.struct_type == b.struct_type;
}

inline bool v__ast__ParExpr_struct_eq(v__ast__ParExpr a, v__ast__ParExpr b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments);
}

inline bool v__ast__PostfixExpr_struct_eq(v__ast__PostfixExpr a, v__ast__PostfixExpr b) {
	return a.op == b.op
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_c2v_prefix == b.is_c2v_prefix
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.typ == b.typ
		&& (((a.auto_locked).len == (b.auto_locked).len && (a.auto_locked).len == 0) || builtin__fast_string_eq(a.auto_locked, b.auto_locked));
}

inline bool v__ast__PrefixExpr_struct_eq(v__ast__PrefixExpr a, v__ast__PrefixExpr b) {
	return v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& v__ast__Expr_sumtype_eq(a.right, b.right)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.right_type == b.right_type
		&& a.op == b.op
		&& a.is_option == b.is_option;
}

inline bool v__ast__RangeExpr_struct_eq(v__ast__RangeExpr a, v__ast__RangeExpr b) {
	return v__ast__Expr_sumtype_eq(a.low, b.low)
		&& v__ast__Expr_sumtype_eq(a.high, b.high)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.has_high == b.has_high
		&& a.has_low == b.has_low
		&& a.is_gated == b.is_gated;
}

inline bool v__ast__SelectBranch_struct_eq(v__ast__SelectBranch a, v__ast__SelectBranch b) {
	return v__ast__Comment_struct_eq(a.comment, b.comment)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Comment_arr_eq(a.post_comments, b.post_comments)
		&& v__ast__Stmt_sumtype_eq(a.stmt, b.stmt)
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_timeout == b.is_timeout
		&& a.is_else == b.is_else;
}

inline bool Array_v__ast__SelectBranch_arr_eq(Array_v__ast__SelectBranch a, Array_v__ast__SelectBranch b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__SelectBranch_struct_eq(((v__ast__SelectBranch*)a.data)[i], ((v__ast__SelectBranch*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__SelectExpr_struct_eq(v__ast__SelectExpr a, v__ast__SelectExpr b) {
	return Array_v__ast__SelectBranch_arr_eq(a.branches, b.branches)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.has_exception == b.has_exception
		&& a.is_expr == b.is_expr
		&& a.expected_type == b.expected_type;
}

inline bool Array_Array_v__ast__Type_arr_eq(Array_Array_v__ast__Type a, Array_Array_v__ast__Type b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!Array_v__ast__Type_arr_eq(((Array_v__ast__Type*)a.data)[i], ((Array_v__ast__Type*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__SelectorExpr_struct_eq(v__ast__SelectorExpr a, v__ast__SelectorExpr b) {
	return v__ast__OrExpr_struct_eq(a.or_block, b.or_block)
		&& Array_Array_v__ast__Type_arr_eq(a.generic_from_embed_types, b.generic_from_embed_types)
		&& Array_v__ast__Type_arr_eq(a.from_embed_types, b.from_embed_types)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& (((a.field_name).len == (b.field_name).len && (a.field_name).len == 0) || builtin__fast_string_eq(a.field_name, b.field_name))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.mut_pos, b.mut_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.name_type == b.name_type
		&& a.expr_type == b.expr_type
		&& a.typ == b.typ
		&& a.next_token == b.next_token
		&& a.gkind_field == b.gkind_field
		&& a.is_mut == b.is_mut
		&& a.has_hidden_receiver == b.has_hidden_receiver
		&& a.is_field_typ == b.is_field_typ;
}

inline bool v__ast__SizeOf_struct_eq(v__ast__SizeOf a, v__ast__SizeOf b) {
	return a.guessed_type == b.guessed_type
		&& a.is_type == b.is_type
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.typ == b.typ;
}

inline bool v__ast__SpawnExpr_struct_eq(v__ast__SpawnExpr a, v__ast__SpawnExpr b) {
	return v__ast__CallExpr_struct_eq(a.call_expr, b.call_expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_expr == b.is_expr;
}

inline bool Map_int_v__ast__SqlExpr_map_eq(Map_int_v__ast__SqlExpr a, Map_int_v__ast__SqlExpr b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = builtin__DenseArray_key(&a.key_values, i);
		if (!builtin__map_exists(&b, k)) return false;
		v__ast__SqlExpr v = *(v__ast__SqlExpr*)builtin__map_get(&a, k, &(v__ast__SqlExpr[]){ 0 });
		if (!v__ast__SqlExpr_struct_eq(*(v__ast__SqlExpr*)builtin__map_get(&b, k, &(v__ast__SqlExpr[]){ 0 }), v)) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__JoinClause_struct_eq(v__ast__JoinClause a, v__ast__JoinClause b) {
	return a.kind == b.kind
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__TypeNode_struct_eq(a.table_expr, b.table_expr)
		&& v__ast__Expr_sumtype_eq(a.on_expr, b.on_expr);
}

inline bool Array_v__ast__JoinClause_arr_eq(Array_v__ast__JoinClause a, Array_v__ast__JoinClause b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__JoinClause_struct_eq(((v__ast__JoinClause*)a.data)[i], ((v__ast__JoinClause*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__SqlExpr_struct_eq(v__ast__SqlExpr a, v__ast__SqlExpr b) {
	return a.is_count == b.is_count
		&& a.is_insert == b.is_insert
		&& (((a.inserted_var).len == (b.inserted_var).len && (a.inserted_var).len == 0) || builtin__fast_string_eq(a.inserted_var, b.inserted_var))
		&& a.has_where == b.has_where
		&& a.has_order == b.has_order
		&& a.has_limit == b.has_limit
		&& a.has_offset == b.has_offset
		&& a.has_desc == b.has_desc
		&& a.has_distinct == b.has_distinct
		&& a.is_array == b.is_array
		&& a.is_generated == b.is_generated
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& v__ast__Expr_sumtype_eq(a.db_expr, b.db_expr)
		&& v__ast__Expr_sumtype_eq(a.where_expr, b.where_expr)
		&& v__ast__Expr_sumtype_eq(a.order_expr, b.order_expr)
		&& v__ast__Expr_sumtype_eq(a.limit_expr, b.limit_expr)
		&& v__ast__Expr_sumtype_eq(a.offset_expr, b.offset_expr)
		&& v__ast__TypeNode_struct_eq(a.table_expr, b.table_expr)
		&& Array_v__ast__StructField_arr_eq(a.fields, b.fields)
		&& Map_int_v__ast__SqlExpr_map_eq(a.sub_structs, b.sub_structs)
		&& v__ast__OrExpr_struct_eq(a.or_expr, b.or_expr)
		&& Array_v__ast__JoinClause_arr_eq(a.joins, b.joins);
}

inline bool Array_int_arr_eq(Array_int a, Array_int b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((int*)((byte*)a.data+(i*a.element_size))) != *((int*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__token__Pos_arr_eq(Array_v__token__Pos a, Array_v__token__Pos b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__token__Pos_struct_eq(((v__token__Pos*)a.data)[i], ((v__token__Pos*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__StringInterLiteral_struct_eq(v__ast__StringInterLiteral a, v__ast__StringInterLiteral b) {
	return Array_string_arr_eq(a.vals, b.vals)
		&& Array_int_arr_eq(a.fwidths, b.fwidths)
		&& Array_int_arr_eq(a.precisions, b.precisions)
		&& Array_bool_arr_eq(a.pluss, b.pluss)
		&& Array_bool_arr_eq(a.fills, b.fills)
		&& Array_v__token__Pos_arr_eq(a.fmt_poss, b.fmt_poss)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Expr_arr_eq(a.exprs, b.exprs)
		&& Array_v__ast__Type_arr_eq(a.expr_types, b.expr_types)
		&& Array_u8_arr_eq(a.fmts, b.fmts)
		&& Array_bool_arr_eq(a.need_fmts, b.need_fmts);
}

inline bool v__ast__StringLiteral_struct_eq(v__ast__StringLiteral a, v__ast__StringLiteral b) {
	return (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.language == b.language
		&& a.is_raw == b.is_raw;
}

inline bool v__ast__StructInitField_struct_eq(v__ast__StructInitField a, v__ast__StructInitField b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& Array_v__ast__Comment_arr_eq(a.next_comments, b.next_comments)
		&& a.has_prev_newline == b.has_prev_newline
		&& a.has_break_line == b.has_break_line
		&& a.is_embed == b.is_embed
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.typ == b.typ
		&& a.expected_type == b.expected_type
		&& a.parent_type == b.parent_type;
}

inline bool Array_v__ast__StructInitField_arr_eq(Array_v__ast__StructInitField a, Array_v__ast__StructInitField b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__StructInitField_struct_eq(((v__ast__StructInitField*)a.data)[i], ((v__ast__StructInitField*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__StructInit_struct_eq(v__ast__StructInit a, v__ast__StructInit b) {
	return Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Type_arr_eq(a.generic_types, b.generic_types)
		&& Array_v__ast__StructInitField_arr_eq(a.init_fields, b.init_fields)
		&& Array_v__ast__Comment_arr_eq(a.update_expr_comments, b.update_expr_comments)
		&& (((a.typ_str).len == (b.typ_str).len && (a.typ_str).len == 0) || builtin__fast_string_eq(a.typ_str, b.typ_str))
		&& v__ast__Expr_sumtype_eq(a.update_expr, b.update_expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& v__token__Pos_struct_eq(a.update_expr_pos, b.update_expr_pos)
		&& a.update_expr_type == b.update_expr_type
		&& a.typ == b.typ
		&& a.language == b.language
		&& a.has_update_expr == b.has_update_expr
		&& a.is_short_syntax == b.is_short_syntax
		&& a.no_keys == b.no_keys
		&& a.is_update_embed == b.is_update_embed
		&& a.is_anon == b.is_anon
		&& a.unresolved == b.unresolved;
}

inline bool v__ast__TypeOf_struct_eq(v__ast__TypeOf a, v__ast__TypeOf b) {
	return v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.is_type == b.is_type;
}

inline bool v__ast__UnsafeExpr_struct_eq(v__ast__UnsafeExpr a, v__ast__UnsafeExpr b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr);
}

inline bool v__ast__Expr_sumtype_eq(v__ast__Expr a, v__ast__Expr b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 258) {
		return v__ast__NodeError_struct_eq(*a._v__ast__NodeError, *b._v__ast__NodeError);
	}
	if (a._typ == 259) {
		return v__ast__AnonFn_struct_eq(*a._v__ast__AnonFn, *b._v__ast__AnonFn);
	}
	if (a._typ == 260) {
		return v__ast__ArrayDecompose_struct_eq(*a._v__ast__ArrayDecompose, *b._v__ast__ArrayDecompose);
	}
	if (a._typ == 261) {
		return v__ast__ArrayInit_struct_eq(*a._v__ast__ArrayInit, *b._v__ast__ArrayInit);
	}
	if (a._typ == 262) {
		return v__ast__AsCast_struct_eq(*a._v__ast__AsCast, *b._v__ast__AsCast);
	}
	if (a._typ == 263) {
		return v__ast__Assoc_struct_eq(*a._v__ast__Assoc, *b._v__ast__Assoc);
	}
	if (a._typ == 264) {
		return v__ast__AtExpr_struct_eq(*a._v__ast__AtExpr, *b._v__ast__AtExpr);
	}
	if (a._typ == 265) {
		return v__ast__BoolLiteral_struct_eq(*a._v__ast__BoolLiteral, *b._v__ast__BoolLiteral);
	}
	if (a._typ == 266) {
		return v__ast__CTempVar_struct_eq(*a._v__ast__CTempVar, *b._v__ast__CTempVar);
	}
	if (a._typ == 267) {
		return v__ast__CallExpr_struct_eq(*a._v__ast__CallExpr, *b._v__ast__CallExpr);
	}
	if (a._typ == 268) {
		return v__ast__CastExpr_struct_eq(*a._v__ast__CastExpr, *b._v__ast__CastExpr);
	}
	if (a._typ == 269) {
		return v__ast__ChanInit_struct_eq(*a._v__ast__ChanInit, *b._v__ast__ChanInit);
	}
	if (a._typ == 270) {
		return v__ast__CharLiteral_struct_eq(*a._v__ast__CharLiteral, *b._v__ast__CharLiteral);
	}
	if (a._typ == 271) {
		return v__ast__Comment_struct_eq(*a._v__ast__Comment, *b._v__ast__Comment);
	}
	if (a._typ == 272) {
		return v__ast__ComptimeCall_struct_eq(*a._v__ast__ComptimeCall, *b._v__ast__ComptimeCall);
	}
	if (a._typ == 273) {
		return v__ast__ComptimeSelector_struct_eq(*a._v__ast__ComptimeSelector, *b._v__ast__ComptimeSelector);
	}
	if (a._typ == 274) {
		return v__ast__ComptimeType_struct_eq(*a._v__ast__ComptimeType, *b._v__ast__ComptimeType);
	}
	if (a._typ == 275) {
		return v__ast__ConcatExpr_struct_eq(*a._v__ast__ConcatExpr, *b._v__ast__ConcatExpr);
	}
	if (a._typ == 276) {
		return v__ast__DumpExpr_struct_eq(*a._v__ast__DumpExpr, *b._v__ast__DumpExpr);
	}
	if (a._typ == 277) {
		return v__ast__EmptyExpr_alias_eq(*a._v__ast__EmptyExpr, *b._v__ast__EmptyExpr);
	}
	if (a._typ == 278) {
		return v__ast__EnumVal_struct_eq(*a._v__ast__EnumVal, *b._v__ast__EnumVal);
	}
	if (a._typ == 279) {
		return v__ast__FloatLiteral_struct_eq(*a._v__ast__FloatLiteral, *b._v__ast__FloatLiteral);
	}
	if (a._typ == 280) {
		return v__ast__GoExpr_struct_eq(*a._v__ast__GoExpr, *b._v__ast__GoExpr);
	}
	if (a._typ == 281) {
		return v__ast__Ident_struct_eq(*a._v__ast__Ident, *b._v__ast__Ident);
	}
	if (a._typ == 282) {
		return v__ast__IfExpr_struct_eq(*a._v__ast__IfExpr, *b._v__ast__IfExpr);
	}
	if (a._typ == 283) {
		return v__ast__IfGuardExpr_struct_eq(*a._v__ast__IfGuardExpr, *b._v__ast__IfGuardExpr);
	}
	if (a._typ == 284) {
		return v__ast__IndexExpr_struct_eq(*a._v__ast__IndexExpr, *b._v__ast__IndexExpr);
	}
	if (a._typ == 285) {
		return v__ast__InfixExpr_struct_eq(*a._v__ast__InfixExpr, *b._v__ast__InfixExpr);
	}
	if (a._typ == 286) {
		return v__ast__IntegerLiteral_struct_eq(*a._v__ast__IntegerLiteral, *b._v__ast__IntegerLiteral);
	}
	if (a._typ == 287) {
		return v__ast__IsRefType_struct_eq(*a._v__ast__IsRefType, *b._v__ast__IsRefType);
	}
	if (a._typ == 288) {
		return v__ast__LambdaExpr_struct_eq(*a._v__ast__LambdaExpr, *b._v__ast__LambdaExpr);
	}
	if (a._typ == 289) {
		return v__ast__Likely_struct_eq(*a._v__ast__Likely, *b._v__ast__Likely);
	}
	if (a._typ == 290) {
		return v__ast__LockExpr_struct_eq(*a._v__ast__LockExpr, *b._v__ast__LockExpr);
	}
	if (a._typ == 291) {
		return v__ast__MapInit_struct_eq(*a._v__ast__MapInit, *b._v__ast__MapInit);
	}
	if (a._typ == 292) {
		return v__ast__MatchExpr_struct_eq(*a._v__ast__MatchExpr, *b._v__ast__MatchExpr);
	}
	if (a._typ == 293) {
		return v__ast__Nil_struct_eq(*a._v__ast__Nil, *b._v__ast__Nil);
	}
	if (a._typ == 294) {
		return v__ast__None_struct_eq(*a._v__ast__None, *b._v__ast__None);
	}
	if (a._typ == 295) {
		return v__ast__OffsetOf_struct_eq(*a._v__ast__OffsetOf, *b._v__ast__OffsetOf);
	}
	if (a._typ == 296) {
		return v__ast__OrExpr_struct_eq(*a._v__ast__OrExpr, *b._v__ast__OrExpr);
	}
	if (a._typ == 297) {
		return v__ast__ParExpr_struct_eq(*a._v__ast__ParExpr, *b._v__ast__ParExpr);
	}
	if (a._typ == 298) {
		return v__ast__PostfixExpr_struct_eq(*a._v__ast__PostfixExpr, *b._v__ast__PostfixExpr);
	}
	if (a._typ == 299) {
		return v__ast__PrefixExpr_struct_eq(*a._v__ast__PrefixExpr, *b._v__ast__PrefixExpr);
	}
	if (a._typ == 300) {
		return v__ast__RangeExpr_struct_eq(*a._v__ast__RangeExpr, *b._v__ast__RangeExpr);
	}
	if (a._typ == 301) {
		return v__ast__SelectExpr_struct_eq(*a._v__ast__SelectExpr, *b._v__ast__SelectExpr);
	}
	if (a._typ == 302) {
		return v__ast__SelectorExpr_struct_eq(*a._v__ast__SelectorExpr, *b._v__ast__SelectorExpr);
	}
	if (a._typ == 303) {
		return v__ast__SizeOf_struct_eq(*a._v__ast__SizeOf, *b._v__ast__SizeOf);
	}
	if (a._typ == 304) {
		return v__ast__SpawnExpr_struct_eq(*a._v__ast__SpawnExpr, *b._v__ast__SpawnExpr);
	}
	if (a._typ == 305) {
		return v__ast__SqlExpr_struct_eq(*a._v__ast__SqlExpr, *b._v__ast__SqlExpr);
	}
	if (a._typ == 306) {
		return v__ast__StringInterLiteral_struct_eq(*a._v__ast__StringInterLiteral, *b._v__ast__StringInterLiteral);
	}
	if (a._typ == 237) {
		return v__ast__StringLiteral_struct_eq(*a._v__ast__StringLiteral, *b._v__ast__StringLiteral);
	}
	if (a._typ == 236) {
		return v__ast__StructInit_struct_eq(*a._v__ast__StructInit, *b._v__ast__StructInit);
	}
	if (a._typ == 307) {
		return v__ast__TypeNode_struct_eq(*a._v__ast__TypeNode, *b._v__ast__TypeNode);
	}
	if (a._typ == 308) {
		return v__ast__TypeOf_struct_eq(*a._v__ast__TypeOf, *b._v__ast__TypeOf);
	}
	if (a._typ == 309) {
		return v__ast__UnsafeExpr_struct_eq(*a._v__ast__UnsafeExpr, *b._v__ast__UnsafeExpr);
	}
	return false;
}

inline bool v__ast__AsmIO_struct_eq(v__ast__AsmIO a, v__ast__AsmIO b) {
	return (((a.alias).len == (b.alias).len && (a.alias).len == 0) || builtin__fast_string_eq(a.alias, b.alias))
		&& (((a.constraint).len == (b.constraint).len && (a.constraint).len == 0) || builtin__fast_string_eq(a.constraint, b.constraint))
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr);
}

inline bool Array_v__ast__AsmIO_arr_eq(Array_v__ast__AsmIO a, Array_v__ast__AsmIO b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__AsmIO_struct_eq(((v__ast__AsmIO*)a.data)[i], ((v__ast__AsmIO*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__AsmStmt_struct_eq(v__ast__AsmStmt a, v__ast__AsmStmt b) {
	return Array_string_arr_eq(a.local_labels, b.local_labels)
		&& Array_v__ast__AsmClobbered_arr_eq(a.clobbered, b.clobbered)
		&& Array_v__ast__AsmTemplate_arr_eq(a.templates, b.templates)
		&& Array_v__ast__AsmIO_arr_eq(a.output, b.output)
		&& Array_v__ast__AsmIO_arr_eq(a.input, b.input)
		&& Array_string_arr_eq(a.global_labels, b.global_labels)
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.arch == b.arch
		&& a.is_basic == b.is_basic
		&& a.is_volatile == b.is_volatile
		&& a.is_goto == b.is_goto;
}

inline bool v__ast__AssertStmt_struct_eq(v__ast__AssertStmt a, v__ast__AssertStmt b) {
	return v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& v__ast__Expr_sumtype_eq(a.extra, b.extra)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.extra_pos, b.extra_pos)
		&& a.is_used == b.is_used;
}

inline bool v__ast__AssignStmt_struct_eq(v__ast__AssignStmt a, v__ast__AssignStmt b) {
	return v__ast__Attr_struct_eq(a.attr, b.attr)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& Array_v__ast__Expr_arr_eq(a.right, b.right)
		&& Array_v__ast__Expr_arr_eq(a.left, b.left)
		&& Array_v__ast__Type_arr_eq(a.left_types, b.left_types)
		&& Array_v__ast__Type_arr_eq(a.right_types, b.right_types)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.op == b.op
		&& a.is_static == b.is_static
		&& a.is_volatile == b.is_volatile
		&& a.is_simple == b.is_simple
		&& a.has_cross_var == b.has_cross_var;
}

inline bool v__ast__Block_struct_eq(v__ast__Block a, v__ast__Block b) {
	return a.is_unsafe == b.is_unsafe
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.scope == b.scope
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts);
}

inline bool v__ast__BranchStmt_struct_eq(v__ast__BranchStmt a, v__ast__BranchStmt b) {
	return (((a.label).len == (b.label).len && (a.label).len == 0) || builtin__fast_string_eq(a.label, b.label))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.kind == b.kind;
}

inline bool v__ast__ComptimeFor_struct_eq(v__ast__ComptimeFor a, v__ast__ComptimeFor b) {
	return (((a.val_var).len == (b.val_var).len && (a.val_var).len == 0) || builtin__fast_string_eq(a.val_var, b.val_var))
		&& a.kind == b.kind
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.typ_pos, b.typ_pos)
		&& a.scope == b.scope
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& a.typ == b.typ
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr);
}

inline bool Array_v__ast__ConstField_arr_eq(Array_v__ast__ConstField a, Array_v__ast__ConstField b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__ConstField_struct_eq(((v__ast__ConstField*)a.data)[i], ((v__ast__ConstField*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__ConstDecl_struct_eq(v__ast__ConstDecl a, v__ast__ConstDecl b) {
	return Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__ConstField_arr_eq(a.fields, b.fields)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_pub == b.is_pub
		&& a.is_block == b.is_block;
}

inline bool v__ast__DebuggerStmt_struct_eq(v__ast__DebuggerStmt a, v__ast__DebuggerStmt b) {
	return v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__EmptyStmt_struct_eq(v__ast__EmptyStmt a, v__ast__EmptyStmt b) {
	return v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__EnumField_struct_eq(v__ast__EnumField a, v__ast__EnumField b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.source_name).len == (b.source_name).len && (a.source_name).len == 0) || builtin__fast_string_eq(a.source_name, b.source_name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Comment_arr_eq(a.next_comments, b.next_comments)
		&& a.has_expr == b.has_expr
		&& a.has_prev_newline == b.has_prev_newline
		&& a.has_break_line == b.has_break_line
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr);
}

inline bool Array_v__ast__EnumField_arr_eq(Array_v__ast__EnumField a, Array_v__ast__EnumField b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__EnumField_struct_eq(((v__ast__EnumField*)a.data)[i], ((v__ast__EnumField*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__EnumDecl_struct_eq(v__ast__EnumDecl a, v__ast__EnumDecl b) {
	return Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__EnumField_arr_eq(a.fields, b.fields)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.typ_pos, b.typ_pos)
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.typ == b.typ
		&& a.enum_typ == b.enum_typ
		&& a.is_multi_allowed == b.is_multi_allowed
		&& a.is_flag == b.is_flag
		&& a.is_pub == b.is_pub;
}

inline bool v__ast__ExprStmt_struct_eq(v__ast__ExprStmt a, v__ast__ExprStmt b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.expr, b.expr)
		&& a.is_expr == b.is_expr
		&& a.typ == b.typ;
}

inline bool v__ast__ForCStmt_struct_eq(v__ast__ForCStmt a, v__ast__ForCStmt b) {
	return a.has_init == b.has_init
		&& a.has_cond == b.has_cond
		&& a.has_inc == b.has_inc
		&& a.is_multi == b.is_multi
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Stmt_sumtype_eq(a.init, b.init)
		&& v__ast__Expr_sumtype_eq(a.cond, b.cond)
		&& v__ast__Stmt_sumtype_eq(a.inc, b.inc)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& (((a.label).len == (b.label).len && (a.label).len == 0) || builtin__fast_string_eq(a.label, b.label))
		&& a.scope == b.scope;
}

inline bool v__ast__ForInStmt_struct_eq(v__ast__ForInStmt a, v__ast__ForInStmt b) {
	return Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.cond, b.cond)
		&& (((a.val_var).len == (b.val_var).len && (a.val_var).len == 0) || builtin__fast_string_eq(a.val_var, b.val_var))
		&& (((a.key_var).len == (b.key_var).len && (a.key_var).len == 0) || builtin__fast_string_eq(a.key_var, b.key_var))
		&& v__ast__Expr_sumtype_eq(a.high, b.high)
		&& (((a.label).len == (b.label).len && (a.label).len == 0) || builtin__fast_string_eq(a.label, b.label))
		&& a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.kv_pos, b.kv_pos)
		&& v__token__Pos_struct_eq(a.vv_pos, b.vv_pos)
		&& a.val_type == b.val_type
		&& a.cond_type == b.cond_type
		&& a.high_type == b.high_type
		&& a.key_type == b.key_type
		&& a.kind == b.kind
		&& a.val_is_mut == b.val_is_mut
		&& a.val_is_ref == b.val_is_ref
		&& a.is_range == b.is_range;
}

inline bool v__ast__ForStmt_struct_eq(v__ast__ForStmt a, v__ast__ForStmt b) {
	return a.is_inf == b.is_inf
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& v__ast__Expr_sumtype_eq(a.cond, b.cond)
		&& Array_v__ast__Stmt_arr_eq(a.stmts, b.stmts)
		&& (((a.label).len == (b.label).len && (a.label).len == 0) || builtin__fast_string_eq(a.label, b.label))
		&& a.scope == b.scope;
}

inline bool Array_v__ast__GlobalField_arr_eq(Array_v__ast__GlobalField a, Array_v__ast__GlobalField b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__GlobalField_struct_eq(((v__ast__GlobalField*)a.data)[i], ((v__ast__GlobalField*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__GlobalDecl_struct_eq(v__ast__GlobalDecl a, v__ast__GlobalDecl b) {
	return (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_block == b.is_block
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__GlobalField_arr_eq(a.fields, b.fields)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments);
}

inline bool v__ast__GotoLabel_struct_eq(v__ast__GotoLabel a, v__ast__GotoLabel b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_used == b.is_used;
}

inline bool v__ast__GotoStmt_struct_eq(v__ast__GotoStmt a, v__ast__GotoStmt b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool v__ast__HashStmt_struct_eq(v__ast__HashStmt a, v__ast__HashStmt b) {
	return (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& (((a.source_file).len == (b.source_file).len && (a.source_file).len == 0) || builtin__fast_string_eq(a.source_file, b.source_file))
		&& a.is_use_once == b.is_use_once
		&& (((a.val).len == (b.val).len && (a.val).len == 0) || builtin__fast_string_eq(a.val, b.val))
		&& (((a.kind).len == (b.kind).len && (a.kind).len == 0) || builtin__fast_string_eq(a.kind, b.kind))
		&& (((a.main).len == (b.main).len && (a.main).len == 0) || builtin__fast_string_eq(a.main, b.main))
		&& (((a.msg).len == (b.msg).len && (a.msg).len == 0) || builtin__fast_string_eq(a.msg, b.msg))
		&& Array_v__ast__Expr_arr_eq(a.ct_conds, b.ct_conds)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs);
}

inline bool v__ast__InterfaceEmbedding_struct_eq(v__ast__InterfaceEmbedding a, v__ast__InterfaceEmbedding b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments);
}

inline bool Array_v__ast__InterfaceEmbedding_arr_eq(Array_v__ast__InterfaceEmbedding a, Array_v__ast__InterfaceEmbedding b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__InterfaceEmbedding_struct_eq(((v__ast__InterfaceEmbedding*)a.data)[i], ((v__ast__InterfaceEmbedding*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool Array_v__ast__FnDecl_arr_eq(Array_v__ast__FnDecl a, Array_v__ast__FnDecl b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__FnDecl_struct_eq(((v__ast__FnDecl*)a.data)[i], ((v__ast__FnDecl*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__InterfaceDecl_struct_eq(v__ast__InterfaceDecl a, v__ast__InterfaceDecl b) {
	return Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Type_arr_eq(a.generic_types, b.generic_types)
		&& Array_v__ast__InterfaceEmbedding_arr_eq(a.embeds, b.embeds)
		&& Array_v__ast__StructField_arr_eq(a.fields, b.fields)
		&& Array_string_arr_eq(a.field_names, b.field_names)
		&& Array_v__ast__FnDecl_arr_eq(a.methods, b.methods)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& a.mut_pos == b.mut_pos
		&& a.typ == b.typ
		&& a.language == b.language
		&& a.is_pub == b.is_pub
		&& a.are_embeds_expanded == b.are_embeds_expanded;
}

inline bool v__ast__Return_struct_eq(v__ast__Return a, v__ast__Return b) {
	return a.scope == b.scope
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Expr_arr_eq(a.exprs, b.exprs)
		&& Array_v__ast__Type_arr_eq(a.types, b.types);
}

inline bool v__ast__SemicolonStmt_struct_eq(v__ast__SemicolonStmt a, v__ast__SemicolonStmt b) {
	return v__token__Pos_struct_eq(a.pos, b.pos);
}

inline bool Map_int_v__ast__SqlStmtLine_map_eq(Map_int_v__ast__SqlStmtLine a, Map_int_v__ast__SqlStmtLine b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = builtin__DenseArray_key(&a.key_values, i);
		if (!builtin__map_exists(&b, k)) return false;
		v__ast__SqlStmtLine v = *(v__ast__SqlStmtLine*)builtin__map_get(&a, k, &(v__ast__SqlStmtLine[]){ 0 });
		if (!v__ast__SqlStmtLine_struct_eq(*(v__ast__SqlStmtLine*)builtin__map_get(&b, k, &(v__ast__SqlStmtLine[]){ 0 }), v)) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__SqlStmtLine_struct_eq(v__ast__SqlStmtLine a, v__ast__SqlStmtLine b) {
	return a.kind == b.kind
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& a.is_generated == b.is_generated
		&& a.scope == b.scope
		&& (((a.object_var).len == (b.object_var).len && (a.object_var).len == 0) || builtin__fast_string_eq(a.object_var, b.object_var))
		&& Array_string_arr_eq(a.updated_columns, b.updated_columns)
		&& v__ast__TypeNode_struct_eq(a.table_expr, b.table_expr)
		&& Array_v__ast__StructField_arr_eq(a.fields, b.fields)
		&& Map_int_v__ast__SqlStmtLine_map_eq(a.sub_structs, b.sub_structs)
		&& v__ast__Expr_sumtype_eq(a.where_expr, b.where_expr)
		&& Array_v__ast__Expr_arr_eq(a.update_exprs, b.update_exprs)
		&& Array_v__ast__Comment_arr_eq(a.pre_comments, b.pre_comments)
		&& Array_v__ast__Comment_arr_eq(a.end_comments, b.end_comments);
}

inline bool Array_v__ast__SqlStmtLine_arr_eq(Array_v__ast__SqlStmtLine a, Array_v__ast__SqlStmtLine b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (!v__ast__SqlStmtLine_struct_eq(((v__ast__SqlStmtLine*)a.data)[i], ((v__ast__SqlStmtLine*)b.data)[i])) {
			return false;
		}
	}
	return true;
}

inline bool v__ast__SqlStmt_struct_eq(v__ast__SqlStmt a, v__ast__SqlStmt b) {
	return v__token__Pos_struct_eq(a.pos, b.pos)
		&& Array_v__ast__SqlStmtLine_arr_eq(a.lines, b.lines)
		&& v__ast__Expr_sumtype_eq(a.db_expr, b.db_expr)
		&& v__ast__OrExpr_struct_eq(a.or_expr, b.or_expr)
		&& a.db_expr_type == b.db_expr_type;
}

inline bool v__ast__AliasTypeDecl_struct_eq(v__ast__AliasTypeDecl a, v__ast__AliasTypeDecl b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& a.is_pub == b.is_pub
		&& a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.type_pos, b.type_pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& a.parent_type == b.parent_type
		&& a.is_markused == b.is_markused;
}

inline bool v__ast__FnTypeDecl_struct_eq(v__ast__FnTypeDecl a, v__ast__FnTypeDecl b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& a.is_pub == b.is_pub
		&& a.typ == b.typ
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.type_pos, b.type_pos)
		&& Array_v__ast__Comment_arr_eq(a.comments, b.comments)
		&& Array_v__ast__Type_arr_eq(a.generic_types, b.generic_types)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& a.is_markused == b.is_markused;
}

inline bool v__ast__SumTypeDecl_struct_eq(v__ast__SumTypeDecl a, v__ast__SumTypeDecl b) {
	return (((a.name).len == (b.name).len && (a.name).len == 0) || builtin__fast_string_eq(a.name, b.name))
		&& (((a.mod).len == (b.mod).len && (a.mod).len == 0) || builtin__fast_string_eq(a.mod, b.mod))
		&& a.is_pub == b.is_pub
		&& v__token__Pos_struct_eq(a.pos, b.pos)
		&& v__token__Pos_struct_eq(a.name_pos, b.name_pos)
		&& a.typ == b.typ
		&& Array_v__ast__Type_arr_eq(a.generic_types, b.generic_types)
		&& Array_v__ast__Attr_arr_eq(a.attrs, b.attrs)
		&& Array_v__ast__TypeNode_arr_eq(a.variants, b.variants)
		&& a.is_markused == b.is_markused;
}

inline bool v__ast__TypeDecl_sumtype_eq(v__ast__TypeDecl a, v__ast__TypeDecl b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 254) {
		return v__ast__AliasTypeDecl_struct_eq(*a._v__ast__AliasTypeDecl, *b._v__ast__AliasTypeDecl);
	}
	if (a._typ == 255) {
		return v__ast__FnTypeDecl_struct_eq(*a._v__ast__FnTypeDecl, *b._v__ast__FnTypeDecl);
	}
	if (a._typ == 256) {
		return v__ast__SumTypeDecl_struct_eq(*a._v__ast__SumTypeDecl, *b._v__ast__SumTypeDecl);
	}
	return false;
}

inline bool v__ast__Stmt_sumtype_eq(v__ast__Stmt a, v__ast__Stmt b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == b._typ && b._typ == 0) { return true; } // uninitialized
	if (a._typ == 311) {
		return v__ast__AsmStmt_struct_eq(*a._v__ast__AsmStmt, *b._v__ast__AsmStmt);
	}
	if (a._typ == 312) {
		return v__ast__AssertStmt_struct_eq(*a._v__ast__AssertStmt, *b._v__ast__AssertStmt);
	}
	if (a._typ == 313) {
		return v__ast__AssignStmt_struct_eq(*a._v__ast__AssignStmt, *b._v__ast__AssignStmt);
	}
	if (a._typ == 314) {
		return v__ast__Block_struct_eq(*a._v__ast__Block, *b._v__ast__Block);
	}
	if (a._typ == 315) {
		return v__ast__BranchStmt_struct_eq(*a._v__ast__BranchStmt, *b._v__ast__BranchStmt);
	}
	if (a._typ == 316) {
		return v__ast__ComptimeFor_struct_eq(*a._v__ast__ComptimeFor, *b._v__ast__ComptimeFor);
	}
	if (a._typ == 231) {
		return v__ast__ConstDecl_struct_eq(*a._v__ast__ConstDecl, *b._v__ast__ConstDecl);
	}
	if (a._typ == 317) {
		return v__ast__DebuggerStmt_struct_eq(*a._v__ast__DebuggerStmt, *b._v__ast__DebuggerStmt);
	}
	if (a._typ == 318) {
		return v__ast__DeferStmt_struct_eq(*a._v__ast__DeferStmt, *b._v__ast__DeferStmt);
	}
	if (a._typ == 319) {
		return v__ast__EmptyStmt_struct_eq(*a._v__ast__EmptyStmt, *b._v__ast__EmptyStmt);
	}
	if (a._typ == 320) {
		return v__ast__EnumDecl_struct_eq(*a._v__ast__EnumDecl, *b._v__ast__EnumDecl);
	}
	if (a._typ == 321) {
		return v__ast__ExprStmt_struct_eq(*a._v__ast__ExprStmt, *b._v__ast__ExprStmt);
	}
	if (a._typ == 229) {
		return v__ast__FnDecl_struct_eq(*a._v__ast__FnDecl, *b._v__ast__FnDecl);
	}
	if (a._typ == 322) {
		return v__ast__ForCStmt_struct_eq(*a._v__ast__ForCStmt, *b._v__ast__ForCStmt);
	}
	if (a._typ == 323) {
		return v__ast__ForInStmt_struct_eq(*a._v__ast__ForInStmt, *b._v__ast__ForInStmt);
	}
	if (a._typ == 324) {
		return v__ast__ForStmt_struct_eq(*a._v__ast__ForStmt, *b._v__ast__ForStmt);
	}
	if (a._typ == 325) {
		return v__ast__GlobalDecl_struct_eq(*a._v__ast__GlobalDecl, *b._v__ast__GlobalDecl);
	}
	if (a._typ == 326) {
		return v__ast__GotoLabel_struct_eq(*a._v__ast__GotoLabel, *b._v__ast__GotoLabel);
	}
	if (a._typ == 327) {
		return v__ast__GotoStmt_struct_eq(*a._v__ast__GotoStmt, *b._v__ast__GotoStmt);
	}
	if (a._typ == 328) {
		return v__ast__HashStmt_struct_eq(*a._v__ast__HashStmt, *b._v__ast__HashStmt);
	}
	if (a._typ == 329) {
		return v__ast__Import_struct_eq(*a._v__ast__Import, *b._v__ast__Import);
	}
	if (a._typ == 330) {
		return v__ast__InterfaceDecl_struct_eq(*a._v__ast__InterfaceDecl, *b._v__ast__InterfaceDecl);
	}
	if (a._typ == 331) {
		return v__ast__Module_struct_eq(*a._v__ast__Module, *b._v__ast__Module);
	}
	if (a._typ == 258) {
		return v__ast__NodeError_struct_eq(*a._v__ast__NodeError, *b._v__ast__NodeError);
	}
	if (a._typ == 332) {
		return v__ast__Return_struct_eq(*a._v__ast__Return, *b._v__ast__Return);
	}
	if (a._typ == 333) {
		return v__ast__SemicolonStmt_struct_eq(*a._v__ast__SemicolonStmt, *b._v__ast__SemicolonStmt);
	}
	if (a._typ == 334) {
		return v__ast__SqlStmt_struct_eq(*a._v__ast__SqlStmt, *b._v__ast__SqlStmt);
	}
	if (a._typ == 228) {
		return v__ast__StructDecl_struct_eq(*a._v__ast__StructDecl, *b._v__ast__StructDecl);
	}
	if (a._typ == 257) {
		return v__ast__TypeDecl_sumtype_eq(*a._v__ast__TypeDecl, *b._v__ast__TypeDecl);
	}
	return false;
}

static void Array_v__ast__Type_free(Array_v__ast__Type* it) {
	builtin__array_free(it);
}

static void v__ast__Param_free(v__ast__Param* it) {
	builtin__string_free(&(it->name));
	v__token__Pos_free(&(it->type_pos));
	v__token__Pos_free(&(it->pos));
}

static void Array_v__ast__Param_free(Array_v__ast__Param* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Param_free(&(((v__ast__Param*)it->data)[i]));
	}
	builtin__array_free(it);
}

static void v__ast__Attr_free(v__ast__Attr* it) {
	builtin__string_free(&(it->name));
	builtin__string_free(&(it->arg));
	v__token__Pos_free(&(it->pos));
}

static void Array_v__ast__Attr_free(Array_v__ast__Attr* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Attr_free(&(((v__ast__Attr*)it->data)[i]));
	}
	builtin__array_free(it);
}

static void v__ast__Fn_free(v__ast__Fn* it) {
	Array_v__ast__Param_free(&(it->params));
	Array_v__ast__Attr_free(&(it->attrs));
	Array_string_free(&(it->dep_names));
	Array_string_free(&(it->generic_names));
	builtin__string_free(&(it->file));
	builtin__string_free(&(it->name));
	builtin__string_free(&(it->mod));
	v__token__Pos_free(&(it->name_pos));
	v__token__Pos_free(&(it->pos));
	v__token__Pos_free(&(it->return_type_pos));
}

static void Array_v__ast__Fn_free(Array_v__ast__Fn* it) {
	for (int i = 0; i < it->len; i++) {
		v__ast__Fn_free(&(((v__ast__Fn*)it->data)[i]));
	}
	builtin__array_free(it);
}

static void v__ast__TypeSymbol_free(v__ast__TypeSymbol* it) {
	Array_v__ast__Type_free(&(it->generic_types));
	Array_v__ast__Fn_free(&(it->methods));
	builtin__string_free(&(it->mod));
	builtin__string_free(&(it->name));
	builtin__string_free(&(it->cname));
	builtin__string_free(&(it->rname));
	builtin__string_free(&(it->ngname));
}


// V json forward decls:
_result_main__StockParams json__decode_main__StockParams(cJSON* root);
cJSON* json__encode_main__StockParams(main__StockParams val);


// V gowrappers:

Array_f64 __v_thread_Array_f64_wait(__v_thread_Array_f64 thread) {
	Array_f64* ret_ptr;
	if ((unsigned long int)thread == 0) { builtin___v_panic(_S("unable to join thread")); }
	int stat = pthread_join(thread, (void **)&ret_ptr);
	if (stat != 0) { builtin___v_panic(_S("unable to join thread")); }
	Array_f64 ret = *ret_ptr;
	builtin___v_free(ret_ptr);
	return ret;
}
void* vphp__ITask_run_thread_wrapper(thread_arg_vphp__ITask_run *arg) {
	Array_f64* ret_ptr = (Array_f64*) builtin___v_malloc(sizeof(Array_f64));
	*ret_ptr = vphp__ITask_name_table[arg->arg0._typ]._method_run(arg->arg0._object);
	builtin___v_free(arg);
	return ret_ptr;
}
void* anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731_thread_wrapper(thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731 *arg) {
	arg->fn(arg->arg1, arg->arg2);
	builtin___v_free(arg);
	return 0;
}

_result_main__StockParams json__decode_main__StockParams(cJSON* root) {
	main__StockParams res = (main__StockParams){.symbol = (string){.str=(byteptr)"", .is_lit=1},.count = 0,};
	if (!root) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
			const int error_pos = (int)cJSON_GetErrorPos();
			int maxcontext_chars = 30;
			byte *buf = builtin__vcalloc_noscan(maxcontext_chars + 10);
			if (error_pos > 0) {
				int backlines = 1;
				int backchars = error_pos < maxcontext_chars-7 ? (int)error_pos : maxcontext_chars-7 ;
				char *prevline_ptr = (char*)error_ptr;
				while(backchars--){
					char prevc = *(prevline_ptr - 1);
					if(0==prevc){
						break;
					}
					if(10==prevc && !backlines--){
						break;
					}
					prevline_ptr--;
					if(123==prevc) {
						break; // stop at `{` too
					}
				}
				int maxchars = builtin__vstrlen_char(prevline_ptr);
				builtin__vmemcpy(buf, prevline_ptr, (maxchars < maxcontext_chars ? maxchars : maxcontext_chars));
			}
			string msg;
			msg = _S("failed to decode JSON string");
			if (buf[0] != '\0') {
				msg = builtin__string__plus(msg, _S(": "));
			}
			return (_result_main__StockParams){.is_error = true,.err = builtin___v_error(builtin__string__plus(msg, builtin__tos2(buf))),.data = {0}};
		}
	}

	cJSON *jsonroot__t1 = js_get(root, "symbol");
	if (jsonroot__t1) {
		if (!(cJSON_IsNull(jsonroot__t1) || cJSON_IsString(jsonroot__t1))) {
			return (_result_main__StockParams){ .is_error = true, .err = builtin___v_error(builtin__string__plus(_S("type mismatch for field 'symbol', expecting `string` type, got: "), json__json_print(jsonroot__t1))), .data = {0} };
		}
		res.symbol = json__decode_string(jsonroot__t1);
	}
	cJSON *jsonroot__t2 = js_get(root, "count");
	if (jsonroot__t2) {
		if (!(cJSON_IsNull(jsonroot__t2) || cJSON_IsNumber(jsonroot__t2) || (cJSON_IsString(jsonroot__t2) && strlen(jsonroot__t2->valuestring)))) {
			return (_result_main__StockParams){ .is_error = true, .err = builtin___v_error(builtin__string__plus(_S("type mismatch for field 'count', expecting `int` type, got: "), json__json_print(jsonroot__t2))), .data = {0} };
		}
		res.count = json__decode_int(jsonroot__t2);
	}
	_result_main__StockParams ret;
	builtin___result_ok(&res, (_result*)&ret, sizeof(res));
	return ret;
}


cJSON* json__encode_main__StockParams(main__StockParams val) {
	cJSON *o;
	o = cJSON_CreateObject();
		cJSON_AddItemToObject(o, "symbol", json__encode_string(val.symbol));
		cJSON_AddItemToObject(o, "count", json__encode_int(val.count));
	return o;
}


// V anon functions:
	VV_LOC void anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731(sync__WaitGroup* wg, void (*f)(void)) {
	f();
	sync__WaitGroup_done(wg);
}

VV_LOC vphp__ITask anon_fn_e0873e5963f3179a_40_string__vphp__ITask_154(string s) {
	return I_main__AnalyzeTask_to_Interface_vphp__ITask(((main__AnalyzeTask*)builtin__memdup(&(main__AnalyzeTask){.json_data = s,}, sizeof(main__AnalyzeTask))));
}


// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(u32 sidx) {
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_voidptr_index) return "voidptr";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_MessageError_index) return "MessageError";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	if (sidx == _IError_flag__UnknownFlagError_index) return "flag.UnknownFlagError";
	if (sidx == _IError_flag__ArgsCountError_index) return "flag.ArgsCountError";
	if (sidx == _IError_semver__InvalidComparatorFormatError_index) return "semver.InvalidComparatorFormatError";
	if (sidx == _IError_semver__EmptyInputError_index) return "semver.EmptyInputError";
	if (sidx == _IError_semver__InvalidVersionFormatError_index) return "semver.InvalidVersionFormatError";
	if (sidx == _IError_os__Eof_index) return "os.Eof";
	if (sidx == _IError_os__NotExpected_index) return "os.NotExpected";
	if (sidx == _IError_os__FileNotOpenedError_index) return "os.FileNotOpenedError";
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return "os.SizeOfTypeIs0Error";
	if (sidx == _IError_os__ExecutableNotFoundError_index) return "os.ExecutableNotFoundError";
	if (sidx == _IError_v__parser__IncludeError_index) return "v.parser.IncludeError";
	return "unknown IError";
}

u32 v_typeof_interface_idx_IError(u32 sidx) {
	if (sidx == _IError_None___index) return 62;
	if (sidx == _IError_voidptr_index) return 2;
	if (sidx == _IError_Error_index) return 63;
	if (sidx == _IError_MessageError_index) return 64;
	if (sidx == _IError_time__TimeParseError_index) return 636;
	if (sidx == _IError_flag__UnknownFlagError_index) return 663;
	if (sidx == _IError_flag__ArgsCountError_index) return 664;
	if (sidx == _IError_semver__InvalidComparatorFormatError_index) return 699;
	if (sidx == _IError_semver__EmptyInputError_index) return 701;
	if (sidx == _IError_semver__InvalidVersionFormatError_index) return 702;
	if (sidx == _IError_os__Eof_index) return 167;
	if (sidx == _IError_os__NotExpected_index) return 168;
	if (sidx == _IError_os__FileNotOpenedError_index) return 170;
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return 171;
	if (sidx == _IError_os__ExecutableNotFoundError_index) return 189;
	if (sidx == _IError_v__parser__IncludeError_index) return 536;
	return 30;
}
static char * v_typeof_interface_vphp__ITask(u32 sidx) {
	if (sidx == _vphp__ITask_main__AnalyzeTask_index) return "AnalyzeTask";
	if (sidx == _vphp__ITask_voidptr_index) return "voidptr";
	return "unknown vphp.ITask";
}

u32 v_typeof_interface_idx_vphp__ITask(u32 sidx) {
	if (sidx == _vphp__ITask_main__AnalyzeTask_index) return 109;
	if (sidx == _vphp__ITask_voidptr_index) return 2;
	return 108;
}
char * v_typeof_sumtype_v__ast__Stmt(u32 sidx) {
	switch(sidx) {
		case 226: return "v.ast.Stmt";
		case 311: return "v.ast.AsmStmt";
		case 312: return "v.ast.AssertStmt";
		case 313: return "v.ast.AssignStmt";
		case 314: return "v.ast.Block";
		case 315: return "v.ast.BranchStmt";
		case 316: return "v.ast.ComptimeFor";
		case 231: return "v.ast.ConstDecl";
		case 317: return "v.ast.DebuggerStmt";
		case 318: return "v.ast.DeferStmt";
		case 319: return "v.ast.EmptyStmt";
		case 320: return "v.ast.EnumDecl";
		case 321: return "v.ast.ExprStmt";
		case 229: return "v.ast.FnDecl";
		case 322: return "v.ast.ForCStmt";
		case 323: return "v.ast.ForInStmt";
		case 324: return "v.ast.ForStmt";
		case 325: return "v.ast.GlobalDecl";
		case 326: return "v.ast.GotoLabel";
		case 327: return "v.ast.GotoStmt";
		case 328: return "v.ast.HashStmt";
		case 329: return "v.ast.Import";
		case 330: return "v.ast.InterfaceDecl";
		case 331: return "v.ast.Module";
		case 258: return "v.ast.NodeError";
		case 332: return "v.ast.Return";
		case 333: return "v.ast.SemicolonStmt";
		case 334: return "v.ast.SqlStmt";
		case 228: return "v.ast.StructDecl";
		case 257: return "v.ast.TypeDecl";
		default: return "unknown v.ast.Stmt";
	}
}

u32 v_typeof_sumtype_idx_v__ast__Stmt(u32 sidx) {
	switch(sidx) {
		case 226: return 226;
		case 311: return 311;
		case 312: return 312;
		case 313: return 313;
		case 314: return 314;
		case 315: return 315;
		case 316: return 316;
		case 231: return 231;
		case 317: return 317;
		case 318: return 318;
		case 319: return 319;
		case 320: return 320;
		case 321: return 321;
		case 229: return 229;
		case 322: return 322;
		case 323: return 323;
		case 324: return 324;
		case 325: return 325;
		case 326: return 326;
		case 327: return 327;
		case 328: return 328;
		case 329: return 329;
		case 330: return 330;
		case 331: return 331;
		case 258: return 258;
		case 332: return 332;
		case 333: return 333;
		case 334: return 334;
		case 228: return 228;
		case 257: return 257;
		default: return 226;
	}
}
static char * v_typeof_interface_vphp__compiler__PhpRepr(u32 sidx) {
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpFuncRepr_index) return "vphp.compiler.PhpFuncRepr";
	if (sidx == _vphp__compiler__PhpRepr_voidptr_index) return "voidptr";
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpTaskRepr_index) return "vphp.compiler.PhpTaskRepr";
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) return "vphp.compiler.PhpClassRepr";
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpConstRepr_index) return "vphp.compiler.PhpConstRepr";
	return "unknown vphp.compiler.PhpRepr";
}

u32 v_typeof_interface_idx_vphp__compiler__PhpRepr(u32 sidx) {
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpFuncRepr_index) return 215;
	if (sidx == _vphp__compiler__PhpRepr_voidptr_index) return 2;
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpTaskRepr_index) return 216;
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) return 217;
	if (sidx == _vphp__compiler__PhpRepr_vphp__compiler__PhpConstRepr_index) return 230;
	return 232;
}
char * v_typeof_sumtype_v__ast__TypeDecl(u32 sidx) {
	switch(sidx) {
		case 257: return "v.ast.TypeDecl";
		case 254: return "v.ast.AliasTypeDecl";
		case 255: return "v.ast.FnTypeDecl";
		case 256: return "v.ast.SumTypeDecl";
		default: return "unknown v.ast.TypeDecl";
	}
}

u32 v_typeof_sumtype_idx_v__ast__TypeDecl(u32 sidx) {
	switch(sidx) {
		case 257: return 257;
		case 254: return 254;
		case 255: return 255;
		case 256: return 256;
		default: return 257;
	}
}
char * v_typeof_sumtype_v__ast__Expr(u32 sidx) {
	switch(sidx) {
		case 310: return "v.ast.Expr";
		case 258: return "v.ast.NodeError";
		case 259: return "v.ast.AnonFn";
		case 260: return "v.ast.ArrayDecompose";
		case 261: return "v.ast.ArrayInit";
		case 262: return "v.ast.AsCast";
		case 263: return "v.ast.Assoc";
		case 264: return "v.ast.AtExpr";
		case 265: return "v.ast.BoolLiteral";
		case 266: return "v.ast.CTempVar";
		case 267: return "v.ast.CallExpr";
		case 268: return "v.ast.CastExpr";
		case 269: return "v.ast.ChanInit";
		case 270: return "v.ast.CharLiteral";
		case 271: return "v.ast.Comment";
		case 272: return "v.ast.ComptimeCall";
		case 273: return "v.ast.ComptimeSelector";
		case 274: return "v.ast.ComptimeType";
		case 275: return "v.ast.ConcatExpr";
		case 276: return "v.ast.DumpExpr";
		case 277: return "v.ast.EmptyExpr";
		case 278: return "v.ast.EnumVal";
		case 279: return "v.ast.FloatLiteral";
		case 280: return "v.ast.GoExpr";
		case 281: return "v.ast.Ident";
		case 282: return "v.ast.IfExpr";
		case 283: return "v.ast.IfGuardExpr";
		case 284: return "v.ast.IndexExpr";
		case 285: return "v.ast.InfixExpr";
		case 286: return "v.ast.IntegerLiteral";
		case 287: return "v.ast.IsRefType";
		case 288: return "v.ast.LambdaExpr";
		case 289: return "v.ast.Likely";
		case 290: return "v.ast.LockExpr";
		case 291: return "v.ast.MapInit";
		case 292: return "v.ast.MatchExpr";
		case 293: return "v.ast.Nil";
		case 294: return "v.ast.None";
		case 295: return "v.ast.OffsetOf";
		case 296: return "v.ast.OrExpr";
		case 297: return "v.ast.ParExpr";
		case 298: return "v.ast.PostfixExpr";
		case 299: return "v.ast.PrefixExpr";
		case 300: return "v.ast.RangeExpr";
		case 301: return "v.ast.SelectExpr";
		case 302: return "v.ast.SelectorExpr";
		case 303: return "v.ast.SizeOf";
		case 304: return "v.ast.SpawnExpr";
		case 305: return "v.ast.SqlExpr";
		case 306: return "v.ast.StringInterLiteral";
		case 237: return "v.ast.StringLiteral";
		case 236: return "v.ast.StructInit";
		case 307: return "v.ast.TypeNode";
		case 308: return "v.ast.TypeOf";
		case 309: return "v.ast.UnsafeExpr";
		default: return "unknown v.ast.Expr";
	}
}

u32 v_typeof_sumtype_idx_v__ast__Expr(u32 sidx) {
	switch(sidx) {
		case 310: return 310;
		case 258: return 258;
		case 259: return 259;
		case 260: return 260;
		case 261: return 261;
		case 262: return 262;
		case 263: return 263;
		case 264: return 264;
		case 265: return 265;
		case 266: return 266;
		case 267: return 267;
		case 268: return 268;
		case 269: return 269;
		case 270: return 270;
		case 271: return 271;
		case 272: return 272;
		case 273: return 273;
		case 274: return 274;
		case 275: return 275;
		case 276: return 276;
		case 277: return 277;
		case 278: return 278;
		case 279: return 279;
		case 280: return 280;
		case 281: return 281;
		case 282: return 282;
		case 283: return 283;
		case 284: return 284;
		case 285: return 285;
		case 286: return 286;
		case 287: return 287;
		case 288: return 288;
		case 289: return 289;
		case 290: return 290;
		case 291: return 291;
		case 292: return 292;
		case 293: return 293;
		case 294: return 294;
		case 295: return 295;
		case 296: return 296;
		case 297: return 297;
		case 298: return 298;
		case 299: return 299;
		case 300: return 300;
		case 301: return 301;
		case 302: return 302;
		case 303: return 303;
		case 304: return 304;
		case 305: return 305;
		case 306: return 306;
		case 237: return 237;
		case 236: return 236;
		case 307: return 307;
		case 308: return 308;
		case 309: return 309;
		default: return 310;
	}
}
char * v_typeof_sumtype_v__ast__ScopeObject(u32 sidx) {
	switch(sidx) {
		case 342: return "v.ast.ScopeObject";
		case 337: return "v.ast.EmptyScopeObject";
		case 338: return "v.ast.AsmRegister";
		case 339: return "v.ast.ConstField";
		case 340: return "v.ast.GlobalField";
		case 341: return "v.ast.Var";
		default: return "unknown v.ast.ScopeObject";
	}
}

u32 v_typeof_sumtype_idx_v__ast__ScopeObject(u32 sidx) {
	switch(sidx) {
		case 342: return 342;
		case 337: return 337;
		case 338: return 338;
		case 339: return 339;
		case 340: return 340;
		case 341: return 341;
		default: return 342;
	}
}
char * v_typeof_sumtype_v__ast__Node(u32 sidx) {
	switch(sidx) {
		case 352: return "v.ast.Node";
		case 343: return "v.ast.CallArg";
		case 339: return "v.ast.ConstField";
		case 344: return "v.ast.EmptyNode";
		case 345: return "v.ast.EnumField";
		case 310: return "v.ast.Expr";
		case 235: return "v.ast.File";
		case 340: return "v.ast.GlobalField";
		case 346: return "v.ast.IfBranch";
		case 347: return "v.ast.MatchBranch";
		case 258: return "v.ast.NodeError";
		case 348: return "v.ast.Param";
		case 342: return "v.ast.ScopeObject";
		case 349: return "v.ast.SelectBranch";
		case 226: return "v.ast.Stmt";
		case 350: return "v.ast.StructField";
		case 351: return "v.ast.StructInitField";
		default: return "unknown v.ast.Node";
	}
}

u32 v_typeof_sumtype_idx_v__ast__Node(u32 sidx) {
	switch(sidx) {
		case 352: return 352;
		case 343: return 343;
		case 339: return 339;
		case 344: return 344;
		case 345: return 345;
		case 310: return 310;
		case 235: return 235;
		case 340: return 340;
		case 346: return 346;
		case 347: return 347;
		case 258: return 258;
		case 348: return 348;
		case 342: return 342;
		case 349: return 349;
		case 226: return 226;
		case 350: return 350;
		case 351: return 351;
		default: return 352;
	}
}
char * v_typeof_sumtype_v__ast__ComptTimeConstValue(u32 sidx) {
	switch(sidx) {
		case 356: return "v.ast.ComptTimeConstValue";
		case 277: return "v.ast.EmptyExpr";
		case 16: return "f32";
		case 17: return "f64";
		case 6: return "i16";
		case 7: return "i32";
		case 9: return "i64";
		case 5: return "i8";
		case 22: return "rune";
		case 21: return "string";
		case 12: return "u16";
		case 13: return "u32";
		case 14: return "u64";
		case 11: return "u8";
		case 2: return "voidptr";
		default: return "unknown v.ast.ComptTimeConstValue";
	}
}

u32 v_typeof_sumtype_idx_v__ast__ComptTimeConstValue(u32 sidx) {
	switch(sidx) {
		case 356: return 356;
		case 277: return 277;
		case 16: return 16;
		case 17: return 17;
		case 6: return 6;
		case 7: return 7;
		case 9: return 9;
		case 5: return 5;
		case 22: return 22;
		case 21: return 21;
		case 12: return 12;
		case 13: return 13;
		case 14: return 14;
		case 11: return 11;
		case 2: return 2;
		default: return 356;
	}
}
char * v_typeof_sumtype_v__ast__IdentInfo(u32 sidx) {
	switch(sidx) {
		case 409: return "v.ast.IdentInfo";
		case 407: return "v.ast.IdentFn";
		case 408: return "v.ast.IdentVar";
		default: return "unknown v.ast.IdentInfo";
	}
}

u32 v_typeof_sumtype_idx_v__ast__IdentInfo(u32 sidx) {
	switch(sidx) {
		case 409: return 409;
		case 407: return 407;
		case 408: return 408;
		default: return 409;
	}
}
char * v_typeof_sumtype_v__ast__AsmArg(u32 sidx) {
	switch(sidx) {
		case 427: return "v.ast.AsmArg";
		case 429: return "v.ast.AsmAddressing";
		case 430: return "v.ast.AsmAlias";
		case 431: return "v.ast.AsmDisp";
		case 338: return "v.ast.AsmRegister";
		case 265: return "v.ast.BoolLiteral";
		case 270: return "v.ast.CharLiteral";
		case 279: return "v.ast.FloatLiteral";
		case 286: return "v.ast.IntegerLiteral";
		case 21: return "string";
		default: return "unknown v.ast.AsmArg";
	}
}

u32 v_typeof_sumtype_idx_v__ast__AsmArg(u32 sidx) {
	switch(sidx) {
		case 427: return 427;
		case 429: return 429;
		case 430: return 430;
		case 431: return 431;
		case 338: return 338;
		case 265: return 265;
		case 270: return 270;
		case 279: return 279;
		case 286: return 286;
		case 21: return 21;
		default: return 427;
	}
}
char * v_typeof_sumtype_v__ast__TypeInfo(u32 sidx) {
	switch(sidx) {
		case 500: return "v.ast.TypeInfo";
		case 498: return "v.ast.UnknownTypeInfo";
		case 480: return "v.ast.Aggregate";
		case 482: return "v.ast.Alias";
		case 452: return "v.ast.Array";
		case 491: return "v.ast.ArrayFixed";
		case 492: return "v.ast.Chan";
		case 490: return "v.ast.Enum";
		case 495: return "v.ast.FnType";
		case 496: return "v.ast.GenericInst";
		case 485: return "v.ast.Interface";
		case 453: return "v.ast.Map";
		case 494: return "v.ast.MultiReturn";
		case 457: return "v.ast.Struct";
		case 486: return "v.ast.SumType";
		case 493: return "v.ast.Thread";
		default: return "unknown v.ast.TypeInfo";
	}
}

u32 v_typeof_sumtype_idx_v__ast__TypeInfo(u32 sidx) {
	switch(sidx) {
		case 500: return 500;
		case 498: return 498;
		case 480: return 480;
		case 482: return 482;
		case 452: return 452;
		case 491: return 491;
		case 492: return 492;
		case 490: return 490;
		case 495: return 495;
		case 496: return 496;
		case 485: return 485;
		case 453: return 453;
		case 494: return 494;
		case 457: return 457;
		case 486: return 486;
		case 493: return 493;
		default: return 500;
	}
}
static char * v_typeof_interface_rand__PRNG(u32 sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	if (sidx == _rand__PRNG_voidptr_index) return "voidptr";
	return "unknown rand.PRNG";
}

u32 v_typeof_interface_idx_rand__PRNG(u32 sidx) {
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return 602;
	if (sidx == _rand__PRNG_voidptr_index) return 2;
	return 599;
}
// << typeof() support for sum types

	// pointers to common sumtype fields
	// pointers to common sumtype fields
	// pointers to common sumtype fields
	// pointers to common sumtype fields
strings__Builder strings__new_builder(int initial_size) {
	strings__Builder res = ((builtin____new_array_with_default(0, initial_size, sizeof(u8), 0)));
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	return res;
}
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b) {
	builtin__ArrayFlags_clear(&b->flags, ArrayFlags__noslices);
	return *b;
}
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len) {
	if (len == 0) {
		return;
	}
	builtin__array_push_many(b, ptr, len);
}
void strings__Builder_write_rune(strings__Builder* b, rune r) {
	Array_fixed_u8_5 buffer = {0};
	string res = builtin__utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	builtin__array_push_many(b, res.str, res.len);
}
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes) {
	Array_fixed_u8_5 buffer = {0};
	for (int _t1 = 0; _t1 < runes.len; ++_t1) {
		rune r = ((rune*)runes.data)[_t1];
		string res = builtin__utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
		if (res.len == 0) {
			continue;
		}
		builtin__array_push_many(b, res.str, res.len);
	}
}
inline void strings__Builder_write_u8(strings__Builder* b, u8 data) {
	builtin__array_push((array*)b, _MOV((u8[]){ data }));
}
inline void strings__Builder_write_byte(strings__Builder* b, u8 data) {
	builtin__array_push((array*)b, _MOV((u8[]){ data }));
}
void strings__Builder_write_decimal(strings__Builder* b, i64 n) {
	if (n == 0) {
		strings__Builder_write_u8(b, 0x30);
		return;
	}
	if (n == _const_min_i64) {
		strings__Builder_write_string(b, builtin__i64_str(n));
		return;
	}
	Array_fixed_u8_25 buf = {0};
	i64 x = (n < 0 ? (-n) : (n));
	int i = 24;
	for (;;) {
		if (!(x != 0)) break;
		i64 nextx = (i64)(x / 10);
		i64 r = (i64)(x % 10);
		buf[i] = (u8)(((u8)(r)) + 0x30);
		x = nextx;
		i--;
	}
	if (n < 0) {
		buf[i] = '-';
		i--;
	}
	strings__Builder_write_ptr(b, &buf[(int)(i + 1)], (int)(24 - i));
}
_result_int strings__Builder_write(strings__Builder* b, Array_u8 data) {
	if (data.len == 0) {
		_result_int _t1;
		builtin___result_ok(&(int[]) { 0 }, (_result*)(&_t1), sizeof(int));
		 
		return _t1;
	}
	builtin__array_push_many(b, data.data, data.len);
	_result_int _t2;
	builtin___result_ok(&(int[]) { data.len }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap) {
	if (other->len > 0) {
		_PUSH_MANY(b, (*other), _t1, strings__Builder);
	}
	strings__Builder_free(other);
	*other = strings__new_builder(other_new_cap);
}
inline u8 strings__Builder_byte_at(strings__Builder* b, int n) {
	return (*(u8*)builtin__array_get(*(((Array_u8*)(b))), n));
}
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if (s.len == 0) {
		return;
	}
	builtin__array_push_many(b, s.str, s.len);
}
inline void strings__Builder_write_string2(strings__Builder* b, string s1, string s2) {
	if (s1.len != 0) {
		builtin__array_push_many(b, s1.str, s1.len);
	}
	if (s2.len != 0) {
		builtin__array_push_many(b, s2.str, s2.len);
	}
}
void strings__Builder_go_back(strings__Builder* b, int n) {
	builtin__array_trim(b, (int)(b->len - n));
}
inline string strings__Builder_spart(strings__Builder* b, int start_pos, int n) {
	{ // Unsafe block
		u8* x = builtin__malloc_noscan((int)(n + 1));
		builtin__vmemcpy(x, ((u8*)(b->data)) + start_pos, n);
		x[n] = 0;
		return builtin__tos(x, n);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strings__Builder_cut_last(strings__Builder* b, int n) {
	int cut_pos = (int)(b->len - n);
	string res = strings__Builder_spart(b, cut_pos, n);
	builtin__array_trim(b, cut_pos);
	return res;
}
string strings__Builder_cut_to(strings__Builder* b, int pos) {
	if (pos > b->len) {
		return _S("");
	}
	return strings__Builder_cut_last(b, (int)(b->len - pos));
}
void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	builtin__array_trim(b, pos);
}
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	if ((s).len != 0) {
		builtin__array_push_many(b, s.str, s.len);
	}
	builtin__array_push((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}
inline void strings__Builder_writeln2(strings__Builder* b, string s1, string s2) {
	if ((s1).len != 0) {
		builtin__array_push_many(b, s1.str, s1.len);
	}
	builtin__array_push((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
	if ((s2).len != 0) {
		builtin__array_push_many(b, s2.str, s2.len);
	}
	builtin__array_push((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}
string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _S("");
	}
	return strings__Builder_spart(b, (int)(b->len - n), n);
}
string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _S("");
	}
	return strings__Builder_spart(b, n, (int)(b->len - n));
}
string strings__Builder_str(strings__Builder* b) {
	builtin__array_push((array*)b, _MOV((u8[]){ ((u8)(0)) }));
	u8* bcopy = ((u8*)(builtin__memdup_noscan(b->data, b->len)));
	string s = builtin__u8_vstring_with_len(bcopy, (int)(b->len - 1));
	builtin__array_clear(b);
	return s;
}
void strings__Builder_ensure_cap(strings__Builder* b, int n) {
	if (n <= b->cap) {
		return;
	}
	u8* new_data = builtin__vcalloc((int)(n * b->element_size));
	if (b->data != ((void*)0)) {
		builtin__vmemcpy(new_data, b->data, (int)(b->len * b->element_size));
		if (builtin__ArrayFlags_has(&b->flags, ArrayFlags__noslices)) {
			builtin___v_free(b->data);
		}
	}
	{ // Unsafe block
		b->data = new_data;
		b->offset = 0;
		b->cap = n;
	}
}
void strings__Builder_grow_len(strings__Builder* b, int n) {
	if (n <= 0) {
		return;
	}
	int new_len = (int)(b->len + n);
	strings__Builder_ensure_cap(b, new_len);
	{ // Unsafe block
		b->len = new_len;
	}
}
void strings__Builder_free(strings__Builder* b) {
	if (b->data != 0) {
		builtin___v_free(b->data);
		{ // Unsafe block
			b->data = ((void*)0);
		}
	}
}
void strings__Builder_write_repeated_rune(strings__Builder* b, rune r, int count) {
	if (count <= 0) {
		return;
	}
	Array_fixed_u8_5 buffer = {0};
	string res = builtin__utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	if (res.len == 1) {
		strings__Builder_ensure_cap(b, (int)(b->len + count));
		{ // Unsafe block
			builtin__vmemset(((u8*)(b->data)) + b->len, buffer[0], count);
			b->len += count;
		}
		return;
	} else {
		int total_needed = (int)(count * res.len);
		strings__Builder_ensure_cap(b, (int)(b->len + total_needed));
		u8* dest = ((u8*)(b->data)) + b->len;
		for (int _t1 = 0; _t1 < count; ++_t1) {
			{ // Unsafe block
				builtin__vmemcpy(dest, res.str, res.len);
				dest += res.len;
			}
		}
		{ // Unsafe block
			b->len += total_needed;
		}
	}
}
void strings__Builder_indent(strings__Builder* b, string s, strings__IndentParam param) {
	if (s.len == 0) {
		return;
	}
	strings__IndentState state = strings__IndentState__normal;
	int indent_level = param.starting_level;
	rune string_char = '\0';
	bool at_line_start = true;
	for (int i = 0; i < s.len; i++) {
		u8 c = s.str[ i];

		if (state == (strings__IndentState__normal)) {

			if (c == ('"') || c == ('\'')) {
				state = strings__IndentState__in_string;
				string_char = c;
				if (at_line_start) {
					strings__Builder_write_repeated_rune(b, param.indent_char, (int)(indent_level * param.indent_count));
					at_line_start = false;
				}
				strings__Builder_write_rune(b, c);
			}
			else if (c == (param.block_start)) {
				if (at_line_start) {
					strings__Builder_write_repeated_rune(b, param.indent_char, (int)(indent_level * param.indent_count));
					at_line_start = false;
				}
				strings__Builder_write_rune(b, c);
				if ((int)(i + 1) < s.len && s.str[ (int)(i + 1)] == param.block_end) {
					strings__Builder_write_rune(b, param.block_end);
					i++;
				} else {
					indent_level++;
					strings__Builder_write_rune(b, '\n');
					at_line_start = true;
				}
			}
			else if (c == (param.block_end)) {
				if (indent_level > 0) {
					indent_level--;
				}
				if (!at_line_start) {
					strings__Builder_write_rune(b, '\n');
				}
				strings__Builder_write_repeated_rune(b, param.indent_char, (int)(indent_level * param.indent_count));
				at_line_start = false;
				strings__Builder_write_rune(b, c);
			}
			else if (c == (' ') || c == ('\t') || c == ('\r') || c == ('\n')) {
				if (!at_line_start) {
					strings__Builder_write_rune(b, c);
				}
				if (c == '\n') {
					at_line_start = true;
				}
			}
			else {
				if (at_line_start) {
					strings__Builder_write_repeated_rune(b, param.indent_char, (int)(indent_level * param.indent_count));
					at_line_start = false;
				}
				strings__Builder_write_rune(b, c);
			}
		}
		else if (state == (strings__IndentState__in_string)) {
			strings__Builder_write_rune(b, c);
			if (c == string_char) {
				if (s.str[ (int)(i - 1)] != '\\') {
					state = strings__IndentState__normal;
					string_char = '\0';
				}
			}
		}
	}
}
inline VV_LOC int strings__min(int a, int b, int c) {
	int m = a;
	if (b < m) {
		m = b;
	}
	if (c < m) {
		m = c;
	}
	return m;
}
inline VV_LOC int strings__max2(int a, int b) {
	if (a < b) {
		return b;
	}
	return a;
}
inline VV_LOC int strings__min2(int a, int b) {
	if (a < b) {
		return a;
	}
	return b;
}
inline VV_LOC int strings__abs2(int a, int b) {
	if (a < b) {
		return (int)(b - a);
	}
	return (int)(a - b);
}
int strings__levenshtein_distance(string a, string b) {
	if (a.len == 0) {
		return b.len;
	}
	if (b.len == 0) {
		return a.len;
	}
	if (builtin__string__eq(a, b)) {
		return 0;
	}
	Array_int row = 	builtin____new_array_with_default((int)(a.len + 1), 0, sizeof(int), 0);
	{
		int* pelem = (int*)row.data;
		for (int index=0; index<row.len; index++, pelem++) {
			int it = index;
			*pelem = index;
		}
	}
	;
	for (int i = 1; i < (int)(b.len + 1); i++) {
		int prev = i;
		for (int j = 1; j < (int)(a.len + 1); j++) {
			int current = ((int*)row.data)[(int)(j - 1)];
			if (b.str[ (int)(i - 1)] != a.str[ (int)(j - 1)]) {
				current = strings__min((int)(((int*)row.data)[(int)(j - 1)] + 1), (int)(prev + 1), (int)(((int*)row.data)[j] + 1));
			}
			((int*)row.data)[(int)(j - 1)] = prev;
			prev = current;
		}
		((int*)row.data)[a.len] = prev;
	}
	return ((int*)row.data)[a.len];
}
f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (f32)(((f32)(((f32)(1.00)) - (f32)(((f32)(d)) / ((f32)(l))))) * ((f32)(100.00)));
}
f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (builtin__string__eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (builtin__string__eq(a, s1) ? (s2) : (s1));
	Map_string_int first_bigrams = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int i = 0; i < (int)(a.len - 1); ++i) {
		string bigram = builtin__string_substr(a, i, (int_literal)(i + 2));
		int q = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((int)((*(int*)builtin__map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 })) + 1)) : (1));
		builtin__map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < (int)(b.len - 1); ++i) {
		string bigram = builtin__string_substr(b, i, (int_literal)(i + 2));
		int count = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)builtin__map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			builtin__map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { (int)(count - 1) });
			intersection_size++;
		}
	}
	return (f32)(((f32)(((f32)(2.0)) * ((f32)(intersection_size)))) / ((f32)((f32)(((f32)(a.len)) + ((f32)(b.len))) - 2)));
}
int strings__hamming_distance(string a, string b) {
	if (a.len == 0 && b.len == 0) {
		return 0;
	}
	int match_len = strings__min2(a.len, b.len);
	int diff_count = strings__abs2(a.len, b.len);
	for (int i = 0; i < match_len; ++i) {
		if (a.str[ i] != b.str[ i]) {
			diff_count++;
		}
	}
	return diff_count;
}
f32 strings__hamming_similarity(string a, string b) {
	int l = strings__max2(a.len, b.len);
	if (l == 0) {
		return 1.0;
	}
	int d = strings__hamming_distance(a, b);
	return (f32)(((f32)(1.00)) - (f32)(((f32)(d)) / ((f32)(l))));
}
f64 strings__jaro_similarity(string a, string b) {
	int a_len = a.len;
	int b_len = b.len;
	if (a_len == 0 && b_len == 0) {
		return 1.0;
	}
	if (a_len == 0 || b_len == 0) {
		return 0;
	}
	int match_distance = (int)((int)(strings__max2(a_len, b_len) / 2) - 1);
	Array_bool a_matches = builtin____new_array_with_default(a_len, 0, sizeof(bool), 0);
	Array_bool b_matches = builtin____new_array_with_default(b_len, 0, sizeof(bool), 0);
	int matches = 0;
	f64 transpositions = 0.0;
	for (int i = 0; i < a_len; ++i) {
		int start = strings__max2(0, (int)(i - match_distance));
		int end = strings__min2(b_len, (int)((int)(i + match_distance) + 1));
		for (int k = start; k < end; ++k) {
			if (((bool*)b_matches.data)[k]) {
				continue;
			}
			if (a.str[ i] != b.str[ k]) {
				continue;
			}
			((bool*)a_matches.data)[i] = true;
			((bool*)b_matches.data)[k] = true;
			matches++;
			break;
		}
	}
	if (matches == 0) {
		return 0;
	}
	int k = 0;
	for (int i = 0; i < a_len; ++i) {
		if (!((bool*)a_matches.data)[i]) {
			continue;
		}
		for (;;) {
			if (!(!((bool*)b_matches.data)[k])) break;
			k++;
		}
		if (a.str[ i] != b.str[ k]) {
			transpositions++;
		}
		k++;
	}
	transpositions /= 2;
	return (f64)(((f64)((f64)((f64)(matches / ((f64)(a_len))) + (f64)(matches / ((f64)(b_len)))) + (f64)(((f64)(matches - transpositions)) / matches))) / 3);
}
f64 strings__jaro_winkler_similarity(string a, string b) {
	int lmax = strings__min2(4, strings__min2(a.len, b.len));
	int l = 0;
	for (int i = 0; i < lmax; ++i) {
		if (a.str[ i] == b.str[ i]) {
			l++;
		}
	}
	f64 js = strings__jaro_similarity(a, b);
	f64 p = 0.1;
	f64 ws = (f64)(js + (f64)((f64)(((f64)(l)) * p) * ((f64)(1 - js))));
	return ws;
}
string strings__repeat(u8 c, int n) {
	if (n <= 0) {
		return _S("");
	}
	u8* bytes = builtin__malloc_noscan((int)(n + 1));
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = 0;
	}
	return builtin__u8_vstring_with_len(bytes, n);
}
string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return _S("");
	}
	int slen = s.len;
	int blen = (int)(slen * n);
	u8* bytes = builtin__malloc_noscan((int)(blen + 1));
	for (int bi = 0; bi < n; ++bi) {
		int bislen = (int)(bi * slen);
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[(int)(bislen + si)] = s.str[ si];
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = 0;
	}
	return builtin__u8_vstring_with_len(bytes, blen);
}
string strings__find_between_pair_u8(string input, u8 start, u8 end) {
	int marks = 0;
	int start_index = -1;
	for (int i = 0; i < input.len; ++i) {
		u8 b = input.str[i];
		if (b == start) {
			if (start_index == -1) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (b == end) {
				marks--;
				if (marks == 0) {
					return builtin__string_substr(input, start_index, i);
				}
			}
		}
	}
	return _S("");
}
string strings__find_between_pair_rune(string input, rune start, rune end) {
	int marks = 0;
	int start_index = -1;
	Array_rune runes = builtin__string_runes(input);
	for (int i = 0; i < runes.len; ++i) {
		rune r = ((rune*)runes.data)[i];
		if (r == start) {
			if (start_index == -1) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (r == end) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(builtin__array_slice(runes, start_index, i));
				}
			}
		}
	}
	return _S("");
}
string strings__find_between_pair_string(string input, string start, string end) {
	int start_index = -1;
	int marks = 0;
	Array_rune start_runes = builtin__string_runes(start);
	Array_rune end_runes = builtin__string_runes(end);
	Array_rune runes = builtin__string_runes(input);
	int i = 0;
	for (; i < runes.len; i++) {
		Array_rune start_slice = builtin__array_slice_ni(runes, i, (int)(i + start_runes.len));
		if (Array_rune_arr_eq(start_slice, start_runes)) {
			i = (int)((int)(i + start_runes.len) - 1);
			if (start_index < 0) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			Array_rune end_slice = builtin__array_slice_ni(runes, i, (int)(i + end_runes.len));
			if (Array_rune_arr_eq(end_slice, end_runes)) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(builtin__array_slice(runes, start_index, i));
				}
				i = (int)((int)(i + end_runes.len) - 1);
				continue;
			}
		}
	}
	return _S("");
}
Array_string strings__split_capital(string s) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	for (int idx = 0; idx < s.len; ++idx) {
		u8 c = s.str[idx];
		if (builtin__u8_is_capital(c)) {
			if (word_start != idx) {
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr_ni(s, word_start, idx) }));
			}
			word_start = idx;
			continue;
		}
	}
	if (word_start != s.len) {
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr_ni(s, word_start, 2147483647) }));
	}
	return res;
}
VV_LOC void builtin__closure__closure_alloc(void) {
	u8* p = builtin__closure__closure_alloc_platform();
	if (builtin__isnil(p)) {
		return;
	}
	u8* x = p + g_closure.v_page_size;
	int remaining = (int)(g_closure.v_page_size / _const_builtin__closure__closure_size);
	g_closure.closure_ptr = x;
	g_closure.closure_cap = remaining;
	for (;;) {
		if (!(remaining > 0)) break;
		builtin__vmemcpy(x, &_const_builtin__closure__closure_thunk[0], 12);
		remaining--;
		{ // Unsafe block
			x += _const_builtin__closure__closure_size;
		}
	}
	builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, g_closure.v_page_size, builtin__closure__MemoryProtectAtrr__read_exec);
}
VV_LOC void builtin__closure__closure_init(void) {
	int page_size = builtin__closure__get_page_size_platform();
	g_closure.v_page_size = page_size;
	builtin__closure__closure_mtx_lock_init_platform();
	builtin__closure__closure_alloc();
	{ // Unsafe block
		builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, page_size, builtin__closure__MemoryProtectAtrr__read_write);
		builtin__vmemcpy(g_closure.closure_ptr, &_const_builtin__closure__closure_get_data_bytes[0], 8);
		builtin__closure__closure_memory_protect_platform(g_closure.closure_ptr, page_size, builtin__closure__MemoryProtectAtrr__read_exec);
	}
	g_closure.closure_get_data = (voidptr)g_closure.closure_ptr;
	{ // Unsafe block
		g_closure.closure_ptr = ((u8*)(g_closure.closure_ptr)) + _const_builtin__closure__closure_size;
	}
	g_closure.closure_cap--;
}
VV_LOC voidptr builtin__closure__closure_create(voidptr func, voidptr data) {
	builtin__closure__closure_mtx_lock_platform();
	if (g_closure.closure_cap == 0) {
		builtin__closure__closure_alloc();
	}
	g_closure.closure_cap--;
	voidptr curr_closure = g_closure.closure_ptr;
	{ // Unsafe block
		g_closure.closure_ptr = ((u8*)(g_closure.closure_ptr)) + _const_builtin__closure__closure_size;
		voidptr* p = ((voidptr*)(((u8*)(curr_closure)) - _const_builtin__closure__assumed_page_size));
		p[0] = data;
		p[1] = func;
	}
	builtin__closure__closure_mtx_unlock_platform();
	return curr_closure;
}
#if !defined(_VFREESTANDING) && !defined(__vinix__)
#endif
inline VV_LOC u8* builtin__closure__closure_alloc_platform(void) {
	u8* p = ((u8*)(((void*)0)));
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		p = mmap(0, (int)(g_closure.v_page_size * 2), (PROT_READ | PROT_WRITE), (MAP_ANONYMOUS | MAP_PRIVATE), -1, 0);
		if (p == ((u8*)(MAP_FAILED))) {
			return ((void*)0);
		}
	}
	#endif
	return p;
}
inline VV_LOC void builtin__closure__closure_memory_protect_platform(voidptr ptr, isize size, builtin__closure__MemoryProtectAtrr attr) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{

		if (attr == (builtin__closure__MemoryProtectAtrr__read_exec)) {
			mprotect(ptr, size, (PROT_READ | PROT_EXEC));
		}
		else if (attr == (builtin__closure__MemoryProtectAtrr__read_write)) {
			mprotect(ptr, size, (PROT_READ | PROT_WRITE));
		}
	}
	#endif
}
inline VV_LOC int builtin__closure__get_page_size_platform(void) {
	int page_size = 0x4000;
	#if !defined(_VFREESTANDING)
	{
		page_size = ((int)(sysconf(_SC_PAGESIZE)));
	}
	#endif
	page_size = (int)(page_size * ((int)(((int)(((int)(_const_builtin__closure__assumed_page_size - 1)) / page_size)) + 1)));
	return page_size;
}
inline VV_LOC void builtin__closure__closure_mtx_lock_init_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_init(&g_closure.ClosureMutex.closure_mtx, 0);
	}
	#endif
}
inline VV_LOC void builtin__closure__closure_mtx_lock_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_lock(&g_closure.ClosureMutex.closure_mtx);
	}
	#endif
}
inline VV_LOC void builtin__closure__closure_mtx_unlock_platform(void) {
	#if !defined(_VFREESTANDING) || defined(__vinix__)
	{
		pthread_mutex_unlock(&g_closure.ClosureMutex.closure_mtx);
	}
	#endif
}
inline multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 hi = ((u64)(0));
	u64 lo = ((u64)(0));
	#if defined(__V_arm64) && !defined(__TINYC__)
	{
		__asm__ (
			"mul %[lo], %[x], %[y]\n\t"
			"umulh %[hi], %[x], %[y]\n\t"
			: [hi] "=&r" (hi),
			[lo] "=&r" (lo)
			: [x] "r" (x),
			[y] "r" (y)
			: "cc"
		);
		return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
	}
	#endif
	return math__bits__mul_64_default(x, y);
}
inline multi_return_u64_u64 math__bits__mul_add_64(u64 x, u64 y, u64 z) {
	u64 hi = ((u64)(0));
	u64 lo = ((u64)(0));
	#if defined(__V_arm64) && !defined(__TINYC__)
	{
		__asm__ (
			"mul %[lo], %[x], %[y]\n\t"
			"umulh %[hi], %[x], %[y]\n\t"
			"adds %[lo], %[lo], %[z]\n\t"
			"adc %[hi], %[hi], xzr\n\t"
			: [hi] "=&r" (hi),
			[lo] "=&r" (lo)
			: [x] "r" (x),
			[y] "r" (y),
			[z] "r" (z)
			: "cc"
		);
		return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
	}
	#endif
	return math__bits__mul_add_64_default(x, y, z);
}
inline int math__bits__leading_zeros_8(u8 x) {
	if (x == 0) {
		return 8;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return (i32)(__builtin_clz(x) - 24);
	}
	#endif
	return math__bits__leading_zeros_8_default(x);
}
inline int math__bits__leading_zeros_16(u16 x) {
	if (x == 0) {
		return 16;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return (i32)(__builtin_clz(x) - 16);
	}
	#endif
	return math__bits__leading_zeros_16_default(x);
}
inline int math__bits__leading_zeros_32(u32 x) {
	if (x == 0) {
		return 32;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_clz(x);
	}
	#endif
	return math__bits__leading_zeros_32_default(x);
}
inline int math__bits__leading_zeros_64(u64 x) {
	if (x == 0) {
		return 64;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_clzll(x);
	}
	#endif
	return math__bits__leading_zeros_64_default(x);
}
inline int math__bits__trailing_zeros_8(u8 x) {
	if (x == 0) {
		return 8;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_ctz(x);
	}
	#endif
	return math__bits__trailing_zeros_8_default(x);
}
inline int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0) {
		return 16;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_ctz(x);
	}
	#endif
	return math__bits__trailing_zeros_16_default(x);
}
inline int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0) {
		return 32;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_ctz(x);
	}
	#endif
	return math__bits__trailing_zeros_32_default(x);
}
inline int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0) {
		return 64;
	}
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_ctzll(x);
	}
	#endif
	return math__bits__trailing_zeros_64_default(x);
}
inline int math__bits__ones_count_8(u8 x) {
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_popcount(x);
	}
	#endif
	return math__bits__ones_count_8_default(x);
}
inline int math__bits__ones_count_16(u16 x) {
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_popcount(x);
	}
	#endif
	return math__bits__ones_count_16_default(x);
}
inline int math__bits__ones_count_32(u32 x) {
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_popcount(x);
	}
	#endif
	return math__bits__ones_count_32_default(x);
}
inline int math__bits__ones_count_64(u64 x) {
	#if defined(_MSC_VER)
	{
	}
	#elif !defined(__TINYC__)
	{
		return __builtin_popcountll(x);
	}
	#endif
	return math__bits__ones_count_64_default(x);
}
inline int math__bits__pure_v_but_overridden_by_c_leading_zeros_8(u8 x) {
	return math__bits__leading_zeros_8_default(x);
}
inline VV_LOC int math__bits__leading_zeros_8_default(u8 x) {
	return (int)(8 - math__bits__len_8(x));
}
inline int math__bits__pure_v_but_overridden_by_c_leading_zeros_16(u16 x) {
	return math__bits__leading_zeros_16_default(x);
}
inline VV_LOC int math__bits__leading_zeros_16_default(u16 x) {
	return (int)(16 - math__bits__len_16(x));
}
inline int math__bits__pure_v_but_overridden_by_c_leading_zeros_32(u32 x) {
	return math__bits__leading_zeros_32_default(x);
}
inline VV_LOC int math__bits__leading_zeros_32_default(u32 x) {
	return (int)(32 - math__bits__len_32(x));
}
inline int math__bits__pure_v_but_overridden_by_c_leading_zeros_64(u64 x) {
	return math__bits__leading_zeros_64_default(x);
}
inline VV_LOC int math__bits__leading_zeros_64_default(u64 x) {
	return (int)(64 - math__bits__len_64(x));
}
inline int math__bits__pure_v_but_overridden_by_c_trailing_zeros_8(u8 x) {
	return math__bits__trailing_zeros_8_default(x);
}
inline VV_LOC int math__bits__trailing_zeros_8_default(u8 x) {
	return ((int)(_const_math__bits__ntz_8_tab[x]));
}
inline int math__bits__pure_v_but_overridden_by_c_trailing_zeros_16(u16 x) {
	return math__bits__trailing_zeros_16_default(x);
}
inline VV_LOC int math__bits__trailing_zeros_16_default(u16 x) {
	if (x == 0) {
		return 16;
	}
	return ((int)(_const_math__bits__de_bruijn32tab[((u32)(((u32)((x & -x))) * _const_math__bits__de_bruijn32) >> 27)]));
}
inline int math__bits__pure_v_but_overridden_by_c_trailing_zeros_32(u32 x) {
	return math__bits__trailing_zeros_32_default(x);
}
inline VV_LOC int math__bits__trailing_zeros_32_default(u32 x) {
	if (x == 0) {
		return 32;
	}
	return ((int)(_const_math__bits__de_bruijn32tab[((u32)(((x & -x)) * _const_math__bits__de_bruijn32) >> 27)]));
}
inline int math__bits__pure_v_but_overridden_by_c_trailing_zeros_64(u64 x) {
	return math__bits__trailing_zeros_64_default(x);
}
inline VV_LOC int math__bits__trailing_zeros_64_default(u64 x) {
	if (x == 0) {
		return 64;
	}
	return ((int)(_const_math__bits__de_bruijn64tab[((u64)(((x & -x)) * _const_math__bits__de_bruijn64) >> 58)]));
}
inline int math__bits__pure_v_but_overridden_by_c_ones_count_8(u8 x) {
	return math__bits__ones_count_8_default(x);
}
inline VV_LOC int math__bits__ones_count_8_default(u8 x) {
	return ((int)(_const_math__bits__pop_8_tab[x]));
}
inline int math__bits__pure_v_but_overridden_by_c_ones_count_16(u16 x) {
	return math__bits__ones_count_16_default(x);
}
inline VV_LOC int math__bits__ones_count_16_default(u16 x) {
	return ((int)((u8)(_const_math__bits__pop_8_tab[(x >> 8)] + _const_math__bits__pop_8_tab[(x & ((u16)(0xff)))])));
}
inline int math__bits__pure_v_but_overridden_by_c_ones_count_32(u32 x) {
	return math__bits__ones_count_32_default(x);
}
inline VV_LOC int math__bits__ones_count_32_default(u32 x) {
	return ((int)((u8)((u8)((u8)(_const_math__bits__pop_8_tab[(x >> 24)] + _const_math__bits__pop_8_tab[(((x >> 16)) & 0xff)]) + _const_math__bits__pop_8_tab[(((x >> 8)) & 0xff)]) + _const_math__bits__pop_8_tab[(x & ((u32)(0xff)))])));
}
inline int math__bits__pure_v_but_overridden_by_c_ones_count_64(u64 x) {
	return math__bits__ones_count_64_default(x);
}
VV_LOC int math__bits__ones_count_64_default(u64 x) {
	u64 y = (u64)(((((x >> ((u64)(1)))) & ((_const_math__bits__m0 & _const_max_u64)))) + ((x & ((_const_math__bits__m0 & _const_max_u64)))));
	y = (u64)(((((y >> ((u64)(2)))) & ((_const_math__bits__m1 & _const_max_u64)))) + ((y & ((_const_math__bits__m1 & _const_max_u64)))));
	y = (((u64)(((y >> 4)) + y)) & ((_const_math__bits__m2 & _const_max_u64)));
	y += (y >> 8);
	y += (y >> 16);
	y += (y >> 32);
	return (((int)(y)) & 127);
}
inline u8 math__bits__rotate_left_8(u8 x, int k) {
	u8 s = (((u8)(k)) & ((u8)(_const_math__bits__n8 - ((u8)(1)))));
	return (((x << s)) | ((x >> ((u8)(_const_math__bits__n8 - s)))));
}
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 s = (((u16)(k)) & ((u16)(_const_math__bits__n16 - ((u16)(1)))));
	return (((x << s)) | ((x >> ((u16)(_const_math__bits__n16 - s)))));
}
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 s = (((u32)(k)) & ((u32)(_const_math__bits__n32 - ((u32)(1)))));
	return (((x << s)) | ((x >> ((u32)(_const_math__bits__n32 - s)))));
}
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 s = (((u64)(k)) & ((u64)(_const_math__bits__n64 - ((u64)(1)))));
	return (((x << s)) | ((x >> ((u64)(_const_math__bits__n64 - s)))));
}
inline u8 math__bits__reverse_8(u8 x) {
	return _const_math__bits__rev_8_tab[x];
}
inline u16 math__bits__reverse_16(u16 x) {
	return (((u16)(_const_math__bits__rev_8_tab[(x >> 8)])) | ((((u16)(_const_math__bits__rev_8_tab[(x & ((u16)(0xff)))])) << 8)));
}
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = ((((((x >> ((u32)(1)))) & ((_const_math__bits__m0 & _const_max_u32)))) | ((((x & ((_const_math__bits__m0 & _const_max_u32)))) << 1))));
	y = ((((((y >> ((u32)(2)))) & ((_const_math__bits__m1 & _const_max_u32)))) | ((((y & ((_const_math__bits__m1 & _const_max_u32)))) << ((u32)(2))))));
	y = ((((((y >> ((u32)(4)))) & ((_const_math__bits__m2 & _const_max_u32)))) | ((((y & ((_const_math__bits__m2 & _const_max_u32)))) << ((u32)(4))))));
	return math__bits__reverse_bytes_32(((u32)(y)));
}
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((((x >> ((u64)(1)))) & ((_const_math__bits__m0 & _const_max_u64)))) | ((((x & ((_const_math__bits__m0 & _const_max_u64)))) << 1))));
	y = ((((((y >> ((u64)(2)))) & ((_const_math__bits__m1 & _const_max_u64)))) | ((((y & ((_const_math__bits__m1 & _const_max_u64)))) << 2))));
	y = ((((((y >> ((u64)(4)))) & ((_const_math__bits__m2 & _const_max_u64)))) | ((((y & ((_const_math__bits__m2 & _const_max_u64)))) << 4))));
	return math__bits__reverse_bytes_64(y);
}
inline u16 math__bits__reverse_bytes_16(u16 x) {
	return (((x >> 8)) | ((x << 8)));
}
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = ((((((x >> ((u32)(8)))) & ((_const_math__bits__m3 & _const_max_u32)))) | ((((x & ((_const_math__bits__m3 & _const_max_u32)))) << ((u32)(8))))));
	return ((u32)((((y >> 16)) | ((y << 16)))));
}
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((((x >> ((u64)(8)))) & ((_const_math__bits__m3 & _const_max_u64)))) | ((((x & ((_const_math__bits__m3 & _const_max_u64)))) << ((u64)(8))))));
	y = ((((((y >> ((u64)(16)))) & ((_const_math__bits__m4 & _const_max_u64)))) | ((((y & ((_const_math__bits__m4 & _const_max_u64)))) << ((u64)(16))))));
	return (((y >> 32)) | ((y << 32)));
}
int math__bits__len_8(u8 x) {
	return ((int)(_const_math__bits__len_8_tab[x]));
}
int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 256) {
		y >>= 8;
		n = 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[y])));
}
int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= 65536) {
		y >>= 16;
		n = 16;
	}
	if (y >= 256) {
		y >>= 8;
		n += 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[y])));
}
int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= (((u64)(1)) << ((u64)(32)))) {
		y >>= 32;
		n = 32;
	}
	if (y >= (((u64)(1)) << ((u64)(16)))) {
		y >>= 16;
		n += 16;
	}
	if (y >= (((u64)(1)) << ((u64)(8)))) {
		y >>= 8;
		n += 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[y])));
}
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = (u64)((u64)(((u64)(x)) + ((u64)(y))) + ((u64)(carry)));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)((sum64 >> 32)));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = (u64)((u64)(x + y) + carry);
	u64 carry_out = (((((x & y)) | ((((x | y)) & ~sum)))) >> 63);
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = (u32)((u32)(x - y) - borrow);
	u32 borrow_out = (((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31);
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = (u64)((u64)(x - y) - borrow);
	u64 borrow_out = (((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63);
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}
inline multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	return math__bits__mul_32_default(x, y);
}
inline VV_LOC multi_return_u32_u32 math__bits__mul_32_default(u32 x, u32 y) {
	u64 tmp = (u64)(((u64)(x)) * ((u64)(y)));
	u32 hi = ((u32)((tmp >> 32)));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}
inline multi_return_u64_u64 math__bits__pure_v_but_overridden_by_arm64_mul_64(u64 x, u64 y) {
	return math__bits__mul_64_default(x, y);
}
VV_LOC multi_return_u64_u64 math__bits__mul_64_default(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = (x >> 32);
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = (y >> 32);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32)));
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = (t >> 32);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32)));
	u64 lo = (u64)(x * y);
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}
inline multi_return_u32_u32 math__bits__mul_add_32(u32 x, u32 y, u32 z) {
	return math__bits__mul_add_32_default(x, y, z);
}
inline VV_LOC multi_return_u32_u32 math__bits__mul_add_32_default(u32 x, u32 y, u32 z) {
	u64 tmp = (u64)((u64)(((u64)(x)) * ((u64)(y))) + ((u64)(z)));
	u32 hi = ((u32)((tmp >> 32)));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}
inline multi_return_u64_u64 math__bits__pure_v_but_overridden_by_arm64_mul_add_64(u64 x, u64 y, u64 z) {
	return math__bits__mul_add_64_default(x, y, z);
}
inline VV_LOC multi_return_u64_u64 math__bits__mul_add_64_default(u64 x, u64 y, u64 z) {
	multi_return_u64_u64 mr_15516 = math__bits__mul_64(x, y);
	u64 h = mr_15516.arg0;
	u64 l = mr_15516.arg1;
	u64 lo = (u64)(l + z);
	u64 hi = (u64)(h + (u64[]){(lo < l)?1:0}[0]);
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}
inline multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	return math__bits__div_32_default(hi, lo, y);
}
VV_LOC multi_return_u32_u32 math__bits__div_32_default(u32 hi, u32 lo, u32 y) {
	if (y != 0 && y <= hi) {
		builtin___v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u64 z = (((((u64)(hi)) << 32)) | ((u64)(lo)));
	u32 quo = ((u32)((u64)(z / ((u64)(y)))));
	u32 rem = ((u32)((u64)(z % ((u64)(y)))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}
inline multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	return math__bits__div_64_default(hi, lo, y1);
}
VV_LOC multi_return_u64_u64 math__bits__div_64_default(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0) {
		builtin___v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	if (y <= hi) {
		builtin___v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = (y >> 32);
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 ss1 = ((hi << s));
	u32 xxx = (u32)(64 - s);
	u64 ss2 = (lo >> xxx);
	if (xxx == 64) {
		ss2 = 0;
	}
	u64 un32 = (ss1 | ss2);
	u64 un10 = (lo << s);
	u64 un1 = (un10 >> 32);
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = (u64)(un32 / yn1);
	u64 rhat = (u64)(un32 - ((u64)(q1 * yn1)));
	for (;;) {
		if (!(q1 >= _const_math__bits__two32 || ((u64)(q1 * yn0)) > ((u64)(((u64)(_const_math__bits__two32 * rhat)) + un1)))) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = (u64)(((u64)(un32 * _const_math__bits__two32)) + ((u64)(un1 - ((u64)(q1 * y)))));
	u64 q0 = (u64)(un21 / yn1);
	rhat = (u64)(un21 - (u64)(q0 * yn1));
	for (;;) {
		if (!(q0 >= _const_math__bits__two32 || ((u64)(q0 * yn0)) > ((u64)(((u64)(_const_math__bits__two32 * rhat)) + un0)))) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 qq = ((u64)(((u64)(q1 * _const_math__bits__two32)) + q0));
	u64 rr = (((u64)((u64)(((u64)(un21 * _const_math__bits__two32)) + un0) - ((u64)(q0 * y)))) >> s);
	return (multi_return_u64_u64){.arg0=qq, .arg1=rr};
}
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	return ((u32)((u64)(((((((u64)(hi)) << 32)) | ((u64)(lo)))) % ((u64)(y)))));
}
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_19031 = math__bits__div_64((u64)(hi % y), lo, y);
	u64 rem = mr_19031.arg1;
	return rem;
}
multi_return_f64_int math__bits__normalize(f64 x) {
	f64 smallest_normal = 2.2250738585072014e-308;
	if (((x > ((f64)(0.0)) ? (x) : (-x))) < smallest_normal) {
		return (multi_return_f64_int){.arg0=(f64)(x * ((((u64)(1)) << ((u64)(52))))), .arg1=-52};
	}
	return (multi_return_f64_int){.arg0=x, .arg1=0};
}
inline u32 math__bits__f32_bits(f32 f) {
	u32 p = *((u32*)(&f));
	return p;
}
inline f32 math__bits__f32_from_bits(u32 b) {
	f32 p = *((f32*)(&b));
	return p;
}
inline u64 math__bits__f64_bits(f64 f) {
	u64 p = *((u64*)(&f));
	return p;
}
inline f64 math__bits__f64_from_bits(u64 b) {
	f64 p = *((f64*)(&b));
	return p;
}
VV_LOC multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r0 = (((s0 >> 1)) | ((((s1 & ((u32)(1)))) << 31)));
	r1 = (((s1 >> 1)) | ((((s2 & ((u32)(1)))) << 31)));
	r2 = (s2 >> 1);
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}
VV_LOC multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	r2 = (((s2 << 1)) | ((((s1 & ((((u32)(1)) << 31)))) >> 31)));
	r1 = (((s1 << 1)) | ((((s0 & ((((u32)(1)) << 31)))) >> 31)));
	r0 = (s0 << 1);
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}
VV_LOC multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0));
	u32 r0 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r2 = ((u32)(0));
	w = (u64)(((u64)(s0)) + ((u64)(d0)));
	r0 = ((u32)(w));
	w >>= 32;
	w += (u64)(((u64)(s1)) + ((u64)(d1)));
	r1 = ((u32)(w));
	w >>= 32;
	w += (u64)(((u64)(s2)) + ((u64)(d2)));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}
VV_LOC multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s) {
	int digx = 0;
	strconv__ParserState result = strconv__ParserState__ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = ((strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,});
	for (;;) {
		if (!(i < s.len && builtin__u8_is_space(s.str[ i]))) break;
		i++;
	}
	if (s.str[ i] == '-') {
		pn.negative = true;
		i++;
	}
	if (s.str[ i] == '+') {
		i++;
	}
	for (;;) {
		if (!(i < s.len && builtin__u8_is_digit(s.str[ i]))) break;
		if (digx < 18) {
			pn.mantissa *= 10;
			pn.mantissa += ((u64)((rune)(s.str[ i] - _const_strconv__c_zero)));
			digx++;
		} else if (pn.exponent < 2147483647) {
			pn.exponent++;
		}
		i++;
	}
	if (i < s.len && s.str[ i] == '.') {
		i++;
		for (;;) {
			if (!(i < s.len && builtin__u8_is_digit(s.str[ i]))) break;
			if (digx < 18) {
				pn.mantissa *= 10;
				pn.mantissa += ((u64)((rune)(s.str[ i] - _const_strconv__c_zero)));
				pn.exponent--;
				digx++;
			}
			i++;
		}
	}
	if (i < s.len && (s.str[ i] == 'e' || s.str[ i] == 'E')) {
		i++;
		if (i < s.len) {
			if (s.str[ i] == _const_strconv__c_plus) {
				i++;
			} else if (s.str[ i] == _const_strconv__c_minus) {
				expneg = true;
				i++;
			}
			for (;;) {
				if (!(i < s.len && builtin__u8_is_digit(s.str[ i]))) break;
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)((rune)(s.str[ i] - _const_strconv__c_zero)));
				}
				i++;
			}
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = strconv__ParserState__minf;
		} else {
			result = strconv__ParserState__pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	}
	if (i == 0 && s.len > 0) {
		return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=strconv__ParserState__invalid_number, .arg1=pn};
	}
	if (i != s.len) {
		return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=strconv__ParserState__extra_char, .arg1=pn};
	}
	return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=result, .arg1=pn};
}
VV_LOC u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0));
	u32 s1 = ((u32)(0));
	u32 s0 = ((u32)(0));
	u32 q2 = ((u32)(0));
	u32 q1 = ((u32)(0));
	u32 q0 = ((u32)(0));
	u32 r2 = ((u32)(0));
	u32 r1 = ((u32)(0));
	u32 r0 = ((u32)(0));
	u32 mask28 = ((u32)((((u64)(0xF)) << 28)));
	u64 result = ((u64)(0));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)((pn->mantissa >> 32)));
	s2 = ((u32)(0));
	if (pn->mantissa == 0 && pn->exponent <= 0) {
		return (pn->negative ? (_const_strconv__double_minus_zero) : (_const_strconv__double_plus_zero));
	}
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_5729 = strconv__lsl96(s2, s1, s0);
		q2 = mr_5729.arg0;
		q1 = mr_5729.arg1;
		q0 = mr_5729.arg2;
		multi_return_u32_u32_u32 mr_5775 = strconv__lsl96(q2, q1, q0);
		r2 = mr_5775.arg0;
		r1 = mr_5775.arg1;
		r0 = mr_5775.arg2;
		multi_return_u32_u32_u32 mr_5831 = strconv__lsl96(r2, r1, r0);
		s2 = mr_5831.arg0;
		s1 = mr_5831.arg1;
		s0 = mr_5831.arg2;
		multi_return_u32_u32_u32 mr_5887 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_5887.arg0;
		s1 = mr_5887.arg1;
		s0 = mr_5887.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0)) break;
			multi_return_u32_u32_u32 mr_6010 = strconv__lsr96(s2, s1, s0);
			q2 = mr_6010.arg0;
			q1 = mr_6010.arg1;
			q0 = mr_6010.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & ((((u32)(1)) << 31)))) != 0))) break;
			multi_return_u32_u32_u32 mr_6157 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6157.arg0;
			q1 = mr_6157.arg1;
			q0 = mr_6157.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = (u32)(s2 / _const_strconv__c_ten);
		r1 = (u32)(s2 % _const_strconv__c_ten);
		r2 = (((s1 >> 8)) | ((r1 << 24)));
		q1 = (u32)(r2 / _const_strconv__c_ten);
		r1 = (u32)(r2 % _const_strconv__c_ten);
		r2 = ((((((s1 & ((u32)(0xFF)))) << 16)) | ((s0 >> 16))) | ((r1 << 24)));
		r0 = (u32)(r2 / _const_strconv__c_ten);
		r1 = (u32)(r2 % _const_strconv__c_ten);
		q1 = (((q1 << 8)) | ((((r0 & ((u32)(0x00FF0000)))) >> 16)));
		q0 = (r0 << 16);
		r2 = (((s0 & ((u32)(0xFFFF)))) | ((r1 << 16)));
		q0 |= (u32)(r2 / _const_strconv__c_ten);
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0 || s1 != 0 || s0 != 0) {
		for (;;) {
			if (!(((s2 & mask28)) == 0)) break;
			multi_return_u32_u32_u32 mr_6837 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6837.arg0;
			q1 = mr_6837.arg1;
			q0 = mr_6837.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	if (binexp < -1022 && ((s2 | s1)) != 0) {
		int shift = (int)(-1022 - binexp);
		if (shift > 60) {
			return (pn->negative ? (_const_strconv__double_minus_zero) : (_const_strconv__double_plus_zero));
		}
		u64 shifted = (((((((u64)(s2)) << 32)) | ((u64)(s1)))) >> ((u32)(shift)));
		u64 q = (u64)(((shifted >> 8)) + (u64[]){((((shifted >> 7)) & 1) != 0 && (((shifted & 0x7F)) != 0 || (((shifted >> 8)) & 1) != 0))?1:0}[0]);
		return (((q & 0x000FFFFFFFFFFFFFLL)) | (((u64[]){(pn->negative)?1:0}[0] << 63)));
	}
	int nbit = 7;
	u32 check_round_bit = (((u32)(1)) << ((u32)(nbit)));
	u32 check_round_mask = (((u32)(0xFFFFFFFFU)) << ((u32)(nbit)));
	if (((s1 & check_round_bit)) != 0) {
		if (((s1 & ~check_round_mask)) != 0) {
			multi_return_u32_u32_u32 mr_9030 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
			s2 = mr_9030.arg0;
			s1 = mr_9030.arg1;
			s0 = mr_9030.arg2;
		} else {
			if (((s1 & ((check_round_bit << ((u32)(1)))))) != 0) {
				multi_return_u32_u32_u32 mr_9224 = strconv__add96(s2, s1, s0, 0, check_round_bit, 0);
				s2 = mr_9224.arg0;
				s1 = mr_9224.arg1;
				s0 = mr_9224.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0));
		if ((s2 & ((mask28 << ((u32)(1))))) != 0) {
			multi_return_u32_u32_u32 mr_9431 = strconv__lsr96(s2, s1, s0);
			q2 = mr_9431.arg0;
			q1 = mr_9431.arg1;
			q0 = mr_9431.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0) {
		u64 q = ((u64)(0));
		u64 binexs2 = (((u64)(binexp)) << 52);
		q = ((((((u64)((s2 & ~mask28))) << 24)) | ((((u64)(((u64)(s1)) + ((u64)(128)))) >> 8))) | binexs2);
		if (pn->negative) {
			q |= ((((u64)(1)) << 63));
		}
		result = q;
	}
	return result;
}
_result_f64 strconv__atof64(string s, strconv__AtoF64Param param) {
	if (s.len == 0) {
		return (_result_f64){ .is_error=true, .err=builtin___v_error(_S("expected a number found an empty string")), .data={E_STRUCT} };
	}
	strconv__Float64u res = ((strconv__Float64u){0});
	multi_return_strconv__ParserState_strconv__PrepNumber mr_10716 = strconv__parser(s);
	strconv__ParserState res_parsing = mr_10716.arg0;
	strconv__PrepNumber pn = mr_10716.arg1;
	switch (res_parsing) {
		case strconv__ParserState__ok: {
			res.u = strconv__converter((voidptr)&pn);
			break;
		}
		case strconv__ParserState__pzero: {
			res.u = _const_strconv__double_plus_zero;
			break;
		}
		case strconv__ParserState__mzero: {
			res.u = _const_strconv__double_minus_zero;
			break;
		}
		case strconv__ParserState__pinf: {
			res.u = _const_strconv__double_plus_infinity;
			break;
		}
		case strconv__ParserState__minf: {
			res.u = _const_strconv__double_minus_infinity;
			break;
		}
		case strconv__ParserState__extra_char: {
			if (param.allow_extra_chars) {
				res.u = strconv__converter((voidptr)&pn);
			} else {
				return (_result_f64){ .is_error=true, .err=builtin___v_error(_S("extra char after number")), .data={E_STRUCT} };
			}
			break;
		}
		case strconv__ParserState__invalid_number: {
			return (_result_f64){ .is_error=true, .err=builtin___v_error(_S("not a number")), .data={E_STRUCT} };
		}
	}
	
	_result_f64 _t4;
	builtin___result_ok(&(f64[]) { res.f }, (_result*)(&_t4), sizeof(f64));
	 
	return _t4;
}
f64 strconv__atof_quick(string s) {
	strconv__Float64u f = ((strconv__Float64u){0});
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && s.str[ i] == ' ')) break;
		i++;
	}
	if (i < s.len) {
		if (s.str[ i] == '-') {
			sign = -1.0;
			i++;
		} else if (s.str[ i] == '+') {
			i++;
		}
	}
	if (s.str[ i] == 'i' && (int)(i + 2) < s.len && s.str[ (int)(i + 1)] == 'n' && s.str[ (int)(i + 2)] == 'f') {
		if (sign > ((f64)(0.0))) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && s.str[ i] == '0')) break;
		i++;
		if (i >= s.len) {
			if (sign > ((f64)(0.0))) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)((rune)(s.str[ i] - '0')));
		i++;
	}
	if (i < s.len && s.str[ i] == '.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
			f.f += (f64)(((f64)((rune)(s.str[ i] - '0'))) * frac_mul);
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (s.str[ i] == 'e' || s.str[ i] == 'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (s.str[ i] == '-') {
				exp_sign = -1;
				i++;
			} else if (s.str[ i] == '+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && s.str[ i] == '0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
			exp *= 10;
			exp += ((int)((rune)(s.str[ i] - '0')));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > 309) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = _const_strconv__pos_exp[exp],});
			f.f = (f64)(f.f * tmp_mul.f);
		} else {
			if (exp > 324) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = _const_strconv__neg_exp[exp],});
			f.f = (f64)(f.f * tmp_mul.f);
		}
	}
	{ // Unsafe block
		f.f = (f64)(f.f * sign);
		return f.f;
	}
	return 0;
}
inline u8 strconv__byte_to_lower(u8 c) {
	return (c | 32);
}
_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_730 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_730.arg0;
	int err = mr_730.arg1;
	if (err != 0 && (error_on_non_digit || error_on_high_digit)) {
		switch (err) {
			case -1: {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("common_parse_uint: wrong base "), 0xfe07, {.d_i32 = _base}}, {_S(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			case -2: {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("common_parse_uint: wrong bit size "), 0xfe07, {.d_i32 = _bit_size}}, {_S(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			case -3: {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("common_parse_uint: integer overflow "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			default: {
				{
					return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("common_parse_uint: syntax error "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
				}
			}
		}
		
	}
	_result_u64 _t5;
	builtin___result_ok(&(u64[]) { result }, (_result*)(&_t5), sizeof(u64));
	 
	return _t5;
}
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	if ((s).len == 0) {
		return (multi_return_u64_int){.arg0=((u64)(0)), .arg1=1};
	}
	int bit_size = _bit_size;
	int base = _base;
	int start_index = 0;
	if (base == 0) {
		base = 10;
		if (s.str[ 0] == '0') {
			u8 ch = (s.len > 1 ? ((s.str[ 1] | 32)) : ('0'));
			if (s.len >= 3) {
				if (ch == 'b') {
					base = 2;
					start_index += 2;
				} else if (ch == 'o') {
					base = 8;
					start_index += 2;
				} else if (ch == 'x') {
					base = 16;
					start_index += 2;
				}
				if (s.str[ start_index] == '_') {
					start_index++;
				}
			} else if (s.len >= 2 && (s.str[ 1] >= '0' && s.str[ 1] <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0)), .arg1=-2};
	}
	u64 cutoff = (u64)((u64)(_const_max_u64 / ((u64)(base))) + ((u64)(1)));
	u64 max_val = (bit_size == 64 ? (_const_max_u64) : ((u64)(((((u64)(1)) << ((u64)(bit_size)))) - ((u64)(1)))));
	int basem1 = (int)(base - 1);
	u64 n = ((u64)(0));
	for (int i = start_index; i < s.len; ++i) {
		u8 c = s.str[ i];
		if (c == '_') {
			if (i == start_index || i >= ((int)(s.len - 1))) {
				return (multi_return_u64_int){.arg0=((u64)(0)), .arg1=1};
			}
			if (s.str[ (int)(i - 1)] == '_' || s.str[ (int)(i + 1)] == '_') {
				return (multi_return_u64_int){.arg0=((u64)(0)), .arg1=1};
			}
			continue;
		}
		int sub_count = 0;
		c -= 48;
		if (c >= 17) {
			sub_count++;
			c -= 7;
			if (c >= 42) {
				sub_count++;
				c -= 32;
			}
		}
		if (c > basem1 || (sub_count == 0 && c > 9)) {
			return (multi_return_u64_int){.arg0=n, .arg1=(int)(i + 1)};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = (u64)(n + ((u64)(c)));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}
_result_u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	if ((_s).len == 0) {
		_result_i64 _t1;
		builtin___result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t1), sizeof(i64));
		 
		return _t1;
	}
	int bit_size = _bit_size;
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	string s = _s;
	bool neg = false;
	if (s.str[ 0] == '+') {
		{ // Unsafe block
			s = builtin__tos(s.str + 1, (int)(s.len - 1));
		}
	} else if (s.str[ 0] == '-') {
		neg = true;
		{ // Unsafe block
			s = builtin__tos(s.str + 1, (int)(s.len - 1));
		}
	}
	_result_u64 _t2 = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (_t2.is_error) {
		_result_i64 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	u64 un = (*(u64*)_t2.data);
	if (un == 0) {
		_result_i64 _t4;
		builtin___result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t4), sizeof(i64));
		 
		return _t4;
	}
	u64 cutoff = (((u64)(1)) << ((u64)((int)(bit_size - 1))));
	if (!neg && un >= cutoff) {
		_result_i64 _t5;
		builtin___result_ok(&(i64[]) { ((i64)((u64)(cutoff - ((u64)(1))))) }, (_result*)(&_t5), sizeof(i64));
		 
		return _t5;
	}
	if (neg && un > cutoff) {
		_result_i64 _t6;
		builtin___result_ok(&(i64[]) { -((i64)(cutoff)) }, (_result*)(&_t6), sizeof(i64));
		 
		return _t6;
	}
	_result_i64 _t8; /* if prepend */
	if (neg) {
		builtin___result_ok(&(i64[]) { -((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
		goto _t9;
	};
	{
		builtin___result_ok(&(i64[]) { ((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
	}
	_t9: {};
		return _t8;
}
_result_i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}
VV_LOC _result_multi_return_i64_int strconv__atoi_common_check(string s) {
	if ((s).len == 0) {
		return (_result_multi_return_i64_int){ .is_error=true, .err=builtin___v_error(_S("strconv.atoi: parsing \"\": empty string")), .data={E_STRUCT} };
	}
	int start_idx = 0;
	i64 sign = ((i64)(1));
	if (s.str[ 0] == '-' || s.str[ 0] == '+') {
		start_idx++;
		if (s.str[ 0] == '-') {
			sign = -1;
		}
	}
	if ((int)(s.len - start_idx) < 1) {
		return (_result_multi_return_i64_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": no number after sign"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (s.str[ start_idx] == '_' || s.str[ (int)(s.len - 1)] == '_') {
		return (_result_multi_return_i64_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": values cannot start or end with underscores"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_multi_return_i64_int _t4;
	builtin___result_ok(&(multi_return_i64_int[]) { (multi_return_i64_int){.arg0=sign, .arg1=start_idx} }, (_result*)(&_t4), sizeof(multi_return_i64_int));
	return _t4;
}
VV_LOC _result_i64 strconv__atoi_common(string s, i64 type_min, i64 type_max) {
	_result_multi_return_i64_int _t1 = strconv__atoi_common_check(s);
	if (_t1.is_error) {
		_result_i64 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	multi_return_i64_int mr_7367 = (*(multi_return_i64_int*)_t1.data);
	i64 sign = mr_7367.arg0;
	int start_idx = mr_7367.arg1;
	i64 x = ((i64)(0));
	bool underscored = false;
	for (int i = start_idx; i < s.len; ++i) {
		rune c = (rune)(s.str[ i] - '0');
		if (c == 47) {
			if (underscored == true) {
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": consecutives underscores are not allowed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = true;
			continue;
		} else {
			if (c > 9) {
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": invalid radix 10 character"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = false;
			x = (i64)(((i64)(x * 10)) + ((i64)(c * sign)));
			if (sign == 1 && x > type_max) {
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": integer overflow"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			} else {
				if (x < type_min) {
					return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": integer underflow"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
				}
			}
		}
	}
	_result_i64 _t7;
	builtin___result_ok(&(i64[]) { x }, (_result*)(&_t7), sizeof(i64));
	 
	return _t7;
}
_result_int strconv__atoi(string s) {
	_result_i64 _t2 = strconv__atoi_common(s, _const_strconv__i64_min_int32, _const_strconv__i64_max_int32);
	if (_t2.is_error) {
		_result_int _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_int _t1;
	builtin___result_ok(&(int[]) { ((int)((*(i64*)_t2.data))) }, (_result*)(&_t1), sizeof(int));
	 
	return _t1;
}
_result_i8 strconv__atoi8(string s) {
	_result_i64 _t2 = strconv__atoi_common(s, _const_min_i8, _const_max_i8);
	if (_t2.is_error) {
		_result_i8 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_i8 _t1;
	builtin___result_ok(&(i8[]) { ((i8)((*(i64*)_t2.data))) }, (_result*)(&_t1), sizeof(i8));
	 
	return _t1;
}
_result_i16 strconv__atoi16(string s) {
	_result_i64 _t2 = strconv__atoi_common(s, _const_min_i16, _const_max_i16);
	if (_t2.is_error) {
		_result_i16 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_i16 _t1;
	builtin___result_ok(&(i16[]) { ((i16)((*(i64*)_t2.data))) }, (_result*)(&_t1), sizeof(i16));
	 
	return _t1;
}
_result_i32 strconv__atoi32(string s) {
	_result_i64 _t2 = strconv__atoi_common(s, _const_min_i32, _const_max_i32);
	if (_t2.is_error) {
		_result_i32 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_i32 _t1;
	builtin___result_ok(&(i32[]) { ((i32)((*(i64*)_t2.data))) }, (_result*)(&_t1), sizeof(i32));
	 
	return _t1;
}
_result_i64 strconv__atoi64(string s) {
	_result_multi_return_i64_int _t1 = strconv__atoi_common_check(s);
	if (_t1.is_error) {
		_result_i64 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	multi_return_i64_int mr_9119 = (*(multi_return_i64_int*)_t1.data);
	i64 sign = mr_9119.arg0;
	int start_idx = mr_9119.arg1;
	i64 x = ((i64)(0));
	bool underscored = false;
	for (int i = start_idx; i < s.len; ++i) {
		rune c = (rune)(s.str[ i] - '0');
		if (c == 47) {
			if (underscored == true) {
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi64: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": consecutives underscores are not allowed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = true;
			continue;
		} else {
			if (c > 9) {
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atoi64: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": invalid radix 10 character"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = false;
			_result_i64 _t5 = strconv__safe_mul10_64bits(x);
			if (_t5.is_error) {
				IError err = _t5.err;
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("strconv.atoi64: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			
 			x = (*(i64*)_t5.data);
			_result_i64 _t7 = strconv__safe_add_64bits(x, ((int)((i64)(c * sign))));
			if (_t7.is_error) {
				IError err = _t7.err;
				return (_result_i64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("strconv.atoi64: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			
 			x = (*(i64*)_t7.data);
		}
	}
	_result_i64 _t9;
	builtin___result_ok(&(i64[]) { x }, (_result*)(&_t9), sizeof(i64));
	 
	return _t9;
}
inline VV_LOC _result_i64 strconv__safe_add_64bits(i64 a, i64 b) {
	if (a > 0 && b > ((i64)(_const_max_i64 - a))) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("integer overflow")), .data={E_STRUCT} };
	} else if (a < 0 && b < ((i64)(_const_min_i64 - a))) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("integer underflow")), .data={E_STRUCT} };
	}
	_result_i64 _t3;
	builtin___result_ok(&(i64[]) { (i64)(a + b) }, (_result*)(&_t3), sizeof(i64));
	 
	return _t3;
}
inline VV_LOC _result_i64 strconv__safe_mul10_64bits(i64 a) {
	if (a > 0 && a > ((i64)(_const_max_i64 / 10))) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("integer overflow")), .data={E_STRUCT} };
	}
	if (a < 0 && a < ((i64)(_const_min_i64 / 10))) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("integer underflow")), .data={E_STRUCT} };
	}
	_result_i64 _t3;
	builtin___result_ok(&(i64[]) { (i64)(a * 10) }, (_result*)(&_t3), sizeof(i64));
	 
	return _t3;
}
VV_LOC _result_int strconv__atou_common_check(string s) {
	if ((s).len == 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("strconv.atou: parsing \"\": empty string")), .data={E_STRUCT} };
	}
	int start_idx = 0;
	if (s.str[ 0] == '-') {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("strconv.atou: parsing \"{s}\" : negative value")), .data={E_STRUCT} };
	}
	if (s.str[ 0] == '+') {
		start_idx++;
	}
	if ((int)(s.len - start_idx) < 1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atou: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": no number after sign"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (s.str[ start_idx] == '_' || s.str[ (int)(s.len - 1)] == '_') {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atou: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": values cannot start or end with underscores"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_int _t5;
	builtin___result_ok(&(int[]) { start_idx }, (_result*)(&_t5), sizeof(int));
	 
	return _t5;
}
VV_LOC _result_u64 strconv__atou_common(string s, u64 type_max) {
	_result_int _t1 = strconv__atou_common_check(s);
	if (_t1.is_error) {
		_result_u64 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	int start_idx = ((int)((*(int*)_t1.data)));
	u64 x = ((u64)(0));
	bool underscored = false;
	for (int i = start_idx; i < s.len; ++i) {
		rune c = (rune)(s.str[ i] - '0');
		if (c == 47) {
			if (underscored == true) {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atou: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": consecutives underscores are not allowed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = true;
			continue;
		} else {
			if (c > 9) {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atou: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": invalid radix 10 character"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			underscored = false;
			u64 oldx = x;
			x = (u64)(((u64)(x * 10)) + ((u64)(c)));
			if (x > type_max || oldx > x) {
				return (_result_u64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("strconv.atou: parsing \""), 0xfe10, {.d_s = s}}, {_S("\": integer overflow"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
		}
	}
	_result_u64 _t6;
	builtin___result_ok(&(u64[]) { x }, (_result*)(&_t6), sizeof(u64));
	 
	return _t6;
}
_result_u8 strconv__atou8(string s) {
	_result_u64 _t2 = strconv__atou_common(s, _const_max_u8);
	if (_t2.is_error) {
		_result_u8 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_u8 _t1;
	builtin___result_ok(&(u8[]) { ((u8)((*(u64*)_t2.data))) }, (_result*)(&_t1), sizeof(u8));
	 
	return _t1;
}
_result_u16 strconv__atou16(string s) {
	_result_u64 _t2 = strconv__atou_common(s, _const_max_u16);
	if (_t2.is_error) {
		_result_u16 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_u16 _t1;
	builtin___result_ok(&(u16[]) { ((u16)((*(u64*)_t2.data))) }, (_result*)(&_t1), sizeof(u16));
	 
	return _t1;
}
_result_u32 strconv__atou(string s) {
	_result_u64 _t2 = strconv__atou_common(s, _const_max_u32);
	if (_t2.is_error) {
		_result_u32 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_u32 _t1;
	builtin___result_ok(&(u32[]) { ((u32)((*(u64*)_t2.data))) }, (_result*)(&_t1), sizeof(u32));
	 
	return _t1;
}
_result_u32 strconv__atou32(string s) {
	_result_u64 _t2 = strconv__atou_common(s, _const_max_u32);
	if (_t2.is_error) {
		_result_u32 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_u32 _t1;
	builtin___result_ok(&(u32[]) { ((u32)((*(u64*)_t2.data))) }, (_result*)(&_t1), sizeof(u32));
	 
	return _t1;
}
_result_u64 strconv__atou64(string s) {
	_result_u64 _t2 = strconv__atou_common(s, _const_max_u64);
	if (_t2.is_error) {
		_result_u64 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_u64 _t1;
	builtin___result_ok(&(u64[]) { ((u64)((*(u64*)_t2.data))) }, (_result*)(&_t1), sizeof(u64));
	 
	return _t1;
}
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (int)(i_n_digit + 1);
	int pad_digit = (int)(i_pad_digit + 1);
	u32 out = d.m;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = builtin____new_array_with_default(((int)((int)((int)((int)(out_len + 5) + 1) + 1))), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		if (buf.data != 0) {
			((u8*)buf.data)[i] = '-';
		}
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u32)(_const_strconv__ten_pow_table_32[(int)((int)(out_len - n_digit) - 1)] * 5);
		out /= _const_strconv__ten_pow_table_32[(int)(out_len - n_digit)];
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10))));
		out /= 10;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return builtin__tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len > 1 || fw_zeros > 0) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		i++;
	}
	x++;
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d.e + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = 0;
	return builtin__tos(((u8*)(&((u8*)buf.data)[0])), i);
}
VV_LOC multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = ((strconv__Dec32){.m = 0,.e = 0,});
	u32 e = (u32)(exp - 127);
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = (u32)(_const_strconv__mantbits32 - e);
	u32 mant = (i_mant | 0x00800000);
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u32)(d.m % 10)) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}
VV_LOC strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0));
	if (exp == 0) {
		e2 = (int)((int)(-126 - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - 127) - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = (((((u32)(1)) << _const_strconv__mantbits32)) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u32 mv = ((u32)((u32)(4 * m2)));
	u32 mp = ((u32)((u32)((u32)(4 * m2) + 2)));
	u32 mm_shift = strconv__bool_to_u32(mant != 0 || exp <= 1);
	u32 mm = ((u32)((u32)((u32)((u32)(4 * m2) - 1) - mm_shift)));
	u32 vr = ((u32)(0));
	u32 vp = ((u32)(0));
	u32 vm = ((u32)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	u8 last_removed_digit = ((u8)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = (int)((int)(59 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0 && (u32)(((u32)(vp - 1)) / 10) <= (u32)(vm / 10)) {
			int l = (int)((int)(59 + strconv__pow5_bits(((int)((u32)(q - 1))))) - 1);
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_invdiv_pow2(mv, (u32)(q - 1), (int)((int)(-e2 + ((int)((u32)(q - 1)))) + l)) % 10)));
		}
		if (q <= 9) {
			if ((u32)(mv % 5) == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - 61);
		int j = (int)(((int)(q)) - k);
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0 && ((u32)(((u32)(vp - 1)) / 10)) <= (u32)(vm / 10)) {
			j = (int)((int)(((int)(q)) - 1) - ((int)(strconv__pow5_bits((int)(i + 1)) - 61)));
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_div_pow2(mv, ((u32)((int)(i + 1))), j) % 10)));
		}
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1;
			} else {
				vp--;
			}
		} else if (q < 31) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, (u32)(q - 1));
		}
	}
	int removed = 0;
	u32 out = ((u32)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!((u32)(vp / 10) > (u32)(vm / 10))) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && ((u32)(vm % 10)) == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)((u32)(vr % 10)));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!((u32)(vm % 10) == 0)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)((u32)(vr % 10)));
				vr /= 10;
				vp /= 10;
				vm /= 10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u32)(vr % 2)) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!((u32)(vp / 10) > (u32)(vm / 10))) break;
			last_removed_digit = ((u8)((u32)(vr % 10)));
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = (u32)(vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5));
	}
	return ((strconv__Dec32){.m = out,.e = (int)(e10 + removed),});
}
string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits32 + _const_strconv__expbits32)))) != 0;
	u32 mant = (u & ((u32)(((((u32)(1)) << _const_strconv__mantbits32)) - ((u32)(1)))));
	u32 exp = (((u >> _const_strconv__mantbits32)) & ((u32)(((((u32)(1)) << _const_strconv__expbits32)) - ((u32)(1)))));
	if (exp == 255 || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_8580 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8580.arg0;
	bool ok = mr_8580.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}
string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits32 + _const_strconv__expbits32)))) != 0;
	u32 mant = (u & ((u32)(((((u32)(1)) << _const_strconv__mantbits32)) - ((u32)(1)))));
	u32 exp = (((u >> _const_strconv__mantbits32)) & ((u32)(((((u32)(1)) << _const_strconv__expbits32)) - ((u32)(1)))));
	if (exp == 255 || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec32_bool mr_9314 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_9314.arg0;
	bool ok = mr_9314.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}
VV_LOC string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (i_n_digit < 1 ? (1) : ((int)(i_n_digit + 1)));
	int pad_digit = (int)(i_pad_digit + 1);
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = builtin____new_array_with_default(((int)((int)((int)((int)(out_len + 6) + 1) + 1) + fw_zeros)), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		((u8*)buf.data)[i] = '-';
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u64)(_const_strconv__ten_pow_table_64[(int)((int)(out_len - n_digit) - 1)] * 5);
		out /= _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)];
		u64 out_div = (u64)(d.m / _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)]);
		if (out_div < out && strconv__dec_digits(out_div) < strconv__dec_digits(out)) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10))));
		out /= 10;
		i++;
		x++;
	}
	if (out_len > 1 || fw_zeros > 0) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		i++;
	}
	x++;
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d_exp + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d2 = (int)(exp % 10);
	exp /= 10;
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	if (d0 > 0) {
		((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
		i++;
	}
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d2)));
	i++;
	((u8*)buf.data)[i] = 0;
	return builtin__tos(((u8*)(&((u8*)buf.data)[0])), i);
}
VV_LOC multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = ((strconv__Dec64){.m = 0,.e = 0,});
	u64 e = (u64)(exp - 1023);
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = (u64)(_const_strconv__mantbits64 - e);
	u64 mant = (i_mant | ((u64)(0x0010000000000000LL)));
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u64)(d.m % 10)) == 0)) break;
		d.m /= 10;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}
VV_LOC strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0));
	if (exp == 0) {
		e2 = (int)((int)(-1022 - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - 1023) - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = (((((u64)(1)) << _const_strconv__mantbits64)) | mant);
	}
	bool even = ((m2 & 1)) == 0;
	bool accept_bounds = even;
	u64 mv = ((u64)((u64)(4 * m2)));
	u64 mm_shift = strconv__bool_to_u64(mant != 0 || exp <= 1);
	u64 vr = ((u64)(0));
	u64 vp = ((u64)(0));
	u64 vm = ((u64)(0));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = (u32)(strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3));
		e10 = ((int)(q));
		int k = (int)((int)(122 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_inv_split_64_x[builtin__v_fixed_index((u32)(q * 2), 584)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4)) * m2), mul, i);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4)) * m2) + ((u64)(2))), mul, i);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4)) * m2) - ((u64)(1))) - mm_shift), mul, i);
		if (q <= 21) {
			if ((u64)(mv % 5) == 0) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64((u64)((u64)(mv - 1) - mm_shift), q);
			} else if (strconv__multiple_of_power_of_five_64((u64)(mv + 2), q)) {
				vp--;
			}
		}
	} else {
		u32 q = (u32)(strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1));
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - 121);
		int j = (int)(((int)(q)) - k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_split_64_x[builtin__v_fixed_index((int)(i * 2), 652)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4)) * m2), mul, j);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4)) * m2) + ((u64)(2))), mul, j);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4)) * m2) - ((u64)(1))) - mm_shift), mul, j);
		if (q <= 1) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1);
			} else {
				vp--;
			}
		} else if (q < 63) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, (u32)(q - 1));
		}
	}
	int removed = 0;
	u8 last_removed_digit = ((u8)(0));
	u64 out = ((u64)(0));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = (u64)(vp / 10);
			u64 vm_div_10 = (u64)(vm / 10);
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = (u64)(vm % 10);
			u64 vr_div_10 = (u64)(vr / 10);
			u64 vr_mod_10 = (u64)(vr % 10);
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = (u64)(vm / 10);
				u64 vm_mod_10 = (u64)(vm % 10);
				if (vm_mod_10 != 0) {
					break;
				}
				u64 vp_div_10 = (u64)(vp / 10);
				u64 vr_div_10 = (u64)(vr / 10);
				u64 vr_mod_10 = (u64)(vr % 10);
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u64)(vr % 2)) == 0) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!((u64)(vp / 100) > (u64)(vm / 100))) break;
			round_up = ((u64)(vr % 100)) >= 50;
			vr /= 100;
			vp /= 100;
			vm /= 100;
			removed += 2;
		}
		for (;;) {
			if (!((u64)(vp / 10) > (u64)(vm / 10))) break;
			round_up = ((u64)(vr % 10)) >= 5;
			vr /= 10;
			vp /= 10;
			vm /= 10;
			removed++;
		}
		out = (u64)(vr + strconv__bool_to_u64(vr == vm || round_up));
	}
	return ((strconv__Dec64){.m = out,.e = (int)(e10 + removed),});
}
string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0;
	u64 mant = (u & ((u64)(((((u64)(1)) << _const_strconv__mantbits64)) - ((u64)(1)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1)) << _const_strconv__expbits64)) - ((u64)(1)))));
	if (exp == 2047 || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_9590 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9590.arg0;
	bool ok = mr_9590.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}
string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0;
	u64 mant = (u & ((u64)(((((u64)(1)) << _const_strconv__mantbits64)) - ((u64)(1)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1)) << _const_strconv__expbits64)) - ((u64)(1)))));
	if (exp == 2047 || (exp == 0 && mant == 0)) {
		return strconv__get_string_special(neg, exp == 0, mant == 0);
	}
	multi_return_strconv__Dec64_bool mr_10371 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10371.arg0;
	bool ok = mr_10371.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}
string strconv__format_str(string s, strconv__BF_param p) {
	if (p.len0 <= 0) {
		return builtin__string_clone(s);
	}
	int dif = (int)(p.len0 - builtin__utf8_str_visible_length(s));
	if (dif <= 0) {
		return builtin__string_clone(s);
	}
	strings__Builder res = strings__new_builder((int)(s.len + dif));
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t3 = strings__Builder_str(&res);
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	return _t3;
}
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb) {
	if (p.len0 <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	int dif = (int)(p.len0 - builtin__utf8_str_visible_length(s));
	if (dif <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
	strings__Builder_write_string(sb, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
}
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res) {
	int n_char = strconv__dec_digits(d);
	int sign_len = (!p.positive || p.sign_flag ? (1) : (0));
	int number_len = (int)(sign_len + n_char);
	int dif = (int)(p.len0 - number_len);
	bool sign_written = false;
	if (p.align == strconv__Align_text__right) {
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(res, '+');
					sign_written = true;
				}
			} else {
				strings__Builder_write_u8(res, '-');
				sign_written = true;
			}
		}
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	if (!sign_written) {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(res, '+');
			}
		} else {
			strings__Builder_write_u8(res, '-');
		}
	}
	Array_fixed_u8_32 buf = {0};
	int i = 20;
	u64 n = d;
	u64 d_i = ((u64)(0));
	if (n > 0) {
		for (;;) {
			if (!(n > 0)) break;
			u64 n1 = (u64)(n / 100);
			d_i = (((u64)(n - ((u64)(n1 * 100)))) << 1);
			n = n1;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
			d_i++;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
		}
		i++;
		if (d_i < 20) {
			i++;
		}
		strings__Builder_write_ptr(res, &buf[i], n_char);
	} else {
		strings__Builder_write_u8(res, '0');
	}
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	return;
}
string strconv__f64_to_str_lnd1(f64 f, int dec_digit) {
	{ // Unsafe block
		string s = strconv__f64_to_str((f64)(f + _const_strconv__dec_round[dec_digit]), 18);
		if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
			return s;
		}
		bool m_sgn_flag = false;
		int sgn = 1;
		Array_fixed_u8_26 b = {0};
		int d_pos = 1;
		int i = 0;
		int i1 = 0;
		int exp = 0;
		int exp_sgn = 1;
		int dot_res_sp = -1;
		for (int _t2 = 0; _t2 < s.len; ++_t2) {
			u8 c = s.str[_t2];

			if (c == ('-')) {
				sgn = -1;
				i++;
			}
			else if (c == ('+')) {
				sgn = 1;
				i++;
			}
			else if ((c >= '0' && c <= '9')) {
				b[i1] = c;
				i1++;
				i++;
			}
			else if (c == ('.')) {
				if (sgn > 0) {
					d_pos = i;
				} else {
					d_pos = (int)(i - 1);
				}
				i++;
			}
			else if (c == ('e')) {
				i++;
				break;
			}
			else {
				builtin__string_free(&s);
				return _S("[Float conversion error!!]");
			}
		}
		b[i1] = 0;
		if (s.str[ i] == '-') {
			exp_sgn = -1;
			i++;
		} else if (s.str[ i] == '+') {
			exp_sgn = 1;
			i++;
		}
		int c = i;
		for (;;) {
			if (!(c < s.len)) break;
			exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
			c++;
		}
		Array_u8 res = builtin____new_array_with_default((int)(exp + 40), 0, sizeof(u8), &(u8[]){0});
		int r_i = 0;
		builtin__string_free(&s);
		if (sgn == 1) {
			if (m_sgn_flag) {
				((u8*)res.data)[r_i] = '+';
				r_i++;
			}
		} else {
			((u8*)res.data)[r_i] = '-';
			r_i++;
		}
		i = 0;
		if (exp_sgn >= 0) {
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
				if (i >= d_pos && exp >= 0) {
					if (exp == 0) {
						dot_res_sp = r_i;
						((u8*)res.data)[r_i] = '.';
						r_i++;
					}
					exp--;
				}
			}
			for (;;) {
				if (!(exp >= 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
			}
		} else {
			bool dot_p = true;
			for (;;) {
				if (!(exp > 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
				if (dot_p) {
					dot_res_sp = r_i;
					((u8*)res.data)[r_i] = '.';
					r_i++;
					dot_p = false;
				}
			}
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
			}
		}
		if (dec_digit <= 0) {
			if (dot_res_sp < 0) {
				dot_res_sp = (int)(i + 1);
			}
			string tmp_res = builtin__string_clone(builtin__tos(res.data, dot_res_sp));
			builtin__array_free(&res);
			return tmp_res;
		}
		if (dot_res_sp >= 0) {
			r_i = (int)((int)(dot_res_sp + dec_digit) + 1);
			((u8*)res.data)[r_i] = 0;
			for (int c1 = 1; c1 < (int)(dec_digit + 1); ++c1) {
				if (((u8*)res.data)[(int)(r_i - c1)] == 0) {
					((u8*)res.data)[(int)(r_i - c1)] = '0';
				}
			}
			string tmp_res = builtin__string_clone(builtin__tos(res.data, r_i));
			builtin__array_free(&res);
			return tmp_res;
		} else {
			if (dec_digit > 0) {
				int c1 = 0;
				((u8*)res.data)[r_i] = '.';
				r_i++;
				for (;;) {
					if (!(c1 < dec_digit)) break;
					((u8*)res.data)[r_i] = '0';
					r_i++;
					c1++;
				}
				((u8*)res.data)[r_i] = 0;
			}
			string tmp_res = builtin__string_clone(builtin__tos(res.data, r_i));
			builtin__array_free(&res);
			return tmp_res;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_fl(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_lnd1((f >= ((f64)(0.0)) ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			builtin__string_free(&tmp);
		}
		Array_fixed_u8_512 buf = {0};
		Array_fixed_u8_512 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		builtin__vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		builtin__vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = builtin__tos_clone(&out[0]);
		builtin__string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_es(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			builtin__string_free(&tmp);
		}
		Array_fixed_u8_512 buf = {0};
		Array_fixed_u8_512 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		builtin__vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		builtin__vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = builtin__tos_clone(&out[0]);
		builtin__string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__remove_tail_zeros(string s) {
	{ // Unsafe block
		u8* buf = builtin__malloc_noscan((int)(s.len + 1));
		int i_d = 0;
		int i_s = 0;
		for (;;) {
			if (!(i_s < s.len && !(s.str[ i_s] == '-' || s.str[ i_s] == '+') && (s.str[ i_s] > '9' || s.str[ i_s] < '0'))) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && (s.str[ i_s] == '-' || s.str[ i_s] == '+')) {
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		for (;;) {
			if (!(i_s < s.len && s.str[ i_s] >= '0' && s.str[ i_s] <= '9')) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && s.str[ i_s] == '.') {
			int i_s1 = (int)(i_s + 1);
			int sum = 0;
			int i_s2 = i_s1;
			for (;;) {
				if (!(i_s1 < s.len && s.str[ i_s1] >= '0' && s.str[ i_s1] <= '9')) break;
				sum += (u8)(s.str[ i_s1] - ((u8)('0')));
				if (s.str[ i_s1] != '0') {
					i_s2 = i_s1;
				}
				i_s1++;
			}
			if (sum > 0) {
				for (int c_i = i_s; c_i < (int)(i_s2 + 1); ++c_i) {
					buf[i_d] = s.str[ c_i];
					i_d++;
				}
			}
			i_s = i_s1;
		}
		if (i_s < s.len && s.str[ i_s] != '.') {
			for (;;) {
				buf[i_d] = s.str[ i_s];
				i_s++;
				i_d++;
				if (i_s >= s.len) {
					break;
				}
			}
		}
		buf[i_d] = 0;
		return builtin__tos(buf, i_d);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}
string strconv__format_int(i64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			builtin__panic_n(_S("invalid radix, it should be => 2 and <= 36, actual:"), radix);
			VUNREACHABLE();
		}
		if (n == 0) {
			return _S("0");
		}
		i64 n_copy = n;
		bool have_minus = false;
		if (n < 0) {
			have_minus = true;
			n_copy = -n_copy;
		}
		string res = _S("");
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			int bdx = ((int)((i64)(n_copy % radix)));
			string tmp_1 = builtin__u8_ascii_str(_const_strconv__base_digits.str[ bdx]);
			res = builtin__string__plus(tmp_1, res);
			builtin__string_free(&tmp_0);
			builtin__string_free(&tmp_1);
			n_copy /= radix;
		}
		if (have_minus) {
			string final_res = builtin__string__plus(_S("-"), res);
			builtin__string_free(&res);
			return final_res;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__format_uint(u64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			builtin__panic_n(_S("invalid radix, it should be => 2 and <= 36, actual:"), radix);
			VUNREACHABLE();
		}
		if (n == 0) {
			return _S("0");
		}
		u64 n_copy = n;
		string res = _S("");
		u64 uradix = ((u64)(radix));
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			string tmp_1 = builtin__u8_ascii_str(_const_strconv__base_digits.str[ (u64)(n_copy % uradix)]);
			res = builtin__string__plus(tmp_1, res);
			builtin__string_free(&tmp_0);
			builtin__string_free(&tmp_1);
			n_copy /= uradix;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string strconv__f32_to_str_l(f32 f) {
	string s = strconv__f32_to_str(f, 8);
	string res = strconv__fxx_to_str_l_parse(s);
	builtin__string_free(&s);
	return res;
}
string strconv__f32_to_str_l_with_dot(f32 f) {
	string s = strconv__f32_to_str(f, 8);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	builtin__string_free(&s);
	return res;
}
string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse(s);
	builtin__string_free(&s);
	return res;
}
string strconv__f64_to_str_l_with_dot(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	builtin__string_free(&s);
	return res;
}
string strconv__fxx_to_str_l_parse(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return builtin__string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _S("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = builtin____new_array_with_default((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!(Array_u8_contains(res, '.'))) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return builtin__tos(res.data, r_i);
}
string strconv__fxx_to_str_l_parse_with_dot(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return builtin__string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _S("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = builtin____new_array_with_default((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!(Array_u8_contains(res, '.'))) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return builtin__tos(res.data, r_i);
}
inline VV_LOC u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1));
	}
	return ((u32)(0));
}
inline VV_LOC u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1));
	}
	return ((u64)(0));
}
VV_LOC string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _S("nan");
	}
	if (!expZero) {
		if (neg) {
			return _S("-inf");
		} else {
			return _S("+inf");
		}
	}
	if (neg) {
		return _S("-0e+00");
	}
	return _S("0e+00");
}
VV_LOC u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_750 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_750.arg0;
	u64 lo = mr_750.arg1;
	u64 shifted_sum = (u64)(((lo >> ((u64)(ishift)))) + ((hi << ((u64)((int)(64 - ishift))))));
	;
	return ((u32)(shifted_sum));
}
inline VV_LOC u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	;
	return strconv__mul_shift_32(m, _const_strconv__pow5_inv_split_32[q], j);
}
inline VV_LOC u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	;
	return strconv__mul_shift_32(m, _const_strconv__pow5_split_32[i], j);
}
VV_LOC u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0)); true; n++) {
		u32 q = (u32)(v / 5);
		u32 r = (u32)(v % 5);
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return v;
}
VV_LOC bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}
VV_LOC bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}
VV_LOC u32 strconv__log10_pow2(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 78913)) >> 18);
}
VV_LOC u32 strconv__log10_pow5(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 732923)) >> 20);
}
VV_LOC int strconv__pow5_bits(int e) {
	;
	;
	return ((int)((u32)(((((u32)(((u32)(e)) * 1217359)) >> 19)) + 1)));
}
VV_LOC u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	;
	return (((v.hi << ((u64)((int)(64 - shift))))) | ((v.lo >> ((u32)(shift)))));
}
VV_LOC u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_3253 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_3253.arg0;
	u64 hilo = mr_3253.arg1;
	multi_return_u64_u64 mr_3288 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_3288.arg0;
	strconv__Uint128 sum = ((strconv__Uint128){.lo = (u64)(lohi + hilo),.hi = hihi,});
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, (int)(shift - 64));
}
VV_LOC u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0)); true; n++) {
		u64 q = (u64)(v / 5);
		u64 r = (u64)(v % 5);
		if (r != 0) {
			return n;
		}
		v = q;
	}
	return ((u32)(0));
}
VV_LOC bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}
VV_LOC bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}
int strconv__dec_digits(u64 n) {
	if (n <= 9999999999LL) {
		if (n <= 99999) {
			if (n <= 99) {
				if (n <= 9) {
					return 1;
				} else {
					return 2;
				}
			} else {
				if (n <= 999) {
					return 3;
				} else {
					if (n <= 9999) {
						return 4;
					} else {
						return 5;
					}
				}
			}
		} else {
			if (n <= 9999999) {
				if (n <= 999999) {
					return 6;
				} else {
					return 7;
				}
			} else {
				if (n <= 99999999) {
					return 8;
				} else {
					if (n <= 999999999) {
						return 9;
					}
					return 10;
				}
			}
		}
	} else {
		if (n <= 999999999999999LL) {
			if (n <= 999999999999LL) {
				if (n <= 99999999999LL) {
					return 11;
				} else {
					return 12;
				}
			} else {
				if (n <= 9999999999999LL) {
					return 13;
				} else {
					if (n <= 99999999999999LL) {
						return 14;
					} else {
						return 15;
					}
				}
			}
		} else {
			if (n <= 99999999999999999LL) {
				if (n <= 9999999999999999LL) {
					return 16;
				} else {
					return 17;
				}
			} else {
				if (n <= 999999999999999999LL) {
					return 18;
				} else {
					if (n <= 9999999999999999999ULL) {
						return 19;
					}
					return 20;
				}
			}
		}
	}
	return 0;
}
void strconv__v_printf(string str, Array_voidptr pt) {
	builtin__print(strconv__v_sprintf(str, pt));
}
string strconv__v_sprintf(string str, Array_voidptr pt) {
	strings__Builder res = strings__new_builder((int)(pt.len * 16));
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text align = strconv__Align_text__right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	u8 pad_ch = ((u8)(' '));
	rune ch1 = '0';
	rune ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state__norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state__reset_params) {
			sign = false;
			align = strconv__Align_text__right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			status = strconv__Char_parse_state__norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		u8 ch = str.str[ i];
		if (ch != '%' && status == strconv__Char_parse_state__norm_char) {
			strings__Builder_write_u8(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__field_char) {
			status = strconv__Char_parse_state__norm_char;
			strings__Builder_write_u8(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__norm_char) {
			status = strconv__Char_parse_state__field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			u8 d1 = *(((u8*)(((voidptr*)pt.data)[p_index])));
			strings__Builder_write_u8(&res, d1);
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write_string(&res, _S("0x"));
			strings__Builder_write_string(&res, builtin__ptr_str(((voidptr*)pt.data)[p_index]));
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state__field_char) {
			rune fc_ch1 = '0';
			rune fc_ch2 = '0';
			if (((int)(i + 1)) < str.len) {
				fc_ch1 = str.str[ (int)(i + 1)];
				if (((int)(i + 2)) < str.len) {
					fc_ch2 = str.str[ (int)(i + 2)];
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				align = strconv__Align_text__left;
				i++;
				continue;
			} else if (ch == '0' || ch == ' ') {
				if (align == strconv__Align_text__right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)(((voidptr*)pt.data)[p_index])));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)(((voidptr*)pt.data)[p_index])));
				s = builtin__string_substr(s, 0, len);
				p_index++;
				strings__Builder_write_string(&res, s);
				status = strconv__Char_parse_state__reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state__len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)((rune)(ch - '0')));
				status = strconv__Char_parse_state__len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)((rune)(ch - '0')));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)((rune)(ch - '0')));
				status = strconv__Char_parse_state__check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)((rune)(ch - '0')));
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if (ch == 'd' || ch == 'i') {
				u64 d1 = ((u64)(0));
				bool positive = true;

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)(((voidptr*)pt.data)[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)(((voidptr*)pt.data)[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				}
				else if (ch1 == ('l')) {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)(((voidptr*)pt.data)[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)(((voidptr*)pt.data)[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.align = align,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				builtin__string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((u8*)(((voidptr*)pt.data)[p_index])))));
					} else {
						d1 = ((u64)(*(((u16*)(((voidptr*)pt.data)[p_index])))));
					}
				}
				else if (ch1 == ('l')) {
					d1 = ((u64)(*(((u64*)(((voidptr*)pt.data)[p_index])))));
				}
				else {
					d1 = ((u64)(*(((u32*)(((voidptr*)pt.data)[p_index])))));
				}
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.align = align,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				builtin__string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'x' || ch == 'X') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = _S("");

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						i8 x = *(((i8*)(((voidptr*)pt.data)[p_index])));
						s = builtin__i8_hex(x);
					} else {
						i16 x = *(((i16*)(((voidptr*)pt.data)[p_index])));
						s = builtin__i16_hex(x);
					}
				}
				else if (ch1 == ('l')) {
					i64 x = *(((i64*)(((voidptr*)pt.data)[p_index])));
					s = builtin__i64_hex(x);
				}
				else {
					int x = *(((int*)(((voidptr*)pt.data)[p_index])));
					s = builtin__int_hex(x);
				}
				if (ch == 'X') {
					string tmp = s;
					s = builtin__string_to_upper(s);
					builtin__string_free(&tmp);
				}
				string tmp = strconv__format_str(s, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.align = align,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				builtin__string_free(&tmp);
				builtin__string_free(&s);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
			if (ch == 'f' || ch == 'F') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_fl_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.align = align,
						.rm_tail_zero = 0,
					}));
					if (ch == 'F') {
						string tmp = builtin__string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						builtin__string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					builtin__string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'e' || ch == 'E') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_es_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.align = align,
						.rm_tail_zero = 0,
					}));
					if (ch == 'E') {
						string tmp = builtin__string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						builtin__string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					builtin__string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'g' || ch == 'G') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					string s = _S("");
					f64 tx = strconv__fabs(x);
					if (tx < ((f64)(999999.0)) && tx >= ((f64)(0.00001))) {
						len1 = (len1 >= 0 ? ((int)(len1 + 1)) : (def_len1));
						string tmp = s;
						s = strconv__format_fl_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.align = align,
							.rm_tail_zero = true,
						}));
						builtin__string_free(&tmp);
					} else {
						len1 = (len1 >= 0 ? ((int)(len1 + 1)) : (def_len1));
						string tmp = s;
						s = strconv__format_es_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.align = align,
							.rm_tail_zero = true,
						}));
						builtin__string_free(&tmp);
					}
					if (ch == 'G') {
						string tmp = builtin__string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						builtin__string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					builtin__string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)(((voidptr*)pt.data)[p_index])));
				pad_ch = ' ';
				string tmp = strconv__format_str(s1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.align = align,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				builtin__string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state__reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		builtin__panic_n2(_S("% conversion specifiers number mismatch (expected %, given args)"), p_index, pt.len);
		VUNREACHABLE();
	}
	string _t4 = strings__Builder_str(&res);
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	return _t4;
}
inline VV_LOC void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		builtin__panic_n2(_S("% conversion specifiers number mismatch (expected %, given args)"), (int)(idx + 1), len);
		VUNREACHABLE();
	}
}
VV_LOC f64 strconv__fabs(f64 x) {
	if (x < ((f64)(0.0))) {
		return -x;
	}
	return x;
}
string strconv__format_fl_old(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string s = _S("");
		string fs = strconv__f64_to_str_lnd1((f >= ((f64)(0.0)) ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			builtin__string_free(&s);
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			builtin__string_free(&tmp);
		}
		strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = builtin__string_clone(fs);
			builtin__string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = builtin__string__plus(_S("+"), fs);
					builtin__string_free(&tmp);
				} else {
					string tmp = s;
					s = builtin__string_clone(fs);
					builtin__string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = builtin__string__plus(_S("-"), fs);
				builtin__string_free(&tmp);
			}
		}
		int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		builtin__string_free(&s);
		builtin__string_free(&fs);
		string _t2 = strings__Builder_str(&res);
			{ // defer begin
				strings__Builder_free(&res);
			} // defer end
		return _t2;
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string strconv__format_es_old(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string s = _S("");
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			builtin__string_free(&tmp);
		}
		strings__Builder res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = builtin__string_clone(fs);
			builtin__string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = builtin__string__plus(_S("+"), fs);
					builtin__string_free(&tmp);
				} else {
					string tmp = s;
					s = builtin__string_clone(fs);
					builtin__string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = builtin__string__plus(_S("-"), fs);
				builtin__string_free(&tmp);
			}
		}
		int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		string _t1 = strings__Builder_str(&res);
			{ // defer begin
				strings__Builder_free(&res);
				builtin__string_free(&fs);
				builtin__string_free(&s);
			} // defer end
		return _t1;
		{ // defer begin
			strings__Builder_free(&res);
			builtin__string_free(&fs);
			builtin__string_free(&s);
		} // defer end
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string strconv__remove_tail_zeros_old(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	u8 prev_ch = ((u8)(0));
	for (;;) {
		if (!(i < s.len)) break;
		u8 ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = _S("");
	if (last_zero_start > 0) {
		if (last_zero_start == (int)(dot_pos + 1)) {
			tmp = builtin__string__plus(builtin__string_substr(s, 0, dot_pos), builtin__string_substr(s, i, 2147483647));
		} else {
			tmp = builtin__string__plus(builtin__string_substr(s, 0, last_zero_start), builtin__string_substr(s, i, 2147483647));
		}
	} else {
		tmp = builtin__string_clone(s);
	}
	if (tmp.str[(int)(tmp.len - 1)] == '.') {
		return builtin__string_substr(tmp, 0, (int)(tmp.len - 1));
	}
	return tmp;
}
string strconv__format_dec_old(u64 d, strconv__BF_param p) {
	string s = _S("");
	strings__Builder res = strings__new_builder(20);
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_u8(&res, '-');
			sign_len_diff = -1;
		}
		string tmp = s;
		s = builtin__u64_str(d);
		builtin__string_free(&tmp);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				string tmp = s;
				s = builtin__string__plus(_S("+"), builtin__u64_str(d));
				builtin__string_free(&tmp);
			} else {
				string tmp = s;
				s = builtin__u64_str(d);
				builtin__string_free(&tmp);
			}
		} else {
			string tmp = s;
			s = builtin__string__plus(_S("-"), builtin__u64_str(d));
			builtin__string_free(&tmp);
		}
	}
	int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t1 = strings__Builder_str(&res);
		{ // defer begin
			strings__Builder_free(&res);
			builtin__string_free(&s);
		} // defer end
	return _t1;
}
VNORETURN VV_LOC void builtin___memory_panic(string fname, isize size) {
	v_memory_panic = true;
	builtin__eprint(fname);
	builtin__eprint(_S("("));
	#if defined(_VFREESTANDING) || defined(__vinix__)
	{
	}
	#else
	{
		fprintf(stderr, "%p", ((voidptr)(size)));
	}
	#endif
	if (size < 0) {
		builtin__eprint(_S(" < 0"));
	}
	builtin__eprintln(_S(")"));
	builtin___v_panic(_S("memory allocation failure"));
	VUNREACHABLE();
	while(1);
}
u8* builtin___v_malloc(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(((void*)0)));
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* builtin__malloc_noscan(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc_noscan"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VNATIVE)
	{
	}
	#elif defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc_noscan"), n);
		VUNREACHABLE();
	}
	return res;
}
inline VV_LOC u64 builtin____at_least_one(u64 how_many) {
	if (how_many == 0) {
		return 1;
	}
	return how_many;
}
u8* builtin__malloc_uncollectable(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = malloc(n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("malloc_uncollectable"), n);
		VUNREACHABLE();
	}
	return res;
}
u8* builtin__v_realloc(u8* b, isize n) {
	u8* new_ptr = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			new_ptr = realloc(b, n);
		}
		#endif
	}
	#endif
	if (new_ptr == 0) {
		builtin___memory_panic(_S("v_realloc"), n);
		VUNREACHABLE();
	}
	return new_ptr;
}
u8* builtin__realloc_data(u8* old_data, int old_size, int new_size) {
	u8* nptr = ((u8*)(((void*)0)));
	#if defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			nptr = realloc(old_data, new_size);
		}
		#endif
	}
	#endif
	if (nptr == 0) {
		builtin___memory_panic(_S("realloc_data"), ((isize)(new_size)));
		VUNREACHABLE();
	}
	return nptr;
}
u8* builtin__vcalloc(isize n) {
	if (n < 0) {
		builtin___memory_panic(_S("vcalloc"), n);
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(((void*)0)));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VNATIVE)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			return calloc(1, n);
		}
		#endif
	}
	#endif
	return ((u8*)(((void*)0)));
}
u8* builtin__vcalloc_noscan(isize n) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		return builtin__vcalloc(n);
	}
	#endif
	return ((u8*)(((void*)0)));
}
void builtin___v_free(voidptr ptr) {
	if (ptr == 0) {
		return;
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			free(ptr);
		}
		#endif
	}
	#endif
}
voidptr builtin__memdup(voidptr src, isize sz) {
	if (sz == 0) {
		return builtin__vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = builtin___v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr builtin__memdup_noscan(voidptr src, isize sz) {
	if (sz == 0) {
		return builtin__vcalloc_noscan(1);
	}
	{ // Unsafe block
		u8* mem = builtin__malloc_noscan(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr builtin__memdup_uncollectable(voidptr src, isize sz) {
	if (sz == 0) {
		return builtin__vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = builtin__malloc_uncollectable(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}
voidptr builtin__memdup_align(voidptr src, isize sz, isize align) {
	if (sz == 0) {
		return builtin__vcalloc(1);
	}
	isize n = sz;
	if (n < 0) {
		builtin___memory_panic(_S("memdup_align"), n);
		VUNREACHABLE();
	}
	u8* res = ((u8*)(((void*)0)));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = aligned_alloc(align, n);
		}
		#endif
	}
	#endif
	if (res == 0) {
		builtin___memory_panic(_S("memdup_align"), n);
		VUNREACHABLE();
	}
	return memcpy(res, src, sz);
}
GCHeapUsage builtin__gc_heap_usage(void) {
	#if defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		return ((GCHeapUsage){.heap_size = 0,.free_bytes = 0,.total_bytes = 0,.unmapped_bytes = 0,.bytes_since_gc = 0,});
	}
	#endif
	return (GCHeapUsage){0};
}
usize builtin__gc_memory_use(void) {
	#if defined(CUSTOM_DEFINE_gcboehm)
	{
	}
	#else
	{
		return 0;
	}
	#endif
	return 0;
}
VV_LOC array builtin____new_array(int mylen, int cap, int elm_size) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = (voidptr)builtin__vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}
VV_LOC array builtin____new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	if (cap_ > 0 && mylen == 0) {
		arr.data = builtin___v_malloc(builtin____at_least_one(total_size));
	} else {
		arr.data = builtin__vcalloc(total_size);
	}
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				if (arr.element_size == 1) {
					u8 byte_value = *(((u8*)(val)));
					for (int i = 0; i < arr.len; ++i) {
						eptr[i] = byte_value;
					}
				} else {
					for (int _t1 = 0; _t1 < arr.len; ++_t1) {
						builtin__vmemcpy(eptr, val, arr.element_size);
						eptr += arr.element_size;
					}
				}
			}
		}
	}
	return arr;
}
VV_LOC array builtin____new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	arr.data = builtin__vcalloc(builtin____at_least_one(total_size));
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int i = 0; i < arr.len; ++i) {
					builtin__vmemcpy(eptr, ((charptr)(val)) + (int)(i * arr.element_size), arr.element_size);
					eptr += arr.element_size;
				}
			}
		}
	}
	return arr;
}
VV_LOC array builtin____new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth) {
	builtin__panic_on_negative_len(mylen);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = (voidptr)builtin___v_malloc(builtin____at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				array val_clone = builtin__array_clone_to_depth(&val, depth);
				builtin__vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}
VV_LOC array builtin__new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	builtin__panic_on_negative_len(len);
	builtin__panic_on_negative_cap(cap);
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = (voidptr)builtin__vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	builtin__vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}
void builtin__array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	if (builtin__ArrayFlags_has(&a->flags, ArrayFlags__nogrow)) {
		builtin__panic_n(_S("array.ensure_cap: array with the flag `.nogrow` cannot grow in size, array required new size:"), required);
		VUNREACHABLE();
	}
	i64 cap = (a->cap > 0 ? (((i64)(a->cap))) : (((i64)(2))));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	if (cap > _const_max_int) {
		if (a->cap < _const_max_int) {
			cap = _const_max_int;
		} else {
			builtin__panic_n(_S("array.ensure_cap: array needs to grow to cap (which is > 2^31):"), cap);
			VUNREACHABLE();
		}
	}
	u64 new_size = (u64)(((u64)(cap)) * ((u64)(a->element_size)));
	u8* new_data = builtin___v_malloc(builtin____at_least_one(new_size));
	if (a->data != ((void*)0)) {
		builtin__vmemcpy(new_data, a->data, (u64)(((u64)(a->len)) * ((u64)(a->element_size))));
		if (builtin__ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
			builtin___v_free(a->data);
		}
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = ((int)(cap));
}
array builtin__array_repeat(array a, int count) {
	return builtin__array_repeat_to_depth(a, count, 0);
}
array builtin__array_repeat_to_depth(array a, int count, int depth) {
	if (count < 0) {
		builtin__panic_n(_S("array.repeat: count is negative:"), count);
		VUNREACHABLE();
	}
	u64 size = (u64)((u64)(((u64)(count)) * ((u64)(a.len))) * ((u64)(a.element_size)));
	if (size == 0) {
		size = ((u64)(a.element_size));
	}
	array arr = ((array){.data = (voidptr)builtin__vcalloc(size),.offset = 0,.len = (int)(count * a.len),.cap = (int)(count * a.len),.flags = 0,.element_size = a.element_size,});
	if (a.len > 0) {
		u64 a_total_size = (u64)(((u64)(a.len)) * ((u64)(a.element_size)));
		u64 arr_step_size = (u64)(((u64)(a.len)) * ((u64)(arr.element_size)));
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int _t1 = 0; _t1 < count; ++_t1) {
					if (depth > 0) {
						array ary_clone = builtin__array_clone_to_depth(&a, depth);
						builtin__vmemcpy(eptr, ((u8*)(ary_clone.data)), a_total_size);
					} else {
						builtin__vmemcpy(eptr, ((u8*)(a.data)), a_total_size);
					}
					eptr += arr_step_size;
				}
			}
		}
	}
	return arr;
}
void builtin__array_insert(array* a, int i, voidptr val) {
	if (i < 0 || i > a->len) {
		builtin__panic_n2(_S("array.insert: index out of range (i,a.len):"), i, a->len);
		VUNREACHABLE();
	}
	if (a->len == _const_max_int) {
		builtin___v_panic(_S("array.insert: a.len reached max_int"));
		VUNREACHABLE();
	}
	if (a->len >= a->cap) {
		builtin__array_ensure_cap(a, (int)(a->len + 1));
	}
	{ // Unsafe block
		builtin__vmemmove(builtin__array_get_unsafe(*a, (int)(i + 1)), builtin__array_get_unsafe(*a, i), (u64)(((u64)(((int)(a->len - i)))) * ((u64)(a->element_size))));
		builtin__array_set_unsafe(a, i, val);
	}
	a->len++;
}
VV_LOC void builtin__array_insert_many(array* a, int i, voidptr val, int size) {
	if (i < 0 || i > a->len) {
		builtin__panic_n2(_S("array.insert_many: index out of range (i,a.len):"), i, a->len);
		VUNREACHABLE();
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		builtin__panic_n(_S("array.insert_many: max_int will be exceeded by a.len:"), new_len);
		VUNREACHABLE();
	}
	builtin__array_ensure_cap(a, ((int)(new_len)));
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = builtin__array_get_unsafe(*a, i);
		builtin__vmemmove(builtin__array_get_unsafe(*a, (int)(i + size)), iptr, (u64)(((u64)((int)(a->len - i))) * ((u64)(elem_size))));
		builtin__vmemcpy(iptr, val, (u64)(((u64)(size)) * ((u64)(elem_size))));
	}
	a->len = ((int)(new_len));
}
void builtin__array_prepend(array* a, voidptr val) {
	builtin__array_insert(a, 0, val);
}
VV_LOC void builtin__array_prepend_many(array* a, voidptr val, int size) {
	builtin__array_insert_many(a, 0, val, size);
}
void builtin__array_delete(array* a, int i) {
	builtin__array_delete_many(a, i, 1);
}
void builtin__array_delete_many(array* a, int i, int size) {
	if (i < 0 || (i64)(((i64)(i)) + ((i64)(size))) > ((i64)(a->len))) {
		if (size > 1) {
			builtin__panic_n3(_S("array.delete: index out of range (i,i+size,a.len):"), i, (int)(i + size), a->len);
			VUNREACHABLE();
		} else {
			builtin__panic_n2(_S("array.delete: index out of range (i,a.len):"), i, a->len);
			VUNREACHABLE();
		}
	}
	if (builtin__ArrayFlags_all(&a->flags, (ArrayFlags__noshrink | ArrayFlags__noslices))) {
		builtin__vmemmove(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(a->data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
		a->len -= size;
		return;
	}
	voidptr old_data = a->data;
	int new_size = (int)(a->len - size);
	int new_cap = (new_size == 0 ? (1) : (new_size));
	a->data = builtin__vcalloc((u64)(((u64)(new_cap)) * ((u64)(a->element_size))));
	builtin__vmemcpy(a->data, old_data, (u64)(((u64)(i)) * ((u64)(a->element_size))));
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(old_data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
	if (builtin__ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
		builtin___v_free(old_data);
	}
	a->len = new_size;
	a->cap = new_cap;
}
void builtin__array_clear(array* a) {
	a->len = 0;
}
void builtin__array_reset(array* a) {
	builtin__vmemset(a->data, 0, (int)(a->len * a->element_size));
}
void builtin__array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}
void builtin__array_drop(array* a, int num) {
	if (num <= 0) {
		return;
	}
	int n = (num <= a->len ? (num) : (a->len));
	u64 blen = (u64)(((u64)(n)) * ((u64)(a->element_size)));
	a->data = ((u8*)(a->data)) + blen;
	a->offset += ((int)(blen));
	a->len -= n;
	a->cap -= n;
}
inline VV_LOC voidptr builtin__array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOC voidptr builtin__array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			builtin__panic_n2(_S("array.get: index out of range (i,a.len):"), i, a.len);
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
VV_LOC voidptr builtin__array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}
voidptr builtin__array_first(array a) {
	if (a.len == 0) {
		builtin___v_panic(_S("array.first: array is empty"));
		VUNREACHABLE();
	}
	return a.data;
}
voidptr builtin__array_last(array a) {
	if (a.len == 0) {
		builtin___v_panic(_S("array.last: array is empty"));
		VUNREACHABLE();
	}
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)((int)(a.len - 1))) * ((u64)(a.element_size)));
	}
	return 0;
}
voidptr builtin__array_pop_left(array* a) {
	if (a->len == 0) {
		builtin___v_panic(_S("array.pop_left: array is empty"));
		VUNREACHABLE();
	}
	voidptr first_elem = a->data;
	{ // Unsafe block
		a->data = ((u8*)(a->data)) + ((u64)(a->element_size));
	}
	a->offset += a->element_size;
	a->len--;
	a->cap--;
	return first_elem;
}
voidptr builtin__array_pop(array* a) {
	if (a->len == 0) {
		builtin___v_panic(_S("array.pop: array is empty"));
		VUNREACHABLE();
	}
	int new_len = (int)(a->len - 1);
	u8* last_elem = ((u8*)(a->data)) + (u64)(((u64)(new_len)) * ((u64)(a->element_size)));
	a->len = new_len;
	return last_elem;
}
void builtin__array_delete_last(array* a) {
	if (a->len == 0) {
		builtin___v_panic(_S("array.delete_last: array is empty"));
		VUNREACHABLE();
	}
	a->len--;
}
VV_LOC array builtin__array_slice(array a, int start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (a.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("array.slice: invalid slice index (start>end):"), builtin__impl_i64_to_string(((i64)(start)))), _S(", ")), builtin__impl_i64_to_string(end)));
			VUNREACHABLE();
		}
		if (end > a.len) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("array.slice: slice bounds out of range ("), builtin__impl_i64_to_string(end)), _S(" >= ")), builtin__impl_i64_to_string(a.len)), _S(")")));
			VUNREACHABLE();
		}
		if (start < 0) {
			builtin___v_panic(builtin__string__plus(_S("array.slice: slice bounds out of range (start<0):"), builtin__impl_i64_to_string(start)));
			VUNREACHABLE();
		}
	}
	#endif
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = (voidptr)data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}
VV_LOC array builtin__array_slice_ni(array a, int _start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (a.len) : (_end));
	int start = _start;
	if (start < 0) {
		start = (int)(a.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(a.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= a.len) {
		end = a.len;
	}
	if (start >= a.len || start > end) {
		array res = ((array){.data = a.data,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = a.element_size,});
		return res;
	}
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = (voidptr)data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}
VV_LOC array builtin__array_clone_static_to_depth(array a, int depth) {
	return builtin__array_clone_to_depth(&a, depth);
}
array builtin__array_clone(array* a) {
	return builtin__array_clone_to_depth(a, 0);
}
array builtin__array_clone_to_depth(array* a, int depth) {
	u64 source_capacity_in_bytes = (u64)(((u64)(a->cap)) * ((u64)(a->element_size)));
	array arr = ((array){.data = (voidptr)builtin__vcalloc(source_capacity_in_bytes),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
		int asize = ((int)(sizeof(array)));
		for (int i = 0; i < a->len; ++i) {
			builtin__vmemcpy(&ar, builtin__array_get_unsafe(*a, i), asize);
			array ar_clone = builtin__array_clone_to_depth(&ar, (int)(depth - 1));
			builtin__array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else if (depth > 0 && _us32_eq(sizeof(string),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		for (int i = 0; i < a->len; ++i) {
			string* str_ptr = ((string*)(builtin__array_get_unsafe(*a, i)));
			string str_clone = builtin__string_clone((*str_ptr));
			builtin__array_set_unsafe(&arr, i, &str_clone);
		}
		return arr;
	} else {
		if (a->data != 0 && source_capacity_in_bytes > 0) {
			builtin__vmemcpy(((u8*)(arr.data)), a->data, source_capacity_in_bytes);
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,};
}
inline VV_LOC void builtin__array_set_unsafe(array* a, int i, voidptr val) {
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
VV_LOC void builtin__array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			builtin__panic_n2(_S("array.set: index out of range (i,a.len):"), i, a->len);
			VUNREACHABLE();
		}
	}
	#endif
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}
VV_LOC void builtin__array_push(array* a, voidptr val) {
	if (a->len < 0) {
		builtin___v_panic(_S("array.push: negative len"));
		VUNREACHABLE();
	}
	if (a->len >= _const_max_int) {
		builtin___v_panic(_S("array.push: len bigger than max_int"));
		VUNREACHABLE();
	}
	if (a->len >= a->cap) {
		builtin__array_ensure_cap(a, (int)(a->len + 1));
	}
	builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, a->element_size);
	a->len++;
}
void builtin__array_push_many(array* a, voidptr val, int size) {
	if (size <= 0 || val == ((void*)0)) {
		return;
	}
	i64 new_len = (i64)(((i64)(a->len)) + ((i64)(size)));
	if (new_len > _const_max_int) {
		builtin___v_panic(_S("array.push_many: new len exceeds max_int"));
		VUNREACHABLE();
	}
	if (new_len >= a->cap) {
		builtin__array_ensure_cap(a, ((int)(new_len)));
	}
	if (a->data == val && a->data != 0) {
		array copy = builtin__array_clone(a);
		builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), copy.data, (u64)(((u64)(a->element_size)) * ((u64)(size))));
	} else {
		if (a->data != 0 && val != 0) {
			builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, (u64)(((u64)(a->element_size)) * ((u64)(size))));
		}
	}
	a->len = ((int)(new_len));
}
void builtin__array_reverse_in_place(array* a) {
	if (a->len < 2 || a->element_size == 0) {
		return;
	}
	{ // Unsafe block
		u8* tmp_value = builtin___v_malloc(a->element_size);
		for (int i = 0; i < (int)(a->len / 2); ++i) {
			builtin__vmemcpy(tmp_value, ((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), a->element_size);
			builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(a->data)) + (u64)(((u64)((int)((int)(a->len - 1) - i))) * ((u64)(a->element_size))), a->element_size);
			builtin__vmemcpy(((u8*)(a->data)) + (u64)(((u64)((int)((int)(a->len - 1) - i))) * ((u64)(a->element_size))), tmp_value, a->element_size);
		}
		builtin___v_free(tmp_value);
	}
}
array builtin__array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = ((array){.data = (voidptr)builtin__vcalloc((u64)(((u64)(a.cap)) * ((u64)(a.element_size)))),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,.element_size = a.element_size,});
	for (int i = 0; i < a.len; ++i) {
		builtin__array_set_unsafe(&arr, i, builtin__array_get_unsafe(a, (int)((int)(a.len - 1) - i)));
	}
	return arr;
}
void builtin__array_free(array* a) {
	if (builtin__ArrayFlags_has(&a->flags, ArrayFlags__nofree)) {
		return;
	}
	u8* mblock_ptr = ((u8*)((u64)(((u64)(a->data)) - ((u64)(a->offset)))));
	if (mblock_ptr != ((void*)0)) {
		builtin___v_free(mblock_ptr);
	}
	{ // Unsafe block
		a->data = ((void*)0);
		a->offset = 0;
		a->len = 0;
		a->cap = 0;
	}
}
array builtin__array_filter(array a, bool (*predicate)(voidptr ));
bool builtin__array_any(array a, bool (*predicate)(voidptr ));
int builtin__array_count(array a, bool (*predicate)(voidptr ));
bool builtin__array_all(array a, bool (*predicate)(voidptr ));
array builtin__array_map(array a, voidptr (*callback)(voidptr ));
void builtin__array_sort(array* a, int (*callback)(voidptr , voidptr ));
array builtin__array_sorted(array* a, int (*callback)(voidptr , voidptr ));
void builtin__array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin__vqsort(a->data, ((usize)(a->len)), ((usize)(a->element_size)), (voidptr)callback);
	}
	#endif
}
array builtin__array_sorted_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		array r = builtin__array_clone(a);
		builtin__vqsort(r.data, ((usize)(r.len)), ((usize)(r.element_size)), (voidptr)callback);
		return r;
	}
	#endif
	return ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
}
bool builtin__array_contains(array a, voidptr value);
int builtin__array_index(array a, voidptr value);
int builtin__array_last_index(array a, voidptr value);
void Array_string_free(Array_string* a) {
	for (int _t1 = 0; _t1 < a->len; ++_t1) {
		string* s = ((string*)a->data) + _t1;
		builtin__string_free(s);
	}
	builtin__array_free((((array*)(a))));
}
string Array_string_str(Array_string a) {
	int sb_len = 4;
	if (a.len > 0) {
		sb_len += ((string*)a.data)[0].len;
		sb_len *= a.len;
	}
	sb_len += 2;
	strings__Builder sb = strings__new_builder(sb_len);
	strings__Builder_write_u8(&sb, '[');
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		strings__Builder_write_u8(&sb, '\'');
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_u8(&sb, '\'');
		if (i < (int)(a.len - 1)) {
			strings__Builder_write_string(&sb, _S(", "));
		}
	}
	strings__Builder_write_u8(&sb, ']');
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string Array_u8_hex(Array_u8 b) {
	if (b.len == 0) {
		return _S("");
	}
	return builtin__data_to_hex_string(((u8*)(b.data)), b.len);
}
int builtin__copy(Array_u8* dst, Array_u8 src) {
	int min = (dst->len < src.len ? (dst->len) : (src.len));
	if (min > 0) {
		builtin__vmemmove(((u8*)(dst->data)), src.data, min);
	}
	return min;
}
void builtin__array_grow_cap(array* a, int amount) {
	i64 new_cap = (i64)(((i64)(amount)) + ((i64)(a->cap)));
	if (new_cap > _const_max_int) {
		builtin__panic_n(_S("array.grow_cap: max_int will be exceeded by new cap:"), new_cap);
		VUNREACHABLE();
	}
	builtin__array_ensure_cap(a, ((int)(new_cap)));
}
void builtin__array_grow_len(array* a, int amount) {
	i64 new_len = (i64)(((i64)(amount)) + ((i64)(a->len)));
	if (new_len > _const_max_int) {
		builtin__panic_n(_S("array.grow_len: max_int will be exceeded by new len:"), new_len);
		VUNREACHABLE();
	}
	builtin__array_ensure_cap(a, ((int)(new_len)));
	a->len = ((int)(new_len));
}
Array_voidptr builtin__array_pointers(array a) {
	Array_voidptr res = builtin____new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		builtin__array_push((array*)&res, _MOV((voidptr[]){ builtin__array_get_unsafe(a, i) }));
	}
	return res;
}
Array_u8 builtin__voidptr_vbytes(voidptr data, int len) {
	array res = ((array){.data = data,.offset = 0,.len = len,.cap = len,.flags = 0,.element_size = 1,});
	return res;
}
Array_u8 builtin__u8_vbytes(u8* data, int len) {
	return builtin__voidptr_vbytes(((voidptr)(data)), len);
}
void builtin__u8_free(u8* data) {
	builtin___v_free(data);
}
inline VV_LOC void builtin__panic_on_negative_len(int len) {
	if (len < 0) {
		builtin__panic_n(_S("negative .len:"), len);
		VUNREACHABLE();
	}
}
inline VV_LOC void builtin__panic_on_negative_cap(int cap) {
	if (cap < 0) {
		builtin__panic_n(_S("negative .cap:"), cap);
		VUNREACHABLE();
	}
}
VV_LOC array builtin____new_array_noscan(int mylen, int cap, int elm_size) {
	return builtin____new_array(mylen, cap, elm_size);
}
VV_LOC array builtin____new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	return builtin____new_array_with_default(mylen, cap, elm_size, val);
}
VV_LOC array builtin____new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	return builtin____new_array_with_multi_default(mylen, cap, elm_size, val);
}
VV_LOC array builtin____new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val, int depth) {
	return builtin____new_array_with_array_default(mylen, cap, elm_size, val, depth);
}
VV_LOC void builtin__array_insert_noscan(array* a, int i, voidptr val) {
	builtin__array_insert(a, i, val);
}
VV_LOC void builtin__array_prepend_noscan(array* a, voidptr val) {
	builtin__array_prepend(a, val);
}
VV_LOC voidptr builtin__array_pop_noscan(array* a) {
	return builtin__array_pop(a);
}
VV_LOC void builtin__array_push_noscan(array* a, voidptr val) {
	builtin__array_push(a, val);
}
VV_LOC void builtin__array_push_many_noscan(array* a, voidptr val, int size) {
	builtin__array_push_many(a, val, size);
}
void builtin__print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#elif defined(_VNATIVE)
		{
		}
		#elif defined(__TINYC__)
		{
		}
		#elif defined(CUSTOM_DEFINE_use_libbacktrace)
		{
		}
		#else
		{
			builtin__print_backtrace_skipping_top_frames(2);
		}
		#endif
	}
	#endif
}
bool builtin__print_backtrace_skipping_top_frames(int xskipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		int skipframes = (int)(xskipframes + 2);
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
		{
			return builtin__print_backtrace_skipping_top_frames_bsd(skipframes);
		}
		#elif defined(__linux__)
		{
		}
		#else
		{
		}
		#endif
	}
	#endif
	return false;
}
VV_LOC bool builtin__print_backtrace_skipping_top_frames_bsd(int skipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__)
		{
			Array_fixed_voidptr_100 buffer = {0};
			i32 nr_ptrs = backtrace(&buffer[0], 100);
			if (nr_ptrs < 2) {
				builtin__eprintln(_S("C.backtrace returned less than 2 frames"));
				return false;
			}
			backtrace_symbols_fd(&buffer[skipframes], (int)(nr_ptrs - skipframes), 2);
		}
		#endif
		return true;
	}
	#endif
	return 0;
}
VNORETURN void builtin___v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}
_result_void builtin__at_exit(void (*cb)(void)) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		i32 res = atexit((voidptr)cb);
		if (res != 0) {
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(_S("at_exit failed"), res), .data={E_STRUCT} };
		}
	}
	#endif
	return (_result_void){0};
}
VV_LOC void builtin__v_segmentation_fault_handler(i32 signal_number) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fprintf(stderr, "signal %d: segmentation fault\n", signal_number);
	}
	#endif
	#if defined(CUSTOM_DEFINE_use_libbacktrace)
	{
	}
	#else
	{
		builtin__print_backtrace();
	}
	#endif
	builtin___v_exit((i32)(128 + signal_number));
	VUNREACHABLE();
}
inline VV_LOC int builtin__v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("fixed array index out of range (index: "), builtin__i64_str(((i64)(i)))), _S(", len: ")), builtin__i64_str(((i64)(len)))), _S(")")));
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}
Array_string builtin__arguments(void) {
	u8** argv = ((u8**)(g_main_argv));
	Array_string res = builtin____new_array_with_default(0, g_main_argc, sizeof(string), 0);
	for (int i = 0; i < g_main_argc; ++i) {
		#if defined(_WIN32)
		{
		}
		#else
		{
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__tos_clone(argv[i]) }));
		}
		#endif
	}
	return res;
}
string builtin__vcurrent_hash(void) {
	return _S("6fa4008");
}
u64 builtin__v_getpid(void) {
	#if defined(CUSTOM_DEFINE_no_getpid)
	{
	}
	#elif defined(_WIN32)
	{
	}
	#else
	{
		return ((u64)(getpid()));
	}
	#endif
	return 0;
}
u64 builtin__v_gettid(void) {
	#if defined(CUSTOM_DEFINE_no_gettid)
	{
	}
	#elif defined(_WIN32)
	{
	}
	#elif defined(__linux__) && !defined(CUSTOM_DEFINE_musl)
	{
	}
	#elif defined(__VTHREADS__)
	{
		return ((u64)(pthread_self()));
	}
	#else
	{
	}
	#endif
	return 0;
}
inline bool builtin__isnil(voidptr v) {
	return v == 0;
}
VV_LOC voidptr builtin____as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = builtin__string_clone(((VCastTypeIndexName*)as_cast_type_indexes.data)[0].tname);
		string expected_name = builtin__string_clone(((VCastTypeIndexName*)as_cast_type_indexes.data)[0].tname);
		for (int _t1 = 0; _t1 < as_cast_type_indexes.len; ++_t1) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t1];
			if (x.tindex == obj_type) {
				obj_name = builtin__string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = builtin__string_clone(x.tname);
			}
		}
		builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("as cast: cannot cast `"), obj_name), _S("` to `")), expected_name), _S("`")));
		VUNREACHABLE();
	}
	return obj;
}
VV_LOC void builtin__builtin_init(void) {
}
VNORETURN void builtin__panic_lasterr(string base) {
	builtin___v_panic(builtin__string__plus(base, _S(" unknown")));
	VUNREACHABLE();
	while(1);
}
void builtin__gc_check_leaks(void) {
}
bool builtin__gc_is_enabled(void) {
	return false;
}
void builtin__gc_enable(void) {
}
void builtin__gc_disable(void) {
}
void builtin__gc_collect(void) {
}
void builtin__gc_get_warn_proc(void) {
}
void builtin__gc_set_warn_proc(void (*cb)(char* msg, usize arg)) {
}
inline int builtin__vstrlen(u8* s) {
	return strlen(((char*)(s)));
}
inline int builtin__vstrlen_char(char* s) {
	return strlen(s);
}
inline voidptr builtin__vmemcpy(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}
inline voidptr builtin__vmemmove(voidptr dest, const voidptr const_src, isize n) {
	if (n == 0) {
		return dest;
	}
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}
inline int builtin__vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n) {
	if (n == 0) {
		return 0;
	}
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}
inline voidptr builtin__vmemset(voidptr s, int c, isize n) {
	if (n == 0) {
		return s;
	}
	{ // Unsafe block
		return memset(s, c, n);
	}
	return 0;
}
inline VV_LOC void builtin__vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b)) {
	if (nmemb == 0) {
		return;
	}
	qsort(base, nmemb, size, ((voidptr)(sort_cb)));
}
void builtin__chan_close(chan ch) {
}
ChanState builtin__chan_try_pop(chan ch, voidptr obj) {
	return ChanState__success;
}
ChanState builtin__chan_try_push(chan ch, voidptr obj) {
	return ChanState__success;
}
VV_LOC void builtin___result_ok(voidptr data, _result* res, int size) {
	{ // Unsafe block
		*res = ((_result){.is_error = 0,.err = _const_none__,});
		builtin__vmemcpy(((u8*)(&res->err)) + sizeof(IError), data, size);
	}
}
string builtin__IError_str(IError err) {
	return ((err._typ == _IError_None___index)? (_S("none")) : (err._typ == _IError_Error_index)? (builtin__Error_msg(*(err._Error))) : (err._typ == _IError_MessageError_index)? (builtin__MessageError_str((*(err._MessageError)))) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = builtin__charptr_vstring_literal(v_typeof_interface_IError( (err)._typ ))}}, {_S(": "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}}))));
}
string builtin__Error_msg(Error err) {
	return _S("");
}
int builtin__Error_code(Error err) {
	return 0;
}
string builtin__MessageError_str(MessageError err) {
	if (err.code > 0) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = err.msg}}, {_S("; code: "), 0xfe07, {.d_i32 = err.code}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return err.msg;
}
string builtin__MessageError_msg(MessageError err) {
	return err.msg;
}
int builtin__MessageError_code(MessageError err) {
	return err.code;
}
void builtin__MessageError_free(MessageError* err) {
	builtin__string_free(&err->msg);
}
inline IError builtin___v_error(string message) {
	;
	return I_MessageError_to_Interface_IError(((MessageError*)builtin__memdup(&(MessageError){.msg = message,.code = 0,}, sizeof(MessageError))));
}
inline IError builtin__error_with_code(string message, int code) {
	;
	return I_MessageError_to_Interface_IError(((MessageError*)builtin__memdup(&(MessageError){.msg = message,.code = code,}, sizeof(MessageError))));
}
VV_LOC void builtin___option_none(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 2,.err = _const_none__,});
		builtin__vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}
VV_LOC void builtin___option_ok(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 0,.err = _const_none__,});
		builtin__vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}
VV_LOC void builtin___option_clone(_option* current, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = current->state,.err = current->err,});
		builtin__vmemcpy(((u8*)(&option->err)) + sizeof(IError), ((u8*)(&current->err)) + sizeof(IError), size);
	}
}
VV_LOC string builtin__None___str(None__ _d1) {
	return _S("none");
}
string builtin__none_str(none _d1) {
	return _S("none");
}
int builtin__input_character(void) {
	int ch = 0;
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__vinix__)
	{
	}
	#else
	{
		ch = getchar();
		if (ch == EOF) {
			return -1;
		}
	}
	#endif
	return ch;
}
int builtin__print_character(u8 ch) {
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#elif defined(__vinix__)
	{
	}
	#else
	{
		i32 x = putchar(ch);
		if (x == EOF) {
			return -1;
		}
	}
	#endif
	return ch;
}
#if !defined(CUSTOM_DEFINE_nofloat)
#endif
#if !defined(_VNATIVE)
#endif
inline string builtin__f64_str(f64 x) {
	{ // Unsafe block
		strconv__Float64u f = ((strconv__Float64u){.f = x,});
		if (f.u == _const_strconv__double_minus_zero) {
			return _S("-0.0");
		}
		if (f.u == _const_strconv__double_plus_zero) {
			return _S("0.0");
		}
	}
	f64 abs_x = builtin__f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__f64_strg(f64 x) {
	if (x == 0) {
		return _S("0.0");
	}
	f64 abs_x = builtin__f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__float_literal_str(float_literal d) {
	return builtin__f64_str(((f64)(d)));
}
inline string builtin__f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}
inline string builtin__f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}
inline string builtin__f32_str(f32 x) {
	{ // Unsafe block
		strconv__Float32u f = ((strconv__Float32u){.f = x,});
		if (f.u == _const_strconv__single_minus_zero) {
			return _S("-0.0");
		}
		if (f.u == _const_strconv__single_plus_zero) {
			return _S("0.0");
		}
	}
	f32 abs_x = builtin__f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__f32_strg(f32 x) {
	if (x == 0) {
		return _S("0.0");
	}
	f32 abs_x = builtin__f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}
inline string builtin__f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}
inline f32 builtin__f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}
inline f64 builtin__f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}
inline f32 builtin__f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}
inline f32 builtin__f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}
inline f64 builtin__f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}
inline f64 builtin__f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}
inline bool builtin__f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = builtin__f32_max(builtin__f32_abs(a), builtin__f32_abs(b));
	f32 delta = builtin__f32_abs((f32)(a - b));
	#if defined(_VNATIVE)
	{
	}
	#else
	{
		if (hi > ((f32)(1.0))) {
			return delta <= (f32)(hi * ((f32)(4 * ((f32)(FLT_EPSILON)))));
		} else {
			return (f32)(((f32)(1 / ((f32)(4 * ((f32)(FLT_EPSILON)))))) * delta) <= hi;
		}
	}
	#endif
	return 0;
}
inline bool builtin__f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = builtin__f64_max(builtin__f64_abs(a), builtin__f64_abs(b));
	f64 delta = builtin__f64_abs((f64)(a - b));
	#if defined(_VNATIVE)
	{
	}
	#else
	{
		if (hi > ((f64)(1.0))) {
			return delta <= (f64)(hi * ((f64)(4 * ((f64)(DBL_EPSILON)))));
		} else {
			return (f64)(((f64)(1 / ((f64)(4 * ((f64)(DBL_EPSILON)))))) * delta) <= hi;
		}
	}
	#endif
	return 0;
}
_option_rune builtin__input_rune(void) {
	int x = builtin__input_character();
	if (x <= 0) {
		return (_option_rune){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int char_len = builtin__utf8_char_len(((u8)(x)));
	if (char_len == 1) {
		_option_rune _t2;
		builtin___option_ok(&(rune[]) { x }, (_option*)(&_t2), sizeof(rune));
		 
		return _t2;
	}
	u8 b = ((u8)(x));
	b = (b << char_len);
	rune res = ((rune)(b));
	int shift = (int)(6 - char_len);
	for (int i = 1; i < char_len; i++) {
		rune c = ((rune)(builtin__input_character()));
		res = (((rune)(res)) << shift);
		res |= (c & 63);
		shift = 6;
	}
	_option_rune _t3;
	builtin___option_ok(&(rune[]) { res }, (_option*)(&_t3), sizeof(rune));
	 
	return _t3;
}
_option_rune builtin__InputRuneIterator_next(InputRuneIterator* self) {
	return builtin__input_rune();
}
InputRuneIterator builtin__input_rune_iterator(void) {
	return ((InputRuneIterator){E_STRUCT});
}
string builtin__ptr_str(voidptr ptr) {
	string buf1 = builtin__u64_to_hex_no_leading_zeros(((u64)(ptr)), 16);
	return buf1;
}
string builtin__isize_str(isize x) {
	return builtin__i64_str(((i64)(x)));
}
string builtin__usize_str(usize x) {
	return builtin__u64_str(((u64)(x)));
}
string builtin__char_str(char* cptr) {
	return builtin__u64_hex(((u64)(cptr)));
}
inline VV_LOC string builtin__int_str_l(int nn, int max) {
	{ // Unsafe block
		i64 n = ((i64)(nn));
		int d = 0;
		if (n == 0) {
			return _S("0");
		}
		#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
		{
		}
		#else
		{
			if (n == _const_min_i32) {
				return _S("-2147483648");
			}
		}
		#endif
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		u8* buf = builtin__malloc_noscan((int)(max + 1));
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			int n1 = ((int)((i64)(n / 100)));
			d = ((int)((((u32)((int)(((int)(n)) - ((int)(n1 * 100))))) << 1)));
			n = n1;
			buf[index] = _const_digit_pairs.str[d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		builtin__vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return builtin__tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__i8_str(i8 n) {
	return builtin__int_str_l(((int)(n)), 4);
}
string builtin__i16_str(i16 n) {
	return builtin__int_str_l(((int)(n)), 6);
}
string builtin__u16_str(u16 n) {
	return builtin__int_str_l(((int)(n)), 6);
}
string builtin__i32_str(i32 n) {
	return builtin__int_str_l(((int)(n)), 11);
}
string builtin__int_hex_full(int nn) {
	return builtin__u64_to_hex(((u64)(nn)), 8);
}
string builtin__int_str(int n) {
	#if defined(CUSTOM_DEFINE_new_int)
	{
	}
	#else
	{
		return builtin__int_str_l(n, 11);
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__u32_str(u32 nn) {
	{ // Unsafe block
		u32 n = nn;
		u32 d = ((u32)(0));
		if (n == 0) {
			return _S("0");
		}
		int max = 10;
		u8* buf = builtin__malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			u32 n1 = (u32)(n / ((u32)(100)));
			d = ((((u32)(n - ((u32)(n1 * ((u32)(100)))))) << ((u32)(1))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((u32)(20))) {
			index++;
		}
		int diff = (int)(max - index);
		builtin__vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return builtin__tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__int_literal_str(int_literal n) {
	return builtin__impl_i64_to_string(n);
}
inline string builtin__i64_str(i64 nn) {
	return builtin__impl_i64_to_string(nn);
}
VV_LOC string builtin__impl_i64_to_string(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _S("0");
		} else if (n == _const_min_i64) {
			return _S("-9223372036854775808");
		}
		int max = 20;
		u8* buf = builtin__malloc_noscan((int)(max + 1));
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = (i64)(n / ((i64)(100)));
			d = ((((u32)((i64)(n - ((i64)(n1 * ((i64)(100))))))) << ((i64)(1))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		builtin__vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return builtin__tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__u64_str(u64 nn) {
	{ // Unsafe block
		u64 n = nn;
		u64 d = ((u64)(0));
		if (n == 0) {
			return _S("0");
		}
		int max = 20;
		u8* buf = builtin__malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			u64 n1 = (u64)(n / 100);
			d = ((((u64)(n - ((u64)(n1 * 100)))) << 1));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		int diff = (int)(max - index);
		builtin__vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return builtin__tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__bool_str(bool b) {
	if (b) {
		return _S("true");
	}
	return _S("false");
}
inline VV_LOC string builtin__u64_to_hex(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = (u8)(len - 1); i >= 0; i--) {
		u8 d = ((u8)((n & 0xF)));
		buf[i] = (d < 10 ? ((rune)(d + '0')) : ((u8)(d + 87)));
		n = (n >> 4);
	}
	return builtin__tos(builtin__memdup(&buf[0], (u8)(len + 1)), len);
}
inline VV_LOC string builtin__u64_to_hex_no_leading_zeros(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = (u8)(len - 1); i >= 0; i--) {
		u8 d = ((u8)((n & 0xF)));
		buf[i] = (d < 10 ? ((rune)(d + '0')) : ((u8)(d + 87)));
		n = (n >> 4);
		if (n == 0) {
			break;
		}
	}
	int res_len = (int)(len - i);
	return builtin__tos(builtin__memdup(&buf[i], (int)(res_len + 1)), res_len);
}
string builtin__u8_hex(u8 nn) {
	if (nn == 0) {
		return _S("00");
	}
	return builtin__u64_to_hex(nn, 2);
}
string builtin__char_hex(char c) {
	return builtin__u8_hex(((u8)(c)));
}
string builtin__rune_hex(rune r) {
	return builtin__u32_hex(((u32)(r)));
}
string builtin__i8_hex(i8 nn) {
	if (nn == 0) {
		return _S("00");
	}
	return builtin__u64_to_hex(((u64)(nn)), 2);
}
string builtin__u16_hex(u16 nn) {
	if (nn == 0) {
		return _S("0");
	}
	return builtin__u64_to_hex_no_leading_zeros(nn, 4);
}
string builtin__i16_hex(i16 nn) {
	return builtin__u16_hex(((u16)(nn)));
}
string builtin__u32_hex(u32 nn) {
	if (nn == 0) {
		return _S("0");
	}
	return builtin__u64_to_hex_no_leading_zeros(nn, 8);
}
string builtin__int_hex(int nn) {
	return builtin__u32_hex(((u32)(nn)));
}
string builtin__int_hex2(int n) {
	return builtin__string__plus(_S("0x"), builtin__int_hex(n));
}
string builtin__u64_hex(u64 nn) {
	if (nn == 0) {
		return _S("0");
	}
	return builtin__u64_to_hex_no_leading_zeros(nn, 16);
}
string builtin__i64_hex(i64 nn) {
	return builtin__u64_hex(((u64)(nn)));
}
string builtin__int_literal_hex(int_literal nn) {
	return builtin__u64_hex(((u64)(nn)));
}
string builtin__voidptr_str(voidptr nn) {
	return builtin__string__plus(_S("0x"), builtin__u64_hex(((u64)(nn))));
}
string builtin__byteptr_str(byteptr nn) {
	return builtin__string__plus(_S("0x"), builtin__u64_hex(((u64)(nn))));
}
string builtin__charptr_str(charptr nn) {
	return builtin__string__plus(_S("0x"), builtin__u64_hex(((u64)(nn))));
}
string builtin__u8_hex_full(u8 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 2);
}
string builtin__i8_hex_full(i8 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 2);
}
string builtin__u16_hex_full(u16 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 4);
}
string builtin__i16_hex_full(i16 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 4);
}
string builtin__u32_hex_full(u32 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 8);
}
string builtin__i64_hex_full(i64 nn) {
	return builtin__u64_to_hex(((u64)(nn)), 16);
}
string builtin__voidptr_hex_full(voidptr nn) {
	return builtin__u64_to_hex(((u64)(nn)), 16);
}
string builtin__int_literal_hex_full(int_literal nn) {
	return builtin__u64_to_hex(((u64)(nn)), 16);
}
string builtin__u64_hex_full(u64 nn) {
	return builtin__u64_to_hex(nn, 16);
}
string builtin__u8_str(u8 b) {
	return builtin__int_str_l(((int)(b)), 4);
}
string builtin__u8_ascii_str(u8 b) {
	string str = ((string){.str = builtin__malloc_noscan(2), .len = 1});
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = 0;
	}
	return str;
}
string builtin__u8_str_escaped(u8 b) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	
	if (b == (0)) {
		_t1 = _S("`\\0`");
	}
	else if (b == (7)) {
		_t1 = _S("`\\a`");
	}
	else if (b == (8)) {
		_t1 = _S("`\\b`");
	}
	else if (b == (9)) {
		_t1 = _S("`\\t`");
	}
	else if (b == (10)) {
		_t1 = _S("`\\n`");
	}
	else if (b == (11)) {
		_t1 = _S("`\\v`");
	}
	else if (b == (12)) {
		_t1 = _S("`\\f`");
	}
	else if (b == (13)) {
		_t1 = _S("`\\r`");
	}
	else if (b == (27)) {
		_t1 = _S("`\\e`");
	}
	else if ((b >= 32 && b <= 126)) {
		_t1 = builtin__u8_ascii_str(b);
	}
	else {
		string xx = builtin__u8_hex(b);
		string yy = builtin__string__plus(_S("0x"), xx);
		builtin__string_free(&xx);
		_t1 = yy;
	}string str = _t1;
	return str;
}
inline bool builtin__u8_is_capital(u8 c) {
	return c >= 'A' && c <= 'Z';
}
string Array_u8_bytestr(Array_u8 b) {
	{ // Unsafe block
		u8* buf = builtin__malloc_noscan((int)(b.len + 1));
		builtin__vmemcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return builtin__tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
_result_rune Array_u8_byterune(Array_u8 b) {
	_result_rune _t1 = Array_u8_utf8_to_utf32(b);
	if (_t1.is_error) {
		_result_rune _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	rune r = (*(rune*)_t1.data);
	_result_rune _t3;
	builtin___result_ok(&(rune[]) { ((rune)(r)) }, (_result*)(&_t3), sizeof(rune));
	 
	return _t3;
}
string builtin__u8_repeat(u8 b, int count) {
	if (count <= 0) {
		return _S("");
	} else if (count == 1) {
		return builtin__u8_ascii_str(b);
	}
	u8* bytes = builtin__malloc_noscan((int)(count + 1));
	{ // Unsafe block
		builtin__vmemset(bytes, b, count);
		bytes[count] = 0;
	}
	return builtin__u8_vstring_with_len(bytes, count);
}
inline int builtin__int_min(int a, int b) {
	return (a < b ? (a) : (b));
}
inline int builtin__int_max(int a, int b) {
	return (a > b ? (a) : (b));
}
inline VV_LOC bool builtin__fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}
VV_LOC u64 builtin__map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	#if defined(_VNATIVE)
	{
	}
	#else
	{
		return wyhash(key.str, ((u64)(key.len)), 0, ((u64*)(((voidptr)(_wyp)))));
	}
	#endif
	return 0;
}
VV_LOC u64 builtin__map_hash_int_1(voidptr pkey) {
	return wyhash64(*((u8*)(pkey)), 0);
}
VV_LOC u64 builtin__map_hash_int_2(voidptr pkey) {
	return wyhash64(*((u16*)(pkey)), 0);
}
VV_LOC u64 builtin__map_hash_int_4(voidptr pkey) {
	return wyhash64(*((u32*)(pkey)), 0);
}
VV_LOC u64 builtin__map_hash_int_8(voidptr pkey) {
	return wyhash64(*((u64*)(pkey)), 0);
}
VV_LOC voidptr builtin__map_enum_fn(int kind, int esize) {
	if (!(kind == 1 || kind == 2 || kind == 3)) {
		builtin___v_panic(_S("map_enum_fn: invalid kind"));
		VUNREACHABLE();
	}
	if (esize > 8 || esize < 0) {
		builtin___v_panic(_S("map_enum_fn: invalid esize"));
		VUNREACHABLE();
	}
	if (kind == 1) {
		if (esize > 4) {
			return ((voidptr)(builtin__map_hash_int_8));
		}
		if (esize > 2) {
			return ((voidptr)(builtin__map_hash_int_4));
		}
		if (esize > 1) {
			return ((voidptr)(builtin__map_hash_int_2));
		}
		if (esize > 0) {
			return ((voidptr)(builtin__map_hash_int_1));
		}
	}
	if (kind == 2) {
		if (esize > 4) {
			return ((voidptr)(builtin__map_eq_int_8));
		}
		if (esize > 2) {
			return ((voidptr)(builtin__map_eq_int_4));
		}
		if (esize > 1) {
			return ((voidptr)(builtin__map_eq_int_2));
		}
		if (esize > 0) {
			return ((voidptr)(builtin__map_eq_int_1));
		}
	}
	if (kind == 3) {
		if (esize > 4) {
			return ((voidptr)(builtin__map_clone_int_8));
		}
		if (esize > 2) {
			return ((voidptr)(builtin__map_clone_int_4));
		}
		if (esize > 1) {
			return ((voidptr)(builtin__map_clone_int_2));
		}
		if (esize > 0) {
			return ((voidptr)(builtin__map_clone_int_1));
		}
	}
	return ((void*)0);
}
VV_LOC void builtin__DenseArray_zeros_to_end(DenseArray* d) {
	u8* tmp_value = builtin___v_malloc(d->value_bytes);
	u8* tmp_key = builtin___v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (builtin__DenseArray_has_index(d, i)) {
			{ // Unsafe block
				if (count != i) {
					memcpy(tmp_key, builtin__DenseArray_key(d, count), d->key_bytes);
					memcpy(builtin__DenseArray_key(d, count), builtin__DenseArray_key(d, i), d->key_bytes);
					memcpy(builtin__DenseArray_key(d, i), tmp_key, d->key_bytes);
					memcpy(tmp_value, builtin__DenseArray_value(d, count), d->value_bytes);
					memcpy(builtin__DenseArray_value(d, count), builtin__DenseArray_value(d, i), d->value_bytes);
					memcpy(builtin__DenseArray_value(d, i), tmp_value, d->value_bytes);
				}
			}
			count++;
		}
	}
	{ // Unsafe block
		builtin___v_free(tmp_value);
		builtin___v_free(tmp_key);
		d->deletes = 0;
		builtin___v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = builtin__realloc_data(d->values, (int)(d->value_bytes * old_cap), (int)(d->value_bytes * d->cap));
		d->keys = builtin__realloc_data(d->keys, (int)(d->key_bytes * old_cap), (int)(d->key_bytes * d->cap));
	}
}
inline VV_LOC DenseArray builtin__new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0,
		.all_deleted = ((void*)0),
		.keys = builtin___v_malloc(builtin____at_least_one((u64)(((u64)(cap)) * ((u64)(key_bytes))))),
		.values = builtin___v_malloc(builtin____at_least_one((u64)(((u64)(cap)) * ((u64)(value_bytes))))),
	});
}
inline VV_LOC voidptr builtin__DenseArray_key(DenseArray* d, int i) {
	return ((voidptr)(d->keys + (int)(i * d->key_bytes)));
}
inline VV_LOC voidptr builtin__DenseArray_value(DenseArray* d, int i) {
	return ((voidptr)(d->values + (int)(i * d->value_bytes)));
}
inline VV_LOC bool builtin__DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0 || d->all_deleted[i] == 0;
}
inline VV_LOC int builtin__DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_key_size = (int)(d->key_bytes * old_cap);
	int old_value_size = (int)(d->value_bytes * old_cap);
	if (d->cap == d->len) {
		d->cap += (d->cap >> 3);
		{ // Unsafe block
			d->keys = builtin__realloc_data(d->keys, old_key_size, (int)(d->key_bytes * d->cap));
			d->values = builtin__realloc_data(d->values, old_value_size, (int)(d->value_bytes * d->cap));
			if (d->deletes != 0) {
				d->all_deleted = builtin__realloc_data(d->all_deleted, old_cap, d->cap);
				builtin__vmemset(((voidptr)(d->all_deleted + d->len)), 0, (int)(d->cap - d->len));
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}
inline VV_LOC bool builtin__map_eq_string(voidptr a, voidptr b) {
	return builtin__fast_string_eq(*((string*)(a)), *((string*)(b)));
}
inline VV_LOC bool builtin__map_eq_int_1(voidptr a, voidptr b) {
	return *((u8*)(a)) == *((u8*)(b));
}
inline VV_LOC bool builtin__map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}
inline VV_LOC bool builtin__map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}
inline VV_LOC bool builtin__map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}
inline VV_LOC void builtin__map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		string cloned = builtin__string_clone(s);
		memcpy(dest, ((voidptr)(&cloned)), sizeof(string));
	}
}
inline VV_LOC void builtin__map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u8*)(dest)) = *((u8*)(pkey));
	}
}
inline VV_LOC void builtin__map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}
inline VV_LOC void builtin__map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}
inline VV_LOC void builtin__map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}
inline VV_LOC void builtin__map_free_string(voidptr pkey) {
	builtin__string_free(ADDR(string, (*((string*)(pkey)))));
}
inline VV_LOC void builtin__map_free_nop(voidptr _d1) {
}
VV_LOC map builtin__new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = key_bytes > ((int)(sizeof(voidptr)));
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = builtin__new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(builtin__vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}
VV_LOC map builtin__new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = builtin__new_map(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			builtin__map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}
map builtin__map_move(map* m) {
	map r = *m;
	builtin__vmemset(m, 0, ((int)(sizeof(map))));
	return r;
}
void builtin__map_clear(map* m) {
	{ // Unsafe block
		if (m->key_values.all_deleted != 0) {
			builtin___v_free(m->key_values.all_deleted);
			m->key_values.all_deleted = ((void*)0);
		}
		builtin__vmemset(m->key_values.keys, 0, (int)(m->key_values.key_bytes * m->key_values.cap));
		builtin__vmemset(m->metas, 0, (u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2) + m->extra_metas))));
	}
	m->key_values.len = 0;
	m->key_values.deletes = 0;
	m->even_index = _const_init_even_index;
	m->cached_hashbits = _const_max_cached_hashbits;
	m->shift = _const_init_log_capicity;
	m->len = 0;
}
inline VV_LOC multi_return_u32_u32 builtin__map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = (((((hash >> m->shift)) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}
inline VV_LOC multi_return_u32_u32 builtin__map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}
inline VV_LOC void builtin__map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[(u32)(index + 1)];
				m->metas[(u32)(index + 1)] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[(u32)(index + 1)] = kv_index;
	}
	u32 probe_count = (u32)(((meta >> _const_hashbits)) - 1);
	builtin__map_ensure_extra_metas(m, probe_count);
}
inline VV_LOC void builtin__map_ensure_extra_metas(map* m, u32 probe_count) {
	if (((probe_count << 1)) == m->extra_metas) {
		u32 size_of_u32 = sizeof(u32);
		u32 old_mem_size = ((u32)((u32)(m->even_index + 2) + m->extra_metas));
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = ((u32)((u32)(m->even_index + 2) + m->extra_metas));
		{ // Unsafe block
			u8* x = builtin__realloc_data(((u8*)(m->metas)), ((int)((u32)(size_of_u32 * old_mem_size))), ((int)((u32)(size_of_u32 * mem_size))));
			m->metas = ((u32*)(x));
			builtin__vmemset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)((u32)(sizeof(u32) * _const_extra_metas_inc))));
		}
		if (probe_count == 252) {
			builtin___v_panic(_S("Probe overflow"));
			VUNREACHABLE();
		}
	}
}
VV_LOC void builtin__map_set(map* m, voidptr key, voidptr value) {
	f32 load_factor = (f32)(((f32)((((u32)(m->len)) << 1))) / ((f32)(m->even_index)));
	if (load_factor > ((f32)(_const_max_load_factor))) {
		builtin__map_expand(m);
	}
	multi_return_u32_u32 mr_12485 = builtin__map_key_to_index(m, key);
	u32 index = mr_12485.arg0;
	u32 meta = mr_12485.arg1;
	multi_return_u32_u32 mr_12521 = builtin__map_meta_less(m, index, meta);
	index = mr_12521.arg0;
	meta = mr_12521.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1)]));
		voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = builtin__DenseArray_value(&m->key_values, kv_index);
				builtin__vmemcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
	int kv_index = builtin__DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = builtin__DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		builtin__vmemcpy(((u8*)(pvalue)), value, m->value_bytes);
	}
	builtin__map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}
VV_LOC void builtin__map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = (u32)(((((u32)(m->even_index + 2)) << 1)) - 2);
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		builtin__map_rehash(m);
	} else {
		builtin__map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}
VV_LOC void builtin__map_rehash(map* m) {
	u32 meta_bytes = (u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2) + m->extra_metas)));
	builtin__map_reserve(m, meta_bytes);
}
void builtin__map_reserve(map* m, u32 meta_bytes) {
	{ // Unsafe block
		u8* x = builtin__v_realloc(((u8*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		builtin__vmemset(m->metas, 0, ((int)(meta_bytes)));
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!builtin__DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = builtin__DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_14282 = builtin__map_key_to_index(m, pkey);
		u32 index = mr_14282.arg0;
		u32 meta = mr_14282.arg1;
		multi_return_u32_u32 mr_14320 = builtin__map_meta_less(m, index, meta);
		index = mr_14320.arg0;
		meta = mr_14320.arg1;
		builtin__map_meta_greater(m, index, meta, ((u32)(i)));
	}
}
VV_LOC void builtin__map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2) + m->extra_metas)))));
	m->metas = ((u32*)(builtin__vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0)); i <= (u32)(old_cap + old_extra_metas); i += 2) {
		if (old_metas[i] == 0) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = (((u32)(((old_meta >> _const_hashbits)) - 1)) << 1);
		u32 old_index = (((u32)(i - old_probe_count)) & ((m->even_index >> 1)));
		u32 index = (((old_index | ((old_meta << m->shift)))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_15122 = builtin__map_meta_less(m, index, meta);
		index = mr_15122.arg0;
		meta = mr_15122.arg1;
		u32 kv_index = old_metas[(u32)(i + 1)];
		builtin__map_meta_greater(m, index, meta, kv_index);
	}
	builtin___v_free(old_metas);
}
VV_LOC voidptr builtin__map_get_and_set(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_15570 = builtin__map_key_to_index(m, key);
		u32 index = mr_15570.arg0;
		u32 meta = mr_15570.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[(u32)(index + 1)]));
				voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = builtin__DenseArray_value(&m->key_values, kv_index);
					return ((u8*)(pval));
				}
			}
			index += 2;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		builtin__map_set(m, key, zero);
	}
	return ((void*)0);
}
VV_LOC voidptr builtin__map_get(map* m, voidptr key, voidptr zero) {
	if (m->len == 0) {
		return zero;
	}
	multi_return_u32_u32 mr_16331 = builtin__map_key_to_index(m, key);
	u32 index = mr_16331.arg0;
	u32 meta = mr_16331.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1)]));
			voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = builtin__DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}
VV_LOC voidptr builtin__map_get_check(map* m, voidptr key) {
	if (m->len == 0) {
		return 0;
	}
	multi_return_u32_u32 mr_17027 = builtin__map_key_to_index(m, key);
	u32 index = mr_17027.arg0;
	u32 meta = mr_17027.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1)]));
			voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = builtin__DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}
VV_LOC bool builtin__map_exists(map* m, voidptr key) {
	if (m->len == 0) {
		return false;
	}
	multi_return_u32_u32 mr_17572 = builtin__map_key_to_index(m, key);
	u32 index = mr_17572.arg0;
	u32 meta = mr_17572.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1)]));
			voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}
inline VV_LOC void builtin__DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0) {
		d->all_deleted = builtin__vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}
void builtin__map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_18210 = builtin__map_key_to_index(m, key);
	u32 index = mr_18210.arg0;
	u32 meta = mr_18210.arg1;
	multi_return_u32_u32 mr_18246 = builtin__map_meta_less(m, index, meta);
	index = mr_18246.arg0;
	meta = mr_18246.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1)]));
		voidptr pkey = builtin__DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!(((m->metas[(u32)(index + 2)] >> _const_hashbits)) > 1)) break;
				{ // Unsafe block
					m->metas[index] = (u32)(m->metas[(u32)(index + 2)] - _const_probe_inc);
					m->metas[(u32)(index + 1)] = m->metas[(u32)(index + 3)];
				}
				index += 2;
			}
			m->len--;
			builtin__DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0;
				m->free_fn(pkey);
				builtin__vmemset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,((m->key_values.len >> 1)))) {
				builtin__DenseArray_zeros_to_end(&m->key_values);
				builtin__map_rehash(m);
			}
			return;
		}
		index += 2;
		meta += _const_probe_inc;
	}
}
array builtin__map_keys(map* m) {
	array keys = builtin____new_array(m->len, 0, m->key_bytes);
	u8* item = ((u8*)(keys.data));
	if (m->key_values.deletes == 0) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = builtin__DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!builtin__DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = builtin__DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}
array builtin__map_values(map* m) {
	array values = builtin____new_array(m->len, 0, m->value_bytes);
	u8* item = ((u8*)(values.data));
	if (m->key_values.deletes == 0) {
		builtin__vmemcpy(item, m->key_values.values, (int)(m->value_bytes * m->key_values.len));
		return values;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!builtin__DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pvalue = builtin__DenseArray_value(&m->key_values, i);
			builtin__vmemcpy(item, pvalue, m->value_bytes);
			item = item + m->value_bytes;
		}
	}
	return values;
}
VV_LOC DenseArray builtin__DenseArray_clone(DenseArray* d) {
	DenseArray res = ((DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = ((void*)0),
		.keys = ((void*)0),
		.values = ((void*)0),
	});
	{ // Unsafe block
		if (d->deletes != 0) {
			res.all_deleted = builtin__memdup(d->all_deleted, d->cap);
		}
		res.keys = builtin__memdup(d->keys, (int)(d->cap * d->key_bytes));
		res.values = builtin__memdup(d->values, (int)(d->cap * d->value_bytes));
	}
	return res;
}
map builtin__map_clone(map* m) {
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2) + m->extra_metas)))));
	map res = ((map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = builtin__DenseArray_clone(&m->key_values),
		.metas = ((u32*)(builtin__malloc_noscan(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = (voidptr)m->hash_fn,
		.key_eq_fn = (voidptr)m->key_eq_fn,
		.clone_fn = (voidptr)m->clone_fn,
		.free_fn = (voidptr)m->free_fn,
		.len = m->len,
	});
	builtin__vmemcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!builtin__DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(builtin__DenseArray_key(&res.key_values, i), builtin__DenseArray_key(&m->key_values, i));
	}
	return res;
}
void builtin__map_free(map* m) {
	builtin___v_free(m->metas);
	{ // Unsafe block
		m->metas = ((void*)0);
	}
	if (m->key_values.deletes == 0) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = builtin__DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				builtin__vmemset(pkey, 0, m->key_bytes);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!builtin__DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = builtin__DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				builtin__vmemset(pkey, 0, m->key_bytes);
			}
		}
	}
	{ // Unsafe block
		if (m->key_values.all_deleted != ((void*)0)) {
			builtin___v_free(m->key_values.all_deleted);
			m->key_values.all_deleted = ((void*)0);
		}
		if (m->key_values.keys != ((void*)0)) {
			builtin___v_free(m->key_values.keys);
			m->key_values.keys = ((void*)0);
		}
		if (m->key_values.values != ((void*)0)) {
			builtin___v_free(m->key_values.values);
			m->key_values.values = ((void*)0);
		}
		m->hash_fn = (voidptr)((void*)0);
		m->key_eq_fn = (voidptr)((void*)0);
		m->clone_fn = (voidptr)((void*)0);
		m->free_fn = (voidptr)((void*)0);
	}
}
void builtin__VAssertMetaInfo_free(VAssertMetaInfo* ami) {
	{ // Unsafe block
		builtin__string_free(&ami->fpath);
		builtin__string_free(&ami->fn_name);
		builtin__string_free(&ami->src);
		builtin__string_free(&ami->op);
		builtin__string_free(&ami->llabel);
		builtin__string_free(&ami->rlabel);
		builtin__string_free(&ami->lvalue);
		builtin__string_free(&ami->rvalue);
		builtin__string_free(&ami->message);
	}
}
void builtin__IError_free(IError* ie) {
	{ // Unsafe block
		IError* cie = ((IError*)(ie));
		builtin___v_free(cie->_object);
	}
}
VNORETURN void builtin__panic_option_not_set(string s) {
	builtin___v_panic(builtin__string__plus(builtin__string__plus(_S("option not set ("), s), _S(")")));
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin__panic_result_not_set(string s) {
	builtin___v_panic(builtin__string__plus(builtin__string__plus(_S("result not set ("), s), _S(")")));
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin___v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin__flush_stdout();
		builtin__eprint(_S("V panic: "));
		builtin__eprintln(s);
		builtin__eprint(_S(" v hash: "));
		builtin__eprintln(builtin__vcurrent_hash());
		#if !defined(__vinix__) && !defined(_VNATIVE)
		{
			builtin__eprint(_S("    pid: "));
			;
			fprintf(stderr, "%p\n", ((voidptr)(builtin__v_getpid())));
			builtin__eprint(_S("    tid: "));
			;
			fprintf(stderr, "%p\n", ((voidptr)(builtin__v_gettid())));
		}
		#endif
		builtin__flush_stdout();
		#if defined(_VNATIVE)
		{
		}
		#elif defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			#if defined(CUSTOM_DEFINE_use_libbacktrace)
			{
			}
			#else
			{
				builtin__print_backtrace_skipping_top_frames(1);
			}
			#endif
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	exit(1);
	VUNREACHABLE();
	while(1);
}
string builtin__c_error_number_str(int errnum) {
	string err_msg = _S("");
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if !defined(__vinix__)
		{
			char* c_msg = strerror(errnum);
			err_msg = ((string){.str = ((u8*)(c_msg)), .len = strlen(c_msg), .is_lit = 1});
		}
		#endif
	}
	#endif
	return err_msg;
}
VNORETURN void builtin__panic_n(string s, i64 number1) {
	builtin___v_panic(builtin__string__plus(s, builtin__impl_i64_to_string(number1)));
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin__panic_n2(string s, i64 number1, i64 number2) {
	builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(s, builtin__impl_i64_to_string(number1)), _S(", ")), builtin__impl_i64_to_string(number2)));
	VUNREACHABLE();
	while(1);
}
VNORETURN VV_LOC void builtin__panic_n3(string s, i64 number1, i64 number2, i64 number3) {
	builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(s, builtin__impl_i64_to_string(number1)), _S(", ")), builtin__impl_i64_to_string(number2)), _S(", ")), builtin__impl_i64_to_string(number3)));
	VUNREACHABLE();
	while(1);
}
VNORETURN void builtin__panic_error_number(string basestr, int errnum) {
	builtin___v_panic(builtin__string__plus(basestr, builtin__c_error_number_str(errnum)));
	VUNREACHABLE();
	while(1);
}
void builtin__eprintln(string s) {
	if (s.str == 0) {
		builtin__eprintln(_S("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		builtin__flush_stdout();
		builtin__flush_stderr();
		builtin___writeln_to_fd(2, s);
		builtin__flush_stderr();
	}
	#endif
}
void builtin__eprint(string s) {
	if (s.str == 0) {
		builtin__eprint(_S("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		builtin__flush_stdout();
		builtin__flush_stderr();
		builtin___write_buf_to_fd(2, s.str, s.len);
		builtin__flush_stderr();
	}
	#endif
}
void builtin__flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(_VNATIVE)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}
void builtin__flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(_VNATIVE)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}
void builtin__unbuffer_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		setbuf(stdout, 0);
	}
	#endif
}
void builtin__print(string s) {
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin___write_buf_to_fd(1, s.str, s.len);
	}
	#endif
}
void builtin__println(string s) {
	if (s.str == 0) {
		builtin__println(_S("println(NIL)"));
		return;
	}
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		builtin___writeln_to_fd(1, s);
	}
	#endif
}
VV_LOC void builtin___writeln_to_fd(int fd, string s) {
	#if defined(CUSTOM_DEFINE_builtin_writeln_should_write_at_once)
	{
	}
	#else
	{
		u8 lf = ((u8)('\n'));
		builtin___write_buf_to_fd(fd, s.str, s.len);
		builtin___write_buf_to_fd(fd, &lf, 1);
	}
	#endif
}
VV_LOC void builtin___write_buf_to_fd(int fd, u8* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	u8* ptr = buf;
	isize remaining_bytes = ((isize)(buf_len));
	isize x = ((isize)(0));
	#if defined(_VFREESTANDING) || defined(__vinix__) || defined(CUSTOM_DEFINE_builtin_write_buf_to_fd_should_use_c_write)
	{
	}
	#else
	{
		voidptr stream = ((voidptr)(stdout));
		if (fd == 2) {
			stream = ((voidptr)(stderr));
		}
		{ // Unsafe block
			for (;;) {
				if (!(remaining_bytes > 0)) break;
				x = ((isize)(fwrite(ptr, 1, remaining_bytes, stream)));
				ptr += x;
				remaining_bytes -= x;
			}
		}
	}
	#endif
}
string builtin__reuse_data_as_string(Array_u8 buffer) {
	return ((string){.str = buffer.data, .len = buffer.len, .is_lit = 1});
}
Array_u8 builtin__reuse_string_as_data(string s) {
	array res = ((array){.data = (voidptr)s.str,.offset = 0,.len = s.len,.cap = 0,.flags = ((ArrayFlags__nogrow | ArrayFlags__noshrink) | ArrayFlags__nofree),.element_size = 1,});
	return res;
}
string builtin__rune_str(rune c) {
	return builtin__utf32_to_str(((u32)(c)));
}
string Array_rune_string(Array_rune ra) {
	strings__Builder sb = strings__new_builder(ra.len);
	strings__Builder_write_runes(&sb, ra);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string builtin__rune_repeat(rune c, int count) {
	if (count <= 0) {
		return _S("");
	} else if (count == 1) {
		return builtin__rune_str(c);
	}
	Array_fixed_u8_5 buffer = {0};
	string res = builtin__utf32_to_str_no_malloc(((u32)(c)), &buffer[0]);
	return builtin__string_repeat(res, count);
}
Array_u8 builtin__rune_bytes(rune c) {
	Array_u8 res = builtin____new_array_with_default(0, 5, sizeof(u8), 0);
	u8* buf = ((u8*)(res.data));
	res.len = builtin__utf32_decode_to_buffer(((u32)(c)), buf);
	return res;
}
int builtin__rune_length_in_bytes(rune c) {
	u32 code = ((u32)(c));
	if (code <= 0x7F) {
		return 1;
	} else if (code <= 0x7FF) {
		return 2;
	} else if (0xD800 <= code && code <= 0xDFFF) {
		return -1;
	} else if (code <= 0xFFFF) {
		return 3;
	} else if (code <= 0x10FFFF) {
		return 4;
	}
	return -1;
}
rune builtin__rune_to_upper(rune c) {
	if (c < 0x80) {
		if (c >= 'a' && c <= 'z') {
			return (rune)(c - 32);
		}
		return c;
	}
	return builtin__rune_map_to(c, MapMode__to_upper);
}
rune builtin__rune_to_lower(rune c) {
	if (c < 0x80) {
		if (c >= 'A' && c <= 'Z') {
			return (rune)(c + 32);
		}
		return c;
	}
	return builtin__rune_map_to(c, MapMode__to_lower);
}
rune builtin__rune_to_title(rune c) {
	if (c < 0x80) {
		if (c >= 'a' && c <= 'z') {
			return (rune)(c - 32);
		}
		return c;
	}
	return builtin__rune_map_to(c, MapMode__to_title);
}
VV_LOC rune builtin__rune_map_to(rune c, MapMode mode) {
	int start = 0;
	int end = (int)(1264 / _const_rune_maps_columns_in_row);
	for (;;) {
		if (!(start < end)) break;
		int middle = (int)(((int)(start + end)) / 2);
		i32* cur_map = &_const_rune_maps[(int)(middle * _const_rune_maps_columns_in_row)];
		if (c >= ((u32)(*cur_map)) && c <= ((u32)(*(cur_map + 1)))) {
			i32 offset = ((mode == MapMode__to_upper || mode == MapMode__to_title) ? (*(cur_map + 2)) : (*(cur_map + 3)));
			if (offset == _const_rune_maps_ul) {
				rune cnt = (rune)(((rune)(c - *cur_map)) % 2);
				if (mode == MapMode__to_lower) {
					return (rune)((rune)(c + 1) - cnt);
				}
				return (rune)(c - cnt);
			} else if (offset == _const_rune_maps_utl) {
				rune cnt = (rune)(((rune)(c - *cur_map)) % 3);
				if (mode == MapMode__to_upper) {
					return (rune)(c - cnt);
				} else if (mode == MapMode__to_lower) {
					return (rune)((rune)(c + 2) - cnt);
				}
				return (rune)((rune)(c + 1) - cnt);
			}
			return (rune)(c + offset);
		}
		if (c < ((u32)(*cur_map))) {
			end = middle;
		} else {
			start = (int)(middle + 1);
		}
	}
	return c;
}
VV_LOC int builtin__mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && builtin__string__lt(n->keys[builtin__v_fixed_index(idx, 11)], k))) break;
		idx++;
	}
	return idx;
}
VV_LOC bool builtin__mapnode_remove_key(mapnode* n, string k) {
	int idx = builtin__mapnode_find_key(n, k);
	if (idx < n->len && builtin__string__eq(n->keys[builtin__v_fixed_index(idx, 11)], k)) {
		if (n->children == ((void*)0)) {
			builtin__mapnode_remove_from_leaf(n, idx);
		} else {
			builtin__mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (n->children == ((void*)0)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			builtin__mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(((void*)0)));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[(int)(idx - 1)]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return builtin__mapnode_remove_key(node, k);
	}
	return 0;
}
VV_LOC void builtin__mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = (int)(idx + 1); i < n->len; i++) {
		n->keys[builtin__v_fixed_index((int)(i - 1), 11)] = n->keys[builtin__v_fixed_index(i, 11)];
		n->values[builtin__v_fixed_index((int)(i - 1), 11)] = n->values[builtin__v_fixed_index(i, 11)];
	}
	n->len--;
}
VV_LOC void builtin__mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[builtin__v_fixed_index(idx, 11)];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(current->children != ((void*)0))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[builtin__v_fixed_index((int)(current->len - 1), 11)];
		n->keys[builtin__v_fixed_index(idx, 11)] = predecessor;
		n->values[builtin__v_fixed_index(idx, 11)] = current->values[builtin__v_fixed_index((int)(current->len - 1), 11)];
		mapnode* node = ((mapnode*)(n->children[idx]));
		builtin__mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[(int)(idx + 1)]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[(int)(idx + 1)]));
		for (;;) {
			if (!(current->children != ((void*)0))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[builtin__v_fixed_index(idx, 11)] = successor;
		n->values[builtin__v_fixed_index(idx, 11)] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[(int)(idx + 1)]));
		builtin__mapnode_remove_key(node, successor);
	} else {
		builtin__mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		builtin__mapnode_remove_key(node, k);
	}
}
VV_LOC void builtin__mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[(int)(idx - 1)]))->len >= _const_degree) {
		builtin__mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[(int)(idx + 1)]))->len >= _const_degree) {
		builtin__mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		builtin__mapnode_merge(n, idx);
	} else {
		builtin__mapnode_merge(n, (int)(idx - 1));
	}
}
VV_LOC void builtin__mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx - 1)]));
	for (int i = (int)(child->len - 1); i >= 0; i--) {
		child->keys[builtin__v_fixed_index((int)(i + 1), 11)] = child->keys[builtin__v_fixed_index(i, 11)];
		child->values[builtin__v_fixed_index((int)(i + 1), 11)] = child->values[builtin__v_fixed_index(i, 11)];
	}
	if (child->children != ((void*)0)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[(int)(i + 1)] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[builtin__v_fixed_index((int)(idx - 1), 11)];
	child->values[0] = n->values[builtin__v_fixed_index((int)(idx - 1), 11)];
	if (child->children != ((void*)0)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[builtin__v_fixed_index((int)(idx - 1), 11)] = sibling->keys[builtin__v_fixed_index((int)(sibling->len - 1), 11)];
	n->values[builtin__v_fixed_index((int)(idx - 1), 11)] = sibling->values[builtin__v_fixed_index((int)(sibling->len - 1), 11)];
	child->len++;
	sibling->len--;
}
VV_LOC void builtin__mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx + 1)]));
	child->keys[builtin__v_fixed_index(child->len, 11)] = n->keys[builtin__v_fixed_index(idx, 11)];
	child->values[builtin__v_fixed_index(child->len, 11)] = n->values[builtin__v_fixed_index(idx, 11)];
	if (child->children != ((void*)0)) {
		{ // Unsafe block
			child->children[(int)(child->len + 1)] = sibling->children[0];
		}
	}
	n->keys[builtin__v_fixed_index(idx, 11)] = sibling->keys[0];
	n->values[builtin__v_fixed_index(idx, 11)] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[builtin__v_fixed_index((int)(i - 1), 11)] = sibling->keys[builtin__v_fixed_index(i, 11)];
		sibling->values[builtin__v_fixed_index((int)(i - 1), 11)] = sibling->values[builtin__v_fixed_index(i, 11)];
	}
	if (sibling->children != ((void*)0)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[(int)(i - 1)] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}
VV_LOC void builtin__mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx + 1)]));
	child->keys[builtin__v_fixed_index(_const_mid_index, 11)] = n->keys[builtin__v_fixed_index(idx, 11)];
	child->values[builtin__v_fixed_index(_const_mid_index, 11)] = n->values[builtin__v_fixed_index(idx, 11)];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[builtin__v_fixed_index((int_literal)(i + _const_degree), 11)] = sibling->keys[builtin__v_fixed_index(i, 11)];
		child->values[builtin__v_fixed_index((int_literal)(i + _const_degree), 11)] = sibling->values[builtin__v_fixed_index(i, 11)];
	}
	if (child->children != ((void*)0)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[(int)(i + _const_degree)] = sibling->children[i];
			}
		}
	}
	for (int i = (int)(idx + 1); i < n->len; i++) {
		n->keys[builtin__v_fixed_index((int)(i - 1), 11)] = n->keys[builtin__v_fixed_index(i, 11)];
		n->values[builtin__v_fixed_index((int)(i - 1), 11)] = n->values[builtin__v_fixed_index(i, 11)];
	}
	for (int i = (int)(idx + 2); i <= n->len; i++) {
		{ // Unsafe block
			n->children[(int)(i - 1)] = n->children[i];
		}
	}
	child->len += (int)(sibling->len + 1);
	n->len--;
}
void builtin__SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = builtin__mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (m->root->children == ((void*)0)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}
VV_LOC int builtin__mapnode_subkeys(mapnode* n, Array_string* keys, int at) {
	int position = at;
	if (n->children != ((void*)0)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += builtin__mapnode_subkeys(child, keys, position);
			builtin__array_set(keys, position, &(string[]) { n->keys[builtin__v_fixed_index(i, 11)] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += builtin__mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			builtin__array_set(keys, (int)(position + i), &(string[]) { n->keys[builtin__v_fixed_index(i, 11)] });
		}
		position += n->len;
	}
	return (int)(position - at);
}
Array_string builtin__SortedMap_keys(SortedMap* m) {
	Array_string keys = builtin____new_array_with_default(m->len, 0, sizeof(string), &(string[]){_S("")});
	if (m->root == ((void*)0) || m->root->len == 0) {
		return keys;
	}
	builtin__mapnode_subkeys(m->root, &keys, 0);
	return keys;
}
VV_LOC void builtin__mapnode_free(mapnode* n) {
}
void builtin__SortedMap_free(SortedMap* m) {
	if (m->root == ((void*)0)) {
		return;
	}
	builtin__mapnode_free(m->root);
}
Array_rune builtin__string_runes(string s) {
	Array_rune runes = builtin____new_array_with_default(0, s.len, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		int char_len = builtin__utf8_char_len(s.str[i]);
		if (char_len > 1) {
			int end = ((int)(s.len - 1) >= (int)(i + char_len) ? ((int)(i + char_len)) : (s.len));
			string r = builtin__string_substr(s, i, end);
			builtin__array_push((array*)&runes, _MOV((rune[]){ builtin__string_utf32_code(r) }));
			i += (int)(char_len - 1);
		} else {
			builtin__array_push((array*)&runes, _MOV((rune[]){ s.str[i] }));
		}
	}
	return runes;
}
string builtin__cstring_to_vstring(const char* const_s) {
	return builtin__string_clone(builtin__tos2(((u8*)(const_s))));
}
string builtin__tos_clone(const u8* const_s) {
	return builtin__string_clone(builtin__tos2(((u8*)(const_s))));
}
string builtin__tos(u8* s, int len) {
	if (s == 0) {
		builtin___v_panic(_S("tos(): nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = len});
}
string builtin__tos2(u8* s) {
	if (s == 0) {
		builtin___v_panic(_S("tos2: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = builtin__vstrlen(s)});
}
string builtin__tos3(char* s) {
	if (s == 0) {
		builtin___v_panic(_S("tos3: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = ((u8*)(s)), .len = builtin__vstrlen_char(s)});
}
string builtin__tos4(u8* s) {
	if (s == 0) {
		return _S("");
	}
	return ((string){.str = s, .len = builtin__vstrlen(s)});
}
string builtin__tos5(char* s) {
	if (s == 0) {
		return _S("");
	}
	return ((string){.str = ((u8*)(s)), .len = builtin__vstrlen_char(s)});
}
string builtin__u8_vstring(u8* bp) {
	return ((string){.str = bp, .len = builtin__vstrlen(bp)});
}
string builtin__u8_vstring_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}
string builtin__char_vstring(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = builtin__vstrlen_char(cp), .is_lit = 0});
}
string builtin__char_vstring_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 0});
}
string builtin__u8_vstring_literal(u8* bp) {
	return ((string){.str = bp, .len = builtin__vstrlen(bp), .is_lit = 1});
}
string builtin__u8_vstring_literal_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}
string builtin__char_vstring_literal(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = builtin__vstrlen_char(cp), .is_lit = 1});
}
string builtin__char_vstring_literal_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 1});
}
int builtin__string_len_utf8(string s) {
	int l = 0;
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		l++;
		i += (int_literal)(((((0xe5000000U >> ((((s.str[i] >> 3)) & 0x1e)))) & 3)) + 1);
	}
	return l;
}
bool builtin__string_is_pure_ascii(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 0x80) {
			return false;
		}
	}
	return true;
}
string builtin__string_clone(string a) {
	if (a.len <= 0) {
		return _S("");
	}
	string b = ((string){.str = builtin__malloc_noscan((int)(a.len + 1)), .len = a.len});
	{ // Unsafe block
		builtin__vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}
string builtin__string_replace_once(string s, string rep, string with) {
	int idx = builtin__string_index_(s, rep);
	if (idx == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_plus_two(builtin__string_substr_unsafe(s, 0, idx), with, builtin__string_substr_unsafe(s, (int)(idx + rep.len), s.len));
}
string builtin__string_replace(string s, string rep, string with) {
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return builtin__string_clone(s);
	}
	if (!builtin__string_contains(s, rep)) {
		return builtin__string_clone(s);
	}
	int pidxs_len = 0;
	int pidxs_cap = (int)(s.len / rep.len);
	Array_fixed_int_10 stack_idxs = {0};
	int* pidxs = &stack_idxs[0];
	if (pidxs_cap > _const_replace_stack_buffer_size) {
		pidxs = ((int*)(builtin___v_malloc((int)(((int)(sizeof(int))) * pidxs_cap))));
	}
	int idx = 0;
	for (;;) {
		idx = builtin__string_index_after_(s, rep, idx);
		if (idx == -1) {
			break;
		}
		{ // Unsafe block
			pidxs[pidxs_len] = idx;
			pidxs_len++;
		}
		idx += rep.len;
	}
	if (pidxs_len == 0) {
		string _t3 = builtin__string_clone(s);
			{ // defer begin
				if (pidxs_cap > _const_replace_stack_buffer_size) {
					builtin___v_free(pidxs);
				}
			} // defer end
		return _t3;
	}
	int new_len = (int)(s.len + (int)(pidxs_len * ((int)(with.len - rep.len))));
	u8* b = builtin__malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int j = 0; j < pidxs_len; ++j) {
		int rep_pos = pidxs[j];
		int before_len = (int)(rep_pos - s_idx);
		builtin__vmemcpy(&b[b_i], &s.str[s_idx], before_len);
		b_i += before_len;
		s_idx = (int)(rep_pos + rep.len);
		builtin__vmemcpy(&b[b_i], &with.str[0], with.len);
		b_i += with.len;
	}
	if (s_idx < s.len) {
		builtin__vmemcpy(&b[b_i], &s.str[s_idx], (int)(s.len - s_idx));
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t4 = builtin__tos(b, new_len);
			{ // defer begin
				if (pidxs_cap > _const_replace_stack_buffer_size) {
					builtin___v_free(pidxs);
				}
			} // defer end
		return _t4;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return builtin__string_clone(s);
	}
	if ((int)(vals.len % 2) != 0) {
		builtin__eprintln(_S("string.replace_each(): odd number of strings"));
		return builtin__string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = builtin____new_array_with_default(0, 6, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = builtin__string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = ((string*)vals.data)[rep_i];
		string with = ((string*)vals.data)[(int)(rep_i + 1)];
		for (;;) {
			idx = builtin__string_index_after_(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[(int)(idx + i)] = 0;
				}
			}
			builtin__array_push((array*)&idxs, _MOV((RepIndex[]){ ((RepIndex){.idx = idx,.val_idx = rep_i,}) }));
			idx += rep.len;
			new_len += (int)(with.len - rep.len);
		}
	}
	if (idxs.len == 0) {
		string _t4 = builtin__string_clone(s);
			{ // defer begin
				builtin__array_free(&idxs);
			} // defer end
		return _t4;
	}
	if (idxs.len > 0) { qsort(idxs.data, idxs.len, idxs.element_size, (voidptr)compare_11835712493692648452_RepIndex_by_idx); }
	;
	u8* buf = builtin__malloc_noscan((int)(new_len + 1));
	int idx_pos = 0;
	RepIndex cur_idx = ((RepIndex*)idxs.data)[idx_pos];
	int buf_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = ((string*)vals.data)[cur_idx.val_idx];
			string with = ((string*)vals.data)[(int)(cur_idx.val_idx + 1)];
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					buf[buf_i] = with.str[ j];
				}
				buf_i++;
			}
			i += (int)(rep.len - 1);
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = ((RepIndex*)idxs.data)[idx_pos];
			}
		} else {
			{ // Unsafe block
				buf[buf_i] = s.str[i];
			}
			buf_i++;
		}
	}
	{ // Unsafe block
		buf[new_len] = 0;
		string _t5 = builtin__tos(buf, new_len);
			{ // defer begin
				builtin__array_free(&idxs);
			} // defer end
		return _t5;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_replace_char(string s, u8 rep, u8 with, int repeat) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (repeat <= 0) {
			builtin___v_panic(_S("string.replace_char(): tab length too short"));
			VUNREACHABLE();
		}
	}
	#endif
	if (s.len == 0) {
		return builtin__string_clone(s);
	}
	Array_int idxs = builtin____new_array_with_default(0, (s.len >> 2), sizeof(int), 0);
	for (int i = 0; i < s.len; ++i) {
		u8 ch = s.str[i];
		if (ch == rep) {
			builtin__array_push((array*)&idxs, _MOV((int[]){ i }));
		}
	}
	if (idxs.len == 0) {
		string _t4 = builtin__string_clone(s);
			{ // defer begin
				builtin__array_free(&idxs);
			} // defer end
		return _t4;
	}
	int new_len = (int)(s.len + (int)(idxs.len * ((int)(repeat - 1))));
	u8* b = builtin__malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int _t5 = 0; _t5 < idxs.len; ++_t5) {
		int rep_pos = ((int*)idxs.data)[_t5];
		for (int i = s_idx; i < rep_pos; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
		s_idx = (int)(rep_pos + 1);
		for (int _t6 = 0; _t6 < repeat; ++_t6) {
			{ // Unsafe block
				b[b_i] = with;
			}
			b_i++;
		}
	}
	if (s_idx < s.len) {
		for (int i = s_idx; i < s.len; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t7 = builtin__tos(b, new_len);
			{ // defer begin
				builtin__array_free(&idxs);
			} // defer end
		return _t7;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string builtin__string_normalize_tabs(string s, int tab_len) {
	return builtin__string_replace_char(s, '\t', ' ', tab_len);
}
string builtin__string_expand_tabs(string s, int tab_len) {
	if (tab_len <= 0) {
		return builtin__string_clone(s);
	}
	strings__Builder output = strings__new_builder(s.len);
	int column = 0;
	RunesIterator _t2 = builtin__string_runes_iterator(s);
	while (1) {
		_option_rune _t3 = builtin__RunesIterator_next(&_t2);
		if (_t3.state != 0) break;
		rune r = *(rune*)_t3.data;

		if (r == ('\t')) {
			int spaces = (int)(tab_len - ((int)(column % tab_len)));
			strings__Builder_write_string(&output, builtin__string_repeat(_S(" "), spaces));
			column += spaces;
		}
		else if (r == ('\n') || r == ('\r')) {
			strings__Builder_write_rune(&output, r);
			column = 0;
		}
		else {
			strings__Builder_write_rune(&output, r);
			column++;
		}
	}
	return strings__Builder_str(&output);
}
inline bool builtin__string_bool(string s) {
	return _SLIT_EQ(s.str, s.len, "true") || _SLIT_EQ(s.str, s.len, "t");
}
inline i8 builtin__string_i8(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 8, false, false);
	if (_t2.is_error) {
		*(i64*) _t2.data = 0;
	}
	
 	return ((i8)((*(i64*)_t2.data)));
}
inline i16 builtin__string_i16(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 16, false, false);
	if (_t2.is_error) {
		*(i64*) _t2.data = 0;
	}
	
 	return ((i16)((*(i64*)_t2.data)));
}
inline i32 builtin__string_i32(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.is_error) {
		*(i64*) _t2.data = 0;
	}
	
 	return ((i32)((*(i64*)_t2.data)));
}
inline int builtin__string_int(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.is_error) {
		*(i64*) _t2.data = 0;
	}
	
 	return ((int)((*(i64*)_t2.data)));
}
inline i64 builtin__string_i64(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 64, false, false);
	if (_t2.is_error) {
		*(i64*) _t2.data = 0;
	}
	
 	return (*(i64*)_t2.data);
}
inline f32 builtin__string_f32(string s) {
	_result_f64 _t2 = strconv__atof64(s, ((strconv__AtoF64Param){.allow_extra_chars = true,}));
	if (_t2.is_error) {
		*(f64*) _t2.data = 0;
	}
	
 	return ((f32)((*(f64*)_t2.data)));
}
inline f64 builtin__string_f64(string s) {
	_result_f64 _t2 = strconv__atof64(s, ((strconv__AtoF64Param){.allow_extra_chars = true,}));
	if (_t2.is_error) {
		*(f64*) _t2.data = 0;
	}
	
 	return (*(f64*)_t2.data);
}
Array_u8 builtin__string_u8_array(string s) {
	string tmps = builtin__string_replace(s, _S("_"), _S(""));
	if (tmps.len == 0) {
		return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
	}
	tmps = builtin__string_to_lower_ascii(tmps);
	if (builtin__string_starts_with(tmps, _S("0x"))) {
		tmps = builtin__string_substr(tmps, 2, 2147483647);
		if (tmps.len == 0) {
			return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
		}
		if (!builtin__string_contains_only(tmps, _S("0123456789abcdef"))) {
			return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
		}
		if ((int)(tmps.len % 2) == 1) {
			tmps = builtin__string__plus(_S("0"), tmps);
		}
		Array_u8 ret = builtin____new_array_with_default((int)(tmps.len / 2), 0, sizeof(u8), 0);
		for (int i = 0; i < ret.len; ++i) {
			_result_u64 _t4 = builtin__string_parse_uint(builtin__string_substr(tmps, (int_literal)(2 * i), (int_literal)((int_literal)(2 * i) + 2)), 16, 8);
			if (_t4.is_error) {
				*(u64*) _t4.data = 0;
			}
			
 			builtin__array_set(&ret, i, &(u8[]) { ((u8)((*(u64*)_t4.data))) });
		}
		return ret;
	} else if (builtin__string_starts_with(tmps, _S("0b"))) {
		tmps = builtin__string_substr(tmps, 2, 2147483647);
		if (tmps.len == 0) {
			return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
		}
		if (!builtin__string_contains_only(tmps, _S("01"))) {
			return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
		}
		if ((int)(tmps.len % 8) != 0) {
			tmps = builtin__string__plus(builtin__string_repeat(_S("0"), (int)(8 - (int)(tmps.len % 8))), tmps);
		}
		Array_u8 ret = builtin____new_array_with_default((int)(tmps.len / 8), 0, sizeof(u8), 0);
		for (int i = 0; i < ret.len; ++i) {
			_result_u64 _t8 = builtin__string_parse_uint(builtin__string_substr(tmps, (int_literal)(8 * i), (int_literal)((int_literal)(8 * i) + 8)), 2, 8);
			if (_t8.is_error) {
				*(u64*) _t8.data = 0;
			}
			
 			builtin__array_set(&ret, i, &(u8[]) { ((u8)((*(u64*)_t8.data))) });
		}
		return ret;
	}
	return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
}
inline u8 builtin__string_u8(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 8, false, false);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	return ((u8)((*(u64*)_t2.data)));
}
inline u16 builtin__string_u16(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 16, false, false);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	return ((u16)((*(u64*)_t2.data)));
}
inline u32 builtin__string_u32(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 32, false, false);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	return ((u32)((*(u64*)_t2.data)));
}
inline u64 builtin__string_u64(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 64, false, false);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	return (*(u64*)_t2.data);
}
inline _result_u64 builtin__string_parse_uint(string s, int _base, int _bit_size) {
	return strconv__parse_uint(s, _base, _bit_size);
}
inline _result_i64 builtin__string_parse_int(string s, int _base, int _bit_size) {
	return strconv__parse_int(s, _base, _bit_size);
}
VV_LOC bool builtin__string__eq(string s, string a) {
	if (s.str == 0) {
		builtin___v_panic(_S("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	{ // Unsafe block
		return builtin__vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}
int builtin__string_compare(string s, string a) {
	int min_len = (s.len < a.len ? (s.len) : (a.len));
	for (int i = 0; i < min_len; ++i) {
		if (s.str[ i] < a.str[ i]) {
			return -1;
		}
		if (s.str[ i] > a.str[ i]) {
			return 1;
		}
	}
	if (s.len < a.len) {
		return -1;
	}
	if (s.len > a.len) {
		return 1;
	}
	return 0;
}
VV_LOC bool builtin__string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}
VV_LOC string builtin__string__plus(string s, string a) {
	int new_len = (int)(a.len + s.len);
	string res = ((string){.str = builtin__malloc_noscan((int)(new_len + 1)), .len = new_len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str, s.len);
		builtin__vmemcpy(res.str + s.len, a.str, a.len);
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}
VV_LOC string builtin__string_plus_two(string s, string a, string b) {
	int new_len = (int)((int)(a.len + b.len) + s.len);
	string res = ((string){.str = builtin__malloc_noscan((int)(new_len + 1)), .len = new_len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str, s.len);
		builtin__vmemcpy(res.str + s.len, a.str, a.len);
		builtin__vmemcpy(res.str + s.len + a.len, b.str, b.len);
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}
Array_string builtin__string_split_any(string s, string delim) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	int i = 0;
	if (s.len > 0) {
		if (delim.len <= 0) {
			Array_string _t1 = builtin__string_split(s, _S(""));
				{ // defer begin
					builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
				} // defer end
			return _t1;
		}
		for (int index = 0; index < s.len; ++index) {
			u8 ch = s.str[index];
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				u8 delim_ch = delim.str[_t2];
				if (ch == delim_ch) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, i, index) }));
					i = (int)(index + 1);
					break;
				}
			}
		}
		if (i < s.len) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, i, 2147483647) }));
		}
	}
	Array_string _t5 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t5;
}
Array_string builtin__string_rsplit_any(string s, string delim) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	int i = (int)(s.len - 1);
	if (s.len > 0) {
		if (delim.len <= 0) {
			Array_string _t1 = builtin__string_rsplit(s, _S(""));
				{ // defer begin
					builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
				} // defer end
			return _t1;
		}
		int rbound = s.len;
		for (;;) {
			if (!(i >= 0)) break;
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				u8 delim_ch = delim.str[_t2];
				if (s.str[ i] == delim_ch) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, (int)(i + 1), rbound) }));
					rbound = i;
					break;
				}
			}
			i--;
		}
		if (rbound > 0) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, 0, rbound) }));
		}
	}
	Array_string _t5 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t5;
}
inline Array_string builtin__string_split(string s, string delim) {
	return builtin__string_split_nth(s, delim, 0);
}
inline Array_string builtin__string_rsplit(string s, string delim) {
	return builtin__string_rsplit_nth(s, delim, 0);
}
_option_multi_return_string_string builtin__string_split_once(string s, string delim) {
	Array_string result = builtin__string_split_nth(s, delim, 2);
	if (result.len != 2) {
		_option_multi_return_string_string _t1 = (_option_multi_return_string_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		return _t1;
	}
	_option_multi_return_string_string _t2;
	builtin___option_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)builtin__array_get(result, 0)), .arg1=(*(string*)builtin__array_get(result, 1))} }, (_option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}
_option_multi_return_string_string builtin__string_rsplit_once(string s, string delim) {
	Array_string result = builtin__string_rsplit_nth(s, delim, 2);
	if (result.len != 2) {
		_option_multi_return_string_string _t1 = (_option_multi_return_string_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		return _t1;
	}
	_option_multi_return_string_string _t2;
	builtin___option_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)builtin__array_get(result, 1)), .arg1=(*(string*)builtin__array_get(result, 0))} }, (_option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}
Array_string builtin__string_split_n(string s, string delim, int n) {
	return builtin__string_split_nth(s, delim, n);
}
Array_string builtin__string_split_nth(string s, string delim, int nth) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	switch (delim.len) {
		case 0: {
			for (int i = 0; i < s.len; ++i) {
				u8 ch = s.str[i];
				if (nth > 0 && res.len == (int)(nth - 1)) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, i, 2147483647) }));
					break;
				}
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__u8_ascii_str(ch) }));
			}
			break;
		}
		case 1: {
			u8 delim_byte = delim.str[ 0];
			int start = 0;
			for (int i = 0; i < s.len; ++i) {
				u8 ch = s.str[i];
				if (ch == delim_byte) {
					if (nth > 0 && res.len == (int)(nth - 1)) {
						break;
					}
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, start, i) }));
					start = (int)(i + 1);
				}
			}
			if (nth < 1 || res.len < nth) {
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, start, 2147483647) }));
			}
			break;
		}
		default: {
			{
				int start = 0;
				for (int i = 0; (int)(i + delim.len) <= s.len; ) {
					if (builtin__string__eq(builtin__string_substr_unsafe(s, i, (int)(i + delim.len)), delim)) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, start, i) }));
						i += delim.len;
						start = i;
					} else {
						i++;
					}
				}
				if (nth < 1 || res.len < nth) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, start, 2147483647) }));
				}
				break;
			}
		}
	}
	
	Array_string _t7 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t7;
}
Array_string builtin__string_rsplit_nth(string s, string delim, int nth) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	switch (delim.len) {
		case 0: {
			for (int i = (int)(s.len - 1); i >= 0; i--) {
				if (nth > 0 && res.len == (int)(nth - 1)) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, 0, (int)(i + 1)) }));
					break;
				}
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__u8_ascii_str(s.str[ i]) }));
			}
			break;
		}
		case 1: {
			u8 delim_byte = delim.str[ 0];
			int rbound = s.len;
			for (int i = (int)(s.len - 1); i >= 0; i--) {
				if (s.str[ i] == delim_byte) {
					if (nth > 0 && res.len == (int)(nth - 1)) {
						break;
					}
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, (int)(i + 1), rbound) }));
					rbound = i;
				}
			}
			if (nth < 1 || res.len < nth) {
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, 0, rbound) }));
			}
			break;
		}
		default: {
			{
				int rbound = s.len;
				for (int i = (int)(s.len - 1); i >= 0; i--) {
					bool is_delim = (int)(i - delim.len) >= 0 && builtin__string__eq(builtin__string_substr(s, (int)(i - delim.len), i), delim);
					if (is_delim) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, i, rbound) }));
						i -= delim.len;
						rbound = i;
					}
				}
				if (nth < 1 || res.len < nth) {
					builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, 0, rbound) }));
				}
				break;
			}
		}
	}
	
	Array_string _t7 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t7;
}
Array_string builtin__string_split_into_lines(string s) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	rune cr = '\r';
	rune lf = '\n';
	int line_start = 0;
	for (int i = 0; i < s.len; i++) {
		if (line_start <= i) {
			if (s.str[ i] == lf) {
				builtin__array_push((array*)&res, _MOV((string[]){ (line_start == i ? (_S("")) : (builtin__string_substr(s, line_start, i))) }));
				line_start = (int)(i + 1);
			} else if (s.str[ i] == cr) {
				builtin__array_push((array*)&res, _MOV((string[]){ (line_start == i ? (_S("")) : (builtin__string_substr(s, line_start, i))) }));
				if (((int)(i + 1)) < s.len && s.str[ (int)(i + 1)] == lf) {
					line_start = (int)(i + 2);
				} else {
					line_start = (int)(i + 1);
				}
			}
		}
	}
	if (line_start < s.len) {
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, line_start, 2147483647) }));
	}
	Array_string _t5 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t5;
}
Array_string builtin__string_split_by_space(string s) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	Array_string _t1 = builtin__string_split_any(s, _S(" \n\t\v\f\r"));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string word = ((string*)_t1.data)[_t2];
		if ((word).len != 0) {
			builtin__array_push((array*)&res, _MOV((string[]){ word }));
		}
	}
	Array_string _t4 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t4;
}
string builtin__string_substr(string s, int start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (s.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("substr("), builtin__impl_i64_to_string(start)), _S(", ")), builtin__impl_i64_to_string(end)), _S(") out of bounds (len=")), builtin__impl_i64_to_string(s.len)), _S(") s=")), s));
			VUNREACHABLE();
		}
	}
	#endif
	int len = (int)(end - start);
	if (len == s.len) {
		return builtin__string_clone(s);
	}
	string res = ((string){.str = builtin__malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}
string builtin__string_substr_unsafe(string s, int start, int _end) {
	int end = (_end == 2147483647 ? (s.len) : (_end));
	int len = (int)(end - start);
	if (len == s.len) {
		return s;
	}
	return ((string){.str = s.str + start, .len = len});
}
_result_string builtin__string_substr_with_check(string s, int start, int _end) {
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (s.len) : (_end));
	if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("substr("), builtin__impl_i64_to_string(start)), _S(", ")), builtin__impl_i64_to_string(end)), _S(") out of bounds (len=")), builtin__impl_i64_to_string(s.len)), _S(")"))), .data={E_STRUCT} };
	}
	int len = (int)(end - start);
	if (len == s.len) {
		_result_string _t2;
		builtin___result_ok(&(string[]) { builtin__string_clone(s) }, (_result*)(&_t2), sizeof(string));
		 
		return _t2;
	}
	string res = ((string){.str = builtin__malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	_result_string _t3;
	builtin___result_ok(&(string[]) { res }, (_result*)(&_t3), sizeof(string));
	 
	return _t3;
}
string builtin__string_substr_ni(string s, int _start, int _end) {
	int start = _start;
	int end = (_end == _const_max_i64 || _end == _const_max_i32 ? (s.len) : (_end));
	if (start < 0) {
		start = (int)(s.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(s.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= s.len) {
		end = s.len;
	}
	if (start > s.len || end < start) {
		return _S("");
	}
	int len = (int)(end - start);
	string res = ((string){.str = builtin__malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		builtin__vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}
int builtin__string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return builtin__string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
_option_int builtin__string_index(string s, string p) {
	int idx = builtin__string_index_(s, p);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	_option_int _t2;
	builtin___option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	 
	return _t2;
}
inline _option_int builtin__string_last_index(string s, string needle) {
	int idx = builtin__string_index_last_(s, needle);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	_option_int _t2;
	builtin___option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	 
	return _t2;
}
VV_LOC int builtin__string_index_kmp(string s, string p) {
	if (p.len > s.len) {
		return -1;
	}
	Array_fixed_int_20 stack_prefixes = {0};
	int* p_prefixes = &stack_prefixes[0];
	if (p.len > _const_kmp_stack_buffer_size) {
		p_prefixes = ((int*)(builtin__vcalloc((int)(p.len * ((int)(sizeof(int)))))));
	}
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		{ // Unsafe block
			p_prefixes[i] = j;
		}
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = p_prefixes[(int)(j - 1)];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = (int)((int)(i - p.len) + 1);
				{ // defer begin
					if (p.len > _const_kmp_stack_buffer_size) {
						builtin___v_free(p_prefixes);
					}
				} // defer end
			return _t2;
		}
	}
	int _t3 = -1;
		{ // defer begin
			if (p.len > _const_kmp_stack_buffer_size) {
				builtin___v_free(p_prefixes);
			}
		} // defer end
	return _t3;
}
int builtin__string_index_any(string s, string chars) {
	for (int i = 0; i < s.len; ++i) {
		u8 ss = s.str[i];
		for (int _t1 = 0; _t1 < chars.len; ++_t1) {
			u8 c = chars.str[_t1];
			if (c == ss) {
				return i;
			}
		}
	}
	return -1;
}
VV_LOC int builtin__string_index_last_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = (int)(s.len - p.len);
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}
_option_int builtin__string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			_option_int _t3;
			builtin___option_ok(&(int[]) { i }, (_option*)(&_t3), sizeof(int));
			 
			return _t3;
		}
		i++;
	}
	return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
int builtin__string_index_after_(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}
int builtin__string_index_u8(string s, u8 c) {
	for (int i = 0; i < s.len; ++i) {
		u8 b = s.str[i];
		if (b == c) {
			return i;
		}
	}
	return -1;
}
inline int builtin__string_last_index_u8(string s, u8 c) {
	for (int i = (int)(s.len - 1); i >= 0; i--) {
		if (s.str[ i] == c) {
			return i;
		}
	}
	return -1;
}
int builtin__string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		u8 target = substr.str[ 0];
		for (int _t3 = 0; _t3 < s.len; ++_t3) {
			u8 letter = s.str[_t3];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = builtin__string_index_after_(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}
bool builtin__string_contains_u8(string s, u8 x) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 c = s.str[_t1];
		if (x == c) {
			return true;
		}
	}
	return false;
}
bool builtin__string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (substr.len == 1) {
		return builtin__string_contains_u8(s, substr.str[0]);
	}
	return builtin__string_index_(s, substr) != -1;
}
bool builtin__string_contains_any(string s, string chars) {
	for (int _t1 = 0; _t1 < chars.len; ++_t1) {
		u8 c = chars.str[_t1];
		if (builtin__string_contains_u8(s, c)) {
			return true;
		}
	}
	return false;
}
bool builtin__string_contains_only(string s, string chars) {
	if (chars.len == 0) {
		return false;
	}
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 ch = s.str[_t2];
		int res = 0;
		for (int i = 0; i < chars.len && res == 0; i++) {
			res += (int[]){(ch == chars.str[i])?1:0}[0];
		}
		if (res == 0) {
			return false;
		}
	}
	return true;
}
bool builtin__string_contains_any_substr(string s, Array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < substrs.len; ++_t2) {
		string sub = ((string*)substrs.data)[_t2];
		if (builtin__string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}
bool builtin__string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	} else if (builtin__vmemcmp(s.str, p.str, p.len) == 0) {
		return true;
	}
	return false;
}
bool builtin__string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	} else if (builtin__vmemcmp(s.str + s.len - p.len, p.str, p.len) == 0) {
		return true;
	}
	return false;
}
string builtin__string_to_lower_ascii(string s) {
	{ // Unsafe block
		u8* b = builtin__malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'A' && s.str[i] <= 'Z') {
				b[i] = (u8)(s.str[i] + 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return builtin__tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_to_lower(string s) {
	if (builtin__string_is_pure_ascii(s)) {
		return builtin__string_to_lower_ascii(s);
	}
	Array_rune runes = builtin__string_runes(s);
	for (int i = 0; i < runes.len; ++i) {
		((rune*)runes.data)[i] = builtin__rune_to_lower(((rune*)runes.data)[i]);
	}
	return Array_rune_string(runes);
}
bool builtin__string_is_lower(string s) {
	if ((s).len == 0 || builtin__u8_is_digit(s.str[ 0])) {
		return false;
	}
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}
string builtin__string_to_upper_ascii(string s) {
	{ // Unsafe block
		u8* b = builtin__malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'a' && s.str[i] <= 'z') {
				b[i] = (u8)(s.str[i] - 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return builtin__tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_to_upper(string s) {
	if (builtin__string_is_pure_ascii(s)) {
		return builtin__string_to_upper_ascii(s);
	}
	Array_rune runes = builtin__string_runes(s);
	for (int i = 0; i < runes.len; ++i) {
		((rune*)runes.data)[i] = builtin__rune_to_upper(((rune*)runes.data)[i]);
	}
	return Array_rune_string(runes);
}
bool builtin__string_is_upper(string s) {
	if ((s).len == 0 || builtin__u8_is_digit(s.str[ 0])) {
		return false;
	}
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'a' && s.str[ i] <= 'z') {
			return false;
		}
	}
	return true;
}
string builtin__string_capitalize(string s) {
	if (s.len == 0) {
		return _S("");
	}
	if (s.len == 1) {
		return builtin__string_to_upper(builtin__u8_ascii_str(s.str[ 0]));
	}
	Array_rune r = builtin__string_runes(s);
	string letter = builtin__rune_str(((rune*)r.data)[0]);
	string uletter = builtin__string_to_upper(letter);
	Array_rune rrest = builtin__array_slice(r, 1, 2147483647);
	string srest = Array_rune_string(rrest);
	string res = builtin__string__plus(uletter, srest);
	return res;
}
string builtin__string_uncapitalize(string s) {
	if (s.len == 0) {
		return _S("");
	}
	if (s.len == 1) {
		return builtin__string_to_lower(builtin__u8_ascii_str(s.str[ 0]));
	}
	Array_rune r = builtin__string_runes(s);
	string letter = builtin__rune_str(((rune*)r.data)[0]);
	string lletter = builtin__string_to_lower(letter);
	Array_rune rrest = builtin__array_slice(r, 1, 2147483647);
	string srest = Array_rune_string(rrest);
	string res = builtin__string__plus(lletter, srest);
	return res;
}
bool builtin__string_is_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}
bool builtin__string_starts_with_capital(string s) {
	if (s.len == 0 || !builtin__u8_is_capital(s.str[ 0])) {
		return false;
	}
	return true;
}
string builtin__string_title(string s) {
	Array_string words = builtin__string_split(s, _S(" "));
	Array_string tit = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		builtin__array_push((array*)&tit, _MOV((string[]){ builtin__string_capitalize(word) }));
	}
	string title = Array_string_join(tit, _S(" "));
	return title;
}
bool builtin__string_is_title(string s) {
	Array_string words = builtin__string_split(s, _S(" "));
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		if (!builtin__string_is_capital(word)) {
			return false;
		}
	}
	return true;
}
string builtin__string_find_between(string s, string start, string end) {
	int start_pos = builtin__string_index_(s, start);
	if (start_pos == -1) {
		return _S("");
	}
	string val = builtin__string_substr(s, (int)(start_pos + start.len), 2147483647);
	int end_pos = builtin__string_index_(val, end);
	if (end_pos == -1) {
		return _S("");
	}
	return builtin__string_substr(val, 0, end_pos);
}
inline string builtin__string_trim_space(string s) {
	return builtin__string_trim(s, _S(" \n\t\v\f\r"));
}
inline string builtin__string_trim_space_left(string s) {
	return builtin__string_trim_left(s, _S(" \n\t\v\f\r"));
}
inline string builtin__string_trim_space_right(string s) {
	return builtin__string_trim_right(s, _S(" \n\t\v\f\r"));
}
string builtin__string_trim(string s, string cutset) {
	if ((s).len == 0 || (cutset).len == 0) {
		return builtin__string_clone(s);
	}
	if (builtin__string_is_pure_ascii(cutset)) {
		return builtin__string_trim_chars(s, cutset, TrimMode__trim_both);
	} else {
		return builtin__string_trim_runes(s, cutset, TrimMode__trim_both);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
multi_return_int_int builtin__string_trim_indexes(string s, string cutset) {
	int pos_left = 0;
	int pos_right = (int)(s.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		for (int _t1 = 0; _t1 < cutset.len; ++_t1) {
			u8 cs = cutset.str[_t1];
			if (s.str[ pos_left] == cs) {
				pos_left++;
				cs_match = true;
				break;
			}
		}
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			u8 cs = cutset.str[_t2];
			if (s.str[ pos_right] == cs) {
				pos_right--;
				cs_match = true;
				break;
			}
		}
		if (pos_left > pos_right) {
			return (multi_return_int_int){.arg0=0, .arg1=0};
		}
	}
	return (multi_return_int_int){.arg0=pos_left, .arg1=(int)(pos_right + 1)};
}
VV_LOC string builtin__string_trim_chars(string s, string cutset, TrimMode mode) {
	int pos_left = 0;
	int pos_right = (int)(s.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (mode == TrimMode__trim_left || mode == TrimMode__trim_both) {
			for (int _t1 = 0; _t1 < cutset.len; ++_t1) {
				u8 cs = cutset.str[_t1];
				if (s.str[ pos_left] == cs) {
					pos_left++;
					cs_match = true;
					break;
				}
			}
		}
		if (mode == TrimMode__trim_right || mode == TrimMode__trim_both) {
			for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
				u8 cs = cutset.str[_t2];
				if (s.str[ pos_right] == cs) {
					pos_right--;
					cs_match = true;
					break;
				}
			}
		}
		if (pos_left > pos_right) {
			return _S("");
		}
	}
	return builtin__string_substr(s, pos_left, (int)(pos_right + 1));
}
VV_LOC string builtin__string_trim_runes(string s, string cutset, TrimMode mode) {
	Array_rune s_runes = builtin__string_runes(s);
	int pos_left = 0;
	int pos_right = (int)(s_runes.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s_runes.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		if (mode == TrimMode__trim_left || mode == TrimMode__trim_both) {
			RunesIterator _t1 = builtin__string_runes_iterator(cutset);
			while (1) {
				_option_rune _t2 = builtin__RunesIterator_next(&_t1);
				if (_t2.state != 0) break;
				rune cs = *(rune*)_t2.data;
				if (((rune*)s_runes.data)[pos_left] == cs) {
					pos_left++;
					cs_match = true;
					break;
				}
			}
		}
		if (mode == TrimMode__trim_right || mode == TrimMode__trim_both) {
			RunesIterator _t3 = builtin__string_runes_iterator(cutset);
			while (1) {
				_option_rune _t4 = builtin__RunesIterator_next(&_t3);
				if (_t4.state != 0) break;
				rune cs = *(rune*)_t4.data;
				if (((rune*)s_runes.data)[pos_right] == cs) {
					pos_right--;
					cs_match = true;
					break;
				}
			}
		}
		if (pos_left > pos_right) {
			return _S("");
		}
	}
	return Array_rune_string(builtin__array_slice(s_runes, pos_left, (int)(pos_right + 1)));
}
string builtin__string_trim_left(string s, string cutset) {
	if ((s).len == 0 || (cutset).len == 0) {
		return builtin__string_clone(s);
	}
	if (builtin__string_is_pure_ascii(cutset)) {
		return builtin__string_trim_chars(s, cutset, TrimMode__trim_left);
	} else {
		return builtin__string_trim_runes(s, cutset, TrimMode__trim_left);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return builtin__string_clone(s);
	}
	if (builtin__string_is_pure_ascii(cutset)) {
		return builtin__string_trim_chars(s, cutset, TrimMode__trim_right);
	} else {
		return builtin__string_trim_runes(s, cutset, TrimMode__trim_right);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_trim_string_left(string s, string str) {
	if (builtin__string_starts_with(s, str)) {
		return builtin__string_substr(s, str.len, 2147483647);
	}
	return builtin__string_clone(s);
}
string builtin__string_trim_string_right(string s, string str) {
	if (builtin__string_ends_with(s, str)) {
		return builtin__string_substr(s, 0, (int)(s.len - str.len));
	}
	return builtin__string_clone(s);
}
int builtin__compare_strings(string* a, string* b) {
	bool _t2 = true;
	return ((_t2 == (builtin__string__lt(*a, *b)))? (-1) : (_t2 == (builtin__string__lt(*b, *a)))? (1) : (0));
}
VV_LOC int builtin__compare_strings_by_len(string* a, string* b) {
	bool _t2 = true;
	return ((_t2 == (a->len < b->len))? (-1) : (_t2 == (a->len > b->len))? (1) : (0));
}
VV_LOC int builtin__compare_lower_strings(string* a, string* b) {
	string aa = builtin__string_to_lower(*a);
	string bb = builtin__string_to_lower(*b);
	return builtin__compare_strings(&aa, &bb);
}
inline void Array_string_sort_ignore_case(Array_string* s) {
	builtin__array_sort_with_compare(s, ((voidptr)(builtin__compare_lower_strings)));
}
inline void Array_string_sort_by_len(Array_string* s) {
	builtin__array_sort_with_compare(s, ((voidptr)(builtin__compare_strings_by_len)));
}
inline string builtin__string_str(string s) {
	return builtin__string_clone(s);
}
VV_LOC u8 builtin__string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			builtin__panic_n2(_S("string index out of range(idx,s.len):"), idx, s.len);
			VUNREACHABLE();
		}
	}
	#endif
	return s.str[idx];
}
VV_LOC _option_u8 builtin__string_at_with_check(string s, int idx) {
	if (idx < 0 || idx >= s.len) {
		return (_option_u8){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	{ // Unsafe block
		_option_u8 _t2;
		builtin___option_ok(&(u8[]) { s.str[idx] }, (_option*)(&_t2), sizeof(u8));
		 
		return _t2;
	}
	return (_option_u8){.state=2, .err=_const_none__, .data={E_STRUCT}};
}
bool builtin__string_is_oct(string str) {
	int i = 0;
	if (str.len == 0) {
		return false;
	}
	if (str.str[ i] == '0') {
		i++;
	} else if (str.str[ i] == '-' || str.str[ i] == '+') {
		i++;
		if (i < str.len && str.str[ i] == '0') {
			i++;
		} else {
			return false;
		}
	} else {
		return false;
	}
	if (i < str.len && str.str[ i] == 'o') {
		i++;
	} else {
		return false;
	}
	if (i == str.len) {
		return false;
	}
	for (;;) {
		if (!(i < str.len)) break;
		if (str.str[ i] < '0' || str.str[ i] > '7') {
			return false;
		}
		i++;
	}
	return true;
}
bool builtin__string_is_bin(string str) {
	int i = 0;
	if (str.len == 0) {
		return false;
	}
	if (str.str[ i] == '0') {
		i++;
	} else if (str.str[ i] == '-' || str.str[ i] == '+') {
		i++;
		if (i < str.len && str.str[ i] == '0') {
			i++;
		} else {
			return false;
		}
	} else {
		return false;
	}
	if (i < str.len && str.str[ i] == 'b') {
		i++;
	} else {
		return false;
	}
	if (i == str.len) {
		return false;
	}
	for (;;) {
		if (!(i < str.len)) break;
		if (str.str[ i] < '0' || str.str[ i] > '1') {
			return false;
		}
		i++;
	}
	return true;
}
bool builtin__string_is_hex(string str) {
	int i = 0;
	if (str.len == 0) {
		return false;
	}
	if (str.str[ i] == '0') {
		i++;
	} else if (str.str[ i] == '-' || str.str[ i] == '+') {
		i++;
		if (i < str.len && str.str[ i] == '0') {
			i++;
		} else {
			return false;
		}
	} else {
		return false;
	}
	if (i < str.len && str.str[ i] == 'x') {
		i++;
	} else {
		return false;
	}
	if (i == str.len) {
		return false;
	}
	for (;;) {
		if (!(i < str.len)) break;
		if ((str.str[ i] < '0' || str.str[ i] > '9') && ((str.str[ i] < 'a' || str.str[ i] > 'f') && (str.str[ i] < 'A' || str.str[ i] > 'F'))) {
			return false;
		}
		i++;
	}
	return true;
}
bool builtin__string_is_int(string str) {
	int i = 0;
	if (str.len == 0) {
		return false;
	}
	if ((str.str[ i] != '-' && str.str[ i] != '+') && (!builtin__u8_is_digit(str.str[ i]))) {
		return false;
	} else {
		i++;
	}
	if (i == str.len && (!builtin__u8_is_digit(str.str[ (int)(i - 1)]))) {
		return false;
	}
	for (;;) {
		if (!(i < str.len)) break;
		if (str.str[ i] < '0' || str.str[ i] > '9') {
			return false;
		}
		i++;
	}
	return true;
}
inline bool builtin__u8_is_space(u8 c) {
	return c == 32 || (c > 8 && c < 14) || c == 0x85 || c == 0xa0;
}
inline bool builtin__u8_is_digit(u8 c) {
	return c >= '0' && c <= '9';
}
inline bool builtin__u8_is_hex_digit(u8 c) {
	return builtin__u8_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
inline bool builtin__u8_is_oct_digit(u8 c) {
	return c >= '0' && c <= '7';
}
inline bool builtin__u8_is_bin_digit(u8 c) {
	return c == '0' || c == '1';
}
inline bool builtin__u8_is_letter(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
inline bool builtin__u8_is_alnum(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
}
void builtin__string_free(string* s) {
	if (s->is_lit == -98761234) {
		u8* double_free_msg = ((u8*)("double string.free() detected\n"));
		int double_free_msg_len = builtin__vstrlen(double_free_msg);
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			builtin___write_buf_to_fd(1, double_free_msg, double_free_msg_len);
		}
		#endif
		return;
	}
	if (s->is_lit == 1 || s->str == 0) {
		return;
	}
	{ // Unsafe block
		builtin___v_free(s->str);
		s->str = ((void*)0);
	}
	s->is_lit = -98761234;
}
string builtin__string_before(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, 0, pos);
}
string builtin__string_all_before(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, 0, pos);
}
string builtin__string_all_before_last(string s, string sub) {
	int pos = builtin__string_index_last_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, 0, pos);
}
string builtin__string_all_after(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, (int)(pos + sub.len), 2147483647);
}
string builtin__string_all_after_last(string s, string sub) {
	int pos = builtin__string_index_last_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, (int)(pos + sub.len), 2147483647);
}
string builtin__string_all_after_first(string s, string sub) {
	int pos = builtin__string_index_(s, sub);
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, (int)(pos + sub.len), 2147483647);
}
inline string builtin__string_after(string s, string sub) {
	return builtin__string_all_after_last(s, sub);
}
string builtin__string_after_char(string s, u8 sub) {
	int pos = -1;
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		if (c == sub) {
			pos = i;
			break;
		}
	}
	if (pos == -1) {
		return builtin__string_clone(s);
	}
	return builtin__string_substr(s, (int)(pos + 1), 2147483647);
}
string Array_string_join(Array_string a, string sep) {
	if (a.len == 0) {
		return _S("");
	}
	int len = 0;
	for (int _t2 = 0; _t2 < a.len; ++_t2) {
		string val = ((string*)a.data)[_t2];
		len += (int)(val.len + sep.len);
	}
	len -= sep.len;
	string res = ((string){.str = builtin__malloc_noscan((int)(len + 1)), .len = len});
	int idx = 0;
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		{ // Unsafe block
			builtin__vmemcpy(((voidptr)(res.str + idx)), val.str, val.len);
			idx += val.len;
		}
		if (i != (int)(a.len - 1)) {
			{ // Unsafe block
				builtin__vmemcpy(((voidptr)(res.str + idx)), sep.str, sep.len);
				idx += sep.len;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}
inline string Array_string_join_lines(Array_string s) {
	return Array_string_join(s, _S("\n"));
}
string builtin__string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return builtin__string_clone(s);
	}
	string res = ((string){.str = builtin__malloc_noscan((int)(s.len + 1)), .len = s.len});
	for (int i = (int)(s.len - 1); i >= 0; i--) {
		{ // Unsafe block
			res.str[(int)((int)(s.len - i) - 1)] = s.str[ i];
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}
string builtin__string_limit(string s, int max) {
	Array_rune u = builtin__string_runes(s);
	if (u.len <= max) {
		return builtin__string_clone(s);
	}
	return Array_rune_string(builtin__array_slice(u, 0, max));
}
int builtin__string_hash(string s) {
	u32 h = ((u32)(0));
	if (h == 0 && s.len > 0) {
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			u8 c = s.str[_t1];
			h = (u32)((u32)(h * 31) + ((u32)(c)));
		}
	}
	return ((int)(h));
}
Array_u8 builtin__string_bytes(string s) {
	if (s.len == 0) {
		return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
	}
	Array_u8 buf = builtin____new_array_with_default(s.len, 0, sizeof(u8), 0);
	builtin__vmemcpy(buf.data, s.str, s.len);
	return buf;
}
string builtin__string_repeat(string s, int count) {
	if (count <= 0) {
		return _S("");
	} else if (count == 1) {
		return builtin__string_clone(s);
	}
	u8* ret = builtin__malloc_noscan((int)((int)(s.len * count) + 1));
	for (int i = 0; i < count; ++i) {
		builtin__vmemcpy(ret + (int)(i * s.len), s.str, s.len);
	}
	int new_len = (int)(s.len * count);
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return builtin__u8_vstring_with_len(ret, new_len);
}
Array_string builtin__string_fields(string s) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	int word_start = 0;
	int word_len = 0;
	bool is_in_word = false;
	bool is_space = false;
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		is_space = (c == 32 || c == 9 || c == 10);
		if (!is_space) {
			word_len++;
		}
		if (!is_in_word && !is_space) {
			word_start = i;
			is_in_word = true;
			continue;
		}
		if (is_space && is_in_word) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, word_start, (int)(word_start + word_len)) }));
			is_in_word = false;
			word_len = 0;
			word_start = 0;
			continue;
		}
	}
	if (is_in_word && word_len > 0) {
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_substr(s, word_start, s.len) }));
	}
	Array_string _t3 = res;
		{ // defer begin
			builtin__ArrayFlags_clear(&res.flags, ArrayFlags__noslices);
		} // defer end
	return _t3;
}
inline string builtin__string_strip_margin(string s) {
	return builtin__string_strip_margin_custom(s, '|');
}
string builtin__string_strip_margin_custom(string s, u8 del) {
	u8 sep = del;
	if (builtin__u8_is_space(sep)) {
		builtin__println(_S("Warning: `strip_margin` cannot use white-space as a delimiter"));
		builtin__println(_S("    Defaulting to `|`"));
		sep = '|';
	}
	u8* ret = builtin__malloc_noscan((int)(s.len + 1));
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10 || s.str[ i] == 13) {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
			if (s.str[ i] == 13 && i < (int)(s.len - 1) && s.str[ (int)(i + 1)] == 10) {
				{ // Unsafe block
					ret[count] = s.str[ (int)(i + 1)];
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(s.str[ i] != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return builtin__u8_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_trim_indent(string s) {
	Array_string lines = builtin__string_split_into_lines(s);
	int min_common_indent = ((int)(_const_max_int));
	for (int _t1 = 0; _t1 < lines.len; ++_t1) {
		string line = ((string*)lines.data)[_t1];
		if (builtin__string_is_blank(line)) {
			continue;
		}
		int line_indent = builtin__string_indent_width(line);
		if (line_indent < min_common_indent) {
			min_common_indent = line_indent;
		}
	}
	if (lines.len > 0 && builtin__string_is_blank((*(string*)builtin__array_first(lines)))) {
		lines = builtin__array_slice(lines, 1, 2147483647);
	}
	if (lines.len > 0 && builtin__string_is_blank((*(string*)builtin__array_last(lines)))) {
		lines = builtin__array_slice(lines, 0, (int)(lines.len - 1));
	}
	Array_string trimmed_lines = builtin____new_array_with_default(0, lines.len, sizeof(string), 0);
	for (int _t2 = 0; _t2 < lines.len; ++_t2) {
		string line = ((string*)lines.data)[_t2];
		if (builtin__string_is_blank(line)) {
			builtin__array_push((array*)&trimmed_lines, _MOV((string[]){ line }));
			continue;
		}
		builtin__array_push((array*)&trimmed_lines, _MOV((string[]){ builtin__string_substr(line, min_common_indent, 2147483647) }));
	}
	return Array_string_join(trimmed_lines, _S("\n"));
}
int builtin__string_indent_width(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		if (!builtin__u8_is_space(c)) {
			return i;
		}
	}
	return 0;
}
bool builtin__string_is_blank(string s) {
	if (s.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (!builtin__u8_is_space(c)) {
			return false;
		}
	}
	return true;
}
bool builtin__string_match_glob(string name, string pattern) {
	int px = 0;
	int nx = 0;
	int next_px = 0;
	int next_nx = 0;
	int plen = pattern.len;
	int nlen = name.len;
	for (;;) {
		if (!(px < plen || nx < nlen)) break;
		if (px < plen) {
			u8 c = pattern.str[ px];

			if (c == ('?')) {
				if (nx < nlen) {
					px++;
					nx++;
					continue;
				}
			}
			else if (c == ('*')) {
				next_px = px;
				next_nx = (int)(nx + 1);
				px++;
				continue;
			}
			else if (c == ('[')) {
				if (nx < nlen) {
					u8 wanted_c = name.str[ nx];
					int bstart = px;
					bool is_inverted = false;
					bool inner_match = false;
					int inner_idx = (int)(bstart + 1);
					int inner_c = 0;
					if (inner_idx < plen) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == '^') {
							is_inverted = true;
							inner_idx++;
						}
					}
					for (; inner_idx < plen; inner_idx++) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == ']') {
							break;
						}
						if (inner_c == wanted_c) {
							inner_match = true;
							for (;;) {
								if (!(px < plen && pattern.str[ px] != ']')) break;
								px++;
							}
							break;
						}
					}
					if (is_inverted) {
						if (inner_match) {
							return false;
						} else {
							px = inner_idx;
						}
					}
				}
				px++;
				nx++;
				continue;
			}
			else {
				if (nx < nlen && name.str[ nx] == c) {
					px++;
					nx++;
					continue;
				}
			}
		}
		if (0 < next_nx && next_nx <= nlen) {
			px = next_px;
			nx = next_nx;
			continue;
		}
		return false;
	}
	return true;
}
inline bool builtin__string_is_ascii(string s) {
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] < ((u8)(' ')) || s.str[ i] > ((u8)('~'))) {
			return false;
		}
	}
	return true;
}
bool builtin__string_is_identifier(string s) {
	if (s.len == 0) {
		return false;
	}
	if (!(builtin__u8_is_letter(s.str[ 0]) || s.str[ 0] == '_')) {
		return false;
	}
	for (int i = 1; i < s.len; i++) {
		u8 c = s.str[ i];
		if (!(builtin__u8_is_letter(c) || builtin__u8_is_digit(c) || c == '_')) {
			return false;
		}
	}
	return true;
}
string builtin__string_camel_to_snake(string s) {
	if (s.len == 0) {
		return _S("");
	}
	if (s.len == 1) {
		return builtin__string_to_lower_ascii(s);
	}
	u8* b = builtin__malloc_noscan((int)((int)(2 * s.len) + 1));
	int pos = 2;
	bool prev_is_upper = false;
	bool prev_inserted_boundary = false;
	{ // Unsafe block
		if (builtin__u8_is_capital(s.str[ 0])) {
			b[0] = (u8)(s.str[ 0] + 32);
			u8 _t3; /* if prepend */
			if (builtin__u8_is_capital(s.str[ 1])) {
				prev_is_upper = true;
				_t3 = (u8)(s.str[ 1] + 32);
				goto _t4;
			};
			{
				_t3 = s.str[ 1];
			}
	_t4: {};
						b[1] = _t3;
		} else {
			b[0] = s.str[ 0];
			if (builtin__u8_is_capital(s.str[ 1])) {
				prev_is_upper = true;
				if (s.str[ 0] != '_' && s.len > 2 && !builtin__u8_is_capital(s.str[ 2])) {
					b[1] = '_';
					b[2] = (u8)(s.str[ 1] + 32);
					pos = 3;
				} else {
					b[1] = (u8)(s.str[ 1] + 32);
				}
			} else {
				b[1] = s.str[ 1];
			}
		}
	}
	for (int i = 2; i < s.len; i++) {
		bool has_boundary_before_upper = false;
		u8 c = s.str[ i];
		bool c_is_upper = builtin__u8_is_capital(c);
		bool c_is_number = builtin__u8_is_digit(c);
		bool next_is_lower = (int)(i + 1) < s.len && builtin__u8_is_letter(s.str[ (int)(i + 1)]) && !builtin__u8_is_capital(s.str[ (int)(i + 1)]);
		bool next2_is_lower = (int)(i + 2) < s.len && builtin__u8_is_letter(s.str[ (int)(i + 2)]) && !builtin__u8_is_capital(s.str[ (int)(i + 2)]);
		bool skip_digit = c_is_number && prev_is_upper && !next_is_lower && next2_is_lower;
		if (c_is_upper && prev_is_upper && i >= 2 && builtin__u8_is_capital(s.str[ (int)(i - 2)]) && next_is_lower && c != '_') {
			{ // Unsafe block
				if (b[(int)(pos - 1)] != '_') {
					b[pos] = '_';
					pos++;
				}
			}
			has_boundary_before_upper = true;
		}
		if (((c_is_upper && !prev_is_upper) || (!c_is_upper && prev_is_upper && builtin__u8_is_capital(s.str[ (int)(i - 2)]) && !prev_inserted_boundary && !skip_digit)) && c != '_') {
			{ // Unsafe block
				if (b[(int)(pos - 1)] != '_') {
					b[pos] = '_';
					pos++;
				}
			}
		}
		u8 lower_c = (c_is_upper ? ((u8)(c + 32)) : (c));
		{ // Unsafe block
			b[pos] = lower_c;
		}
		prev_is_upper = c_is_upper;
		prev_inserted_boundary = has_boundary_before_upper;
		pos++;
	}
	{ // Unsafe block
		b[pos] = 0;
	}
	return builtin__tos(b, pos);
}
string builtin__string_snake_to_camel(string s) {
	if (s.len == 0) {
		return _S("");
	}
	if (s.len == 1) {
		return s;
	}
	bool need_upper = true;
	rune upper_c = '_';
	u8* b = builtin__malloc_noscan((int)(s.len + 1));
	int i = 0;
	for (int _t3 = 0; _t3 < s.len; ++_t3) {
		u8 c = s.str[_t3];
		upper_c = (c >= 'a' && c <= 'z' ? ((u8)(c - 32)) : (c));
		if (c == '_') {
			need_upper = true;
		} else if (need_upper) {
			{ // Unsafe block
				b[i] = upper_c;
			}
			i++;
			need_upper = false;
		} else {
			{ // Unsafe block
				b[i] = c;
			}
			i++;
		}
	}
	{ // Unsafe block
		b[i] = 0;
	}
	return builtin__tos(b, i);
}
string builtin__string_wrap(string s, WrapConfig config) {
	if (config.width <= 0) {
		return _S("");
	}
	Array_string words = builtin__string_fields(s);
	if (words.len == 0) {
		return _S("");
	}
	strings__Builder sb = strings__new_builder(s.len);
	strings__Builder_write_string(&sb, (*(string*)builtin__array_get(words, 0)));
	int space_left = (int)(config.width - (*(string*)builtin__array_get(words, 0)).len);
	for (int i = 1; i < words.len; ++i) {
		string word = (*(string*)builtin__array_get(words, i));
		if ((int)(word.len + 1) > space_left) {
			strings__Builder_write_string(&sb, config.end);
			strings__Builder_write_string(&sb, word);
			space_left = (int)(config.width - word.len);
		} else {
			strings__Builder_write_string(&sb, _S(" "));
			strings__Builder_write_string(&sb, word);
			space_left -= (int)(1 + word.len);
		}
	}
	return strings__Builder_str(&sb);
}
string builtin__string_hex(string s) {
	if ((s).len == 0) {
		return _S("");
	}
	return builtin__data_to_hex_string(((u8*)(s.str)), s.len);
}
VV_LOC string builtin__data_to_hex_string(u8* data, int len) {
	u8* hex = builtin__malloc_noscan((u64)((u64)(((u64)(len)) * 2) + 1));
	int dst = 0;
	for (int c = 0; c < len; ++c) {
		u8 b = data[c];
		u8 n0 = (b >> 4);
		u8 n1 = (b & 0xF);
		hex[dst] = (n0 < 10 ? ((rune)(n0 + '0')) : ((rune)(n0 + 'W')));
		hex[(int)(dst + 1)] = (n1 < 10 ? ((rune)(n1 + '0')) : ((rune)(n1 + 'W')));
		dst += 2;
	}
	hex[dst] = 0;
	return builtin__tos(hex, dst);
}
RunesIterator builtin__string_runes_iterator(string s) {
	return ((RunesIterator){.s = s,.i = 0,});
}
_option_rune builtin__RunesIterator_next(RunesIterator* ri) {
	if (ri->i >= ri->s.len) {
		return (_option_rune){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int char_len = builtin__utf8_char_len(ri->s.str[ri->i]);
	if (char_len == 1) {
		u8 res = ri->s.str[ri->i];
		ri->i++;
		_option_rune _t2;
		builtin___option_ok(&(rune[]) { res }, (_option*)(&_t2), sizeof(rune));
		 
		return _t2;
	}
	u8* start = ((u8*)(&ri->s.str[ri->i]));
	int len = ((int)(ri->s.len - 1) >= (int)(ri->i + char_len) ? (char_len) : ((int)(ri->s.len - ri->i)));
	ri->i += char_len;
	if (char_len > 4) {
		_option_rune _t3;
		builtin___option_ok(&(rune[]) { 0 }, (_option*)(&_t3), sizeof(rune));
		 
		return _t3;
	}
	_option_rune _t4;
	builtin___option_ok(&(rune[]) { ((rune)(builtin__impl_utf8_to_utf32(start, len))) }, (_option*)(&_t4), sizeof(rune));
	 
	return _t4;
}
Array_u8 builtin__byteptr_vbytes(byteptr data, int len) {
	return builtin__voidptr_vbytes(((voidptr)(data)), len);
}
string builtin__byteptr_vstring(byteptr bp) {
	return ((string){.str = bp, .len = builtin__vstrlen(bp)});
}
string builtin__byteptr_vstring_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}
string builtin__charptr_vstring(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = builtin__vstrlen_char(cp), .is_lit = 0});
}
string builtin__charptr_vstring_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0});
}
string builtin__byteptr_vstring_literal(byteptr bp) {
	return ((string){.str = bp, .len = builtin__vstrlen(bp), .is_lit = 1});
}
string builtin__byteptr_vstring_literal_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}
string builtin__charptr_vstring_literal(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = builtin__vstrlen_char(cp), .is_lit = 1});
}
string builtin__charptr_vstring_literal_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 1});
}
string builtin__StrIntpType_str(StrIntpType x) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (x) {
		case StrIntpType__si_no_str: {
			_t2 = _S("no_str");
			break;
		}
		case StrIntpType__si_c: {
			_t2 = _S("c");
			break;
		}
		case StrIntpType__si_u8: {
			_t2 = _S("u8");
			break;
		}
		case StrIntpType__si_i8: {
			_t2 = _S("i8");
			break;
		}
		case StrIntpType__si_u16: {
			_t2 = _S("u16");
			break;
		}
		case StrIntpType__si_i16: {
			_t2 = _S("i16");
			break;
		}
		case StrIntpType__si_u32: {
			_t2 = _S("u32");
			break;
		}
		case StrIntpType__si_i32: {
			_t2 = _S("i32");
			break;
		}
		case StrIntpType__si_u64: {
			_t2 = _S("u64");
			break;
		}
		case StrIntpType__si_i64: {
			_t2 = _S("i64");
			break;
		}
		case StrIntpType__si_f32: {
			_t2 = _S("f32");
			break;
		}
		case StrIntpType__si_f64: {
			_t2 = _S("f64");
			break;
		}
		case StrIntpType__si_g32: {
			_t2 = _S("f32");
			break;
		}
		case StrIntpType__si_g64: {
			_t2 = _S("f64");
			break;
		}
		case StrIntpType__si_e32: {
			_t2 = _S("f32");
			break;
		}
		case StrIntpType__si_e64: {
			_t2 = _S("f64");
			break;
		}
		case StrIntpType__si_s: {
			_t2 = _S("s");
			break;
		}
		case StrIntpType__si_p: {
			_t2 = _S("p");
			break;
		}
		case StrIntpType__si_r: {
			_t2 = _S("r");
			break;
		}
		case StrIntpType__si_vp: {
			_t2 = _S("vp");
			break;
		}
	}
	return _t2;
}
inline VV_LOC f32 builtin__fabs32(f32 x) {
	return (x < 0 ? (-x) : (x));
}
inline VV_LOC f64 builtin__fabs64(f64 x) {
	return (x < 0 ? (-x) : (x));
}
inline VV_LOC u64 builtin__abs64(i64 x) {
	return (x < 0 ? (((u64)(-x))) : (((u64)(x))));
}
u64 builtin__get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (builtin__abs64(in_width)) : (((u64)(0))));
	u64 align = (in_width > 0 ? (((u64)(32))) : (((u64)(0))));
	u64 upper_case = (in_upper_case ? (((u64)(128))) : (((u64)(0))));
	u64 sign = (in_sign ? (((u64)(256))) : (((u64)(0))));
	u64 precision = (in_precision != 987698 ? (((((u64)((in_precision & 0x7F))) << 9))) : ((((u64)(0x7F)) << 9)));
	u32 tail_zeros = (in_tail_zeros ? ((((u32)(1)) << 16)) : (((u32)(0))));
	u64 base = ((u64)((((u32)((in_base & 0xf))) << 27)));
	u64 res = ((u64)(((((((((((((u64)(fmt_type)) & 0x1F)) | align) | upper_case) | sign) | precision) | tail_zeros) | ((((u64)((width & 0x3FF))) << 17))) | base) | ((((u64)(in_pad_ch)) << 31)))));
	return res;
}
u32 builtin__get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (builtin__abs64(in_width)) : (((u32)(0))));
	u32 align = (in_width > 0 ? (((u32)(32))) : (((u32)(0))));
	u32 upper_case = (in_upper_case ? (((u32)(128))) : (((u32)(0))));
	u32 sign = (in_sign ? (((u32)(256))) : (((u32)(0))));
	u32 precision = (in_precision != 987698 ? (((((u32)((in_precision & 0x7F))) << 9))) : ((((u32)(0x7F)) << 9)));
	u32 tail_zeros = (in_tail_zeros ? ((((u32)(1)) << 16)) : (((u32)(0))));
	u32 base = ((u32)((((u32)((in_base & 0xf))) << 27)));
	u32 res = ((u32)(((((((((((((u32)(fmt_type)) & 0x1F)) | align) | upper_case) | sign) | precision) | tail_zeros) | ((((u32)((width & 0x3FF))) << 17))) | base) | ((((u32)((in_pad_ch & 1))) << 31)))));
	return res;
}
VV_LOC void builtin__StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb) {
	u32 x = data->fmt;
	StrIntpType typ = ((StrIntpType)((x & 0x1F)));
	int align = ((int)((((x >> 5)) & 0x01)));
	bool upper_case = ((((x >> 7)) & 0x01)) > 0;
	int sign = ((int)((((x >> 8)) & 0x01)));
	int precision = ((int)((((x >> 9)) & 0x7F)));
	bool tail_zeros = ((((x >> 16)) & 0x01)) > 0;
	int width = ((int)(((i16)((((x >> 17)) & 0x3FF)))));
	int base = (((int)((x >> 27))) & 0xF);
	u8 fmt_pad_ch = ((u8)((((x >> 31)) & 0xFF)));
	if (typ == StrIntpType__si_no_str) {
		return;
	}
	if (base > 0) {
		base += 2;
	}
	u8 pad_ch = ((u8)(' '));
	if (fmt_pad_ch > 0) {
		pad_ch = '0';
	}
	int len0_set = (width > 0 ? (width) : (-1));
	int len1_set = (precision == 0x7F ? (-1) : (precision));
	bool sign_set = sign == 1;
	strconv__BF_param bf = ((strconv__BF_param){
		.pad_ch = pad_ch,
		.len0 = len0_set,
		.len1 = len1_set,
		.positive = true,
		.sign_flag = sign_set,
		.align = strconv__Align_text__left,
		.rm_tail_zero = tail_zeros,
	});
	if (fmt_pad_ch == 0 || pad_ch == '0') {
		switch (align) {
			case 0: {
				bf.align = strconv__Align_text__left;
				break;
			}
			case 1: {
				bf.align = strconv__Align_text__right;
				break;
			}
			default: {
				{
					bf.align = strconv__Align_text__left;
					break;
				}
			}
		}
		
	} else {
		bf.align = strconv__Align_text__right;
	}
	{ // Unsafe block
		if (typ == StrIntpType__si_s) {
			if (upper_case) {
				string s = builtin__string_to_upper(data->d.d_s);
				if (width == 0) {
					strings__Builder_write_string(sb, s);
				} else {
					strconv__format_str_sb(s, bf, sb);
				}
				builtin__string_free(&s);
			} else {
				if (width == 0) {
					strings__Builder_write_string(sb, data->d.d_s);
				} else {
					strconv__format_str_sb(data->d.d_s, bf, sb);
				}
			}
			return;
		}
		if (typ == StrIntpType__si_r) {
			if (width > 0) {
				if (upper_case) {
					string s = builtin__string_to_upper(data->d.d_s);
					for (int _t1 = 1; _t1 < ((int)(1 + ((width > 0 ? (width) : (0))))); ++_t1) {
						strings__Builder_write_string(sb, s);
					}
					builtin__string_free(&s);
				} else {
					for (int _t2 = 1; _t2 < ((int)(1 + ((width > 0 ? (width) : (0))))); ++_t2) {
						strings__Builder_write_string(sb, data->d.d_s);
					}
				}
			}
			return;
		}
		if (typ == StrIntpType__si_i8 || typ == StrIntpType__si_i16 || typ == StrIntpType__si_i32 || typ == StrIntpType__si_i64) {
			i64 d = data->d.d_i64;
			if (typ == StrIntpType__si_i8) {
				d = ((i64)(data->d.d_i8));
			} else if (typ == StrIntpType__si_i16) {
				d = ((i64)(data->d.d_i16));
			} else if (typ == StrIntpType__si_i32) {
				d = ((i64)(data->d.d_i32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = builtin__i64_str(d);
					strings__Builder_write_string(sb, d_str);
					builtin__string_free(&d_str);
					return;
				}
				if (d < 0) {
					bf.positive = false;
				}
				strconv__format_dec_sb(builtin__abs64(d), bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				i64 absd = d;
				bool write_minus = false;
				if (d < 0 && pad_ch != ' ') {
					absd = -d;
					write_minus = true;
				}
				string hx = strconv__format_int(absd, base);
				if (upper_case) {
					string tmp = hx;
					hx = builtin__string_to_upper(hx);
					builtin__string_free(&tmp);
				}
				if (write_minus) {
					strings__Builder_write_u8(sb, '-');
					bf.len0--;
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				builtin__string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_u8 || typ == StrIntpType__si_u16 || typ == StrIntpType__si_u32 || typ == StrIntpType__si_u64) {
			u64 d = data->d.d_u64;
			if (typ == StrIntpType__si_u8) {
				d = ((u64)(data->d.d_u8));
			} else if (typ == StrIntpType__si_u16) {
				d = ((u64)(data->d.d_u16));
			} else if (typ == StrIntpType__si_u32) {
				d = ((u64)(data->d.d_u32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = builtin__u64_str(d);
					strings__Builder_write_string(sb, d_str);
					builtin__string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = builtin__string_to_upper(hx);
					builtin__string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				builtin__string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_p) {
			u64 d = data->d.d_u64;
			base = 16;
			if (base == 0) {
				if (width == 0) {
					string d_str = builtin__u64_str(d);
					strings__Builder_write_string(sb, d_str);
					builtin__string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = builtin__string_to_upper(hx);
					builtin__string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				builtin__string_free(&hx);
			}
			return;
		}
		bool use_default_str = false;
		if (width == 0 && precision == 0x7F) {
			bf.len1 = 3;
			use_default_str = true;
		}
		if (bf.len1 < 0) {
			bf.len1 = 3;
		}
		switch (typ) {
			case StrIntpType__si_f32: {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					if (use_default_str) {
						string f = builtin__f32_str(data->d.d_f32);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					} else {
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						string f = strconv__format_fl(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
				}
				#endif
				break;
			}
			case StrIntpType__si_f64: {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					if (use_default_str) {
						string f = builtin__f64_str(data->d.d_f64);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					} else {
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						strconv__Float64u f_union = ((strconv__Float64u){.f = data->d.d_f64,});
						if (f_union.u == _const_strconv__double_minus_zero) {
							bf.positive = false;
						}
						string f = strconv__format_fl(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
				}
				#endif
				break;
			}
			case StrIntpType__si_g32: {
				if (use_default_str) {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						string f = builtin__f32_strg(data->d.d_f32);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
					#endif
				} else {
					if (data->d.d_f32 == _const_strconv__single_plus_zero) {
						string tmp_str = _S("0");
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
						return;
					}
					if (data->d.d_f32 == _const_strconv__single_minus_zero) {
						string tmp_str = _S("-0");
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
						return;
					}
					if (data->d.d_f32 == _const_strconv__single_plus_infinity) {
						string tmp_str = _S("+inf");
						if (upper_case) {
							tmp_str = _S("+INF");
						}
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
					}
					if (data->d.d_f32 == _const_strconv__single_minus_infinity) {
						string tmp_str = _S("-inf");
						if (upper_case) {
							tmp_str = _S("-INF");
						}
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
					}
					if (data->d.d_f32 < 0) {
						bf.positive = false;
					}
					f32 d = builtin__fabs32(data->d.d_f32);
					if (d < ((f32)(999999.0)) && d >= ((f32)(0.00001))) {
						string f = strconv__format_fl(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
						return;
					}
					bf.len1--;
					string f = strconv__format_es(data->d.d_f32, bf);
					if (upper_case) {
						string tmp = f;
						f = builtin__string_to_upper(f);
						builtin__string_free(&tmp);
					}
					strings__Builder_write_string(sb, f);
					builtin__string_free(&f);
				}
				break;
			}
			case StrIntpType__si_g64: {
				if (use_default_str) {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						string f = builtin__f64_strg(data->d.d_f64);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
					#endif
				} else {
					if (data->d.d_f64 == _const_strconv__double_plus_zero) {
						string tmp_str = _S("0");
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
						return;
					}
					if (data->d.d_f64 == _const_strconv__double_minus_zero) {
						string tmp_str = _S("-0");
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
						return;
					}
					if (data->d.d_f64 == _const_strconv__double_plus_infinity) {
						string tmp_str = _S("+inf");
						if (upper_case) {
							tmp_str = _S("+INF");
						}
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
					}
					if (data->d.d_f64 == _const_strconv__double_minus_infinity) {
						string tmp_str = _S("-inf");
						if (upper_case) {
							tmp_str = _S("-INF");
						}
						strconv__format_str_sb(tmp_str, bf, sb);
						builtin__string_free(&tmp_str);
					}
					if (data->d.d_f64 < 0) {
						bf.positive = false;
					}
					f64 d = builtin__fabs64(data->d.d_f64);
					if (d < ((f64)(999999.0)) && d >= ((f64)(0.00001))) {
						string f = strconv__format_fl(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
						return;
					}
					bf.len1--;
					string f = strconv__format_es(data->d.d_f64, bf);
					if (upper_case) {
						string tmp = f;
						f = builtin__string_to_upper(f);
						builtin__string_free(&tmp);
					}
					strings__Builder_write_string(sb, f);
					builtin__string_free(&f);
				}
				break;
			}
			case StrIntpType__si_e32: {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					if (use_default_str) {
						string f = builtin__f32_str(data->d.d_f32);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					} else {
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						string f = strconv__format_es(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
				}
				#endif
				break;
			}
			case StrIntpType__si_e64: {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					if (use_default_str) {
						string f = builtin__f64_str(data->d.d_f64);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					} else {
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						string f = strconv__format_es(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = builtin__string_to_upper(f);
							builtin__string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						builtin__string_free(&f);
					}
				}
				#endif
				break;
			}
			case StrIntpType__si_c: {
				string ss = builtin__utf32_to_str(data->d.d_c);
				strings__Builder_write_string(sb, ss);
				builtin__string_free(&ss);
				break;
			}
			case StrIntpType__si_vp: {
				string ss = builtin__u64_hex(((u64)(data->d.d_vp)));
				strings__Builder_write_string(sb, ss);
				builtin__string_free(&ss);
				break;
			}
			case StrIntpType__si_no_str:
			case StrIntpType__si_u8:
			case StrIntpType__si_i8:
			case StrIntpType__si_u16:
			case StrIntpType__si_i16:
			case StrIntpType__si_u32:
			case StrIntpType__si_i32:
			case StrIntpType__si_u64:
			case StrIntpType__si_i64:
			case StrIntpType__si_s:
			case StrIntpType__si_p:
			case StrIntpType__si_r:
			default: {
				{
					strings__Builder_write_string(sb, _S("***ERROR!***"));
					break;
				}
			}
		}
		
	}
}
string builtin__str_intp(int data_len, StrIntpData* input_base) {
	strings__Builder res = strings__new_builder(64);
	for (int i = 0; i < data_len; i++) {
		StrIntpData* data = &input_base[i];
		if (data->str.len != 0) {
			strings__Builder_write_string(&res, data->str);
		}
		if (data->fmt != 0) {
			builtin__StrIntpData_process_str_intp_data(data, (voidptr)&res);
		}
	}
	string ret = strings__Builder_str(&res);
	strings__Builder_free(&res);
	return ret;
}
inline string builtin__str_intp_sq(string in_str) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("builtin__str_intp(2, _MOV((StrIntpData[]){{_S(\"\'\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_S(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_S("}},{_S(\"\'\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}
inline string builtin__str_intp_rune(string in_str) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("builtin__str_intp(2, _MOV((StrIntpData[]){{_S(\"`\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_S(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_S("}},{_S(\"`\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}
inline string builtin__str_intp_g32(string in_str) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("builtin__str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g32_code}}, {_S(", {.d_f32 = "), 0xfe10, {.d_s = in_str}}, {_S(" }}}))"), 0, { .d_c = 0 }}}));
}
inline string builtin__str_intp_g64(string in_str) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("builtin__str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g64_code}}, {_S(", {.d_f64 = "), 0xfe10, {.d_s = in_str}}, {_S(" }}}))"), 0, { .d_c = 0 }}}));
}
string builtin__str_intp_sub(string base_str, string in_str) {
	_option_int _t1 = builtin__string_index(base_str, _S("%%"));
	if (_t1.state != 0) {
		builtin__eprintln(_S("No string interpolation %% parameters"));
		builtin___v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	int index = (*(int*)_t1.data);
	{ // Unsafe block
		string st_str = builtin__string_substr(base_str, 0, index);
		if ((int)(index + 2) < base_str.len) {
			string en_str = builtin__string_substr(base_str, (int)(index + 2), 2147483647);
			string res_str = builtin__str_intp(5, _MOV((StrIntpData[]){{_S("builtin__str_intp(2, _MOV((StrIntpData[]){{_S(\""), 0xfe10, {.d_s = st_str}}, {_S("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_S(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_S(" }},{_S(\""), 0xfe10, {.d_s = en_str}}, {_S("\"), 0, {.d_c = 0}}}))"), 0, { .d_c = 0 }}}));
			builtin__string_free(&st_str);
			builtin__string_free(&en_str);
			return res_str;
		}
		string res2_str = builtin__str_intp(4, _MOV((StrIntpData[]){{_S("builtin__str_intp(1, _MOV((StrIntpData[]){{_S(\""), 0xfe10, {.d_s = st_str}}, {_S("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_S(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_S(" }}}))"), 0, { .d_c = 0 }}}));
		builtin__string_free(&st_str);
		return res2_str;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
u16* builtin__string_to_wide(string _str, ToWideConfig param) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		Array_rune srunes = builtin__string_runes(_str);
		{ // Unsafe block
			u16* result = ((u16*)(builtin__vcalloc_noscan((int)(((int)(srunes.len + 1)) * 2))));
			for (int i = 0; i < srunes.len; ++i) {
				rune r = ((rune*)srunes.data)[i];
				result[i] = ((u16)(r));
			}
			result[srunes.len] = 0;
			return result;
		}
	}
	#endif
	return 0;
}
string builtin__string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int i = 0;
		for (;;) {
			if (!(_wstr[i] != 0)) break;
			i++;
		}
		return builtin__string_from_wide2(_wstr, i);
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		strings__Builder sb = strings__new_builder(len);
		for (int i = 0; i < len; i++) {
			rune u = ((rune)(_wstr[i]));
			strings__Builder_write_rune(&sb, u);
		}
		string res = strings__Builder_str(&sb);
		strings__Builder_free(&sb);
		return res;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
Array_u8 builtin__wide_to_ansi(u16* _wstr) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		string s = builtin__string_from_wide(_wstr);
		Array_u8 str_to = builtin____new_array_with_default((int)(s.len + 1), 0, sizeof(u8), 0);
		builtin__vmemcpy(str_to.data, s.str, s.len);
		return str_to;
	}
	#endif
	return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
}
int builtin__utf8_char_len(u8 b) {
	return (int_literal)(((((0xe5000000U >> ((((b >> 3)) & 0x1e)))) & 3)) + 1);
}
string builtin__utf32_to_str(u32 code) {
	{ // Unsafe block
		u8* buffer = builtin__malloc_noscan(5);
		string res = builtin__utf32_to_str_no_malloc(code, buffer);
		if (res.len == 0) {
			builtin___v_free(buffer);
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string builtin__utf32_to_str_no_malloc(u32 code, u8* buf) {
	{ // Unsafe block
		int len = builtin__utf32_decode_to_buffer(code, buf);
		if (len == 0) {
			return _S("");
		}
		buf[len] = 0;
		return builtin__tos(buf, len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
int builtin__utf32_decode_to_buffer(u32 code, u8* buf) {
	{ // Unsafe block
		int icode = ((int)(code));
		u8* buffer = ((u8*)(buf));
		if (icode <= 127) {
			buffer[0] = ((u8)(icode));
			return 1;
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((u8)((icode >> 6))));
			buffer[1] = (128 | ((u8)((icode & 63))));
			return 2;
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((u8)((icode >> 12))));
			buffer[1] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[2] = (128 | ((u8)((icode & 63))));
			return 3;
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((u8)((icode >> 18))));
			buffer[1] = (128 | ((((u8)((icode >> 12))) & 63)));
			buffer[2] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[3] = (128 | ((u8)((icode & 63))));
			return 4;
		}
	}
	return 0;
}
int builtin__string_utf32_code(string _rune) {
	if (_rune.len > 4) {
		return 0;
	}
	return ((int)(builtin__impl_utf8_to_utf32(((u8*)(_rune.str)), _rune.len)));
}
_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes) {
	if (_bytes.len > 4) {
		return (_result_rune){ .is_error=true, .err=builtin___v_error(_S("attempted to decode too many bytes, utf-8 is limited to four bytes maximum")), .data={E_STRUCT} };
	}
	_result_rune _t2;
	builtin___result_ok(&(rune[]) { builtin__impl_utf8_to_utf32(((u8*)(_bytes.data)), _bytes.len) }, (_result*)(&_t2), sizeof(rune));
	 
	return _t2;
}
VV_LOC rune builtin__impl_utf8_to_utf32(u8* _bytes, int _bytes_len) {
	if (_bytes_len == 0 || _bytes_len > 4) {
		return 0;
	}
	if (_bytes_len == 1) {
		return ((rune)(_bytes[0]));
	}
	switch (_bytes_len) {
		case 2: {
			rune b0 = ((rune)(_bytes[0]));
			rune b1 = ((rune)(_bytes[1]));
			return (((((b0 & 0x1F)) << 6)) | ((b1 & 0x3F)));
		}
		case 3: {
			rune b0 = ((rune)(_bytes[0]));
			rune b1 = ((rune)(_bytes[1]));
			rune b2 = ((rune)(_bytes[2]));
			return ((((((b0 & 0x0F)) << 12)) | ((((b1 & 0x3F)) << 6))) | ((b2 & 0x3F)));
		}
		case 4: {
			rune b0 = ((rune)(_bytes[0]));
			rune b1 = ((rune)(_bytes[1]));
			rune b2 = ((rune)(_bytes[2]));
			rune b3 = ((rune)(_bytes[3]));
			return (((((((b0 & 0x07)) << 18)) | ((((b1 & 0x3F)) << 12))) | ((((b2 & 0x3F)) << 6))) | ((b3 & 0x3F)));
		}
		default: {
			{
				return 0;
			}
		}
	}
	
	return 0;
}
int builtin__utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		u8 c = s.str[i];
		ul = (int_literal)(((((0xe5000000U >> ((((s.str[i] >> 3)) & 0x1e)))) & 3)) + 1);
		if ((int)(i + ul) > s.len) {
			return l;
		}
		l++;
		if (ul == 1) {
			continue;
		}

		if (ul == (2)) {
			u64 r = ((u64)((((((u16)(c)) << 8)) | s.str[(int)(i + 1)])));
			if (r >= 0xcc80 && r < 0xcdb0) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)((((((u32)(c)) << 16)) | (((((u32)(s.str[(int)(i + 1)])) << 8)) | s.str[(int)(i + 2)]))));
			if ((r >= 0xe1aab0 && r <= 0xe1ac7f) || (r >= 0xe1b780 && r <= 0xe1b87f) || (r >= 0xe28390 && r <= 0xe2847f) || (r >= 0xefb8a0 && r <= 0xefb8af)) {
				l--;
			} else if ((r >= 0xe18480 && r <= 0xe1859f) || (r >= 0xe2ba80 && r <= 0xe2bf95) || (r >= 0xe38080 && r <= 0xe4b77f) || (r >= 0xe4b880 && r <= 0xea807f) || (r >= 0xeaa5a0 && r <= 0xeaa79f) || (r >= 0xeab080 && r <= 0xed9eaf) || (r >= 0xefa480 && r <= 0xefac7f) || (r >= 0xefb8b8 && r <= 0xefb9af)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)((((((u32)(c)) << 24)) | ((((((u32)(s.str[(int)(i + 1)])) << 16)) | ((((u32)(s.str[(int)(i + 2)])) << 8))) | s.str[(int)(i + 3)]))));
			if ((r >= 0xf09f8880U && r <= 0xf09f8a8fU) || (r >= 0xf09f8c80U && r <= 0xf09f9c90U) || (r >= 0xf09fa490U && r <= 0xf09fa7afU) || (r >= 0xf0a08080U && r <= 0xf180807fU)) {
				l++;
			}
		}
		else {
		}
	}
	return l;
}
Array_u8 builtin__string_to_ansi_not_null_terminated(string _str) {
	u16* wstr = builtin__string_to_wide(_str, ((ToWideConfig){.from_ansi = 0,}));
	Array_u8 ansi = builtin__wide_to_ansi(wstr);
	if (ansi.len > 0) {
		ansi.len--;
	}
	return ansi;
}
inline bool builtin__ArrayFlags_is_empty(ArrayFlags* e) {
	return ((int)(*e)) == 0;
}
inline bool builtin__ArrayFlags_has(ArrayFlags* e, ArrayFlags flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) != 0;
}
inline bool builtin__ArrayFlags_all(ArrayFlags* e, ArrayFlags flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) == ((int)(flag_));
}
inline void builtin__ArrayFlags_set(ArrayFlags* e, ArrayFlags flag_) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) | (((int)(flag_))))));
	}
}
inline void builtin__ArrayFlags_set_all(ArrayFlags* e) {
	{ // Unsafe block
		*e = ((ArrayFlags)(0b1111));
	}
}
inline void builtin__ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag_) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) & ~(((int)(flag_))))));
	}
}
inline void builtin__ArrayFlags_clear_all(ArrayFlags* e) {
	{ // Unsafe block
		*e = ((ArrayFlags)(0));
	}
}
inline void builtin__ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag_) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) ^ (((int)(flag_))))));
	}
}
inline ArrayFlags builtin__ArrayFlags__static__zero(void) {
	return ((ArrayFlags)(0));
}
#if defined(_WIN32)
#else
#endif
_result_voidptr json__decode(voidptr typ, string s) {
	_result_voidptr _t1;
	builtin___result_ok(&(voidptr[]) { 0 }, (_result*)(&_t1), sizeof(voidptr));
	 
	return _t1;
}
string json__encode(voidptr x) {
	return _S("");
}
string json__encode_pretty(voidptr x) {
	return _S("");
}
VV_LOC int json__decode_int(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return 0;
	}
	return root->valueint;
}
VV_LOC i8 json__decode_i8(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((i8)(0));
	}
	return ((i8)(root->valueint));
}
VV_LOC i16 json__decode_i16(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((i16)(0));
	}
	return ((i16)(root->valueint));
}
VV_LOC i64 json__decode_i64(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((i64)(0));
	}
	return ((i64)(root->valuedouble));
}
VV_LOC u8 json__decode_byte(struct cJSON* root) {
	return json__decode_u8(root);
}
VV_LOC u8 json__decode_u8(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((u8)(0));
	}
	return ((u8)(root->valueint));
}
VV_LOC u16 json__decode_u16(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((u16)(0));
	}
	return ((u16)(root->valueint));
}
VV_LOC u32 json__decode_u32(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((u32)(0));
	}
	return ((u32)(root->valueint));
}
VV_LOC u64 json__decode_u64(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((u64)(0));
	}
	return ((u64)(root->valuedouble));
}
VV_LOC f32 json__decode_f32(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((f32)(0));
	}
	return ((f32)(root->valuedouble));
}
VV_LOC f64 json__decode_f64(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((f64)(0));
	}
	return root->valuedouble;
}
VV_LOC rune json__decode_rune(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return ((rune)(0));
	}
	if (builtin__isnil(root->valuestring)) {
		return ((rune)(0));
	}
	return (*(rune*)builtin__array_first(builtin__string_runes(builtin__tos_clone(((u8*)(root->valuestring))))));
}
VV_LOC string json__decode_string(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return _S("");
	}
	if (builtin__isnil(root->valuestring)) {
		return _S("");
	}
	return builtin__tos_clone(((u8*)(root->valuestring)));
}
VV_LOC bool json__decode_bool(struct cJSON* root) {
	if (builtin__isnil(root)) {
		return false;
	}
	return cJSON_IsTrue(root);
}
VV_LOC struct cJSON* json__encode_int(int val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_i8(i8 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_i16(i16 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_i64(i64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_byte(u8 root) {
	return json__encode_u8(root);
}
VV_LOC struct cJSON* json__encode_u8(u8 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_u16(u16 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_u32(u32 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_u64(u64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_f32(f32 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_f64(f64 val) {
	return cJSON_CreateNumber(val);
}
VV_LOC struct cJSON* json__encode_bool(bool val) {
	return cJSON_CreateBool(val);
}
VV_LOC struct cJSON* json__encode_rune(rune val) {
	return cJSON_CreateString(((char*)(builtin__rune_str(val).str)));
}
VV_LOC struct cJSON* json__encode_string(string val) {
	return cJSON_CreateString(((char*)(val.str)));
}
VV_LOC struct cJSON* json__json_parse(string s) {
	return cJSON_Parse(((char*)(s.str)));
}
VV_LOC string json__json_print(struct cJSON* data) {
	char* s = cJSON_PrintUnformatted(data);
	if (s == ((void*)0)) {
		return _S("");
	}
	string r = builtin__tos_clone(((u8*)(s)));
	cJSON_free(s);
	return r;
}
VV_LOC string json__json_print_pretty(struct cJSON* data) {
	char* s = cJSON_Print(data);
	if (s == ((void*)0)) {
		return _S("");
	}
	string r = builtin__tos_clone(((u8*)(s)));
	cJSON_free(s);
	return r;
}
#if !defined(_WIN32) && !defined(__ANDROID__)
#endif
strings__textscanner__TextScanner strings__textscanner__new(string input) {
	return ((strings__textscanner__TextScanner){.input = input,.ilen = input.len,.pos = 0,});
}
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss) {
	builtin__string_free(&ss->input);
}
inline int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss) {
	return (int)(ss->ilen - ss->pos);
}
inline int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		int opos = ss->pos;
		ss->pos++;
		return ss->input.str[ opos];
	}
	return -1;
}
inline void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		ss->pos++;
	}
}
inline void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos += n;
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}
inline int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		return ss->input.str[ ss->pos];
	}
	return -1;
}
inline u8 strings__textscanner__TextScanner_peek_u8(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		return ss->input.str[ ss->pos];
	}
	return 0;
}
inline int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n) {
	if ((int)(ss->pos + n) < ss->ilen) {
		return ss->input.str[ (int)(ss->pos + n)];
	}
	return -1;
}
inline u8 strings__textscanner__TextScanner_peek_n_u8(strings__textscanner__TextScanner* ss, int n) {
	if ((int)(ss->pos + n) < ss->ilen) {
		return ss->input.str[ (int)(ss->pos + n)];
	}
	return 0;
}
inline void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		ss->pos--;
	}
}
void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos -= n;
	if (ss->pos < 0) {
		ss->pos = 0;
	}
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}
inline int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss) {
	return strings__textscanner__TextScanner_peek_back_n(ss, 1);
}
inline int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n) {
	int offset = (int)(n + 1);
	if (ss->pos >= offset) {
		return ss->input.str[ (int)(ss->pos - offset)];
	}
	return -1;
}
inline int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		return ss->input.str[ (int)(ss->pos - 1)];
	}
	return -1;
}
void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss) {
	ss->pos = 0;
}
void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss) {
	ss->pos = ss->ilen;
}
void strings__textscanner__TextScanner_skip_whitespace(strings__textscanner__TextScanner* ss) {
	for (;;) {
		if (!((int)(ss->ilen - ss->pos) > 0 && builtin__u8_is_space(strings__textscanner__TextScanner_peek_u8(ss)))) break;
		strings__textscanner__TextScanner_next(ss);
	}
}
inline term__termios__TcFlag term__termios__flag(int value) {
	return ((usize)(value));
}
inline term__termios__TcFlag term__termios__invert(term__termios__TcFlag value) {
	return ~((usize)(value));
}
inline int term__termios__tcgetattr(int fd, term__termios__Termios* termios_p) {
	{ // Unsafe block
		return tcgetattr(fd, ((struct termios*)(termios_p)));
	}
	return 0;
}
inline int term__termios__tcsetattr(int fd, int optional_actions, term__termios__Termios* termios_p) {
	{ // Unsafe block
		return tcsetattr(fd, optional_actions, ((struct termios*)(termios_p)));
	}
	return 0;
}
inline int term__termios__ioctl(int fd, u64 request, voidptr arg) {
	{ // Unsafe block
		return ioctl(fd, request, arg);
	}
	return 0;
}
int term__termios__set_state(int fd, term__termios__Termios new_state) {
	term__termios__Termios x = new_state;
	return term__termios__tcsetattr(0, TCSANOW, (voidptr)&x);
}
void term__termios__Termios_disable_echo(term__termios__Termios* t) {
	t->c_lflag &= term__termios__invert(((usize)(ECHO)));
}
string v__token__KeywordsMatcherTrie_str(v__token__KeywordsMatcherTrie* km) {
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_S("KeywordsMatcherTrie{ /* nodes.len: "), 0xfe07, {.d_i32 = km->nodes.len}}, {_S(" */ min_len: "), 0xfe07, {.d_i32 = km->min_len}}, {_S(", max_len: "), 0xfe07, {.d_i32 = km->max_len}}, {_S(" }"), 0, { .d_c = 0 }}}));
}
string v__token__TrieNode_str(v__token__TrieNode* node) {
	if (builtin__isnil(node)) {
		return _S("&TrieNode(nil)");
	}
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("&TrieNode{value: "), 0xfe07, {.d_i32 = node->value}}, {_S("}"), 0, { .d_c = 0 }}}));
}
int v__token__KeywordsMatcherTrie_find(v__token__KeywordsMatcherTrie* km, string word) {
	int wlen = word.len;
	if (wlen < km->min_len || wlen > km->max_len) {
		return -1;
	}
	v__token__TrieNode* node = ((v__token__TrieNode**)km->nodes.data)[wlen];
	if (node == ((void*)0)) {
		return -1;
	}
	return v__token__TrieNode_find(node, word);
}
inline bool v__token__KeywordsMatcherTrie_matches(v__token__KeywordsMatcherTrie* km, string word) {
	return v__token__KeywordsMatcherTrie_find(km, word) != -1;
}
void v__token__KeywordsMatcherTrie_add_word(v__token__KeywordsMatcherTrie* km, string word, int value) {
	int wlen = word.len;
	if (km->max_len < wlen) {
		km->max_len = wlen;
	}
	if (km->min_len > wlen) {
		km->min_len = wlen;
	}
	for (;;) {
		if (!(km->nodes.len < (int)(wlen + 1))) break;
		builtin__array_push((array*)&km->nodes, _MOV((v__token__TrieNode*[]){ ((v__token__TrieNode*)(((void*)0))) }));
	}
	if (((v__token__TrieNode**)km->nodes.data)[wlen] == ((void*)0)) {
		((v__token__TrieNode**)km->nodes.data)[wlen] = v__token__new_trie_node();
	}
	v__token__TrieNode_add_word(((v__token__TrieNode**)km->nodes.data)[wlen], word, value, 0);
}
v__token__KeywordsMatcherTrie v__token__KeywordsMatcherTrie__static__new(int cap) {
	v__token__KeywordsMatcherTrie *km = HEAP(v__token__KeywordsMatcherTrie, (((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array_with_default(0, cap, sizeof(v__token__TrieNode*), 0),.min_len = 999999,.max_len = 0,})));
	for (int _t1 = 0; _t1 < cap; ++_t1) {
		builtin__array_push((array*)&(*(km)).nodes, _MOV((v__token__TrieNode*[]){ ((v__token__TrieNode*)(((void*)0))) }));
	}
	return (*(km));
}
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_trie_T_int(Map_string_int kw_map) {
	v__token__KeywordsMatcherTrie *km = HEAP(v__token__KeywordsMatcherTrie, (v__token__KeywordsMatcherTrie__static__new(10)));
	int _t2 = kw_map.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kw_map.key_values.len - _t2;
		_t2 = kw_map.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&kw_map.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&kw_map.key_values, _t1);
		k = builtin__string_clone(k);
		int v = (*(int*)builtin__DenseArray_value(&kw_map.key_values, _t1));
		v__token__KeywordsMatcherTrie_add_word(&(*(km)), k, ((int)(v)));
	}
	return (*(km));
}
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_trie_T_v__token__Kind(Map_string_v__token__Kind kw_map) {
	v__token__KeywordsMatcherTrie *km = HEAP(v__token__KeywordsMatcherTrie, (v__token__KeywordsMatcherTrie__static__new(10)));
	int _t2 = kw_map.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kw_map.key_values.len - _t2;
		_t2 = kw_map.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&kw_map.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&kw_map.key_values, _t1);
		k = builtin__string_clone(k);
		v__token__Kind v = (*(v__token__Kind*)builtin__DenseArray_value(&kw_map.key_values, _t1));
		v__token__KeywordsMatcherTrie_add_word(&(*(km)), k, ((int)(v)));
	}
	return (*(km));
}
v__token__KeywordsMatcherTrie v__token__new_keywords_matcher_from_array_trie(Array_string names) {
	Map_string_int m = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int i = 0; i < names.len; ++i) {
		string name = ((string*)names.data)[i];
		builtin__map_set(&m, &(string[]){name}, &(int[]) { i });
	}
	return v__token__new_keywords_matcher_trie_T_int(m);
}
v__token__TrieNode* v__token__new_trie_node(void) {
	return ((v__token__TrieNode*)builtin__memdup(&(v__token__TrieNode){.children = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.value = -1,}, sizeof(v__token__TrieNode)));
}
void v__token__TrieNode_show(v__token__TrieNode* node, int level) {
	Array_int non_nil_children = builtin____new_array_with_default(0, 0, sizeof(int), 0);
for (int idx = 0; idx != 123; ++idx) {
		v__token__TrieNode* x = node->children[idx];
		if (x != ((void*)0)) {
			builtin__array_push((array*)&non_nil_children, _MOV((int[]){ idx }));
		}
	}
	Array_string _t2 = {0};
	Array_int _t2_orig = non_nil_children;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
		int it = ((int*) _t2_orig.data)[_t4];
		string _t3 = builtin__u8_ascii_str(((u8)(it)));
		builtin__array_push((array*)&_t2, &_t3);
	}
	Array_string children =_t2;
	builtin__eprintln(builtin__str_intp(5, _MOV((StrIntpData[]){{_S("> level: "), 0x4fe27, {.d_i32 = level}}, {_S(" | value: "), 0x18fe27, {.d_i32 = node->value}}, {_S(" | non_nil_children: "), 0x4fe27, {.d_i32 = non_nil_children.len}}, {_S(" | "), 0xfe10, {.d_s = Array_string_str(children)}}, {_SLIT0, 0, { .d_c = 0 }}})));
for (int _t5 = 0; _t5 != 123; ++_t5) {
		v__token__TrieNode* x = node->children[_t5];
		if (x != ((void*)0)) {
			v__token__TrieNode_show(x, (int)(level + 1));
		}
	}
}
void v__token__TrieNode_add_word(v__token__TrieNode* node, string word, int value, int word_idx) {
	if (word_idx < 0 || word_idx >= word.len) {
		node->value = value;
		return;
	}
	u8 first = ((u8)(word.str[ word_idx]));
	v__token__TrieNode* child_node = node->children[first];
	if (child_node == ((void*)0)) {
		child_node = v__token__new_trie_node();
		node->children[first] = child_node;
	}
	v__token__TrieNode_add_word(child_node, word, value, (int)(word_idx + 1));
}
int v__token__TrieNode_find(v__token__TrieNode* root, string word) {
	int wlen = word.len;
	v__token__TrieNode* node = ((v__token__TrieNode*)(root));
	int idx = 0;
	for (;;) {
		if (idx == wlen) {
			int k = node->value;
			if (k != -1) {
				return k;
			}
			return -1;
		}
		u8 c = word.str[ idx];
		v__token__TrieNode* child = node->children[c];
		if (child == ((void*)0)) {
			return -1;
		}
		node = child;
		idx++;
	}
	return -1;
}
void v__token__Pos_free(v__token__Pos* p) {
}
string v__token__Pos_line_str(v__token__Pos p) {
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("{l: "), 0xafe27, {.d_i32 = (int)(p.line_nr + 1)}}, {_S(", c: "), 0x6fe24, {.d_u16 = p.col}}, {_S(", p: "), 0xafe27, {.d_i32 = p.pos}}, {_S(", ll: "), 0xafe27, {.d_i32 = (int)(p.last_line + 1)}}, {_S("}"), 0, { .d_c = 0 }}}));
}
v__token__Pos v__token__Pos_extend(v__token__Pos pos, v__token__Pos end) {
	return ((v__token__Pos){.len = (int)((int)(end.pos - pos.pos) + end.len),.line_nr = (pos).line_nr,.pos = (pos).pos,.col = (pos).col,.file_idx = (pos).file_idx,.last_line = end.last_line,});
}
v__token__Pos v__token__Pos_extend_with_last_line(v__token__Pos pos, v__token__Pos end, int last_line) {
	return ((v__token__Pos){.len = (int)((int)(end.pos - pos.pos) + end.len),.line_nr = (pos).line_nr,.pos = (pos).pos,.col = (pos).col,.file_idx = (pos).file_idx,.last_line = (int)(last_line - 1),});
}
void v__token__Pos_update_last_line(v__token__Pos* pos, int last_line) {
	pos->last_line = (int)(last_line - 1);
}
inline v__token__Pos v__token__Token_pos(v__token__Token* tok) {
	return ((v__token__Pos){
		.len = tok->len,
		.line_nr = (int)(tok->line_nr - 1),
		.pos = tok->pos,
		.col = (u16)(tok->col - 1),
		.file_idx = tok->file_idx,
		.last_line = (int)(tok->line_nr - 1),
	});
}
VV_LOC Map_string_v__token__Kind v__token__build_keys(void) {
	Map_string_v__token__Kind res = builtin__new_map(sizeof(string), sizeof(v__token__Kind), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int t = (int)(((int)(v__token__Kind__keyword_beg)) + 1); t < ((int)(v__token__Kind__keyword_end)); ++t) {
		string key = ((string*)_const_v__token__token_str.data)[t];
		if ((Array_string_contains(_const_v__token__orm_custom_operators, key))) {
			continue;
		}
		builtin__map_set(&res, &(string[]){key}, &(v__token__Kind[]) { ((v__token__Kind)(t)) });
	}
	return res;
}
VV_LOC Array_string v__token__build_token_str(void) {
	Array_string s = builtin____new_array_with_default(((int)(v__token__Kind___end_)), 0, sizeof(string), &(string[]){_S("")});
	((string*)s.data)[v__token__Kind__unknown] = _S("unknown");
	((string*)s.data)[v__token__Kind__eof] = _S("eof");
	((string*)s.data)[v__token__Kind__name] = _S("name");
	((string*)s.data)[v__token__Kind__number] = _S("number");
	((string*)s.data)[v__token__Kind__string] = _S("string");
	((string*)s.data)[v__token__Kind__chartoken] = _S("char");
	((string*)s.data)[v__token__Kind__plus] = _S("+");
	((string*)s.data)[v__token__Kind__minus] = _S("-");
	((string*)s.data)[v__token__Kind__mul] = _S("*");
	((string*)s.data)[v__token__Kind__div] = _S("/");
	((string*)s.data)[v__token__Kind__mod] = _S("%");
	((string*)s.data)[v__token__Kind__xor] = _S("^");
	((string*)s.data)[v__token__Kind__bit_not] = _S("~");
	((string*)s.data)[v__token__Kind__pipe] = _S("|");
	((string*)s.data)[v__token__Kind__hash] = _S("#");
	((string*)s.data)[v__token__Kind__amp] = _S("&");
	((string*)s.data)[v__token__Kind__inc] = _S("++");
	((string*)s.data)[v__token__Kind__dec] = _S("--");
	((string*)s.data)[v__token__Kind__and] = _S("&&");
	((string*)s.data)[v__token__Kind__logical_or] = _S("||");
	((string*)s.data)[v__token__Kind__not] = _S("!");
	((string*)s.data)[v__token__Kind__dot] = _S(".");
	((string*)s.data)[v__token__Kind__dotdot] = _S("..");
	((string*)s.data)[v__token__Kind__ellipsis] = _S("...");
	((string*)s.data)[v__token__Kind__comma] = _S(",");
	((string*)s.data)[v__token__Kind__not_in] = _S("!in");
	((string*)s.data)[v__token__Kind__not_is] = _S("!is");
	((string*)s.data)[v__token__Kind__semicolon] = _S(";");
	((string*)s.data)[v__token__Kind__colon] = _S(":");
	((string*)s.data)[v__token__Kind__arrow] = _S("<-");
	((string*)s.data)[v__token__Kind__assign] = _S("=");
	((string*)s.data)[v__token__Kind__decl_assign] = _S(":=");
	((string*)s.data)[v__token__Kind__plus_assign] = _S("+=");
	((string*)s.data)[v__token__Kind__minus_assign] = _S("-=");
	((string*)s.data)[v__token__Kind__mult_assign] = _S("*=");
	((string*)s.data)[v__token__Kind__div_assign] = _S("/=");
	((string*)s.data)[v__token__Kind__xor_assign] = _S("^=");
	((string*)s.data)[v__token__Kind__mod_assign] = _S("%=");
	((string*)s.data)[v__token__Kind__or_assign] = _S("|=");
	((string*)s.data)[v__token__Kind__and_assign] = _S("&=");
	((string*)s.data)[v__token__Kind__right_shift_assign] = _S(">>=");
	((string*)s.data)[v__token__Kind__unsigned_right_shift_assign] = _S(">>>=");
	((string*)s.data)[v__token__Kind__left_shift_assign] = _S("<<=");
	((string*)s.data)[v__token__Kind__boolean_or_assign] = _S("||=");
	((string*)s.data)[v__token__Kind__boolean_and_assign] = _S("&&=");
	((string*)s.data)[v__token__Kind__lcbr] = _S("{");
	((string*)s.data)[v__token__Kind__rcbr] = _S("}");
	((string*)s.data)[v__token__Kind__lpar] = _S("(");
	((string*)s.data)[v__token__Kind__rpar] = _S(")");
	((string*)s.data)[v__token__Kind__lsbr] = _S("[");
	((string*)s.data)[v__token__Kind__nilsbr] = _S("#[");
	((string*)s.data)[v__token__Kind__rsbr] = _S("]");
	((string*)s.data)[v__token__Kind__eq] = _S("==");
	((string*)s.data)[v__token__Kind__ne] = _S("!=");
	((string*)s.data)[v__token__Kind__gt] = _S(">");
	((string*)s.data)[v__token__Kind__lt] = _S("<");
	((string*)s.data)[v__token__Kind__ge] = _S(">=");
	((string*)s.data)[v__token__Kind__le] = _S("<=");
	((string*)s.data)[v__token__Kind__question] = _S("?");
	((string*)s.data)[v__token__Kind__left_shift] = _S("<<");
	((string*)s.data)[v__token__Kind__right_shift] = _S(">>");
	((string*)s.data)[v__token__Kind__unsigned_right_shift] = _S(">>>");
	((string*)s.data)[v__token__Kind__comment] = _S("comment");
	((string*)s.data)[v__token__Kind__nl] = _S("NLL");
	((string*)s.data)[v__token__Kind__dollar] = _S("$");
	((string*)s.data)[v__token__Kind__at] = _S("@");
	((string*)s.data)[v__token__Kind__str_dollar] = _S("$2");
	((string*)s.data)[v__token__Kind__key_assert] = _S("assert");
	((string*)s.data)[v__token__Kind__key_struct] = _S("struct");
	((string*)s.data)[v__token__Kind__key_if] = _S("if");
	((string*)s.data)[v__token__Kind__key_else] = _S("else");
	((string*)s.data)[v__token__Kind__key_asm] = _S("asm");
	((string*)s.data)[v__token__Kind__key_return] = _S("return");
	((string*)s.data)[v__token__Kind__key_module] = _S("module");
	((string*)s.data)[v__token__Kind__key_sizeof] = _S("sizeof");
	((string*)s.data)[v__token__Kind__key_isreftype] = _S("isreftype");
	((string*)s.data)[v__token__Kind__key_likely] = _S("_likely_");
	((string*)s.data)[v__token__Kind__key_unlikely] = _S("_unlikely_");
	((string*)s.data)[v__token__Kind__key_go] = _S("go");
	((string*)s.data)[v__token__Kind__key_goto] = _S("goto");
	((string*)s.data)[v__token__Kind__key_const] = _S("const");
	((string*)s.data)[v__token__Kind__key_mut] = _S("mut");
	((string*)s.data)[v__token__Kind__key_shared] = _S("shared");
	((string*)s.data)[v__token__Kind__key_lock] = _S("lock");
	((string*)s.data)[v__token__Kind__key_rlock] = _S("rlock");
	((string*)s.data)[v__token__Kind__key_type] = _S("type");
	((string*)s.data)[v__token__Kind__key_for] = _S("for");
	((string*)s.data)[v__token__Kind__key_fn] = _S("fn");
	((string*)s.data)[v__token__Kind__key_true] = _S("true");
	((string*)s.data)[v__token__Kind__key_false] = _S("false");
	((string*)s.data)[v__token__Kind__key_continue] = _S("continue");
	((string*)s.data)[v__token__Kind__key_break] = _S("break");
	((string*)s.data)[v__token__Kind__key_import] = _S("import");
	((string*)s.data)[v__token__Kind__key_unsafe] = _S("unsafe");
	((string*)s.data)[v__token__Kind__key_typeof] = _S("typeof");
	((string*)s.data)[v__token__Kind__key_dump] = _S("dump");
	((string*)s.data)[v__token__Kind__key_enum] = _S("enum");
	((string*)s.data)[v__token__Kind__key_interface] = _S("interface");
	((string*)s.data)[v__token__Kind__key_pub] = _S("pub");
	((string*)s.data)[v__token__Kind__key_in] = _S("in");
	((string*)s.data)[v__token__Kind__key_atomic] = _S("atomic");
	((string*)s.data)[v__token__Kind__key_orelse] = _S("or");
	((string*)s.data)[v__token__Kind__key_global] = _S("__global");
	((string*)s.data)[v__token__Kind__key_union] = _S("union");
	((string*)s.data)[v__token__Kind__key_static] = _S("static");
	((string*)s.data)[v__token__Kind__key_volatile] = _S("volatile");
	((string*)s.data)[v__token__Kind__key_as] = _S("as");
	((string*)s.data)[v__token__Kind__key_defer] = _S("defer");
	((string*)s.data)[v__token__Kind__key_match] = _S("match");
	((string*)s.data)[v__token__Kind__key_select] = _S("select");
	((string*)s.data)[v__token__Kind__key_like] = _S("like");
	((string*)s.data)[v__token__Kind__key_ilike] = _S("ilike");
	((string*)s.data)[v__token__Kind__key_none] = _S("none");
	((string*)s.data)[v__token__Kind__key_nil] = _S("nil");
	((string*)s.data)[v__token__Kind__key_offsetof] = _S("__offsetof");
	((string*)s.data)[v__token__Kind__key_is] = _S("is");
	((string*)s.data)[v__token__Kind__key_spawn] = _S("spawn");
	((string*)s.data)[v__token__Kind__key_implements] = _S("implements");
	((string*)s.data)[v__token__Kind__keyword_beg] = _S("keyword_beg");
	((string*)s.data)[v__token__Kind__keyword_end] = _S("keyword_end");
	((string*)s.data)[v__token__Kind__str_inter] = _S("str_inter");
	return s;
}
inline bool v__token__is_key(string key) {
	return ((int)((*(v__token__Kind*)builtin__map_get(ADDR(map, _const_v__token__keywords), &(string[]){key}, &(v__token__Kind[]){ 0 })))) > 0;
}
inline bool v__token__is_decl(v__token__Kind t) {
	return (t == v__token__Kind__key_enum || t == v__token__Kind__key_interface || t == v__token__Kind__key_fn || t == v__token__Kind__key_struct || t == v__token__Kind__key_type || t == v__token__Kind__key_const || t == v__token__Kind__key_pub || t == v__token__Kind__eof);
}
inline bool v__token__Kind_is_assign(v__token__Kind t) {
	return (Array_v__token__Kind_contains(_const_v__token__assign_tokens, t));
}
inline string v__token__Kind_str(v__token__Kind t) {
	int idx = ((int)(t));
	if (idx < 0 || _const_v__token__token_str.len <= idx) {
		return _S("unknown");
	}
	return ((string*)_const_v__token__token_str.data)[idx];
}
inline bool v__token__Token_is_next_to(v__token__Token t, v__token__Token pre_token) {
	return (int)(t.pos - pre_token.pos) == pre_token.len;
}
inline bool v__token__Token_is_key(v__token__Token t) {
	return ((int)(t.kind)) > ((int)(v__token__Kind__keyword_beg)) && ((int)(t.kind)) < ((int)(v__token__Kind__keyword_end));
}
string v__token__Token_str(v__token__Token t) {
	string s = v__token__Kind_str(t.kind);
	if (s.len == 0) {
		builtin__eprintln(_S("missing token kind string"));
	} else if (!builtin__u8_is_letter(s.str[ 0])) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("token `"), 0xfe10, {.d_s = s}}, {_S("`"), 0, { .d_c = 0 }}}));
	}
	if (v__token__is_key(t.lit)) {
		s = _S("keyword");
	}
	if ((t.lit).len != 0) {
		s = builtin__string__plus(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" `"), 0xfe10, {.d_s = t.lit}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	return s;
}
string v__token__Token_debug(v__token__Token t) {
	string ks = v__token__kind_to_string(t.kind);
	string s = ((t.lit).len == 0 ? (v__token__Kind_str(t.kind)) : (t.lit));
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("tok: ."), 0x18fe10, {.d_s = ks}}, {_S(" | lit: `"), 0xfe10, {.d_s = s}}, {_S("`"), 0, { .d_c = 0 }}}));
}
Array_v__token__Precedence v__token__build_precedences(void) {
	Array_v__token__Precedence p = builtin____new_array_with_default(((int)(v__token__Kind___end_)), 0, sizeof(v__token__Precedence), &(v__token__Precedence[]){v__token__Precedence__lowest});
	((v__token__Precedence*)p.data)[v__token__Kind__lsbr] = v__token__Precedence__index;
	((v__token__Precedence*)p.data)[v__token__Kind__nilsbr] = v__token__Precedence__index;
	((v__token__Precedence*)p.data)[v__token__Kind__dot] = v__token__Precedence__call;
	((v__token__Precedence*)p.data)[v__token__Kind__inc] = v__token__Precedence__postfix;
	((v__token__Precedence*)p.data)[v__token__Kind__dec] = v__token__Precedence__postfix;
	((v__token__Precedence*)p.data)[v__token__Kind__question] = v__token__Precedence__postfix;
	((v__token__Precedence*)p.data)[v__token__Kind__mul] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__div] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__mod] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__left_shift] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__right_shift] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__unsigned_right_shift] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__amp] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__arrow] = v__token__Precedence__product;
	((v__token__Precedence*)p.data)[v__token__Kind__plus] = v__token__Precedence__sum;
	((v__token__Precedence*)p.data)[v__token__Kind__minus] = v__token__Precedence__sum;
	((v__token__Precedence*)p.data)[v__token__Kind__pipe] = v__token__Precedence__sum;
	((v__token__Precedence*)p.data)[v__token__Kind__xor] = v__token__Precedence__sum;
	((v__token__Precedence*)p.data)[v__token__Kind__eq] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__ne] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__lt] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__le] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__gt] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__ge] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__key_like] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__key_ilike] = v__token__Precedence__eq;
	((v__token__Precedence*)p.data)[v__token__Kind__assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__plus_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__minus_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__div_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__mod_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__or_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__and_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__left_shift_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__right_shift_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__unsigned_right_shift_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__mult_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__xor_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__boolean_or_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__boolean_and_assign] = v__token__Precedence__assign;
	((v__token__Precedence*)p.data)[v__token__Kind__key_in] = v__token__Precedence__in_as;
	((v__token__Precedence*)p.data)[v__token__Kind__not_in] = v__token__Precedence__in_as;
	((v__token__Precedence*)p.data)[v__token__Kind__key_as] = v__token__Precedence__in_as;
	((v__token__Precedence*)p.data)[v__token__Kind__key_is] = v__token__Precedence__in_as;
	((v__token__Precedence*)p.data)[v__token__Kind__not_is] = v__token__Precedence__in_as;
	((v__token__Precedence*)p.data)[v__token__Kind__logical_or] = v__token__Precedence__cond;
	((v__token__Precedence*)p.data)[v__token__Kind__and] = v__token__Precedence__cond;
	return p;
}
inline int v__token__Token_precedence(v__token__Token tok) {
	return ((int)(((v__token__Precedence*)_const_v__token__precedences.data)[tok.kind]));
}
inline int v__token__Kind_precedence(v__token__Kind kind) {
	return ((int)(((v__token__Precedence*)_const_v__token__precedences.data)[kind]));
}
inline bool v__token__Token_is_scalar(v__token__Token tok) {
	return (tok.kind == v__token__Kind__number || tok.kind == v__token__Kind__string);
}
inline bool v__token__Token_is_unary(v__token__Token tok) {
	return (tok.kind == v__token__Kind__plus || tok.kind == v__token__Kind__minus || tok.kind == v__token__Kind__not || tok.kind == v__token__Kind__bit_not || tok.kind == v__token__Kind__mul || tok.kind == v__token__Kind__amp || tok.kind == v__token__Kind__arrow);
}
inline bool v__token__Kind_is_relational(v__token__Kind tok) {
	return (tok == v__token__Kind__lt || tok == v__token__Kind__le || tok == v__token__Kind__gt || tok == v__token__Kind__ge || tok == v__token__Kind__eq || tok == v__token__Kind__ne);
}
inline bool v__token__Kind_is_start_of_type(v__token__Kind k) {
	return (k == v__token__Kind__name || k == v__token__Kind__lpar || k == v__token__Kind__amp || k == v__token__Kind__lsbr || k == v__token__Kind__question || k == v__token__Kind__key_shared || k == v__token__Kind__not);
}
inline bool v__token__Kind_is_prefix(v__token__Kind kind) {
	return (kind == v__token__Kind__minus || kind == v__token__Kind__amp || kind == v__token__Kind__mul || kind == v__token__Kind__not || kind == v__token__Kind__bit_not);
}
inline bool v__token__Kind_is_infix(v__token__Kind kind) {
	return (kind == v__token__Kind__plus || kind == v__token__Kind__minus || kind == v__token__Kind__mod || kind == v__token__Kind__mul || kind == v__token__Kind__div || kind == v__token__Kind__eq || kind == v__token__Kind__ne || kind == v__token__Kind__gt || kind == v__token__Kind__lt || kind == v__token__Kind__key_in || kind == v__token__Kind__key_as || kind == v__token__Kind__ge || kind == v__token__Kind__le || kind == v__token__Kind__logical_or || kind == v__token__Kind__xor || kind == v__token__Kind__not_in || kind == v__token__Kind__key_is || kind == v__token__Kind__not_is || kind == v__token__Kind__and || kind == v__token__Kind__dot || kind == v__token__Kind__pipe || kind == v__token__Kind__amp || kind == v__token__Kind__left_shift || kind == v__token__Kind__right_shift || kind == v__token__Kind__unsigned_right_shift || kind == v__token__Kind__arrow || kind == v__token__Kind__key_like || kind == v__token__Kind__key_ilike);
}
inline bool v__token__Kind_is_postfix(v__token__Kind kind) {
	return (kind == v__token__Kind__inc || kind == v__token__Kind__dec || kind == v__token__Kind__question);
}
string v__token__kind_to_string(v__token__Kind k) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (k) {
		case v__token__Kind__unknown: {
			_t2 = _S("unknown");
			break;
		}
		case v__token__Kind__eof: {
			_t2 = _S("eof");
			break;
		}
		case v__token__Kind__name: {
			_t2 = _S("name");
			break;
		}
		case v__token__Kind__number: {
			_t2 = _S("number");
			break;
		}
		case v__token__Kind__string: {
			_t2 = _S("string");
			break;
		}
		case v__token__Kind__str_inter: {
			_t2 = _S("str_inter");
			break;
		}
		case v__token__Kind__chartoken: {
			_t2 = _S("chartoken");
			break;
		}
		case v__token__Kind__plus: {
			_t2 = _S("plus");
			break;
		}
		case v__token__Kind__minus: {
			_t2 = _S("minus");
			break;
		}
		case v__token__Kind__mul: {
			_t2 = _S("mul");
			break;
		}
		case v__token__Kind__div: {
			_t2 = _S("div");
			break;
		}
		case v__token__Kind__mod: {
			_t2 = _S("mod");
			break;
		}
		case v__token__Kind__xor: {
			_t2 = _S("xor");
			break;
		}
		case v__token__Kind__pipe: {
			_t2 = _S("pipe");
			break;
		}
		case v__token__Kind__inc: {
			_t2 = _S("inc");
			break;
		}
		case v__token__Kind__dec: {
			_t2 = _S("dec");
			break;
		}
		case v__token__Kind__and: {
			_t2 = _S("and");
			break;
		}
		case v__token__Kind__logical_or: {
			_t2 = _S("logical_or");
			break;
		}
		case v__token__Kind__not: {
			_t2 = _S("not");
			break;
		}
		case v__token__Kind__bit_not: {
			_t2 = _S("bit_not");
			break;
		}
		case v__token__Kind__question: {
			_t2 = _S("question");
			break;
		}
		case v__token__Kind__comma: {
			_t2 = _S("comma");
			break;
		}
		case v__token__Kind__semicolon: {
			_t2 = _S("semicolon");
			break;
		}
		case v__token__Kind__colon: {
			_t2 = _S("colon");
			break;
		}
		case v__token__Kind__arrow: {
			_t2 = _S("arrow");
			break;
		}
		case v__token__Kind__amp: {
			_t2 = _S("amp");
			break;
		}
		case v__token__Kind__hash: {
			_t2 = _S("hash");
			break;
		}
		case v__token__Kind__dollar: {
			_t2 = _S("dollar");
			break;
		}
		case v__token__Kind__at: {
			_t2 = _S("at");
			break;
		}
		case v__token__Kind__str_dollar: {
			_t2 = _S("str_dollar");
			break;
		}
		case v__token__Kind__left_shift: {
			_t2 = _S("left_shift");
			break;
		}
		case v__token__Kind__right_shift: {
			_t2 = _S("right_shift");
			break;
		}
		case v__token__Kind__unsigned_right_shift: {
			_t2 = _S("unsigned_right_shift");
			break;
		}
		case v__token__Kind__not_in: {
			_t2 = _S("not_in");
			break;
		}
		case v__token__Kind__not_is: {
			_t2 = _S("not_is");
			break;
		}
		case v__token__Kind__assign: {
			_t2 = _S("assign");
			break;
		}
		case v__token__Kind__decl_assign: {
			_t2 = _S("decl_assign");
			break;
		}
		case v__token__Kind__plus_assign: {
			_t2 = _S("plus_assign");
			break;
		}
		case v__token__Kind__minus_assign: {
			_t2 = _S("minus_assign");
			break;
		}
		case v__token__Kind__div_assign: {
			_t2 = _S("div_assign");
			break;
		}
		case v__token__Kind__mult_assign: {
			_t2 = _S("mult_assign");
			break;
		}
		case v__token__Kind__xor_assign: {
			_t2 = _S("xor_assign");
			break;
		}
		case v__token__Kind__mod_assign: {
			_t2 = _S("mod_assign");
			break;
		}
		case v__token__Kind__or_assign: {
			_t2 = _S("or_assign");
			break;
		}
		case v__token__Kind__and_assign: {
			_t2 = _S("and_assign");
			break;
		}
		case v__token__Kind__right_shift_assign: {
			_t2 = _S("right_shift_assign");
			break;
		}
		case v__token__Kind__left_shift_assign: {
			_t2 = _S("left_shift_assign");
			break;
		}
		case v__token__Kind__unsigned_right_shift_assign: {
			_t2 = _S("unsigned_right_shift_assign");
			break;
		}
		case v__token__Kind__boolean_and_assign: {
			_t2 = _S("boolean_and_assign");
			break;
		}
		case v__token__Kind__boolean_or_assign: {
			_t2 = _S("boolean_or_assign");
			break;
		}
		case v__token__Kind__lcbr: {
			_t2 = _S("lcbr");
			break;
		}
		case v__token__Kind__rcbr: {
			_t2 = _S("rcbr");
			break;
		}
		case v__token__Kind__lpar: {
			_t2 = _S("lpar");
			break;
		}
		case v__token__Kind__rpar: {
			_t2 = _S("rpar");
			break;
		}
		case v__token__Kind__lsbr: {
			_t2 = _S("lsbr");
			break;
		}
		case v__token__Kind__nilsbr: {
			_t2 = _S("nilsbr");
			break;
		}
		case v__token__Kind__rsbr: {
			_t2 = _S("rsbr");
			break;
		}
		case v__token__Kind__eq: {
			_t2 = _S("eq");
			break;
		}
		case v__token__Kind__ne: {
			_t2 = _S("ne");
			break;
		}
		case v__token__Kind__gt: {
			_t2 = _S("gt");
			break;
		}
		case v__token__Kind__lt: {
			_t2 = _S("lt");
			break;
		}
		case v__token__Kind__ge: {
			_t2 = _S("ge");
			break;
		}
		case v__token__Kind__le: {
			_t2 = _S("le");
			break;
		}
		case v__token__Kind__comment: {
			_t2 = _S("comment");
			break;
		}
		case v__token__Kind__nl: {
			_t2 = _S("nl");
			break;
		}
		case v__token__Kind__dot: {
			_t2 = _S("dot");
			break;
		}
		case v__token__Kind__dotdot: {
			_t2 = _S("dotdot");
			break;
		}
		case v__token__Kind__ellipsis: {
			_t2 = _S("ellipsis");
			break;
		}
		case v__token__Kind__keyword_beg: {
			_t2 = _S("keyword_beg");
			break;
		}
		case v__token__Kind__key_as: {
			_t2 = _S("key_as");
			break;
		}
		case v__token__Kind__key_asm: {
			_t2 = _S("key_asm");
			break;
		}
		case v__token__Kind__key_assert: {
			_t2 = _S("key_assert");
			break;
		}
		case v__token__Kind__key_atomic: {
			_t2 = _S("key_atomic");
			break;
		}
		case v__token__Kind__key_break: {
			_t2 = _S("key_break");
			break;
		}
		case v__token__Kind__key_const: {
			_t2 = _S("key_const");
			break;
		}
		case v__token__Kind__key_continue: {
			_t2 = _S("key_continue");
			break;
		}
		case v__token__Kind__key_defer: {
			_t2 = _S("key_defer");
			break;
		}
		case v__token__Kind__key_else: {
			_t2 = _S("key_else");
			break;
		}
		case v__token__Kind__key_enum: {
			_t2 = _S("key_enum");
			break;
		}
		case v__token__Kind__key_false: {
			_t2 = _S("key_false");
			break;
		}
		case v__token__Kind__key_for: {
			_t2 = _S("key_for");
			break;
		}
		case v__token__Kind__key_fn: {
			_t2 = _S("key_fn");
			break;
		}
		case v__token__Kind__key_global: {
			_t2 = _S("key_global");
			break;
		}
		case v__token__Kind__key_go: {
			_t2 = _S("key_go");
			break;
		}
		case v__token__Kind__key_goto: {
			_t2 = _S("key_goto");
			break;
		}
		case v__token__Kind__key_if: {
			_t2 = _S("key_if");
			break;
		}
		case v__token__Kind__key_import: {
			_t2 = _S("key_import");
			break;
		}
		case v__token__Kind__key_in: {
			_t2 = _S("key_in");
			break;
		}
		case v__token__Kind__key_interface: {
			_t2 = _S("key_interface");
			break;
		}
		case v__token__Kind__key_is: {
			_t2 = _S("key_is");
			break;
		}
		case v__token__Kind__key_match: {
			_t2 = _S("key_match");
			break;
		}
		case v__token__Kind__key_module: {
			_t2 = _S("key_module");
			break;
		}
		case v__token__Kind__key_mut: {
			_t2 = _S("key_mut");
			break;
		}
		case v__token__Kind__key_shared: {
			_t2 = _S("key_shared");
			break;
		}
		case v__token__Kind__key_lock: {
			_t2 = _S("key_lock");
			break;
		}
		case v__token__Kind__key_rlock: {
			_t2 = _S("key_rlock");
			break;
		}
		case v__token__Kind__key_none: {
			_t2 = _S("key_none");
			break;
		}
		case v__token__Kind__key_return: {
			_t2 = _S("key_return");
			break;
		}
		case v__token__Kind__key_select: {
			_t2 = _S("key_select");
			break;
		}
		case v__token__Kind__key_like: {
			_t2 = _S("key_like");
			break;
		}
		case v__token__Kind__key_ilike: {
			_t2 = _S("key_ilike");
			break;
		}
		case v__token__Kind__key_sizeof: {
			_t2 = _S("key_sizeof");
			break;
		}
		case v__token__Kind__key_isreftype: {
			_t2 = _S("key_isreftype");
			break;
		}
		case v__token__Kind__key_likely: {
			_t2 = _S("key_likely");
			break;
		}
		case v__token__Kind__key_unlikely: {
			_t2 = _S("key_unlikely");
			break;
		}
		case v__token__Kind__key_offsetof: {
			_t2 = _S("key_offsetof");
			break;
		}
		case v__token__Kind__key_struct: {
			_t2 = _S("key_struct");
			break;
		}
		case v__token__Kind__key_true: {
			_t2 = _S("key_true");
			break;
		}
		case v__token__Kind__key_type: {
			_t2 = _S("key_type");
			break;
		}
		case v__token__Kind__key_typeof: {
			_t2 = _S("key_typeof");
			break;
		}
		case v__token__Kind__key_dump: {
			_t2 = _S("key_dump");
			break;
		}
		case v__token__Kind__key_orelse: {
			_t2 = _S("key_orelse");
			break;
		}
		case v__token__Kind__key_union: {
			_t2 = _S("key_union");
			break;
		}
		case v__token__Kind__key_pub: {
			_t2 = _S("key_pub");
			break;
		}
		case v__token__Kind__key_static: {
			_t2 = _S("key_static");
			break;
		}
		case v__token__Kind__key_volatile: {
			_t2 = _S("key_volatile");
			break;
		}
		case v__token__Kind__key_unsafe: {
			_t2 = _S("key_unsafe");
			break;
		}
		case v__token__Kind__key_spawn: {
			_t2 = _S("key_spawn");
			break;
		}
		case v__token__Kind__key_implements: {
			_t2 = _S("key_implements");
			break;
		}
		case v__token__Kind__keyword_end: {
			_t2 = _S("keyword_end");
			break;
		}
		case v__token__Kind___end_: {
			_t2 = _S("_end_");
			break;
		}
		case v__token__Kind__key_nil: {
			_t2 = _S("key_nil");
			break;
		}
	}
	return _t2;
}
v__token__Kind v__token__assign_op_to_infix_op(v__token__Kind op) {
	v__token__Kind _t2 = 0;
	switch (op) {
		case v__token__Kind__plus_assign: {
			_t2 = v__token__Kind__plus;
			break;
		}
		case v__token__Kind__minus_assign: {
			_t2 = v__token__Kind__minus;
			break;
		}
		case v__token__Kind__mult_assign: {
			_t2 = v__token__Kind__mul;
			break;
		}
		case v__token__Kind__div_assign: {
			_t2 = v__token__Kind__div;
			break;
		}
		case v__token__Kind__xor_assign: {
			_t2 = v__token__Kind__xor;
			break;
		}
		case v__token__Kind__mod_assign: {
			_t2 = v__token__Kind__mod;
			break;
		}
		case v__token__Kind__or_assign: {
			_t2 = v__token__Kind__pipe;
			break;
		}
		case v__token__Kind__and_assign: {
			_t2 = v__token__Kind__amp;
			break;
		}
		case v__token__Kind__right_shift_assign: {
			_t2 = v__token__Kind__right_shift;
			break;
		}
		case v__token__Kind__unsigned_right_shift_assign: {
			_t2 = v__token__Kind__unsigned_right_shift;
			break;
		}
		case v__token__Kind__left_shift_assign: {
			_t2 = v__token__Kind__left_shift;
			break;
		}
		case v__token__Kind__boolean_and_assign: {
			_t2 = v__token__Kind__and;
			break;
		}
		case v__token__Kind__boolean_or_assign: {
			_t2 = v__token__Kind__logical_or;
			break;
		}
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__name:
		case v__token__Kind__number:
		case v__token__Kind__string:
		case v__token__Kind__str_inter:
		case v__token__Kind__chartoken:
		case v__token__Kind__plus:
		case v__token__Kind__minus:
		case v__token__Kind__mul:
		case v__token__Kind__div:
		case v__token__Kind__mod:
		case v__token__Kind__xor:
		case v__token__Kind__pipe:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__and:
		case v__token__Kind__logical_or:
		case v__token__Kind__not:
		case v__token__Kind__bit_not:
		case v__token__Kind__question:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__arrow:
		case v__token__Kind__amp:
		case v__token__Kind__hash:
		case v__token__Kind__dollar:
		case v__token__Kind__at:
		case v__token__Kind__str_dollar:
		case v__token__Kind__left_shift:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__not_in:
		case v__token__Kind__not_is:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__lcbr:
		case v__token__Kind__rcbr:
		case v__token__Kind__lpar:
		case v__token__Kind__rpar:
		case v__token__Kind__lsbr:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__eq:
		case v__token__Kind__ne:
		case v__token__Kind__gt:
		case v__token__Kind__lt:
		case v__token__Kind__ge:
		case v__token__Kind__le:
		case v__token__Kind__comment:
		case v__token__Kind__nl:
		case v__token__Kind__dot:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_asm:
		case v__token__Kind__key_assert:
		case v__token__Kind__key_atomic:
		case v__token__Kind__key_break:
		case v__token__Kind__key_const:
		case v__token__Kind__key_continue:
		case v__token__Kind__key_defer:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_false:
		case v__token__Kind__key_for:
		case v__token__Kind__key_fn:
		case v__token__Kind__key_global:
		case v__token__Kind__key_go:
		case v__token__Kind__key_goto:
		case v__token__Kind__key_if:
		case v__token__Kind__key_import:
		case v__token__Kind__key_in:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_is:
		case v__token__Kind__key_match:
		case v__token__Kind__key_module:
		case v__token__Kind__key_mut:
		case v__token__Kind__key_nil:
		case v__token__Kind__key_shared:
		case v__token__Kind__key_lock:
		case v__token__Kind__key_rlock:
		case v__token__Kind__key_none:
		case v__token__Kind__key_return:
		case v__token__Kind__key_select:
		case v__token__Kind__key_like:
		case v__token__Kind__key_ilike:
		case v__token__Kind__key_sizeof:
		case v__token__Kind__key_isreftype:
		case v__token__Kind__key_likely:
		case v__token__Kind__key_unlikely:
		case v__token__Kind__key_offsetof:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_true:
		case v__token__Kind__key_type:
		case v__token__Kind__key_typeof:
		case v__token__Kind__key_dump:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_static:
		case v__token__Kind__key_volatile:
		case v__token__Kind__key_unsafe:
		case v__token__Kind__key_spawn:
		case v__token__Kind__key_implements:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default: {
			{
				_t2 = v__token__Kind___end_;
				break;
			}
		}
	}
	return _t2;
}
#if defined(_WIN32)
#else
#endif
inline u64 sync__stdatomic__add_u64(u64* ptr, int delta) {
	atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	return *ptr;
}
inline u64 sync__stdatomic__sub_u64(u64* ptr, int delta) {
	atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	return *ptr;
}
inline i64 sync__stdatomic__add_i64(i64* ptr, int delta) {
	atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	return *ptr;
}
inline i64 sync__stdatomic__sub_i64(i64* ptr, int delta) {
	atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	return *ptr;
}
inline void sync__stdatomic__store_u64(u64* ptr, u64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}
inline u64 sync__stdatomic__load_u64(u64* ptr) {
	return atomic_load_u64(((voidptr)(ptr)));
}
inline void sync__stdatomic__store_i64(i64* ptr, i64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}
inline i64 sync__stdatomic__load_i64(i64* ptr) {
	return ((i64)(atomic_load_u64(((voidptr)(ptr)))));
}
inline u32 hash__fnv1a__sum32_string(string data) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = (u32)(((hash ^ ((u32)(data.str[ i])))) * _const_hash__fnv1a__fnv32_prime);
	}
	return hash;
}
inline u32 hash__fnv1a__sum32(Array_u8 data) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = (u32)(((hash ^ ((u32)(((u8*)data.data)[i])))) * _const_hash__fnv1a__fnv32_prime);
	}
	return hash;
}
inline u32 hash__fnv1a__sum32_bytes(u8* data, int data_len) {
	u32 hash = _const_hash__fnv1a__fnv32_offset_basis;
	for (int i = 0; i < data_len; ++i) {
		hash = (u32)(((hash ^ ((u32)(data[i])))) * _const_hash__fnv1a__fnv32_prime);
	}
	return hash;
}
inline u64 hash__fnv1a__sum64_string(string data) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = (u64)(((hash ^ ((u64)(data.str[ i])))) * _const_hash__fnv1a__fnv64_prime);
	}
	return hash;
}
inline u64 hash__fnv1a__sum64(Array_u8 data) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data.len; ++i) {
		hash = (u64)(((hash ^ ((u64)(((u8*)data.data)[i])))) * _const_hash__fnv1a__fnv64_prime);
	}
	return hash;
}
inline u64 hash__fnv1a__sum64_bytes(u8* data, int data_len) {
	u64 hash = _const_hash__fnv1a__fnv64_offset_basis;
	for (int i = 0; i < data_len; ++i) {
		hash = (u64)(((hash ^ ((u64)(data[i])))) * _const_hash__fnv1a__fnv64_prime);
	}
	return hash;
}
Array_string os__cmdline__options(Array_string args, string param) {
	Array_string flags = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < args.len; ++i) {
		string v = ((string*)args.data)[i];
		if (builtin__string__eq(v, param)) {
			if ((int)(i + 1) < args.len) {
				builtin__array_push((array*)&flags, _MOV((string[]){ (*(string*)builtin__array_get(args, (int)(i + 1))) }));
			}
		}
	}
	return flags;
}
string os__cmdline__option(Array_string args, string param, string def) {
	bool found = false;
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string arg = ((string*)args.data)[_t1];
		if (found) {
			return arg;
		} else if (builtin__string__eq(param, arg)) {
			found = true;
		}
	}
	return def;
}
Array_string os__cmdline__options_before(Array_string args, Array_string what) {
	Array_string args_before = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		if ((Array_string_contains(what, a))) {
			break;
		}
		builtin__array_push((array*)&args_before, _MOV((string[]){ builtin__string_clone(a) }));
	}
	return args_before;
}
Array_string os__cmdline__options_after(Array_string args, Array_string what) {
	bool found = false;
	Array_string args_after = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		if ((Array_string_contains(what, a))) {
			found = true;
			continue;
		}
		if (found) {
			builtin__array_push((array*)&args_after, _MOV((string[]){ builtin__string_clone(a) }));
		}
	}
	return args_after;
}
Array_string os__cmdline__only_non_options(Array_string args) {
	Array_string _t2 = {0};
	Array_string _t2_orig = args;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if (!builtin__string_starts_with(it, _S("-"))) {
			builtin__array_push((array*)&_t2, &it);
		}
	}
	return _t2;
}
Array_string os__cmdline__only_options(Array_string args) {
	Array_string _t2 = {0};
	Array_string _t2_orig = args;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if (builtin__string_starts_with(it, _S("-"))) {
			builtin__array_push((array*)&_t2, &it);
		}
	}
	return _t2;
}
i64 time__portable_timegm(struct tm* t) {
	int year = (int)(t->tm_year + 1900);
	int month = t->tm_mon;
	if (month > 11) {
		year += (int)(month / 12);
		month %= 12;
	} else if (month < 0) {
		int years_diff = (int)(((int)(11 - month)) / 12);
		year -= years_diff;
		month += (int)(12 * years_diff);
	}
	i64 days_since_1970 = ((i64)(time__days_from_unix_epoch(year, (int)(month + 1), t->tm_mday)));
	return (i64)((i64)(60 * ((i64)((i64)(60 * ((i64)((i64)(24 * days_since_1970) + t->tm_hour))) + t->tm_min))) + t->tm_sec);
}
int time__days_from_unix_epoch(int year, int month, int day) {
	int y = (month <= 2 ? ((int)(year - 1)) : (year));
	int era = (int)(y / 400);
	int year_of_the_era = (int)(y - (int)(era * 400));
	int day_of_year = (int)((int)((int)(((int)((int)(153 * ((int)(month + ((month > 2 ? (-3) : (9)))))) + 2)) / 5) + day) - 1);
	int day_of_the_era = (int)((int)((int)((int)(year_of_the_era * 365) + (int)(year_of_the_era / 4)) - (int)(year_of_the_era / 100)) + day_of_year);
	return (int)((int)((int)(era * 146097) + day_of_the_era) - 719468);
}
inline int time__Time_days_from_unix_epoch(time__Time t) {
	return time__days_from_unix_epoch(t.year, t.month, t.day);
}
time__Time time__date_from_days_after_unix_epoch(int days) {
	multi_return_int_int_int mr_1379 = time__calculate_date_from_day_offset(((i64)(days)));
	int year = mr_1379.arg0;
	int month = mr_1379.arg1;
	int day = mr_1379.arg2;
	return ((time__Time){.__v_unix = 0,.year = year,.month = month,.day = day,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,});
}
VV_LOC time__DateTimeParser time__new_date_time_parser(string datetime, string format) {
	return ((time__DateTimeParser){.datetime = datetime,.format = format,.current_pos_datetime = 0,});
}
VV_LOC _result_string time__DateTimeParser_next(time__DateTimeParser* p, int length) {
	if ((int)(p->current_pos_datetime + length) > p->datetime.len) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("end of string")), .data={E_STRUCT} };
	}
	string val = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + length));
	p->current_pos_datetime += length;
	_result_string _t2;
	builtin___result_ok(&(string[]) { val }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
VV_LOC _result_string time__DateTimeParser_peek(time__DateTimeParser* p, int length) {
	if ((int)(p->current_pos_datetime + length) > p->datetime.len) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("end of string")), .data={E_STRUCT} };
	}
	_result_string _t2;
	builtin___result_ok(&(string[]) { builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + length)) }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
VV_LOC _result_int time__DateTimeParser_must_be_int(time__DateTimeParser* p, int length) {
	_result_string _t1 = time__DateTimeParser_next(p, length);
	if (_t1.is_error) {
		_result_int _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	string val = (*(string*)_t1.data);
	if (!builtin__string_contains_only(val, _S("0123456789"))) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected int, found: "), 0xfe10, {.d_s = val}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_int _t4;
	builtin___result_ok(&(int[]) { builtin__string_int(val) }, (_result*)(&_t4), sizeof(int));
	 
	return _t4;
}
VV_LOC _result_int time__DateTimeParser_must_be_int_with_minimum_length(time__DateTimeParser* p, int min, int max, bool allow_leading_zero) {
	int length = (int)((int)(max + 1) - min);
	string val = _S("");
	for (int _t1 = 0; _t1 < length; ++_t1) {
		_result_string _t2 = time__DateTimeParser_peek(p, 1);
		if (_t2.is_error) {
			break;
		}
		
 		string tok = (*(string*)_t2.data);
		if (!builtin__string_contains_only(tok, _S("0123456789"))) {
			break;
		}
		_result_string _t3 = time__DateTimeParser_next(p, 1);
		if (_t3.is_error) {
			_result_int _t4 = {0};
			_t4.is_error = true;
			_t4.err = _t3.err;
			return _t4;
		}
		
 ;
		val = builtin__string__plus(val, tok);
	}
	if (val.len < min) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("expected int with a minimum length of "), 0xfe07, {.d_i32 = min}}, {_S(", found: "), 0xfe07, {.d_i32 = val.len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (!allow_leading_zero && builtin__string_starts_with(val, _S("0"))) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("0 is not allowed for this format")), .data={E_STRUCT} };
	}
	_result_int _t7;
	builtin___result_ok(&(int[]) { builtin__string_int(val) }, (_result*)(&_t7), sizeof(int));
	 
	return _t7;
}
VV_LOC _result_void time__DateTimeParser_must_be_string(time__DateTimeParser* p, string must) {
	_result_string _t1 = time__DateTimeParser_next(p, must.len);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	string val = (*(string*)_t1.data);
	if (!builtin__string__eq(val, must)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("invalid string: \""), 0xfe10, {.d_s = val}}, {_S("\"!=\""), 0xfe10, {.d_s = must}}, {_S("\" at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
VV_LOC _result_int time__DateTimeParser_must_be_valid_month(time__DateTimeParser* p) {
	for (int _t1 = 0; _t1 < _const_time__long_months.len; ++_t1) {
		string v = ((string*)_const_time__long_months.data)[_t1];
		if ((int)(p->current_pos_datetime + v.len) < p->datetime.len) {
			string month_name = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + v.len));
			if (builtin__string__eq(v, month_name)) {
				p->current_pos_datetime += v.len;
				_result_int _t2;
				builtin___result_ok(&(int[]) { (int)(Array_string_index(_const_time__long_months, month_name) + 1) }, (_result*)(&_t2), sizeof(int));
				 
				return _t2;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid month name, at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
VV_LOC _result_int time__DateTimeParser_must_be_valid_three_letter_month(time__DateTimeParser* p) {
	if ((int)(p->current_pos_datetime + 3) < p->datetime.len) {
		string letters = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + 3));
		for (int m = 1; m <= _const_time__long_months.len; m++) {
			if (builtin__string__eq(builtin__string_substr(_const_time__months_string, (int)(((int)(m - 1)) * 3), (int)(m * 3)), letters)) {
				p->current_pos_datetime += 3;
				_result_int _t1;
				builtin___result_ok(&(int[]) { m }, (_result*)(&_t1), sizeof(int));
				 
				return _t1;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid three letter month, at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
VV_LOC _result_string time__DateTimeParser_must_be_valid_week_day(time__DateTimeParser* p) {
for (int _t1 = 0; _t1 != 7; ++_t1) {
		string v = _const_time__long_days[_t1];
		if ((int)(p->current_pos_datetime + v.len) < p->datetime.len) {
			string weekday = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + v.len));
			if (builtin__string__eq(v, weekday)) {
				p->current_pos_datetime += v.len;
				_result_string _t2;
				builtin___result_ok(&(string[]) { weekday }, (_result*)(&_t2), sizeof(string));
				 
				return _t2;
			}
		}
	}
	return (_result_string){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid weekday, at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
VV_LOC _result_int time__DateTimeParser_must_be_valid_two_letter_week_day(time__DateTimeParser* p) {
	if ((int)(p->current_pos_datetime + 2) < p->datetime.len) {
		string letters = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + 2));
		for (int d = 1; d <= 7; d++) {
			if (builtin__string__eq(builtin__string_substr(_const_time__days_string, (int)(((int)(d - 1)) * 3), (int)((int)(d * 3) - 1)), letters)) {
				p->current_pos_datetime += 2;
				_result_int _t1;
				builtin___result_ok(&(int[]) { d }, (_result*)(&_t1), sizeof(int));
				 
				return _t1;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid two letter weekday, at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
VV_LOC _result_int time__DateTimeParser_must_be_valid_three_letter_week_day(time__DateTimeParser* p) {
	if ((int)(p->current_pos_datetime + 3) < p->datetime.len) {
		string letters = builtin__string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + 3));
		for (int d = 1; d <= 7; d++) {
			if (builtin__string__eq(builtin__string_substr(_const_time__days_string, (int)(((int)(d - 1)) * 3), (int)(d * 3)), letters)) {
				p->current_pos_datetime += 3;
				_result_int _t1;
				builtin___result_ok(&(int[]) { d }, (_result*)(&_t1), sizeof(int));
				 
				return _t1;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid three letter weekday, at: "), 0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
VV_LOC _result_Array_string time__extract_tokens(string s) {
	Array_string tokens = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string current = _S("");
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 r = s.str[_t1];
		if (builtin__string_contains_only(current, builtin__u8_ascii_str(r)) || (current).len == 0) {
			current = builtin__string__plus(current, builtin__u8_ascii_str(r));
		} else {
			builtin__array_push((array*)&tokens, _MOV((string[]){ builtin__string_clone(current) }));
			current = builtin__u8_ascii_str(r);
		}
	}
	if ((current).len != 0) {
		builtin__array_push((array*)&tokens, _MOV((string[]){ builtin__string_clone(current) }));
	}
	_result_Array_string _t4;
	builtin___result_ok(&(Array_string[]) { tokens }, (_result*)(&_t4), sizeof(Array_string));
	 
	return _t4;
}
VV_LOC _result_time__Time time__DateTimeParser_parse(time__DateTimeParser* p) {
	int year_ = 0;
	int month_ = 0;
	int day_in_month = 0;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	_result_Array_string _t1 = time__extract_tokens(p->format);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("malformed format string: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	Array_string tokens = (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < tokens.len; ++_t3) {
		string token = ((string*)tokens.data)[_t3];

		if (_SLIT_EQ(token.str, token.len, "YYYY")) {
			_result_int _t4 = time__DateTimeParser_must_be_int(p, 4);
			if (_t4.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the full year was specified")), .data={E_STRUCT} };
			}
			
 			year_ = (*(int*)_t4.data);
		}
		else if (_SLIT_EQ(token.str, token.len, "YY")) {
			_result_int _t6 = time__DateTimeParser_must_be_int(p, 2);
			if (_t6.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the full year was specified")), .data={E_STRUCT} };
			}
			
 			year_ = (int)((int)((int)(time__now().year / 100) * 100) + (*(int*)_t6.data));
		}
		else if (_SLIT_EQ(token.str, token.len, "M")) {
			_result_int _t8 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, false);
			if (_t8.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the month was specified")), .data={E_STRUCT} };
			}
			
 			month_ = (*(int*)_t8.data);
			if (month_ < 1 || month_ > 12) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("month must be  between 1 and 12")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "MM")) {
			_result_int _t11 = time__DateTimeParser_must_be_int(p, 2);
			if (_t11.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the month was specified")), .data={E_STRUCT} };
			}
			
 			month_ = (*(int*)_t11.data);
			if (month_ < 1 || month_ > 12) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("month must be  between 01 and 12")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "MMM")) {
			_result_int _t14 = time__DateTimeParser_must_be_valid_three_letter_month(p);
			if (_t14.is_error) {
				IError err = _t14.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			month_ = (*(int*)_t14.data);
		}
		else if (_SLIT_EQ(token.str, token.len, "MMMM")) {
			_result_int _t16 = time__DateTimeParser_must_be_valid_month(p);
			if (_t16.is_error) {
				IError err = _t16.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			month_ = (*(int*)_t16.data);
		}
		else if (_SLIT_EQ(token.str, token.len, "D")) {
			_result_int _t18 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, false);
			if (_t18.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the day was specified")), .data={E_STRUCT} };
			}
			
 			day_in_month = (*(int*)_t18.data);
			if (day_in_month < 1 || day_in_month > 31) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("day must be  between 1 and 31")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "DD")) {
			_result_int _t21 = time__DateTimeParser_must_be_int(p, 2);
			if (_t21.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before the month was specified")), .data={E_STRUCT} };
			}
			
 			day_in_month = (*(int*)_t21.data);
			if (day_in_month < 1 || day_in_month > 31) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("day must be  between 01 and 31")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "d")) {
			_result_int _t24 = time__DateTimeParser_must_be_int(p, 1);
			if (_t24.is_error) {
				IError err = _t24.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
		}
		else if (_SLIT_EQ(token.str, token.len, "c")) {
			_result_int _t26 = time__DateTimeParser_must_be_int(p, 1);
			if (_t26.is_error) {
				IError err = _t26.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
		}
		else if (_SLIT_EQ(token.str, token.len, "dd")) {
			_result_int _t28 = time__DateTimeParser_must_be_valid_two_letter_week_day(p);
			if (_t28.is_error) {
				IError err = _t28.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
		}
		else if (_SLIT_EQ(token.str, token.len, "ddd")) {
			_result_int _t30 = time__DateTimeParser_must_be_valid_three_letter_week_day(p);
			if (_t30.is_error) {
				IError err = _t30.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
		}
		else if (_SLIT_EQ(token.str, token.len, "dddd")) {
			_result_string _t32 = time__DateTimeParser_must_be_valid_week_day(p);
			if (_t32.is_error) {
				IError err = _t32.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
		}
		else if (_SLIT_EQ(token.str, token.len, "H")) {
			_result_int _t34 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, true);
			if (_t34.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t34.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 0 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "HH")) {
			_result_int _t37 = time__DateTimeParser_must_be_int(p, 2);
			if (_t37.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t37.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 00 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "h")) {
			_result_int _t40 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, true);
			if (_t40.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t40.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 0 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "hh")) {
			_result_int _t43 = time__DateTimeParser_must_be_int(p, 2);
			if (_t43.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t43.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 00 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "k")) {
			_result_int _t46 = time__DateTimeParser_must_be_int(p, 1);
			if (_t46.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t46.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 0 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "kk")) {
			_result_int _t49 = time__DateTimeParser_must_be_int(p, 2);
			if (_t49.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before hours where specified")), .data={E_STRUCT} };
			}
			
 			hour_ = (*(int*)_t49.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("hour must be  between 00 and 23")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "m")) {
			_result_int _t52 = time__DateTimeParser_must_be_int(p, 1);
			if (_t52.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before minutes where specified")), .data={E_STRUCT} };
			}
			
 			minute_ = (*(int*)_t52.data);
			if (minute_ < 0 || minute_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("minute must be between 0 and 59")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "mm")) {
			_result_int _t55 = time__DateTimeParser_must_be_int(p, 2);
			if (_t55.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before minutes where specified")), .data={E_STRUCT} };
			}
			
 			minute_ = (*(int*)_t55.data);
			if (minute_ < 0 || minute_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("minute must be between 00 and 59")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "s")) {
			_result_int _t58 = time__DateTimeParser_must_be_int(p, 1);
			if (_t58.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before seconds where specified")), .data={E_STRUCT} };
			}
			
 			second_ = (*(int*)_t58.data);
			if (second_ < 0 || second_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("second must be between 0 and 59")), .data={E_STRUCT} };
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "ss")) {
			_result_int _t61 = time__DateTimeParser_must_be_int(p, 2);
			if (_t61.is_error) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("end of string reached before seconds where specified")), .data={E_STRUCT} };
			}
			
 			second_ = (*(int*)_t61.data);
			if (second_ < 0 || second_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("second must be between 00 and 59")), .data={E_STRUCT} };
			}
		}
		else {
			_result_void _t64 = time__DateTimeParser_must_be_string(p, token);
			if (_t64.is_error) {
				IError err = _t64.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			
 ;
		}
	}
	if (month_ == 2) {
		int feb_days_in_year = (time__is_leap_year(year_) ? (29) : (28));
		if (day_in_month > feb_days_in_year) {
			return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("February has only 28 days in the given year")), .data={E_STRUCT} };
		}
	} else if (day_in_month == 31 && !(month_ == 1 || month_ == 3 || month_ == 5 || month_ == 7 || month_ == 8 || month_ == 10 || month_ == 12)) {
		string month_name = time__Time_custom_format(((time__Time){.__v_unix = 0,.year = 0,.month = month_,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.is_local = 0,}), _S("MMMM"));
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month_name}}, {_S(" has only 30 days"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_time__Time _t68;
	builtin___result_ok(&(time__Time[]) { time__new(((time__Time){
		.__v_unix = 0,
		.year = year_,
		.month = month_,
		.day = day_in_month,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = 0,
		.is_local = 0,
	})) }, (_result*)(&_t68), sizeof(time__Time));
	 
	return _t68;
}
i64 time__Duration_nanoseconds(time__Duration d) {
	return ((i64)(d));
}
i64 time__Duration_microseconds(time__Duration d) {
	return ((i64)(d)) / _const_time__microsecond;
}
i64 time__Duration_milliseconds(time__Duration d) {
	return ((i64)(d)) / _const_time__millisecond;
}
f64 time__Duration_seconds(time__Duration d) {
	return (f64)(((f64)(d)) / ((f64)(_const_time__second)));
}
f64 time__Duration_minutes(time__Duration d) {
	return (f64)(((f64)(d)) / ((f64)(_const_time__minute)));
}
f64 time__Duration_hours(time__Duration d) {
	return (f64)(((f64)(d)) / ((f64)(_const_time__hour)));
}
f64 time__Duration_days(time__Duration d) {
	return (f64)(((f64)(d)) / ((f64)(_const_time__hour * 24)));
}
string time__Duration_str(time__Duration d) {
	if (d == _const_time__infinite) {
		return _S("inf");
	}
	string sign = _S("");
	i64 t = ((i64)(d));
	if (t < 0) {
		sign = _S("-");
		t = -t;
	}
	i64 hr = t / _const_time__hour;
	t -= hr * _const_time__hour;
	i64 min = t / _const_time__minute;
	t -= min * _const_time__minute;
	i64 sec = t / _const_time__second;
	t -= sec * _const_time__second;
	i64 ms = t / _const_time__millisecond;
	t -= ms * _const_time__millisecond;
	i64 us = t / _const_time__microsecond;
	t -= us * _const_time__microsecond;
	i64 ns = t;
	bool _t3 = true;
	return ((_t3 == (hr > 0))? (builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = hr}}, {_S(":"), 0x8004fe29, {.d_i64 = min}}, {_S(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_t3 == (min > 0))? (builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = min}}, {_S(":"), 0x8004fe29, {.d_i64 = sec}}, {_S("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_t3 == (sec > 0))? (builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = sec}}, {_S("."), 0x8006fe29, {.d_i64 = ms}}, {_S("s"), 0, { .d_c = 0 }}}))) : (_t3 == (ms > 0))? (builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = ms}}, {_S("."), 0x8006fe29, {.d_i64 = us}}, {_S("ms"), 0, { .d_c = 0 }}}))) : (_t3 == (us > 0))? (builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = us}}, {_S("."), 0x8006fe29, {.d_i64 = ns}}, {_S("us"), 0, { .d_c = 0 }}}))) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe09, {.d_i64 = ns}}, {_S("ns"), 0, { .d_c = 0 }}}))));
}
string time__Duration_debug(time__Duration d) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	i64 x = ((i64)(d));
	string sign = _S("");
	if (x < 0) {
		sign = _S("- ");
		x = -x;
	}
	Map_string_i64 _t1 = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 6, sizeof(string), sizeof(i64),
		_MOV((string[6]){
			_S("days"),
			_S("h"),
			_S("m"),
			_S("s"),
			_S("ms"),
			_S("us"),
		}),
		_MOV((i64[6]){
			24 * _const_time__hour, 
			_const_time__hour, 
			_const_time__minute, 
			_const_time__second, 
			_const_time__millisecond, 
			_const_time__microsecond, 
		})
	)
	;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string label = *(string*)builtin__DenseArray_key(&_t1.key_values, _t2);
		label = builtin__string_clone(label);
		i64 v = (*(i64*)builtin__DenseArray_value(&_t1.key_values, _t2));
		if (x > v) {
			i64 xx = (i64)(x / v);
			x = (i64)(x % v);
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string__plus(builtin__i64_str(xx), label) }));
		}
	}
	if (x > 0) {
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = x}}, {_S("ns"), 0, { .d_c = 0 }}})) }));
	}
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Duration: "), 0xfe10, {.d_s = sign}}, {_SLIT0, 0xfe10, {.d_s = Array_string_join(res, _S(", "))}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
time__Duration time__Duration_times(time__Duration d, f64 x) {
	return (f64)(((f64)(d)) * x);
}
VV_LOC int time__iclamp(int x, int a, int b) {
	if (x < a) {
		return a;
	}
	if (x > b) {
		return b;
	}
	return x;
}
VV_LOC void time__int_to_byte_array_no_pad(int value, Array_u8* arr, int size) {
	int num = value;
	if (size <= 0 || num < 0) {
		return;
	}
	int i = (int)(size - 1);
	for (;;) {
		if (!(num > 0 && i >= 0)) break;
		((u8*)arr->data)[i] = (rune)(((int)(num % 10)) + '0');
		num /= 10;
		i--;
	}
}
VV_LOC void time__int_to_ptr_byte_array_no_pad(int value, u8* arr_prt, int arr_len) {
	int num = value;
	if (arr_len <= 0 || num < 0) {
		return;
	}
	int i = (int)(arr_len - 1);
	for (;;) {
		if (!(num > 0 && i >= 0)) break;
		{ // Unsafe block
			*(arr_prt + i) = (rune)(((int)(num % 10)) + '0');
		}
		num /= 10;
		i--;
	}
}
string time__Time_format(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(16, 16, sizeof(u8), _MOV((u8[16]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0'}));
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_ss(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(19, 19, sizeof(u8), _MOV((u8[19]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0', ':',
			'0', '0'}));
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	time__int_to_byte_array_no_pad(t.second, &buf, 19);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_ss_milli(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(23, 23, sizeof(u8), _MOV((u8[23]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0'}));
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	time__int_to_byte_array_no_pad(t.second, &buf, 19);
	int millis = (int)(t.nanosecond / 1000000);
	time__int_to_byte_array_no_pad(millis, &buf, 23);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_ss_micro(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(26, 26, sizeof(u8), _MOV((u8[26]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0', '0', '0',
			'0'}));
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	time__int_to_byte_array_no_pad(t.second, &buf, 19);
	int micros = (int)(t.nanosecond / 1000);
	time__int_to_byte_array_no_pad(micros, &buf, 26);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_ss_nano(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(29, 29, sizeof(u8), _MOV((u8[29]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', ' ', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0', '0', '0',
			'0', '0', '0', '0'}));
	time__int_to_byte_array_no_pad(t.year, &buf, 4);
	time__int_to_byte_array_no_pad(t.month, &buf, 7);
	time__int_to_byte_array_no_pad(t.day, &buf, 10);
	time__int_to_byte_array_no_pad(t.hour, &buf, 13);
	time__int_to_byte_array_no_pad(t.minute, &buf, 16);
	time__int_to_byte_array_no_pad(t.second, &buf, 19);
	time__int_to_byte_array_no_pad(t.nanosecond, &buf, 29);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_rfc3339(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(24, 24, sizeof(u8), _MOV((u8[24]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', 'T', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0', 'Z'}));
	time__Time t_ = time__time_with_unix(t);
	if (t_.is_local) {
		time__Time utc_time = time__Time_local_to_utc(t_);
		time__int_to_byte_array_no_pad(utc_time.year, &buf, 4);
		time__int_to_byte_array_no_pad(utc_time.month, &buf, 7);
		time__int_to_byte_array_no_pad(utc_time.day, &buf, 10);
		time__int_to_byte_array_no_pad(utc_time.hour, &buf, 13);
		time__int_to_byte_array_no_pad(utc_time.minute, &buf, 16);
		time__int_to_byte_array_no_pad(utc_time.second, &buf, 19);
		time__int_to_byte_array_no_pad((int)(utc_time.nanosecond / 1000000), &buf, 23);
	} else {
		time__int_to_byte_array_no_pad(t_.year, &buf, 4);
		time__int_to_byte_array_no_pad(t_.month, &buf, 7);
		time__int_to_byte_array_no_pad(t_.day, &buf, 10);
		time__int_to_byte_array_no_pad(t_.hour, &buf, 13);
		time__int_to_byte_array_no_pad(t_.minute, &buf, 16);
		time__int_to_byte_array_no_pad(t_.second, &buf, 19);
		time__int_to_byte_array_no_pad((int)(t_.nanosecond / 1000000), &buf, 23);
	}
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_rfc3339_micro(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(27, 27, sizeof(u8), _MOV((u8[27]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', 'T', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0', '0', '0',
			'0', 'Z'}));
	time__Time t_ = time__time_with_unix(t);
	if (t_.is_local) {
		time__Time utc_time = time__Time_local_to_utc(t_);
		time__int_to_byte_array_no_pad(utc_time.year, &buf, 4);
		time__int_to_byte_array_no_pad(utc_time.month, &buf, 7);
		time__int_to_byte_array_no_pad(utc_time.day, &buf, 10);
		time__int_to_byte_array_no_pad(utc_time.hour, &buf, 13);
		time__int_to_byte_array_no_pad(utc_time.minute, &buf, 16);
		time__int_to_byte_array_no_pad(utc_time.second, &buf, 19);
		time__int_to_byte_array_no_pad((int)(utc_time.nanosecond / 1000), &buf, 26);
	} else {
		time__int_to_byte_array_no_pad(t_.year, &buf, 4);
		time__int_to_byte_array_no_pad(t_.month, &buf, 7);
		time__int_to_byte_array_no_pad(t_.day, &buf, 10);
		time__int_to_byte_array_no_pad(t_.hour, &buf, 13);
		time__int_to_byte_array_no_pad(t_.minute, &buf, 16);
		time__int_to_byte_array_no_pad(t_.second, &buf, 19);
		time__int_to_byte_array_no_pad((int)(t_.nanosecond / 1000), &buf, 26);
	}
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_format_rfc3339_nano(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(30, 30, sizeof(u8), _MOV((u8[30]){
			((u8)('0')), '0', '0', '0', '-', '0', '0', '-', '0',
			'0', 'T', '0', '0', ':', '0', '0', ':',
			'0', '0', '.', '0', '0', '0', '0', '0',
			'0', '0', '0', '0', 'Z'}));
	time__Time t_ = time__time_with_unix(t);
	if (t_.is_local) {
		time__Time utc_time = time__Time_local_to_utc(t_);
		time__int_to_byte_array_no_pad(utc_time.year, &buf, 4);
		time__int_to_byte_array_no_pad(utc_time.month, &buf, 7);
		time__int_to_byte_array_no_pad(utc_time.day, &buf, 10);
		time__int_to_byte_array_no_pad(utc_time.hour, &buf, 13);
		time__int_to_byte_array_no_pad(utc_time.minute, &buf, 16);
		time__int_to_byte_array_no_pad(utc_time.second, &buf, 19);
		time__int_to_byte_array_no_pad(utc_time.nanosecond, &buf, 29);
	} else {
		time__int_to_byte_array_no_pad(t_.year, &buf, 4);
		time__int_to_byte_array_no_pad(t_.month, &buf, 7);
		time__int_to_byte_array_no_pad(t_.day, &buf, 10);
		time__int_to_byte_array_no_pad(t_.hour, &buf, 13);
		time__int_to_byte_array_no_pad(t_.minute, &buf, 16);
		time__int_to_byte_array_no_pad(t_.second, &buf, 19);
		time__int_to_byte_array_no_pad(t_.nanosecond, &buf, 29);
	}
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_hhmm(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(5, 5, sizeof(u8), _MOV((u8[5]){((u8)('0')), '0', ':', '0', '0'}));
	time__int_to_byte_array_no_pad(t.hour, &buf, 2);
	time__int_to_byte_array_no_pad(t.minute, &buf, 5);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_hhmmss(time__Time t) {
	Array_u8 buf = builtin__new_array_from_c_array(8, 8, sizeof(u8), _MOV((u8[8]){((u8)('0')), '0', ':', '0', '0', ':', '0', '0'}));
	time__int_to_byte_array_no_pad(t.hour, &buf, 2);
	time__int_to_byte_array_no_pad(t.minute, &buf, 5);
	time__int_to_byte_array_no_pad(t.second, &buf, 8);
	string _t1 = Array_u8_bytestr(buf);
		{ // defer begin
			builtin__array_free(&buf);
		} // defer end
	return _t1;
}
string time__Time_hhmm12(time__Time t) {
	return time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
}
string time__Time_ymmdd(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter__hyphen, time__FormatDate__yyyymmdd);
}
string time__Time_ddmmy(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter__dot, time__FormatDate__ddmmyyyy);
}
string time__Time_md(time__Time t) {
	return time__Time_get_fmt_date_str(t, time__FormatDelimiter__space, time__FormatDate__mmmd);
}
VV_LOC string time__ordinal_suffix(int n) {
	if (n > 3 && n < 21) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = n}}, {_S("th"), 0, { .d_c = 0 }}}));
	}
	int _t2 = (int)(n % 10);
		switch (_t2) {
		case 1: {
			return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = n}}, {_S("st"), 0, { .d_c = 0 }}}));
		}
		case 2: {
			return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = n}}, {_S("nd"), 0, { .d_c = 0 }}}));
		}
		case 3: {
			return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = n}}, {_S("rd"), 0, { .d_c = 0 }}}));
		}
		default: {
			{
				return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = n}}, {_S("th"), 0, { .d_c = 0 }}}));
			}
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}
string time__Time_custom_format(time__Time t, string s) {
	Array_string tokens = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < s.len; ) {
		for (int j = 4; j > 0; j--) {
			if (i > (int)(s.len - j)) {
				continue;
			}
			if (j == 1 || (j == 2 && (Array_string_contains(_const_time__tokens_2, builtin__string_substr(s, i, (int)(i + j))))) || (j == 3 && (Array_string_contains(_const_time__tokens_3, builtin__string_substr(s, i, (int)(i + j))))) || (j == 4 && (Array_string_contains(_const_time__tokens_4, builtin__string_substr(s, i, (int)(i + j)))))) {
				builtin__array_push((array*)&tokens, _MOV((string[]){ builtin__string_substr(s, i, (int)(i + j)) }));
				i += ((int)(j - 1));
				break;
			}
		}
		i++;
	}
	strings__Builder sb = strings__new_builder(128);
	for (int _t2 = 0; _t2 < tokens.len; ++_t2) {
		string token = ((string*)tokens.data)[_t2];

		if (_SLIT_EQ(token.str, token.len, "M")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.month));
		}
		else if (_SLIT_EQ(token.str, token.len, "MM")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "Mo")) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(t.month));
		}
		else if (_SLIT_EQ(token.str, token.len, "MMM")) {
			strings__Builder_write_string(&sb, builtin__string_substr((*(string*)builtin__array_get(_const_time__long_months, time__iclamp(0, (int)(t.month - 1), 11))), 0, 3));
		}
		else if (_SLIT_EQ(token.str, token.len, "MMMM")) {
			strings__Builder_write_string(&sb, (*(string*)builtin__array_get(_const_time__long_months, time__iclamp(0, (int)(t.month - 1), 11))));
		}
		else if (_SLIT_EQ(token.str, token.len, "D")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.day));
		}
		else if (_SLIT_EQ(token.str, token.len, "DD")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "Do")) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(t.day));
		}
		else if (_SLIT_EQ(token.str, token.len, "DDD")) {
			strings__Builder_write_string(&sb, builtin__int_str((time__Time_year_day(t))));
		}
		else if (_SLIT_EQ(token.str, token.len, "DDDD")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8006fe27, {.d_i32 = time__Time_year_day(t)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "DDDo")) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(time__Time_year_day(t)));
		}
		else if (_SLIT_EQ(token.str, token.len, "d")) {
			{
				strings__Builder_write_decimal(&sb, (int)(time__Time_day_of_week(t) % 7));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "dd")) {
			strings__Builder_write_string(&sb, builtin__string_substr(_const_time__long_days[builtin__v_fixed_index(time__iclamp(0, (int)(time__Time_day_of_week(t) - 1), 6), 7)], 0, 2));
		}
		else if (_SLIT_EQ(token.str, token.len, "ddd")) {
			strings__Builder_write_string(&sb, builtin__string_substr(_const_time__long_days[builtin__v_fixed_index(time__iclamp(0, (int)(time__Time_day_of_week(t) - 1), 6), 7)], 0, 3));
		}
		else if (_SLIT_EQ(token.str, token.len, "dddd")) {
			strings__Builder_write_string(&sb, _const_time__long_days[builtin__v_fixed_index(time__iclamp(0, (int)(time__Time_day_of_week(t) - 1), 6), 7)]);
		}
		else if (_SLIT_EQ(token.str, token.len, "YY")) {
			strings__Builder_write_string(&sb, builtin__string_substr_ni(builtin__int_str(t.year), 2, 4));
		}
		else if (_SLIT_EQ(token.str, token.len, "YYYY")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.year));
		}
		else if (_SLIT_EQ(token.str, token.len, "H")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.hour));
		}
		else if (_SLIT_EQ(token.str, token.len, "HH")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "h")) {
			int h = (int)((int)(((int)(t.hour + 11)) % 12) + 1);
			strings__Builder_write_string(&sb, builtin__int_str(h));
		}
		else if (_SLIT_EQ(token.str, token.len, "hh")) {
			int h = (int)((int)(((int)(t.hour + 11)) % 12) + 1);
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "i")) {
			int h = (t.hour > 12 ? ((int)(t.hour - 12)) : (t.hour));
			strings__Builder_write_string(&sb, builtin__int_str(h));
		}
		else if (_SLIT_EQ(token.str, token.len, "ii")) {
			int h = (t.hour > 12 ? ((int)(t.hour - 12)) : (t.hour));
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "m")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.minute));
		}
		else if (_SLIT_EQ(token.str, token.len, "mm")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "s")) {
			strings__Builder_write_string(&sb, builtin__int_str(t.second));
		}
		else if (_SLIT_EQ(token.str, token.len, "ss")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "k")) {
			strings__Builder_write_string(&sb, builtin__int_str(((int)(t.hour + 1))));
		}
		else if (_SLIT_EQ(token.str, token.len, "kk")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = ((int)(t.hour + 1))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "w")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x7, {.d_i32 = time__Time_week_of_year(t)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "ww")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x80040027, {.d_i32 = time__Time_week_of_year(t)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "wo")) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(time__Time_week_of_year(t)));
		}
		else if (_SLIT_EQ(token.str, token.len, "Q")) {
			{
				strings__Builder_write_decimal(&sb, (int)((int)(((int)(t.month - 1)) / 3) + 1));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "QQ")) {
			strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = (int)((int)(((int)(t.month - 1)) / 3) + 1)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(token.str, token.len, "Qo")) {
			strings__Builder_write_string(&sb, time__ordinal_suffix((int)((int)(((int)(t.month - 1)) / 3) + 1)));
		}
		else if (_SLIT_EQ(token.str, token.len, "c")) {
			{
				strings__Builder_write_decimal(&sb, time__Time_day_of_week(t));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "N")) {
			strings__Builder_write_string(&sb, _S("AD"));
		}
		else if (_SLIT_EQ(token.str, token.len, "NN")) {
			strings__Builder_write_string(&sb, _S("Anno Domini"));
		}
		else if (_SLIT_EQ(token.str, token.len, "Z")) {
			int hours = (int)(time__offset() / 3600);
			if (hours >= 0) {
				{
					strings__Builder_write_string(&sb, _S("+"));
					strings__Builder_write_decimal(&sb, hours);
				}
			} else {
				hours = -hours;
				{
					strings__Builder_write_string(&sb, _S("-"));
					strings__Builder_write_decimal(&sb, hours);
				}
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "ZZ")) {
			int hours = (int)(time__offset() / 3600);
			if (hours >= 0) {
				strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("+"), 0x8004fe27, {.d_i32 = hours}}, {_S("00"), 0, { .d_c = 0 }}})));
			} else {
				hours = -hours;
				strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-"), 0x8004fe27, {.d_i32 = hours}}, {_S("00"), 0, { .d_c = 0 }}})));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "ZZZ")) {
			int hours = (int)(time__offset() / 3600);
			if (hours >= 0) {
				strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("+"), 0x8004fe27, {.d_i32 = hours}}, {_S(":00"), 0, { .d_c = 0 }}})));
			} else {
				hours = -hours;
				strings__Builder_write_string(&sb, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-"), 0x8004fe27, {.d_i32 = hours}}, {_S(":00"), 0, { .d_c = 0 }}})));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "a")) {
			if (t.hour < 12) {
				strings__Builder_write_string(&sb, _S("am"));
			} else {
				strings__Builder_write_string(&sb, _S("pm"));
			}
		}
		else if (_SLIT_EQ(token.str, token.len, "A")) {
			if (t.hour < 12) {
				strings__Builder_write_string(&sb, _S("AM"));
			} else {
				strings__Builder_write_string(&sb, _S("PM"));
			}
		}
		else {
			strings__Builder_write_string(&sb, token);
		}
	}
	return strings__Builder_str(&sb);
}
string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
	}
	if (t.year == znow.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm24, time__FormatDate__mmmd);
	}
	return time__Time_format(t);
}
string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		return time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
	}
	if (t.year == znow.year) {
		return time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm12, time__FormatDate__mmmd);
	}
	return time__Time_format(t);
}
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime__no_time) {
		return _S("");
	}
	string tp = (t.hour > 11 ? (_S("p.m.")) : (_S("a.m.")));
	int hour_ = (t.hour > 12 ? ((int)(t.hour - 12)) : t.hour == 0 ? (12) : (t.hour));
	string _t3 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_time) {
		case time__FormatTime__hhmm12: {
			_t3 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmm24: {
			_t3 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmmss12: {
			_t3 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_S(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmmss24: {
			_t3 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmmss24_milli: {
			_t3 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_S("."), 0x8006fe27, {.d_i32 = ((int)(t.nanosecond / 1000000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmmss24_micro: {
			_t3 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_S("."), 0x800cfe27, {.d_i32 = ((int)(t.nanosecond / 1000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__hhmmss24_nano: {
			_t3 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_S("."), 0x800cfe27, {.d_i32 = t.nanosecond}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatTime__no_time:
		default: {
			{
				_t3 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown enumeration "), 0xfe10, {.d_s = time__FormatTime_str(fmt_time)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		}
	}
	return _t3;
}
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		return _S("");
	}
	string month = time__Time_smonth(t);
	string year = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = ((int)(t.year % 100))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_date) {
		case time__FormatDate__ddmmyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__ddmmyyyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmddyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmddyyyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmmd: {
			_t2 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_S("|"), 0xfe07, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmmdd: {
			_t2 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmmddyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__mmmddyyyy: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_S("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__yyyymmdd: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8008fe27, {.d_i32 = t.year}}, {_S("|"), 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__yymmdd: {
			_t2 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = year}}, {_S("|"), 0x8004fe27, {.d_i32 = t.month}}, {_S("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case time__FormatDate__no_date:
		default: {
			{
				_t2 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown enumeration "), 0xfe10, {.d_s = time__FormatDate_str(fmt_date)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		}
	}
	string res = _t2;
	string del = ((fmt_dlmtr == (time__FormatDelimiter__dot))? (_S(".")) : (fmt_dlmtr == (time__FormatDelimiter__hyphen))? (_S("-")) : (fmt_dlmtr == (time__FormatDelimiter__slash))? (_S("/")) : (fmt_dlmtr == (time__FormatDelimiter__space))? (_S(" ")) : (_S("")));
	res = builtin__string_replace(res, _S("|"), del);
	return res;
}
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		if (fmt_time == time__FormatTime__no_time) {
			return _S("");
		} else {
			return time__Time_get_fmt_time_str(t, fmt_time);
		}
	} else {
		if (fmt_time != time__FormatTime__no_time) {
			string dstr = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			string tstr = time__Time_get_fmt_time_str(t, fmt_time);
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dstr}}, {_S(" "), 0xfe10, {.d_s = tstr}}, {_SLIT0, 0, { .d_c = 0 }}}));
		} else {
			return time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	string utc_string = builtin__str_intp(8, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = day_str}}, {_S(", "), 0xfe07, {.d_i32 = t.day}}, {_S(" "), 0xfe10, {.d_s = month_str}}, {_S(" "), 0xfe07, {.d_i32 = t.year}}, {_S(" "), 0x8004fe27, {.d_i32 = t.hour}}, {_S(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_S(":"), 0x8004fe27, {.d_i32 = t.second}}, {_S(" UTC"), 0, { .d_c = 0 }}}));
	return utc_string;
}
string time__Time_http_header_string(time__Time t) {
	Array_u8 buf = builtin____new_array_with_default(0, 29, sizeof(u8), 0);
	time__Time_push_to_http_header(t, &buf);
	return Array_u8_bytestr(buf);
}
void time__Time_push_to_http_header(time__Time t, Array_u8* buffer) {
	string day_str = time__Time_weekday_str(t);
	string month_str = time__Time_smonth(t);
	Array_fixed_u8_29 buf = {builtin__string_at(day_str, 0), builtin__string_at(day_str, 1), builtin__string_at(day_str, 2), ',', ' ', '0', '0', ' ', builtin__string_at(month_str, 0), builtin__string_at(month_str, 1), builtin__string_at(month_str, 2), ' ', '0', '0', '0', '0', ' ', '0', '0', ':', '0', '0', ':', '0', '0', ' ', 'G', 'M', 'T'};
	{ // Unsafe block
		time__int_to_ptr_byte_array_no_pad(t.day, &buf[5], 2);
		time__int_to_ptr_byte_array_no_pad(t.year, &buf[12], 4);
		time__int_to_ptr_byte_array_no_pad(t.hour, &buf[17], 2);
		time__int_to_ptr_byte_array_no_pad(t.minute, &buf[20], 2);
		time__int_to_ptr_byte_array_no_pad(t.second, &buf[23], 2);
	}
	builtin__array_push_many(buffer, &buf[0], 29);
}
_result_void time__Time_from_json_number(time__Time* t, string raw_number) {
	*t = time__unix(builtin__string_i64(raw_number));
	return (_result_void){0};
}
_result_void time__Time_from_json_string(time__Time* t, string raw_string) {
	bool is_iso8601 = builtin__string_at(raw_string, 4) == '-' && builtin__string_at(raw_string, 7) == '-';
	if (is_iso8601) {
		_result_time__Time _t1 = time__parse_iso8601(raw_string);
		if (_t1.is_error) {
			_result_void _t2 = {0};
			_t2.is_error = true;
			_t2.err = _t1.err;
			return _t2;
		}
		
 		*t = (*(time__Time*)_t1.data);
		return (_result_void){0};
	}
	bool is_rfc3339 = raw_string.len == 24 && builtin__string_at(raw_string, 23) == 'Z' && builtin__string_at(raw_string, 10) == 'T';
	if (is_rfc3339) {
		_result_time__Time _t3 = time__parse_rfc3339(raw_string);
		if (_t3.is_error) {
			_result_void _t4 = {0};
			_t4.is_error = true;
			_t4.err = _t3.err;
			return _t4;
		}
		
 		*t = (*(time__Time*)_t3.data);
		return (_result_void){0};
	}
	bool is_unix_timestamp = true;
	for (int _t5 = 0; _t5 < raw_string.len; ++_t5) {
		u8 c = raw_string.str[_t5];
		if (c == '-' || (c >= '0' && c <= '9')) {
			continue;
		}
		is_unix_timestamp = false;
		break;
	}
	if (is_unix_timestamp) {
		*t = time__unix(builtin__string_i64(raw_string));
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Expected iso8601/rfc3339/unix time but got: "), 0xfe10, {.d_s = raw_string}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
string time__Time_to_json(time__Time t) {
	return builtin__string__plus(builtin__string__plus(_S("\""), time__Time_format_rfc3339(t)), _S("\""));
}
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	return t1.nanosecond == t2.nanosecond && t1.is_local == t2.is_local && time__Time_local_unix(t1) == time__Time_local_unix(t2);
}
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	i64 t1u = time__Time_unix(t1);
	i64 t2u = time__Time_unix(t2);
	return t1u < t2u || (t1u == t2u && t1.nanosecond < t2.nanosecond);
}
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	i64 unixs = ((i64)((i64)(time__Time_unix(lhs) - time__Time_unix(rhs)))) * _const_time__second;
	int nanos = (int)(lhs.nanosecond - rhs.nanosecond);
	return (i64)(unixs + nanos);
}
VV_LOC _result_void time__validate_time_bounds(int hour, int minute, int second, int nanosecond) {
	if (hour < 0 || hour > 23) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid hour: "), 0xfe07, {.d_i32 = hour}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (minute < 0 || minute > 59) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid minute: "), 0xfe07, {.d_i32 = minute}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (second < 0 || second > 59) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid second: "), 0xfe07, {.d_i32 = second}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (nanosecond < 0 || nanosecond > 1000000000) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid nanosecond: "), 0xfe07, {.d_i32 = nanosecond}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
VV_LOC _result_multi_return_int_int_int_int time__check_and_extract_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int nanosecond_ = 0;
	for (int i = 0; i < 8; i++) {
		if (_const_time__time_format_buffer[builtin__v_fixed_index(i, 8)] == ((u8)('0'))) {
			if (builtin__string_at(s, i) < ((u8)('0')) || builtin__string_at(s, i) > ((u8)('9'))) {
				return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("`HH:MM:SS` match error: expected digit, not `"), 0xfe02, {.d_u8 = builtin__string_at(s, i)}}, {_S("` in position "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			} else {
				if (i < 2) {
					hour_ = (int)((int)(hour_ * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				} else if (i < 5) {
					minute_ = (int)((int)(minute_ * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				} else {
					second_ = (int)((int)(second_ * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				}
			}
		} else if (_const_time__time_format_buffer[builtin__v_fixed_index(i, 8)] != builtin__string_at(s, i)) {
			return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("time separator error: expected `:`, not `"), 0xfe10, {.d_s = Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){builtin__string_at(s, i)})))}}, {_S("` in position "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	if (s.len == (int)(8 + 1)) {
		if (!(builtin__string_at(s, 8) == ((u8)('Z')) || builtin__string_at(s, 8) == 'z')) {
			return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(_S("timezone error: expected \"Z\" or \"z\" at the end of the string")), .data={E_STRUCT} };
		}
		_result_void _t4 = time__validate_time_bounds(hour_, minute_, second_, nanosecond_);
		if (_t4.is_error) {
			_result_multi_return_int_int_int_int _t5 = {0};
			_t5.is_error = true;
			_t5.err = _t4.err;
			return _t5;
		}
		
 ;
		_result_multi_return_int_int_int_int _t6;
		builtin___result_ok(&(multi_return_int_int_int_int[]) { (multi_return_int_int_int_int){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=nanosecond_} }, (_result*)(&_t6), sizeof(multi_return_int_int_int_int));
		return _t6;
	}
	if (s.len < (int)(8 + 1)) {
		return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(_S("datetime string is too short")), .data={E_STRUCT} };
	}
	if (builtin__string_at(s, 8) == ((u8)('.'))) {
		if (s.len < (int)(8 + 1)) {
			return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(_S("datetime string is too short")), .data={E_STRUCT} };
		}
		int nanosecond_digits = 0;
		for (int i = (int)(8 + 1); i < s.len; i++) {
			if (builtin__string_at(s, i) < ((u8)('0')) || builtin__string_at(s, i) > ((u8)('9'))) {
				if (builtin__string_at(s, i) == ((u8)('Z')) || builtin__string_at(s, i) == 'z') {
					if (i != (int)(s.len - 1)) {
						return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(_S("timezone error: \"Z\" or \"z\" can only be at the end of the string")), .data={E_STRUCT} };
					}
					break;
				} else if (builtin__string_at(s, i) == ((u8)('+')) || builtin__string_at(s, i) == '-') {
					break;
				}
				return (_result_multi_return_int_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("nanoseconds error: expected digit, not `"), 0xfe02, {.d_u8 = builtin__string_at(s, i)}}, {_S("` in position "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			if (!(i >= (int)((int)(8 + 1) + 9))) {
				nanosecond_ = (int)((int)(nanosecond_ * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				nanosecond_digits++;
			}
		}
		if (nanosecond_digits < 9) {
			for (int i = 0; i < (int)(9 - nanosecond_digits); i++) {
				nanosecond_ *= 10;
			}
		}
	}
	_result_void _t11 = time__validate_time_bounds(hour_, minute_, second_, nanosecond_);
	if (_t11.is_error) {
		_result_multi_return_int_int_int_int _t12 = {0};
		_t12.is_error = true;
		_t12.err = _t11.err;
		return _t12;
	}
	
 ;
	_result_multi_return_int_int_int_int _t13;
	builtin___result_ok(&(multi_return_int_int_int_int[]) { (multi_return_int_int_int_int){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=nanosecond_} }, (_result*)(&_t13), sizeof(multi_return_int_int_int_int));
	return _t13;
}
VV_LOC _result_multi_return_int_int_int time__check_and_extract_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	for (int i = 0; i < 10; i++) {
		if (_const_time__date_format_buffer[builtin__v_fixed_index(i, 10)] == ((u8)('0'))) {
			if (builtin__string_at(s, i) < ((u8)('0')) || builtin__string_at(s, i) > ((u8)('9'))) {
				return (_result_multi_return_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("`YYYY-MM-DD` match error: expected digit, not `"), 0xfe02, {.d_u8 = builtin__string_at(s, i)}}, {_S("` in position "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			} else {
				if (i < 4) {
					year = (int)((int)(year * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				} else if (i < 7) {
					month = (int)((int)(month * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				} else {
					day = (int)((int)(day * 10) + ((u8)(builtin__string_at(s, i) - ((u8)('0')))));
				}
			}
		} else if (_const_time__date_format_buffer[builtin__v_fixed_index(i, 10)] != builtin__string_at(s, i)) {
			return (_result_multi_return_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("date separator error:expected \""), 0xfe02, {.d_u8 = _const_time__date_format_buffer[builtin__v_fixed_index(i, 10)]}}, {_S("\", not `"), 0xfe02, {.d_u8 = builtin__string_at(s, i)}}, {_S("` in position "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	if (month < 1 || month > 12) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("date error: invalid month "), 0xfe07, {.d_i32 = month}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (day < 1 || day > 31) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("date error: invalid day "), 0xfe07, {.d_i32 = day}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_multi_return_int_int_int _t5;
	builtin___result_ok(&(multi_return_int_int_int[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (_result*)(&_t5), sizeof(multi_return_int_int_int));
	return _t5;
}
_result_time__Time time__parse_rfc3339(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("datetime string is empty")), .data={E_STRUCT} };
	}
	if (s.len < 8) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(_S("string is too short to parse")), .data={E_STRUCT} };
	}
	int year = 0;
	int month = 0;
	int day = 0;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int nanosecond_ = 0;
	bool is_time = (s.len >= 8 ? (builtin__string_at(s, 2) == ((u8)(':')) && builtin__string_at(s, 5) == ((u8)(':'))) : (false));
	if (is_time) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(_S("missing date part of RFC 3339")), .data={E_STRUCT} };
	}
	bool is_date = (s.len >= 10 ? (builtin__string_at(s, 4) == ((u8)('-')) && builtin__string_at(s, 7) == ((u8)('-'))) : (false));
	if (is_date) {
		_result_multi_return_int_int_int _t4 = time__check_and_extract_date(s);
		if (_t4.is_error) {
			_result_time__Time _t5 = {0};
			_t5.is_error = true;
			_t5.err = _t4.err;
			return _t5;
		}
		
 		multi_return_int_int_int mr_4783 = (*(multi_return_int_int_int*)_t4.data);
		year = mr_4783.arg0;
		month = mr_4783.arg1;
		day = mr_4783.arg2;
	}
	if (s.len <= 10) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(_S("date-time too short to parse")), .data={E_STRUCT} };
	}
	if (!(builtin__string_at(s, 10) == ((u8)('T')) || builtin__string_at(s, 10) == 't' || builtin__string_at(s, 10) == ' ')) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid date-time separator:"), 0xfe10, {.d_s = builtin__u8_ascii_str(builtin__string_at(s, 10))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	bool is_datetime = (s.len >= (int)((int)((int)(10 + 1) + 8) + 1) ? (is_date) : (false));
	if (is_datetime) {
		_result_multi_return_int_int_int_int _t8 = time__check_and_extract_time(builtin__string_substr(s, (int)(10 + 1), 2147483647));
		if (_t8.is_error) {
			_result_time__Time _t9 = {0};
			_t9.is_error = true;
			_t9.err = _t8.err;
			return _t9;
		}
		
 		multi_return_int_int_int_int mr_5236 = (*(multi_return_int_int_int_int*)_t8.data);
		hour_ = mr_5236.arg0;
		minute_ = mr_5236.arg1;
		second_ = mr_5236.arg2;
		nanosecond_ = mr_5236.arg3;
	}
	int timezone_start_position = 0;
	if (is_datetime || is_time) {
		timezone_start_position = (int)((int)(10 + 1) + 8);
		if (builtin__string_at(s, timezone_start_position) == ((u8)('.'))) {
			timezone_start_position++;
			for (;;) {
				if (!(!(builtin__string_at(s, timezone_start_position) == ((u8)('Z')) || builtin__string_at(s, timezone_start_position) == 'z' || builtin__string_at(s, timezone_start_position) == '+' || builtin__string_at(s, timezone_start_position) == '-'))) break;
				timezone_start_position++;
				if (timezone_start_position == s.len) {
					return (_result_time__Time){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("timezone error: expected \"Z\" or \"z\" or \"+\" or \"-\" in position "), 0xfe07, {.d_i32 = timezone_start_position}}, {_S(", not \""), 0xfe10, {.d_s = Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){builtin__string_at(s, (int)(s.len - 1))})))}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
				}
			}
		}
	}
	int pos = (int)((int)(10 + 8) + 1);
	if (pos >= s.len) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(_S("timezone error: datetime string is too short")), .data={E_STRUCT} };
	}
	if (!(builtin__string_at(s, (int)((int)(10 + 8) + 1)) == ((u8)('Z')) || builtin__string_at(s, (int)((int)(10 + 8) + 1)) == 'z' || builtin__string_at(s, (int)((int)(10 + 8) + 1)) == '+' || builtin__string_at(s, (int)((int)(10 + 8) + 1)) == '-' || builtin__string_at(s, (int)((int)(10 + 8) + 1)) == '.')) {
		return (_result_time__Time){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("timezone error: expected \"Z\" or \"z\" or \"+\" or \"-\" in position "), 0xfe07, {.d_i32 = (int)((int)(10 + 8) + 1)}}, {_S(", not \""), 0xfe10, {.d_s = Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){builtin__string_at(s, (int)((int)(10 + 8) + 1))})))}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	} else {
		if (builtin__string_at(s, (int)(s.len - 1)) == ((u8)('Z')) || builtin__string_at(s, (int)(s.len - 1)) == 'z') {
			_result_time__Time _t13;
			builtin___result_ok(&(time__Time[]) { time__new(((time__Time){
				.__v_unix = 0,
				.year = year,
				.month = month,
				.day = day,
				.hour = hour_,
				.minute = minute_,
				.second = second_,
				.nanosecond = nanosecond_,
				.is_local = false,
			})) }, (_result*)(&_t13), sizeof(time__Time));
			 
			return _t13;
		} else {
			if (s.len < (int)((int)((int)(10 + 1) + 8) + 6)) {
				return (_result_time__Time){ .is_error=true, .err=builtin___v_error(_S("datetime string is too short")), .data={E_STRUCT} };
			}
			if (builtin__string_at(s, (int)(s.len - 3)) != ((u8)(':'))) {
				return (_result_time__Time){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("timezone separator error: expected \":\", not `"), 0xfe10, {.d_s = Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){builtin__string_at(s, (int)((int)(10 + 8) + 3))})))}}, {_S("` in position "), 0xfe07, {.d_i32 = (int)((int)(10 + 8) + 3)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			if (builtin__vmemcmp(s.str + s.len - 5, "00:00", 5) == 0) {
				_result_time__Time _t16;
				builtin___result_ok(&(time__Time[]) { time__new(((time__Time){
					.__v_unix = 0,
					.year = year,
					.month = month,
					.day = day,
					.hour = hour_,
					.minute = minute_,
					.second = second_,
					.nanosecond = nanosecond_,
					.is_local = false,
				})) }, (_result*)(&_t16), sizeof(time__Time));
				 
				return _t16;
			}
			bool is_negative = builtin__string_at(s, (int)(s.len - 6)) == ((u8)('-'));
			int offset_in_minutes = 0;
			int offset_in_hours = 0;
			for (int i = 0; i < 2; i++) {
				offset_in_hours = (int)((int)(offset_in_hours * 10) + ((u8)(builtin__string_at(s, (int)((int)(s.len - 5) + i)) - ((u8)('0')))));
			}
			for (int i = 0; i < 2; i++) {
				offset_in_minutes = (int)((int)(offset_in_minutes * 10) + ((u8)(builtin__string_at(s, (int)((int)(s.len - 2) + i)) - ((u8)('0')))));
			}
			offset_in_minutes += (int)(offset_in_hours * 60);
			if (!is_negative) {
				offset_in_minutes *= -1;
			}
			time__Time time_to_be_returned = time__new(((time__Time){
				.__v_unix = 0,
				.year = year,
				.month = month,
				.day = day,
				.hour = hour_,
				.minute = minute_,
				.second = second_,
				.nanosecond = nanosecond_,
				.is_local = false,
			}));
			time_to_be_returned = time__Time_add_seconds(time_to_be_returned, (int)(offset_in_minutes * 60));
			_result_time__Time _t17;
			builtin___result_ok(&(time__Time[]) { time_to_be_returned }, (_result*)(&_t17), sizeof(time__Time));
			 
			return _t17;
		}
	}
	return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(9, _S("malformed date")), .data={E_STRUCT} };
}
_result_time__Time time__parse(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("datetime string is empty")), .data={E_STRUCT} };
	}
	_option_int _t2 = builtin__string_index(s, _S(" "));
	if (_t2.state != 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(1, _S("string has no space between date and time")), .data={E_STRUCT} };
	}
	
 	int pos = (*(int*)_t2.data);
	string symd = builtin__string_substr(s, 0, pos);
	Array_string ymd = builtin__string_split(symd, _S("-"));
	if (ymd.len != 3) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(2, _S("date must be in the form of y-m-d")), .data={E_STRUCT} };
	}
	string shms = builtin__string_substr(s, pos, 2147483647);
	Array_string hms = builtin__string_split(shms, _S(":"));
	if (hms.len != 3) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(9, _S("time must be in the form of H:i:s")), .data={E_STRUCT} };
	}
	string hour_ = builtin__string_substr((*(string*)builtin__array_get(hms, 0)), 1, 2147483647);
	string minute_ = (*(string*)builtin__array_get(hms, 1));
	string second_ = (*(string*)builtin__array_get(hms, 2));
	_result_int _t6 = strconv__atoi((*(string*)builtin__array_get(ymd, 0)));
	if (_t6.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid year format: "), 0xfe10, {.d_s = (*(string*)builtin__array_get(ymd, 0))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int iyear = (*(int*)_t6.data);
	_result_int _t8 = strconv__atoi((*(string*)builtin__array_get(ymd, 1)));
	if (_t8.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid month format: "), 0xfe10, {.d_s = (*(string*)builtin__array_get(ymd, 1))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int imonth = (*(int*)_t8.data);
	_result_int _t10 = strconv__atoi((*(string*)builtin__array_get(ymd, 2)));
	if (_t10.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid day format: "), 0xfe10, {.d_s = (*(string*)builtin__array_get(ymd, 2))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int iday = (*(int*)_t10.data);
	_result_int _t12 = strconv__atoi(hour_);
	if (_t12.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid hour format: "), 0xfe10, {.d_s = hour_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int ihour = (*(int*)_t12.data);
	_result_int _t14 = strconv__atoi(minute_);
	if (_t14.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid minute format: "), 0xfe10, {.d_s = minute_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int iminute = (*(int*)_t14.data);
	_result_int _t16 = strconv__atoi(second_);
	if (_t16.is_error) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid second format: "), 0xfe10, {.d_s = second_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int isecond = (*(int*)_t16.data);
	if (iyear > 9999 || iyear < -9999) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(3, _S("year must be between -10000 and 10000")), .data={E_STRUCT} };
	}
	if (imonth > 12 || imonth < 1) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(4, _S("month must be between 1 and 12")), .data={E_STRUCT} };
	}
	if (iday > 31 || iday < 1) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(5, _S("day must be between 1 and 31")), .data={E_STRUCT} };
	}
	if (ihour > 23 || ihour < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(6, _S("hours must be between 0 and 24")), .data={E_STRUCT} };
	}
	if (iminute > 59 || iminute < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(7, _S("minutes must be between 0 and 60")), .data={E_STRUCT} };
	}
	if (isecond > 59 || isecond < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(8, _S("seconds must be between 0 and 60")), .data={E_STRUCT} };
	}
	time__Time res = time__new(((time__Time){
		.__v_unix = 0,
		.year = iyear,
		.month = imonth,
		.day = iday,
		.hour = ihour,
		.minute = iminute,
		.second = isecond,
		.nanosecond = 0,
		.is_local = 0,
	}));
	_result_time__Time _t24;
	builtin___result_ok(&(time__Time[]) { res }, (_result*)(&_t24), sizeof(time__Time));
	 
	return _t24;
}
_result_time__Time time__parse_format(string s, string format) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("datetime string is empty")), .data={E_STRUCT} };
	}
	time__DateTimeParser p = time__new_date_time_parser(s, format);
	return time__DateTimeParser_parse(&p);
}
_result_time__Time time__parse_iso8601(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("datetime string is empty")), .data={E_STRUCT} };
	}
	int t_i = builtin__string_index_(s, _S("T"));
	Array_string parts = (t_i != -1 ? (builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){builtin__string_substr(s, 0, t_i), builtin__string_substr(s, (int)(t_i + 1), 2147483647)}))) : (builtin__string_split(s, _S(" "))));
	if (!(parts.len == 1 || parts.len == 2)) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(12, _S("malformed date")), .data={E_STRUCT} };
	}
	_result_multi_return_int_int_int _t3 = time__parse_iso8601_date((*(string*)builtin__array_get(parts, 0)));
	if (_t3.is_error) {
		_result_time__Time _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	multi_return_int_int_int mr_12466 = (*(multi_return_int_int_int*)_t3.data);
	int year = mr_12466.arg0;
	int month = mr_12466.arg1;
	int day = mr_12466.arg2;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	int nanosecond_ = 0;
	i64 unix_offset = ((i64)(0));
	bool is_local_time = true;
	if (parts.len == 2) {
		_result_multi_return_int_int_int_int_int_i64_bool _t5 = time__parse_iso8601_time((*(string*)builtin__array_get(parts, 1)));
		if (_t5.is_error) {
			_result_time__Time _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 		multi_return_int_int_int_int_int_i64_bool mr_12740 = (*(multi_return_int_int_int_int_int_i64_bool*)_t5.data);
		hour_ = mr_12740.arg0;
		minute_ = mr_12740.arg1;
		second_ = mr_12740.arg2;
		microsecond_ = mr_12740.arg3;
		nanosecond_ = mr_12740.arg4;
		unix_offset = mr_12740.arg5;
		is_local_time = mr_12740.arg6;
	}
	time__Time t = time__new(((time__Time){
		.__v_unix = 0,
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = nanosecond_,
		.is_local = 0,
	}));
	if (is_local_time) {
		_result_time__Time _t7;
		builtin___result_ok(&(time__Time[]) { t }, (_result*)(&_t7), sizeof(time__Time));
		 
		return _t7;
	}
	i64 unix_time = t.__v_unix;
	if (unix_offset < 0) {
		unix_time -= (-unix_offset);
	} else if (unix_offset > 0) {
		unix_time += unix_offset;
	}
	t = time__unix_nanosecond(((i64)(unix_time)), t.nanosecond);
	_result_time__Time _t8;
	builtin___result_ok(&(time__Time[]) { t }, (_result*)(&_t8), sizeof(time__Time));
	 
	return _t8;
}
_result_time__Time time__parse_rfc2822(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _S("datetime string is empty")), .data={E_STRUCT} };
	}
	Array_string fields = builtin__string_split(s, _S(" "));
	if (fields.len < 5) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(1, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("datetime string must have 5 components, has: "), 0xfe07, {.d_i32 = fields.len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_option_int _t3 = builtin__string_index(_const_time__months_string, (*(string*)builtin__array_get(fields, 2)));
	if (_t3.state != 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(2, _S("invalid month format")), .data={E_STRUCT} };
	}
	
 	int pos = (*(int*)_t3.data);
	int mm = (int)((int)(pos / 3) + 1);
	{ // Unsafe block
		u8* tmstr = builtin__malloc_noscan((int)(s.len * 2));
		i32 count = snprintf(((char*)(tmstr)), ((int)(s.len * 2)), "%s-%02d-%s %s", (*(string*)builtin__array_get(fields, 3)).str, mm, (*(string*)builtin__array_get(fields, 1)).str, (*(string*)builtin__array_get(fields, 4)).str);
		return time__parse(builtin__tos(tmstr, count));
	}
	return (_result_time__Time){0};
}
VV_LOC _result_multi_return_int_int_int time__parse_iso8601_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	u8 dummy = ((u8)(0));
	i32 count = sscanf(((char*)(s.str)), "%4d-%2d-%2d%c", &year, &month, &day, &dummy);
	if (count != 3) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(10, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("datetime string must have 3 components, but has "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (year > 9999) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(13, _S("year must be smaller than 10000")), .data={E_STRUCT} };
	}
	if (month > 12) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(14, _S("month must be smaller than 12")), .data={E_STRUCT} };
	}
	if (day > 31) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(15, _S("day must be smaller than 31")), .data={E_STRUCT} };
	}
	_result_multi_return_int_int_int _t5;
	builtin___result_ok(&(multi_return_int_int_int[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (_result*)(&_t5), sizeof(multi_return_int_int_int));
	return _t5;
}
VV_LOC _result_multi_return_int_int_int_int_int_i64_bool time__parse_iso8601_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	int nanosecond_ = 0;
	rune plus_min_z = 'a';
	int offset_hour = 0;
	int offset_minute = 0;
	int count = 0;
	count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%9d%c", &hour_, &minute_, &second_, &nanosecond_, ((char*)(&plus_min_z)));
	if (count == 5 && plus_min_z == 'Z') {
		int ndigits = 0;
		_option_int _t1;
		if (_t1 = builtin__string_index(s, _S(".")), _t1.state == 0) {
			int pos = *(int*)_t1.data;
			pos++;
			for (; pos < s.len && builtin__u8_is_digit(builtin__string_at(s, pos)); pos++) {
				ndigits++;
			}
		}
		for (;;) {
			if (!(ndigits < 9)) break;
			nanosecond_ *= 10;
			ndigits++;
		}
		microsecond_ = (int)(nanosecond_ / 1000);
	} else {
		count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%9d%c%2d:%2d", &hour_, &minute_, &second_, &microsecond_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
		if (count < 4) {
			count = sscanf(((char*)(s.str)), "%2d:%2d:%2d%c%2d:%2d", &hour_, &minute_, &second_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
			count++;
		}
		if (count < 4) {
			return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(10, _S("malformed date")), .data={E_STRUCT} };
		}
		nanosecond_ = (int)(microsecond_ * 1000);
	}
	bool is_local_time = plus_min_z == 'a' && count == 4;
	bool is_utc = plus_min_z == 'Z' && count == 5;
	if (!(count == 7 || is_local_time || is_utc)) {
		return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(11, _S("malformed date")), .data={E_STRUCT} };
	}
	if (plus_min_z != '+' && plus_min_z != '-' && !is_utc && !is_local_time) {
		return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(12, _S("missing timezone")), .data={E_STRUCT} };
	}
	int unix_offset = 0;
	if (offset_hour > 0) {
		unix_offset += (int)(3600 * offset_hour);
	}
	if (offset_minute > 0) {
		unix_offset += (int)(60 * offset_minute);
	}
	if (plus_min_z == '+') {
		unix_offset *= -1;
	}
	_result_multi_return_int_int_int_int_int_i64_bool _t5;
	builtin___result_ok(&(multi_return_int_int_int_int_int_i64_bool[]) { (multi_return_int_int_int_int_int_i64_bool){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=microsecond_, .arg4=nanosecond_, .arg5=unix_offset, .arg6=is_local_time} }, (_result*)(&_t5), sizeof(multi_return_int_int_int_int_int_i64_bool));
	return _t5;
}
string time__TimeParseError_msg(time__TimeParseError err) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Invalid time format code: "), 0xfe07, {.d_i32 = err.code}}, {_S(", error: "), 0xfe10, {.d_s = err.message}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
VV_LOC IError time__error_invalid_time(int code, string message) {
	return I_time__TimeParseError_to_Interface_IError(((time__TimeParseError*)builtin__memdup(&(time__TimeParseError){.Error = ((Error){E_STRUCT}),.code = code,.message = message,}, sizeof(time__TimeParseError))));
}
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	return ((time__StopWatch){.elapsed = 0,.start = initial,.end = 0,});
}
void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
}
void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0;
	t->elapsed = 0;
}
void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}
void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0) {
		if (t->end == 0) {
			t->elapsed += (u64)(time__sys_mono_now() - t->start);
		} else {
			t->elapsed += (u64)(t->end - t->start);
		}
	}
	t->start = 0;
}
time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0) {
		if (t.end == 0) {
			return ((((i64)((u64)((u64)(time__sys_mono_now() - t.start) + t.elapsed)))));
		} else {
			return ((((i64)((u64)((u64)(t.end - t.start) + t.elapsed)))));
		}
	}
	return ((((i64)(t.elapsed))));
}
time__Time time__now(void) {
	{
		return time__darwin_now();
	}
	return time__linux_now();
}
time__Time time__utc(void) {
	{
		return time__darwin_utc();
	}
	return time__linux_utc();
}
VV_LOC time__Time time__time_with_unix(time__Time t) {
	if (t.__v_unix != 0) {
		return t;
	}
	struct tm tt = ((struct tm){
		.tm_sec = t.second,
		.tm_min = t.minute,
		.tm_hour = t.hour,
		.tm_mday = t.day,
		.tm_mon = (int)(t.month - 1),
		.tm_year = (int)(t.year - 1900),
		.tm_wday = 0,
		.tm_yday = 0,
		.tm_isdst = 0,
		.tm_gmtoff = 0,
	});
	i64 utime = time__make_unix_time(tt);
	return ((time__Time){.__v_unix = utime,.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.is_local = (t).is_local,});
}
i64 time__ticks(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct timeval ts = ((struct timeval){.tv_sec = 0,.tv_usec = 0,});
		gettimeofday(&ts, 0);
		return ((i64)((u64)((u64)(ts.tv_sec * ((u64)(1000))) + ((u64)(ts.tv_usec / ((u64)(1000)))))));
	}
	#endif
	return 0;
}
string time__Time_str(time__Time t) {
	return time__Time_format_ss(t);
}
VV_LOC time__Time time__convert_ctime(struct tm t, int nanosecond) {
	return ((time__Time){
		.__v_unix = time__make_unix_time(t),
		.year = (int)(t.tm_year + 1900),
		.month = (int)(t.tm_mon + 1),
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.nanosecond = nanosecond,
		.is_local = true,
	});
}
string time__Time_strftime(time__Time t, string fmt) {
	struct tm* tm = ((struct tm*)builtin__memdup(&(struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,.tm_gmtoff = 0,}, sizeof(struct tm)));
	#if defined(_WIN32)
	{
	}
	#else
	{
		gmtime_r(((voidptr)(&t.__v_unix)), tm);
	}
	#endif
	Array_fixed_char_1024 buf = {0};
	char* fmt_c = ((char*)(fmt.str));
	strftime(&buf[0], ((usize)(sizeof(Array_fixed_char_1024))), fmt_c, tm);
	return builtin__cstring_to_vstring(((char*)(&buf[0])));
}
int time__Duration_sys_milliseconds(time__Duration d) {
	if (d > 2147483647 * _const_time__millisecond) {
		return -1;
	} else if (d <= 0) {
		return 0;
	} else {
		return ((int)(d / _const_time__millisecond));
	}
	return 0;
}
time__Time time__Time__static__new(time__Time t) {
	return time__time_with_unix(t);
}
time__Time time__new(time__Time t) {
	return time__time_with_unix(t);
}
string time__Time_smonth(time__Time t) {
	if (t.month <= 0 || t.month > 12) {
		return _S("---");
	}
	int i = (int)(t.month - 1);
	return builtin__string_substr(_const_time__months_string, (int)(i * 3), (int)(((int)(i + 1)) * 3));
}
inline i64 time__Time_unix(time__Time t) {
	return time__time_with_unix(time__Time_local_to_utc(t)).__v_unix;
}
inline i64 time__Time_local_unix(time__Time t) {
	return time__time_with_unix(t).__v_unix;
}
inline i64 time__Time_unix_milli(time__Time t) {
	return (i64)((i64)(time__Time_unix(t) * 1000) + ((i64)(((i64)(t.nanosecond)) / 1000000)));
}
inline i64 time__Time_unix_micro(time__Time t) {
	return (i64)((i64)(time__Time_unix(t) * 1000000) + ((i64)(((i64)(t.nanosecond)) / 1000)));
}
inline i64 time__Time_unix_nano(time__Time t) {
	return (i64)((i64)(time__Time_unix(t) * 1000000000) + ((i64)(t.nanosecond)));
}
time__Time time__Time_add(time__Time t, time__Duration duration_in_nanosecond) {
	i64 increased_time_nanosecond = (i64)(((i64)(t.nanosecond)) + time__Duration_nanoseconds(duration_in_nanosecond));
	i64 increased_time_second = (i64)(time__Time_local_unix(t) + (increased_time_nanosecond / _const_time__second));
	increased_time_nanosecond = increased_time_nanosecond % _const_time__second;
	if (increased_time_nanosecond < 0) {
		increased_time_second--;
		increased_time_nanosecond += _const_time__second;
	}
	time__Time res = time__unix_nanosecond(increased_time_second, ((int)(increased_time_nanosecond)));
	if (t.is_local) {
		return ((time__Time){.__v_unix = 0,.year = (res).year,.month = (res).month,.day = (res).day,.hour = (res).hour,.minute = (res).minute,.second = (res).second,.nanosecond = (res).nanosecond,.is_local = true,});
	}
	return res;
}
time__Time time__Time_add_seconds(time__Time t, int seconds) {
	return time__Time_add(time__time_with_unix(t), ((i64)(seconds)) * _const_time__second);
}
time__Time time__Time_add_days(time__Time t, int days) {
	return time__Time_add(time__time_with_unix(t), (i64)(((i64)(days)) * 24) * _const_time__hour);
}
time__Duration time__since(time__Time t) {
	return time__Time__minus(time__now(), t);
}
string time__Time_relative(time__Time t) {
	time__Time znow = time__now();
	i64 secs = (i64)(time__Time_unix(znow) - time__Time_unix(t));
	string prefix = _S("");
	string suffix = _S("");
	if (secs < 0) {
		secs *= -1;
		prefix = _S("in ");
	} else {
		suffix = _S(" ago");
	}
	if (secs < 30) {
		return _S("now");
	}
	if (secs < 3600) {
		i64 m = (i64)(secs / 60);
		if (m == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1 minute"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = m}}, {_S(" minutes"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (secs < 86400) {
		i64 h = (i64)(secs / 3600);
		if (h == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1 hour"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = h}}, {_S(" hours"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (secs < 604800) {
		i64 d = (i64)((i64)(secs / 3600) / 24);
		if (d == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1 day"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = d}}, {_S(" days"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (secs < 31536000) {
		if (_SLIT_EQ(prefix.str, prefix.len, "in ")) {
			return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("on "), 0xfe10, {.d_s = time__Time_md(t)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("last "), 0xfe10, {.d_s = time__Time_md(t)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	i64 y = (i64)((i64)((i64)(secs / 3600) / 24) / 365);
	if (y == 1) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1 year"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = y}}, {_S(" years"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string time__Time_relative_short(time__Time t) {
	time__Time znow = time__now();
	i64 secs = (i64)(time__Time_unix(znow) - time__Time_unix(t));
	string prefix = _S("");
	string suffix = _S("");
	if (secs < 0) {
		secs *= -1;
		prefix = _S("in ");
	} else {
		suffix = _S(" ago");
	}
	if (secs < 30) {
		return _S("now");
	}
	if (secs < 3600) {
		i64 m = (i64)(secs / 60);
		if (m == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1m"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = m}}, {_S("m"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (secs < 86400) {
		i64 h = (i64)(secs / 3600);
		if (h == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1h"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = h}}, {_S("h"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (secs < 31536000) {
		i64 d = (i64)((i64)(secs / 3600) / 24);
		if (d == 1) {
			return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1d"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = d}}, {_S("d"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	i64 y = (i64)((i64)((i64)(secs / 3600) / 24) / 365);
	if (y == 1) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S("1y"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_SLIT0, 0xfe09, {.d_i64 = y}}, {_S("y"), 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
int time__day_of_week(int y, int m, int d) {
	Array_int t = builtin__new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4,
			6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = (int)(sy - 1);
	}
	return (int)((int)(((int)((int)((int)((int)((int)((int)(sy + (int)(sy / 4)) - (int)(sy / 100)) + (int)(sy / 400)) + (*(int*)builtin__array_get(t, time__iclamp(0, (int)(m - 1), 11)))) + d) - 1)) % 7) + 1);
}
int time__Time_day_of_week(time__Time t) {
	return time__day_of_week(t.year, t.month, t.day);
}
int time__Time_week_of_year(time__Time t) {
	int day_of_week = time__Time_day_of_week(t);
	int days_to_thursday = (int)(4 - day_of_week);
	time__Time thursday_date = time__Time_add_days(t, days_to_thursday);
	int thursday_day_of_year = time__Time_year_day(thursday_date);
	int week_number = (int)((int)(((int)(thursday_day_of_year - 1)) / 7) + 1);
	return week_number;
}
int time__Time_year_day(time__Time t) {
	int yday = (int)(t.day + _const_time__days_before[builtin__v_fixed_index(time__iclamp(0, (int)(t.month - 1), 12), 13)]);
	if (time__is_leap_year(t.year) && t.month > 2) {
		return (int)(yday + 1);
	}
	return yday;
}
string time__Time_weekday_str(time__Time t) {
	int i = (int)(time__Time_day_of_week(t) - 1);
	return builtin__string_substr(_const_time__long_days[builtin__v_fixed_index(time__iclamp(0, i, 6), 7)], 0, 3);
}
string time__Time_long_weekday_str(time__Time t) {
	int i = (int)(time__Time_day_of_week(t) - 1);
	return _const_time__long_days[builtin__v_fixed_index(time__iclamp(0, i, 6), 7)];
}
bool time__is_leap_year(int year) {
	return (int)(year % 4) == 0 && ((int)(year % 100) != 0 || (int)(year % 400) == 0);
}
_result_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Invalid month: "), 0xfe07, {.d_i32 = month}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (int)(_const_time__month_days[builtin__v_fixed_index((int)(month - 1), 12)] + extra);
	_result_int _t2;
	builtin___result_ok(&(int[]) { res }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
string time__Time_debug(time__Time t) {
	return builtin__str_intp(10, _MOV((StrIntpData[]){{_S("Time{ year: "), 0x8008fe27, {.d_i32 = t.year}}, {_S(" month: "), 0x8004fe27, {.d_i32 = t.month}}, {_S(" day: "), 0x8004fe27, {.d_i32 = t.day}}, {_S(" hour: "), 0x8004fe27, {.d_i32 = t.hour}}, {_S(" minute: "), 0x8004fe27, {.d_i32 = t.minute}}, {_S(" second: "), 0x8004fe27, {.d_i32 = t.second}}, {_S(" nanosecond: "), 0x8012fe27, {.d_i32 = t.nanosecond}}, {_S(" unix: "), 0x800efe29, {.d_i64 = t.__v_unix}}, {_S(" is_local: "), 0xfe10, {.d_s = t.is_local ? _S("true") : _S("false")}}, {_S(" }"), 0, { .d_c = 0 }}}));
}
int time__offset(void) {
	time__Time t = time__utc();
	time__Time local = time__Time_local(t);
	return ((int)((i64)(local.__v_unix - t.__v_unix)));
}
time__Time time__Time_local_to_utc(time__Time t) {
	if (!t.is_local) {
		return t;
	}
	time__Time _t3 = time__Time_add(t, ((i64)(-time__offset())) * _const_time__second);
	return ((time__Time){.__v_unix = _t3.__v_unix,.year = _t3.year,.month = _t3.month,.day = _t3.day,.hour = _t3.hour,.minute = _t3.minute,.second = _t3.second,.nanosecond = _t3.nanosecond,.is_local = false,});
}
time__Time time__Time_utc_to_local(time__Time u) {
	if (u.is_local) {
		return u;
	}
	time__Time _t3 = time__Time_add(u, ((i64)(time__offset())) * _const_time__second);
	return ((time__Time){.__v_unix = _t3.__v_unix,.year = _t3.year,.month = _t3.month,.day = _t3.day,.hour = _t3.hour,.minute = _t3.minute,.second = _t3.second,.nanosecond = _t3.nanosecond,.is_local = true,});
}
time__Time time__Time_as_local(time__Time t) {
	return ((time__Time){.__v_unix = (t).__v_unix,.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.is_local = true,});
}
time__Time time__Time_as_utc(time__Time t) {
	return ((time__Time){.__v_unix = (t).__v_unix,.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.is_local = false,});
}
bool time__Time_is_utc(time__Time t) {
	return !t.is_local;
}
VV_LOC mach_timebase_info_data_t time__init_time_base(void) {
	mach_timebase_info_data_t tb = ((mach_timebase_info_data_t){.numer = 0,.denom = 0,});
	mach_timebase_info(&tb);
	return ((mach_timebase_info_data_t){.numer = tb.numer,.denom = tb.denom,});
}
VV_LOC u64 time__sys_mono_now_darwin(void) {
	u64 tm = mach_absolute_time();
	if (_const_time__time_base.denom == 0) {
		mach_timebase_info(&_const_time__time_base);
	}
	return (u64)((u64)(((u64)(tm - _const_time__start_time)) * _const_time__time_base.numer) / _const_time__time_base.denom);
}
VV_LOC time__Time time__darwin_now(void) {
	i64 epoch_ns = ((i64)(clock_gettime_nsec_np(CLOCK_REALTIME)));
	i64 sec = (i64)(epoch_ns / ((i64)(_const_time__second)));
	int nsec = ((int)((i64)(epoch_ns % ((i64)(_const_time__second)))));
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,.tm_gmtoff = 0,});
	localtime_r(((voidptr)(&sec)), &loc_tm);
	return time__convert_ctime(loc_tm, nsec);
}
VV_LOC time__Time time__darwin_utc(void) {
	i64 epoch_ns = ((i64)(clock_gettime_nsec_np(CLOCK_REALTIME)));
	i64 sec = (i64)(epoch_ns / ((i64)(_const_time__second)));
	int nsec = ((int)((i64)(epoch_ns % ((i64)(_const_time__second)))));
	return time__unix_nanosecond(sec, nsec);
}
VV_LOC i64 time__make_unix_time(struct tm t) {
	return ((i64)(timegm(&t)));
}
time__Time time__Time_local(time__Time t) {
	if (t.is_local) {
		return t;
	}
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,.tm_gmtoff = 0,});
	i64 t_ = time__Time_unix(t);
	localtime_r(((voidptr)(&t_)), &loc_tm);
	return time__convert_ctime(loc_tm, t.nanosecond);
}
u64 time__sys_mono_now(void) {
	#if defined(__APPLE__)
	{
		return time__sys_mono_now_darwin();
	}
	#else
	{
	}
	#endif
	return 0;
}
VV_LOC time__Time time__linux_now(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,.tm_gmtoff = 0,});
	localtime_r(((voidptr)(&ts.tv_sec)), &loc_tm);
	return time__convert_ctime(loc_tm, ((int)(ts.tv_nsec)));
}
VV_LOC time__Time time__linux_utc(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	return time__unix_nanosecond(((i64)(ts.tv_sec)), ((int)(ts.tv_nsec)));
}
struct timespec time__Duration_timespec(time__Duration d) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	time__Duration d_sec = d / _const_time__second;
	time__Duration d_nsec = d % _const_time__second;
	ts.tv_sec += d_sec;
	ts.tv_nsec += d_nsec;
	if (ts.tv_nsec > ((i64)(_const_time__second))) {
		ts.tv_nsec -= ((i64)(_const_time__second));
		ts.tv_sec++;
	}
	return ts;
}
void time__sleep(time__Duration duration) {
	struct timespec req = ((struct timespec){.tv_sec = duration / _const_time__second,.tv_nsec = duration % _const_time__second,});
	struct timespec rem = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	for (;;) {
		if (!(nanosleep(&req, &rem) < 0)) break;
		if (errno == EINTR) {
			req = rem;
		} else {
			break;
		}
	}
}
time__Time time__unix(i64 epoch) {
	return time__unix_nanosecond(epoch, 0);
}
time__Time time__unix_milli(i64 ms) {
	return time__ts_to_time_impl(ms, 1000, 1000000);
}
time__Time time__unix_micro(i64 us) {
	return time__ts_to_time_impl(us, 1000000, 1000);
}
time__Time time__unix_nano(i64 ns) {
	return time__ts_to_time_impl(ns, 1000000000, 1);
}
VV_LOC time__Time time__ts_to_time_impl(i64 value, i64 down, i64 up) {
	i64 epoch = (i64)(value / down);
	i64 remainder = (i64)(((i64)(value % down)) * up);
	return time__unix_nanosecond(epoch, ((int)(remainder)));
}
time__Time time__unix_microsecond(i64 epoch, int microsecond) {
	return time__unix_nanosecond(epoch, (int)(microsecond * 1000));
}
time__Time time__unix_nanosecond(i64 abs_unix_timestamp, int nanosecond) {
	i64 day_offset = (i64)(abs_unix_timestamp / 86400);
	if ((i64)(abs_unix_timestamp % 86400) < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1698 = time__calculate_date_from_day_offset(day_offset);
	int year = mr_1698.arg0;
	int month = mr_1698.arg1;
	int day = mr_1698.arg2;
	multi_return_int_int_int mr_1769 = time__calculate_time_from_second_offset((i64)(abs_unix_timestamp % 86400));
	int hour_ = mr_1769.arg0;
	int minute_ = mr_1769.arg1;
	int second_ = mr_1769.arg2;
	return ((time__Time){
		.__v_unix = abs_unix_timestamp,
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = nanosecond,
		.is_local = 0,
	});
}
VV_LOC multi_return_int_int_int time__calculate_date_from_day_offset(i64 day_offset_) {
	i64 day_offset = day_offset_;
	day_offset += 719468;
	int era = 0;
	if (day_offset >= 0) {
		era = ((int)((i64)(day_offset / 146097)));
	} else {
		era = ((int)((i64)(((i64)((i64)(day_offset - 146097) - 1)) / 146097)));
	}
	i64 day_of_era = (i64)(day_offset - (int)(era * 146097));
	i64 year_of_era = (i64)(((i64)((i64)((i64)(day_of_era - (i64)(day_of_era / 1460)) + (i64)(day_of_era / 36524)) - (i64)(day_of_era / 146096))) / 365);
	int year = ((int)((i64)(year_of_era + (int)(era * 400))));
	i64 day_of_year = (i64)(day_of_era - ((i64)((i64)((i64)(365 * year_of_era) + (i64)(year_of_era / 4)) - (i64)(year_of_era / 100))));
	i64 month_position = (i64)(((i64)((i64)(5 * day_of_year) + 2)) / 153);
	int day = ((int)((i64)((i64)(day_of_year - (i64)(((i64)((i64)(153 * month_position) + 2)) / 5)) + 1)));
	int month = ((int)(month_position));
	if (month_position < 10) {
		month += 3;
	} else {
		month -= 9;
	}
	if (month <= 2) {
		year += 1;
	}
	return (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day};
}
VV_LOC multi_return_int_int_int time__calculate_time_from_second_offset(i64 second_offset_) {
	i64 second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	i64 hour_ = (i64)(second_offset / 3600);
	second_offset %= _const_time__seconds_per_hour;
	i64 minute_ = (i64)(second_offset / 60);
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=((int)(hour_)), .arg1=((int)(minute_)), .arg2=((int)(second_offset))};
}
inline u64 hash__wyhash_c(u8* key, u64 len, u64 seed) {
	return wyhash(key, len, seed, ((u64*)(((voidptr)(_wyp)))));
}
inline u64 hash__wyhash64_c(u64 a, u64 b) {
	return wyhash64(a, b);
}
inline u64 hash__sum64_string(string key, u64 seed) {
	return hash__wyhash_c(key.str, ((u64)(key.len)), seed);
}
inline u64 hash__sum64(Array_u8 key, u64 seed) {
	return hash__wyhash_c(((u8*)(key.data)), ((u64)(key.len)), seed);
}
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = (a >> 32);
	u64 y0 = (b & mask32);
	u64 y1 = (b >> 32);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32)));
	u64 w1 = (t & mask32);
	u64 w2 = (t >> 32);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32)));
	u64 lo = (u64)(a * b);
	return (hi ^ lo);
}
VV_LOC string flag__UnknownFlagError_msg(flag__UnknownFlagError err) {
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Unknown flag `"), 0xfe10, {.d_s = err.flag}}, {_S("`"), 0, { .d_c = 0 }}}));
}
VV_LOC string flag__ArgsCountError_msg(flag__ArgsCountError err) {
	if (err.want == 0) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Expected no arguments, but got "), 0xfe07, {.d_i32 = err.got}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if (err.got > err.want) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Expected at most "), 0xfe07, {.d_i32 = err.want}}, {_S(" arguments, but got "), 0xfe07, {.d_i32 = err.got}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Expected at least "), 0xfe07, {.d_i32 = err.want}}, {_S(" arguments, but got "), 0xfe07, {.d_i32 = err.got}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC void flag__Flag_free(flag__Flag* f) {
	{ // Unsafe block
		builtin__string_free(&f->name);
		builtin__string_free(&f->usage);
		builtin__string_free(&f->val_desc);
	}
}
string flag__Flag_str(flag__Flag f) {
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("    flag:\n            name: "), 0xfe10, {.d_s = f.name}}, {_S("\n            abbr: `"), 0xfe10, {.d_s = builtin__u8_ascii_str(f.abbr)}}, {_S("`\n            usage: "), 0xfe10, {.d_s = f.usage}}, {_S("\n            desc: "), 0xfe10, {.d_s = f.val_desc}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string Array_flag__Flag_str(Array_flag__Flag af) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__array_push((array*)&res, _MOV((string[]){ _S("\n  []Flag = [") }));
	for (int _t2 = 0; _t2 < af.len; ++_t2) {
		flag__Flag f = ((flag__Flag*)af.data)[_t2];
		builtin__array_push((array*)&res, _MOV((string[]){ flag__Flag_str(f) }));
	}
	builtin__array_push((array*)&res, _MOV((string[]){ _S("  ]") }));
	return Array_string_join(res, _S("\n"));
}
VV_LOC void flag__FlagParser_free(flag__FlagParser* f) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < f->flags.len; ++_t1) {
			flag__Flag flag = ((flag__Flag*)f->flags.data)[_t1];
			flag__Flag_free(&flag);
		}
		builtin__array_free(&f->flags);
		builtin__string_free(&f->application_name);
		builtin__string_free(&f->application_version);
		builtin__string_free(&f->application_description);
		builtin__string_free(&f->args_description);
	}
}
flag__FlagParser* flag__new_flag_parser(Array_string args) {
	Array_string original_args = builtin__array_clone_to_depth(&args, 1);
	int idx_dashdash = Array_string_index(args, _S("--"));
	Array_string all_before_dashdash = builtin__array_clone_to_depth(&args, 1);
	Array_string all_after_dashdash = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (idx_dashdash >= 0) {
		builtin__array_trim(&all_before_dashdash, idx_dashdash);
		if (idx_dashdash < original_args.len) {
			all_after_dashdash = builtin__array_slice(original_args, (int)(idx_dashdash + 1), 2147483647);
		}
	}
	return ((flag__FlagParser*)builtin__memdup(&(flag__FlagParser){.original_args = original_args,.idx_dashdash = idx_dashdash,.all_after_dashdash = all_after_dashdash,.usage_examples = builtin____new_array(0, 0, sizeof(string)),.default_help_label = _S("display this help and exit"),.default_version_label = _S("output version information and exit"),.args = all_before_dashdash,.max_free_args = _const_flag__max_args_number,.flags = builtin____new_array(0, 0, sizeof(flag__Flag)),.application_name = (string){.str=(byteptr)"", .is_lit=1},.application_version = (string){.str=(byteptr)"", .is_lit=1},.application_description = (string){.str=(byteptr)"", .is_lit=1},.min_free_args = 0,.args_description = (string){.str=(byteptr)"", .is_lit=1},.allow_unknown_args = 0,.footers = builtin____new_array(0, 0, sizeof(string)),}, sizeof(flag__FlagParser)));
}
void flag__FlagParser_usage_example(flag__FlagParser* fs, string example) {
	builtin__array_push((array*)&fs->usage_examples, _MOV((string[]){ builtin__string_clone(example) }));
}
void flag__FlagParser_footer(flag__FlagParser* fs, string footer) {
	builtin__array_push((array*)&fs->footers, _MOV((string[]){ builtin__string_clone(footer) }));
}
void flag__FlagParser_application(flag__FlagParser* fs, string name) {
	fs->application_name = name;
}
void flag__FlagParser_version(flag__FlagParser* fs, string vers) {
	fs->application_version = vers;
}
void flag__FlagParser_description(flag__FlagParser* fs, string desc) {
	if (fs->application_description.len == 0) {
		fs->application_description = desc;
	} else {
		fs->application_description = builtin__string__plus(fs->application_description, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = desc}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}
void flag__FlagParser_skip_executable(flag__FlagParser* fs) {
	builtin__array_delete(&fs->args, 0);
}
void flag__FlagParser_allow_unknown_args(flag__FlagParser* fs) {
	fs->allow_unknown_args = true;
}
VV_LOC void flag__FlagParser_add_flag(flag__FlagParser* fs, string name, u8 abbr, string usage, string desc) {
	builtin__array_push((array*)&fs->flags, _MOV((flag__Flag[]){ ((flag__Flag){.name = name,.abbr = abbr,.usage = usage,.val_desc = desc,}) }));
}
VV_LOC Array_string flag__FlagParser_parse_value(flag__FlagParser* fs, string longhand, u8 shorthand) {
	string full = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("--"), 0xfe10, {.d_s = longhand}}, {_SLIT0, 0, { .d_c = 0 }}}));
	Array_string found_entries = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_int to_delete = builtin____new_array_with_default(0, 0, sizeof(int), 0);
	bool should_skip_one = false;
	for (int i = 0; i < fs->args.len; ++i) {
		string arg = ((string*)fs->args.data)[i];
		if (should_skip_one) {
			should_skip_one = false;
			continue;
		}
		if (arg.len == 0 || builtin__string_at(arg, 0) != '-') {
			continue;
		}
		if ((arg.len == 2 && builtin__string_at(arg, 0) == '-' && builtin__string_at(arg, 1) == shorthand) || builtin__string__eq(arg, full)) {
			if ((int)(i + 1) >= fs->args.len) {
				Array_string _t1 = builtin____new_array_with_default(0, 0, sizeof(string), 0);
					{ // defer begin
						builtin__array_free(&to_delete);
					} // defer end
					{ // defer begin
						builtin__string_free(&full);
					} // defer end
				return _t1;
			}
			string nextarg = (*(string*)builtin__array_get(fs->args, (int)(i + 1)));
			if (nextarg.len > 2) {
				string nextarg_rest = builtin__string_substr(nextarg, 0, 2);
				if (_SLIT_EQ(nextarg_rest.str, nextarg_rest.len, "--")) {
					builtin__string_free(&nextarg_rest);
					Array_string _t2 = builtin____new_array_with_default(0, 0, sizeof(string), 0);
						{ // defer begin
							builtin__array_free(&to_delete);
						} // defer end
						{ // defer begin
							builtin__string_free(&full);
						} // defer end
					return _t2;
				}
				builtin__string_free(&nextarg_rest);
			}
			builtin__array_push((array*)&found_entries, _MOV((string[]){ (*(string*)builtin__array_get(fs->args, (int)(i + 1))) }));
			builtin__array_push((array*)&to_delete, _MOV((int[]){ i }));
			builtin__array_push((array*)&to_delete, _MOV((int[]){ (int)(i + 1) }));
			should_skip_one = true;
			continue;
		}
		if (arg.len > (int)(full.len + 1) && builtin__string__eq(builtin__string_substr(arg, 0, (int)(full.len + 1)), builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = full}}, {_S("="), 0, { .d_c = 0 }}})))) {
			builtin__array_push((array*)&found_entries, _MOV((string[]){ builtin__string_substr(arg, (int)(full.len + 1), 2147483647) }));
			builtin__array_push((array*)&to_delete, _MOV((int[]){ i }));
			continue;
		}
	}
	for (int i = 0; i < to_delete.len; ++i) {
		int del = ((int*)to_delete.data)[i];
		builtin__array_delete(&fs->args, (int)(del - i));
	}
	Array_string _t8 = found_entries;
		{ // defer begin
			builtin__array_free(&to_delete);
		} // defer end
		{ // defer begin
			builtin__string_free(&full);
		} // defer end
	return _t8;
}
VV_LOC _result_string flag__FlagParser_parse_bool_value(flag__FlagParser* fs, string longhand, u8 shorthand) {
	string full = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("--"), 0xfe10, {.d_s = longhand}}, {_SLIT0, 0, { .d_c = 0 }}}));
	for (int i = 0; i < fs->args.len; ++i) {
		string arg = ((string*)fs->args.data)[i];
		if (arg.len == 0) {
			continue;
		}
		if (builtin__string_at(arg, 0) != '-') {
			continue;
		}
		if ((arg.len == 2 && builtin__string_at(arg, 0) == '-' && builtin__string_at(arg, 1) == shorthand) || builtin__string__eq(arg, full)) {
			if (fs->args.len > (int)(i + 1) && (builtin__fast_string_eq((*(string*)builtin__array_get(fs->args, (int)(i + 1))), _S("true")) || builtin__fast_string_eq((*(string*)builtin__array_get(fs->args, (int)(i + 1))), _S("false")))) {
				string val = (*(string*)builtin__array_get(fs->args, (int)(i + 1)));
				builtin__array_delete(&fs->args, (int)(i + 1));
				builtin__array_delete(&fs->args, i);
				_result_string _t1;
				builtin___result_ok(&(string[]) { val }, (_result*)(&_t1), sizeof(string));
				 
				return _t1;
			} else {
				builtin__array_delete(&fs->args, i);
				_result_string _t2;
				builtin___result_ok(&(string[]) { _S("true") }, (_result*)(&_t2), sizeof(string));
				 
				return _t2;
			}
		}
		if (arg.len > (int)(full.len + 1) && builtin__string__eq(builtin__string_substr(arg, 0, (int)(full.len + 1)), builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = full}}, {_S("="), 0, { .d_c = 0 }}})))) {
			string val = builtin__string_substr(arg, (int)(full.len + 1), 2147483647);
			builtin__array_delete(&fs->args, i);
			_result_string _t3;
			builtin___result_ok(&(string[]) { val }, (_result*)(&_t3), sizeof(string));
			 
			return _t3;
		}
		if (arg.len > 1 && builtin__string_at(arg, 0) == '-' && builtin__string_at(arg, 1) != '-') {
			bool found = false;
			for (int j = 1; j < arg.len; ++j) {
				if (builtin__u8_is_space(builtin__string_at(arg, j))) {
					break;
				} else if (builtin__string_at(arg, j) == shorthand) {
					found = true;
				}
			}
			if (found) {
				builtin__array_set(&fs->args, i, &(string[]) { builtin__string_replace(arg, builtin__u8_ascii_str(shorthand), _S("")) });
				_result_string _t4;
				builtin___result_ok(&(string[]) { _S("true") }, (_result*)(&_t4), sizeof(string));
				 
				return _t4;
			}
		}
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter '"), 0xfe10, {.d_s = longhand}}, {_S("' not found"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
_result_bool flag__FlagParser_bool_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<bool>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	_result_string _t1 = flag__FlagParser_parse_bool_value(fs, name, abbr);
	if (_t1.is_error) {
		return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter '"), 0xfe10, {.d_s = name}}, {_S("' not provided"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	string parsed = (*(string*)_t1.data);
	_result_bool _t3;
	builtin___result_ok(&(bool[]) { _SLIT_EQ(parsed.str, parsed.len, "true") }, (_result*)(&_t3), sizeof(bool));
	 
	return _t3;
}
bool flag__FlagParser_bool(flag__FlagParser* fs, string name, u8 abbr, bool bdefault, string usage, flag__FlagConfig c) {
	_result_bool _t1 = flag__FlagParser_bool_opt(fs, name, abbr, usage, c);
	if (_t1.is_error) {
		return bdefault;
	}
	
 	bool value = (*(bool*)_t1.data);
	return value;
}
Array_int flag__FlagParser_int_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<multiple ints>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_int value = builtin____new_array_with_default(0, 0, sizeof(int), 0);
	for (int _t1 = 0; _t1 < parsed.len; ++_t1) {
		string val = ((string*)parsed.data)[_t1];
		builtin__array_push((array*)&value, _MOV((int[]){ builtin__string_int(val) }));
	}
	return value;
}
_result_int flag__FlagParser_int_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<int>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter '"), 0xfe10, {.d_s = name}}, {_S("' not provided"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	string parsed0 = (*(string*)builtin__array_get(parsed, 0));
	_result_int _t2;
	builtin___result_ok(&(int[]) { builtin__string_int(parsed0) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
int flag__FlagParser_int(flag__FlagParser* fs, string name, u8 abbr, int idefault, string usage, flag__FlagConfig c) {
	_result_int _t1 = flag__FlagParser_int_opt(fs, name, abbr, usage, c);
	if (_t1.is_error) {
		return idefault;
	}
	
 	int value = (*(int*)_t1.data);
	return value;
}
Array_f64 flag__FlagParser_float_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<multiple floats>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	Array_f64 value = builtin____new_array_with_default(0, 0, sizeof(f64), 0);
	for (int _t1 = 0; _t1 < parsed.len; ++_t1) {
		string val = ((string*)parsed.data)[_t1];
		builtin__array_push((array*)&value, _MOV((f64[]){ builtin__string_f64(val) }));
	}
	return value;
}
_result_f64 flag__FlagParser_float_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<float>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		return (_result_f64){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter '"), 0xfe10, {.d_s = name}}, {_S("' not provided"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_f64 _t2;
	builtin___result_ok(&(f64[]) { builtin__string_f64((*(string*)builtin__array_get(parsed, 0))) }, (_result*)(&_t2), sizeof(f64));
	 
	return _t2;
}
f64 flag__FlagParser_float(flag__FlagParser* fs, string name, u8 abbr, f64 fdefault, string usage, flag__FlagConfig c) {
	_result_f64 _t1 = flag__FlagParser_float_opt(fs, name, abbr, usage, c);
	if (_t1.is_error) {
		return fdefault;
	}
	
 	f64 value = (*(f64*)_t1.data);
	return value;
}
Array_string flag__FlagParser_string_multi(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<multiple strings>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	return flag__FlagParser_parse_value(fs, name, abbr);
}
_result_string flag__FlagParser_string_opt(flag__FlagParser* fs, string name, u8 abbr, string usage, flag__FlagConfig c) {
	string val_desc = ((c.val_desc).len == 0 ? (_S("<string>")) : (c.val_desc));
	flag__FlagParser_add_flag(fs, name, abbr, usage, val_desc);
	Array_string parsed = flag__FlagParser_parse_value(fs, name, abbr);
	if (parsed.len == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter '"), 0xfe10, {.d_s = name}}, {_S("' not provided"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_string _t2;
	builtin___result_ok(&(string[]) { (*(string*)builtin__array_get(parsed, 0)) }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
string flag__FlagParser_string(flag__FlagParser* fs, string name, u8 abbr, string sdefault, string usage, flag__FlagConfig c) {
	_result_string _t1 = flag__FlagParser_string_opt(fs, name, abbr, usage, c);
	if (_t1.is_error) {
		return sdefault;
	}
	
 	string value = (*(string*)_t1.data);
	return value;
}
_result_void flag__FlagParser_limit_free_args_to_at_least(flag__FlagParser* fs, int n) {
	if (n > 4048) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("flag.limit_free_args_to_at_least expect n to be smaller than "), 0xfe07, {.d_i32 = _const_flag__max_args_number}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (n <= 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("flag.limit_free_args_to_at_least expect n to be a positive number")), .data={E_STRUCT} };
	}
	fs->min_free_args = n;
	return (_result_void){0};
}
_result_void flag__FlagParser_limit_free_args_to_exactly(flag__FlagParser* fs, int n) {
	if (n > 4048) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("flag.limit_free_args_to_exactly expect n to be smaller than "), 0xfe07, {.d_i32 = _const_flag__max_args_number}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (n < 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("flag.limit_free_args_to_exactly expect n to be a non negative number")), .data={E_STRUCT} };
	}
	fs->min_free_args = n;
	fs->max_free_args = n;
	return (_result_void){0};
}
_result_void flag__FlagParser_limit_free_args(flag__FlagParser* fs, int min, int max) {
	if (min > max) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("flag.limit_free_args expect min < max, got "), 0xfe07, {.d_i32 = min}}, {_S(" >= "), 0xfe07, {.d_i32 = max}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	fs->min_free_args = min;
	fs->max_free_args = max;
	return (_result_void){0};
}
void flag__FlagParser_arguments_description(flag__FlagParser* fs, string description) {
	fs->args_description = description;
}
string flag__FlagParser_usage(flag__FlagParser* fs) {
	bool positive_min_arg = (fs->min_free_args > 0);
	bool positive_max_arg = (fs->max_free_args > 0 && fs->max_free_args != 4048);
	bool no_arguments = (fs->min_free_args == 0 && fs->max_free_args == 0);
	string adesc = (fs->args_description.len > 0 ? (fs->args_description) : (_S("[ARGS]")));
	if (no_arguments) {
		adesc = _S("");
	}
	Array_string use = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if ((fs->application_version).len != 0) {
		builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fs->application_name}}, {_S(" "), 0xfe10, {.d_s = fs->application_version}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_flag__underline}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	if (fs->usage_examples.len == 0) {
		builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Usage: "), 0xfe10, {.d_s = fs->application_name}}, {_S(" [options] "), 0xfe10, {.d_s = adesc}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	} else {
		for (int i = 0; i < fs->usage_examples.len; ++i) {
			string example = ((string*)fs->usage_examples.data)[i];
			if (i == 0) {
				builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Usage: "), 0xfe10, {.d_s = fs->application_name}}, {_S(" "), 0xfe10, {.d_s = example}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			} else {
				builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("   or: "), 0xfe10, {.d_s = fs->application_name}}, {_S(" "), 0xfe10, {.d_s = example}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			}
		}
	}
	builtin__array_push((array*)&use, _MOV((string[]){ _S("") }));
	if ((fs->application_description).len != 0) {
		builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Description: "), 0xfe10, {.d_s = fs->application_description}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		builtin__array_push((array*)&use, _MOV((string[]){ _S("") }));
	}
	if (positive_min_arg || positive_max_arg || no_arguments) {
		if (no_arguments) {
			builtin__array_push((array*)&use, _MOV((string[]){ _S("This application does not expect any arguments") }));
			builtin__array_push((array*)&use, _MOV((string[]){ _S("") }));
		} else {
			Array_string s = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			if (positive_min_arg) {
				builtin__array_push((array*)&s, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("at least "), 0xfe07, {.d_i32 = fs->min_free_args}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			}
			if (positive_max_arg) {
				builtin__array_push((array*)&s, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("at most "), 0xfe07, {.d_i32 = fs->max_free_args}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			}
			if (positive_min_arg && positive_max_arg && fs->min_free_args == fs->max_free_args) {
				s = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__str_intp(2, _MOV((StrIntpData[]){{_S("exactly "), 0xfe07, {.d_i32 = fs->min_free_args}}, {_SLIT0, 0, { .d_c = 0 }}}))}));
			}
			string sargs = Array_string_join(s, _S(" and "));
			builtin__array_push((array*)&use, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("The arguments should be "), 0xfe10, {.d_s = sargs}}, {_S(" in number."), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&use, _MOV((string[]){ _S("") }));
		}
	}
	if (fs->flags.len > 0) {
		builtin__array_push((array*)&use, _MOV((string[]){ _S("Options:") }));
		for (int _t16 = 0; _t16 < fs->flags.len; ++_t16) {
			flag__Flag f = ((flag__Flag*)fs->flags.data)[_t16];
			Array_string onames = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			if (f.abbr != 0) {
				builtin__array_push((array*)&onames, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-"), 0xfe10, {.d_s = builtin__u8_ascii_str(f.abbr)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			}
			if ((f.name).len != 0) {
				if (!builtin__string_contains(f.val_desc, _S("<bool>"))) {
					builtin__array_push((array*)&onames, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("--"), 0xfe10, {.d_s = f.name}}, {_S(" "), 0xfe10, {.d_s = f.val_desc}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
				} else {
					builtin__array_push((array*)&onames, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("--"), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
				}
			}
			string option_names = builtin__string__plus(_S("  "), Array_string_join(onames, _S(", ")));
			string xspace = _S("");
			if (option_names.len > (int)(_const_flag__space.len - 2)) {
				xspace = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = _const_flag__space}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				xspace = builtin__string_substr(_const_flag__space, option_names.len, 2147483647);
			}
			string fdesc = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = option_names}}, {_SLIT0, 0xfe10, {.d_s = xspace}}, {_SLIT0, 0xfe10, {.d_s = f.usage}}, {_SLIT0, 0, { .d_c = 0 }}}));
			builtin__array_push((array*)&use, _MOV((string[]){ builtin__string_clone(fdesc) }));
		}
	}
	for (int _t21 = 0; _t21 < fs->footers.len; ++_t21) {
		string footer = ((string*)fs->footers.data)[_t21];
		builtin__array_push((array*)&use, _MOV((string[]){ builtin__string_clone(footer) }));
	}
	return builtin__string_replace(Array_string_join(use, _S("\n")), _S("- ,"), _S("   "));
}
VV_LOC _result_flag__Flag flag__FlagParser_find_existing_flag(flag__FlagParser* fs, string fname) {
	for (int _t1 = 0; _t1 < fs->flags.len; ++_t1) {
		flag__Flag f = ((flag__Flag*)fs->flags.data)[_t1];
		if (builtin__string__eq(f.name, fname)) {
			_result_flag__Flag _t2;
			builtin___result_ok(&(flag__Flag[]) { f }, (_result*)(&_t2), sizeof(flag__Flag));
			 
			return _t2;
		}
	}
	return (_result_flag__Flag){ .is_error=true, .err=builtin___v_error(_S("no such flag")), .data={E_STRUCT} };
}
VV_LOC void flag__FlagParser_handle_builtin_options(flag__FlagParser* fs) {
	bool show_version = false;
	bool show_help = false;
	_result_flag__Flag _t1 = flag__FlagParser_find_existing_flag(fs, _S("help"));
	if (_t1.is_error) {
		show_help = flag__FlagParser_bool(fs, _S("help"), 'h', false, fs->default_help_label, ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},}));
	}
	
 ;
	_result_flag__Flag _t2 = flag__FlagParser_find_existing_flag(fs, _S("version"));
	if (_t2.is_error) {
		show_version = flag__FlagParser_bool(fs, _S("version"), 0, false, fs->default_version_label, ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},}));
	}
	
 ;
	if (show_help) {
		builtin__println(flag__FlagParser_usage(fs));
		builtin___v_exit(0);
		VUNREACHABLE();
	}
	if (show_version) {
		builtin__println(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fs->application_name}}, {_S(" "), 0xfe10, {.d_s = fs->application_version}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin___v_exit(0);
		VUNREACHABLE();
	}
}
_result_Array_string flag__FlagParser_finalize(flag__FlagParser* fs) {
	flag__FlagParser_handle_builtin_options(fs);
	Array_string remaining = builtin__array_clone_to_depth(&fs->args, 1);
	if (!fs->allow_unknown_args) {
		for (int _t1 = 0; _t1 < remaining.len; ++_t1) {
			string a = ((string*)remaining.data)[_t1];
			if ((a.len >= 2 && builtin__string__eq(builtin__string_substr(a, 0, 2), _S("--"))) || (a.len == 2 && builtin__string_at(a, 0) == '-')) {
				return (_result_Array_string){ .is_error=true, .err=I_flag__UnknownFlagError_to_Interface_IError(((flag__UnknownFlagError*)builtin__memdup(&(flag__UnknownFlagError){.Error = ((Error){E_STRUCT}),.flag = a,}, sizeof(flag__UnknownFlagError)))), .data={E_STRUCT} };
			}
		}
	}
	_PUSH_MANY(&remaining, (fs->all_after_dashdash), _t3, Array_string);
	if (fs->min_free_args > remaining.len) {
		return (_result_Array_string){ .is_error=true, .err=I_flag__ArgsCountError_to_Interface_IError(((flag__ArgsCountError*)builtin__memdup(&(flag__ArgsCountError){.Error = ((Error){E_STRUCT}),.got = remaining.len,.want = fs->min_free_args,}, sizeof(flag__ArgsCountError)))), .data={E_STRUCT} };
	}
	if (fs->max_free_args < remaining.len) {
		return (_result_Array_string){ .is_error=true, .err=I_flag__ArgsCountError_to_Interface_IError(((flag__ArgsCountError*)builtin__memdup(&(flag__ArgsCountError){.Error = ((Error){E_STRUCT}),.got = remaining.len,.want = fs->max_free_args,}, sizeof(flag__ArgsCountError)))), .data={E_STRUCT} };
	}
	_result_Array_string _t6;
	builtin___result_ok(&(Array_string[]) { remaining }, (_result*)(&_t6), sizeof(Array_string));
	 
	return _t6;
}
Array_string flag__FlagParser_remaining_parameters(flag__FlagParser* fs) {
	_result_Array_string _t2 = flag__FlagParser_finalize(fs);
	if (_t2.is_error) {
		IError err = _t2.err;
		builtin__eprintln(IError_name_table[err._typ]._method_msg(err._object));
		builtin__println(flag__FlagParser_usage(fs));
		builtin___v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	return (*(Array_string*)_t2.data);
}
VV_LOC _option_string flag__StructField_shortest_match_name(flag__StructField sf) {
	string name = sf.__v_short;
	if ((name).len == 0 && sf.match_name.len == 1) {
		name = sf.match_name;
	}
	if ((name).len != 0) {
		_option_string _t1;
		builtin___option_ok(&(string[]) { name }, (_option*)(&_t1), sizeof(string));
		 
		return _t1;
	}
	return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
int flag__DocLayout_max_width(flag__DocLayout dl) {
	return (int)((int)(dl.flag_indent + dl.description_padding) + dl.description_width);
}
Array_string flag__FlagMapper_no_matches(flag__FlagMapper fm) {
	Array_string non_matching = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < fm.no_match.len; ++_t1) {
		int i = ((int*)fm.no_match.data)[_t1];
		builtin__array_push((array*)&non_matching, _MOV((string[]){ (*(string*)builtin__array_get(fm.input, i)) }));
	}
	return non_matching;
}
_result_string flag__FlagMapper_to_doc(flag__FlagMapper fm, flag__DocConfig dc) {
	Array_string docs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string name_and_version = _S("");
	if (flag__Show_has(&dc.options.show, flag__Show__name)) {
		string app_name = _S("");
		string* _t2 = (string*)(builtin__map_get_check(ADDR(map, fm.si.attrs), &(string[]){_S("name")}));
		_option_string _t1 = {0};
		if (_t2) {
			*((string*)&_t1.data) = *((string*)_t2);
		} else {
			_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t1.state == 0) {
			string attr_name = (*(string*)_t1.data);
			app_name = attr_name;
		}
		if ((dc.name).len != 0) {
			app_name = dc.name;
		}
		if ((app_name).len != 0) {
			name_and_version = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = app_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
	}
	if (flag__Show_has(&dc.options.show, flag__Show__version)) {
		string app_version = _S("");
		string* _t4 = (string*)(builtin__map_get_check(ADDR(map, fm.si.attrs), &(string[]){_S("version")}));
		_option_string _t3 = {0};
		if (_t4) {
			*((string*)&_t3.data) = *((string*)_t4);
		} else {
			_t3.state = 2; _t3.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t3.state == 0) {
			string attr_version = (*(string*)_t3.data);
			app_version = attr_version;
		}
		if ((dc.version).len != 0) {
			app_version = dc.version;
		}
		if ((app_version).len != 0) {
			if ((name_and_version).len != 0) {
				name_and_version = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name_and_version}}, {_S(" "), 0xfe10, {.d_s = app_version}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				name_and_version = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = app_version}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
		}
	}
	if ((name_and_version).len != 0) {
		builtin__array_push((array*)&docs, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name_and_version}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	if (flag__Show_has(&dc.options.show, flag__Show__description)) {
		string description = _S("");
		string* _t7 = (string*)(builtin__map_get_check(ADDR(map, fm.si.attrs), &(string[]){_S("xdoc")}));
		_option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t6.state == 0) {
			string attr_desc = (*(string*)_t6.data);
			description = attr_desc;
		}
		if ((dc.description).len != 0) {
			description = dc.description;
		}
		if ((description).len != 0) {
			builtin__array_push((array*)&docs, _MOV((string[]){ flag__keep_at_max(description, flag__DocLayout_max_width(dc.layout)) }));
		}
	}
	if (flag__Show_has(&dc.options.show, flag__Show__flags)) {
		_result_Array_string _t9 = flag__FlagMapper_fields_docs(fm, dc);
		if (_t9.is_error) {
			_result_string _t10 = {0};
			_t10.is_error = true;
			_t10.err = _t9.err;
			return _t10;
		}
		
 		Array_string fields_docs = (*(Array_string*)_t9.data);
		if (fields_docs.len > 0) {
			if (flag__Show_has(&dc.options.show, flag__Show__flags_header)) {
				builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_clone(dc.options.flag_header) }));
			}
			_PUSH_MANY(&docs, (fields_docs), _t12, Array_string);
		}
	}
	if (flag__Show_has(&dc.options.show, flag__Show__footer)) {
		string footer = _S("");
		string* _t14 = (string*)(builtin__map_get_check(ADDR(map, fm.si.attrs), &(string[]){_S("footer")}));
		_option_string _t13 = {0};
		if (_t14) {
			*((string*)&_t13.data) = *((string*)_t14);
		} else {
			_t13.state = 2; _t13.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t13.state == 0) {
			string attr_footer = (*(string*)_t13.data);
			footer = attr_footer;
		}
		if ((dc.footer).len != 0) {
			footer = dc.footer;
		}
		if ((footer).len != 0) {
			builtin__array_push((array*)&docs, _MOV((string[]){ flag__keep_at_max(footer, flag__DocLayout_max_width(dc.layout)) }));
		}
	}
	if ((name_and_version).len != 0) {
		int longest_line = 0;
		for (int _t16 = 0; _t16 < docs.len; ++_t16) {
			string doc_line = ((string*)docs.data)[_t16];
			Array_string lines = builtin__string_split(doc_line, _S("\n"));
			for (int _t17 = 0; _t17 < lines.len; ++_t17) {
				string line = ((string*)lines.data)[_t17];
				if (line.len > longest_line) {
					longest_line = line.len;
				}
			}
		}
		builtin__array_insert(&docs, 1, &(string[]){builtin__string_repeat(_S("-"), longest_line)});
	}
	_result_string _t18;
	builtin___result_ok(&(string[]) { Array_string_join(docs, _S("\n")) }, (_result*)(&_t18), sizeof(string));
	 
	return _t18;
}
_result_Array_string flag__FlagMapper_fields_docs(flag__FlagMapper fm, flag__DocConfig dc) {
	string short_delimiter = ((dc.style == (flag__Style__short) || dc.style == (flag__Style__short_long) || dc.style == (flag__Style__v) || dc.style == (flag__Style__v_flag_parser) || dc.style == (flag__Style__go_flag) || dc.style == (flag__Style__cmd_exe))? (dc.delimiter) : (builtin__string_repeat(dc.delimiter, 2)));
	string long_delimiter = ((dc.style == (flag__Style__short) || dc.style == (flag__Style__v) || dc.style == (flag__Style__go_flag) || dc.style == (flag__Style__cmd_exe))? (dc.delimiter) : (builtin__string_repeat(dc.delimiter, 2)));
	int pad_desc = (dc.layout.description_padding < 0 ? (0) : (dc.layout.description_padding));
	string empty_padding = builtin__string_repeat(_S(" "), pad_desc);
	int indent_flags = (dc.layout.flag_indent < 0 ? (0) : (dc.layout.flag_indent));
	string indent_flags_padding = builtin__string_repeat(_S(" "), indent_flags);
	int desc_max = (dc.layout.description_width < 1 ? (1) : (dc.layout.description_width));
	Array_string docs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_flag__StructField _t1 = fm.si.fields;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		flag__StructField field = (*(flag__StructField*)builtin__DenseArray_value(&_t1.key_values, _t2));
		if (flag__FieldHints_has(&field.hints, flag__FieldHints__is_ignore)) {
			;
			continue;
		}
		string* _t6 = (string*)(builtin__map_get_check(ADDR(map, dc.fields), &(string[]){field.name}));
		_option_string _t5 = {0};
		if (_t6) {
			*((string*)&_t5.data) = *((string*)_t6);
		} else {
			_t5.state = 2; _t5.err = builtin___v_error(_S("map key does not exist"));
		}
		;
		if (_t5.state != 0) {
			*(string*) _t5.data = field.doc;
		}
		
		string doc = (*(string*)_t5.data);
		_option_string _t7 = flag__StructField_shortest_match_name(field);
		if (_t7.state != 0) {
			*(string*) _t7.data = _S("");
		}
		
 		string __v_short = (*(string*)_t7.data);
		string __v_long = field.match_name;
		string flag_line = indent_flags_padding;
		flag_line = builtin__string__plus(flag_line, ((__v_short).len != 0 ? (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = short_delimiter}}, {_SLIT0, 0xfe10, {.d_s = __v_short}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_S(""))));
		if (!flag__FieldHints_has(&field.hints, flag__FieldHints__short_only) && (__v_long).len != 0) {
			if ((__v_short).len != 0) {
				flag_line = builtin__string__plus(flag_line, _S(", "));
			}
			flag_line = builtin__string__plus(flag_line, builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = long_delimiter}}, {_SLIT0, 0xfe10, {.d_s = __v_long}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		if (flag__Show_has(&dc.options.show, flag__Show__flag_type) && !builtin__fast_string_eq(field.type_name, _S("bool"))) {
			if (!flag__FieldHints_has(&field.hints, flag__FieldHints__can_repeat)) {
				flag_line = builtin__string__plus(flag_line, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" <"), 0xfe10, {.d_s = builtin__string_replace(field.type_name, _S("[]"), _S(""))}}, {_S(">"), 0, { .d_c = 0 }}})));
			}
		}
		if (flag__Show_has(&dc.options.show, flag__Show__flag_hint)) {
			if (flag__FieldHints_has(&field.hints, flag__FieldHints__is_array)) {
				flag_line = builtin__string__plus(flag_line, _S(" (allowed multiple times)"));
			}
			if (flag__FieldHints_has(&field.hints, flag__FieldHints__can_repeat)) {
				flag_line = builtin__string__plus(flag_line, builtin__str_intp(5, _MOV((StrIntpData[]){{_S(", "), 0xfe10, {.d_s = short_delimiter}}, {_SLIT0, 0xfe10, {.d_s = __v_short}}, {_SLIT0, 0xfe10, {.d_s = __v_short}}, {_SLIT0, 0xfe10, {.d_s = __v_short}}, {_S("... (can repeat)"), 0, { .d_c = 0 }}})));
			}
		}
		int flag_line_diff = (int)(flag_line.len - pad_desc);
		if (flag_line_diff < 0) {
			int diff = -flag_line_diff;
			string line = builtin__string__plus(builtin__string__plus(flag_line, builtin__string_repeat(_S(" "), diff)), builtin__string_replace(flag__keep_at_max(doc, desc_max), _S("\n"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = empty_padding}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_trim_space_right(line) }));
		} else {
			builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_trim_space_right(flag_line) }));
			if ((doc).len != 0) {
				string line = builtin__string__plus(empty_padding, builtin__string_replace(flag__keep_at_max(doc, desc_max), _S("\n"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = empty_padding}}, {_SLIT0, 0, { .d_c = 0 }}}))));
				builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_trim_space_right(line) }));
			}
		}
		if (!dc.options.compact) {
			builtin__array_push((array*)&docs, _MOV((string[]){ _S("") }));
		}
	}
	Map_string_string _t12 = dc.fields;
	int _t14 = _t12.key_values.len;
	for (int _t13 = 0; _t13 < _t14; ++_t13 ) {
		int _t15 = _t12.key_values.len - _t14;
		_t14 = _t12.key_values.len;
		if (_t15 < 0) {
			_t13 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t12.key_values, _t13)) {continue;}
		string entry = *(string*)builtin__DenseArray_key(&_t12.key_values, _t13);
		entry = builtin__string_clone(entry);
		string doc = (*(string*)builtin__DenseArray_value(&_t12.key_values, _t13));
		if (builtin__string_starts_with(entry, dc.delimiter)) {
			int flag_line_diff = (int)((int)(entry.len - pad_desc) + indent_flags);
			if (flag_line_diff < 0) {
				int diff = -flag_line_diff;
				string line = builtin__string__plus(builtin__string__plus(builtin__string__plus(indent_flags_padding, builtin__string_trim(entry, _S(" "))), builtin__string_repeat(_S(" "), diff)), builtin__string_replace(flag__keep_at_max(doc, desc_max), _S("\n"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = empty_padding}}, {_SLIT0, 0, { .d_c = 0 }}}))));
				builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_trim_space_right(line) }));
			} else {
				builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string__plus(indent_flags_padding, builtin__string_trim(entry, _S(" "))) }));
				string line = builtin__string__plus(empty_padding, builtin__string_replace(flag__keep_at_max(doc, desc_max), _S("\n"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = empty_padding}}, {_SLIT0, 0, { .d_c = 0 }}}))));
				builtin__array_push((array*)&docs, _MOV((string[]){ builtin__string_trim_space_right(line) }));
			}
			if (!dc.options.compact) {
				builtin__array_push((array*)&docs, _MOV((string[]){ _S("") }));
			}
		}
	}
	if (docs.len > 0) {
		if (!dc.options.compact) {
			builtin__array_delete_last(&docs);
		}
	}
	_result_Array_string _t20;
	builtin___result_ok(&(Array_string[]) { docs }, (_result*)(&_t20), sizeof(Array_string));
	 
	return _t20;
}
VV_LOC string flag__keep_at_max(string str, int max) {
	int safe_max = (max <= 0 ? (1) : (max));
	if (str.len <= safe_max || builtin__string_count(str, _S(" ")) == 0) {
		return str;
	}
	string fitted = _S("");
	int width = 0;
	_option_int _t2 = builtin__string_index(str, _S(" "));
	if (_t2.state != 0) {
		*(int*) _t2.data = 0;
	}
	
 	int last_possible_break = (*(int*)_t2.data);
	bool never_touched = true;
	string s = builtin__string_trim_space(str);
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		width++;
		if (c == ' ') {
			last_possible_break = i;
		} else if (c == '\n') {
			width = 0;
		}
		if (width == safe_max) {
			never_touched = false;
			fitted = builtin__string__plus(builtin__string_substr(s, 0, last_possible_break), _S("\n"));
			fitted = builtin__string__plus(fitted, builtin__string_trim(flag__keep_at_max(builtin__string_trim(builtin__string_replace(builtin__string_substr(s, last_possible_break, 2147483647), _S("\n"), _S(" ")), _S(" ")), safe_max), _S(" ")));
		} else if (width > safe_max) {
			break;
		}
	}
	if (never_touched) {
		return str;
	}
	return fitted;
}
inline bool flag__FieldHints_is_empty(flag__FieldHints* e) {
	return ((int)(*e)) == 0;
}
inline bool flag__FieldHints_has(flag__FieldHints* e, flag__FieldHints flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) != 0;
}
inline bool flag__FieldHints_all(flag__FieldHints* e, flag__FieldHints flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) == ((int)(flag_));
}
inline void flag__FieldHints_set(flag__FieldHints* e, flag__FieldHints flag_) {
	{ // Unsafe block
		*e = ((flag__FieldHints)((((int)(*e)) | (((int)(flag_))))));
	}
}
inline void flag__FieldHints_set_all(flag__FieldHints* e) {
	{ // Unsafe block
		*e = ((flag__FieldHints)(0b1111111));
	}
}
inline void flag__FieldHints_clear(flag__FieldHints* e, flag__FieldHints flag_) {
	{ // Unsafe block
		*e = ((flag__FieldHints)((((int)(*e)) & ~(((int)(flag_))))));
	}
}
inline void flag__FieldHints_clear_all(flag__FieldHints* e) {
	{ // Unsafe block
		*e = ((flag__FieldHints)(0));
	}
}
inline void flag__FieldHints_toggle(flag__FieldHints* e, flag__FieldHints flag_) {
	{ // Unsafe block
		*e = ((flag__FieldHints)((((int)(*e)) ^ (((int)(flag_))))));
	}
}
inline flag__FieldHints flag__FieldHints__static__zero(void) {
	return ((flag__FieldHints)(0));
}
inline bool flag__Show_is_empty(flag__Show* e) {
	return ((int)(*e)) == 0;
}
inline bool flag__Show_has(flag__Show* e, flag__Show flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) != 0;
}
inline bool flag__Show_all(flag__Show* e, flag__Show flag_) {
	return ((((int)(*e)) & (((int)(flag_))))) == ((int)(flag_));
}
inline void flag__Show_set(flag__Show* e, flag__Show flag_) {
	{ // Unsafe block
		*e = ((flag__Show)((((int)(*e)) | (((int)(flag_))))));
	}
}
inline void flag__Show_set_all(flag__Show* e) {
	{ // Unsafe block
		*e = ((flag__Show)(0b11111111));
	}
}
inline void flag__Show_clear(flag__Show* e, flag__Show flag_) {
	{ // Unsafe block
		*e = ((flag__Show)((((int)(*e)) & ~(((int)(flag_))))));
	}
}
inline void flag__Show_clear_all(flag__Show* e) {
	{ // Unsafe block
		*e = ((flag__Show)(0));
	}
}
inline void flag__Show_toggle(flag__Show* e, flag__Show flag_) {
	{ // Unsafe block
		*e = ((flag__Show)((((int)(*e)) ^ (((int)(flag_))))));
	}
}
inline flag__Show flag__Show__static__zero(void) {
	return ((flag__Show)(0));
}
inline VV_LOC bool semver__version_satisfies(semver__Version ver, string input) {
	_result_semver__Range _t1 = semver__parse_range(input);
	if (_t1.is_error) {
		return false;
	}
	
 	semver__Range range = (*(semver__Range*)_t1.data);
	return semver__Range_satisfies(range, ver);
}
VV_LOC bool semver__compare_eq(semver__Version v1, semver__Version v2) {
	return v1.major == v2.major && v1.minor == v2.minor && v1.patch == v2.patch && builtin__string__eq(v1.prerelease, v2.prerelease);
}
VV_LOC bool semver__compare_lt(semver__Version v1, semver__Version v2) {
	bool _t2 = true;
	return ((_t2 == (v1.major > v2.major))? (false) : (_t2 == (v1.major < v2.major))? (true) : (_t2 == (v1.minor > v2.minor))? (false) : (_t2 == (v1.minor < v2.minor))? (true) : (v1.patch < v2.patch));
}
VV_LOC semver__RawVersion semver__parse(string input) {
	string raw_version = input;
	string prerelease = _S("");
	string metadata = _S("");
	int plus_idx = builtin__string_last_index_u8(raw_version, '+');
	if (plus_idx > 0) {
		metadata = builtin__string_substr(raw_version, ((int)(plus_idx + 1)), 2147483647);
		raw_version = builtin__string_substr(raw_version, 0, plus_idx);
	}
	int hyphen_idx = builtin__string_index_(raw_version, _S("-"));
	if (hyphen_idx > 0) {
		prerelease = builtin__string_substr(raw_version, ((int)(hyphen_idx + 1)), 2147483647);
		raw_version = builtin__string_substr(raw_version, 0, hyphen_idx);
	}
	Array_string raw_ints = builtin__string_split(raw_version, _S("."));
	return ((semver__RawVersion){.prerelease = prerelease,.metadata = metadata,.raw_ints = raw_ints,});
}
VV_LOC bool semver__RawVersion_is_valid(semver__RawVersion ver) {
	if (ver.raw_ints.len != 3) {
		return false;
	}
	return semver__is_valid_number((*(string*)builtin__array_get(ver.raw_ints, _const_semver__ver_major))) && semver__is_valid_number((*(string*)builtin__array_get(ver.raw_ints, _const_semver__ver_minor))) && semver__is_valid_number((*(string*)builtin__array_get(ver.raw_ints, _const_semver__ver_patch))) && semver__is_valid_string(ver.prerelease) && semver__is_valid_string(ver.metadata);
}
VV_LOC bool semver__RawVersion_is_missing(semver__RawVersion ver, int typ) {
	return typ >= (int)(ver.raw_ints.len - 1);
}
VV_LOC _result_semver__Version semver__RawVersion_coerce(semver__RawVersion raw_ver) {
	semver__RawVersion ver = semver__RawVersion_complete(raw_ver);
	if (!semver__is_valid_number((*(string*)builtin__array_get(ver.raw_ints, _const_semver__ver_major)))) {
		return (_result_semver__Version){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Invalid major version: "), 0xfe10, {.d_s = Array_string_str(ver.raw_ints)}}, {_S("[ver_major]"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_semver__Version _t2;
	builtin___result_ok(&(semver__Version[]) { semver__RawVersion_to_version(ver) }, (_result*)(&_t2), sizeof(semver__Version));
	 
	return _t2;
}
VV_LOC semver__RawVersion semver__RawVersion_complete(semver__RawVersion raw_ver) {
	Array_string raw_ints = builtin__array_clone_to_depth(&raw_ver.raw_ints, 1);
	for (;;) {
		if (!(raw_ints.len < 3)) break;
		builtin__array_push((array*)&raw_ints, _MOV((string[]){ _S("0") }));
	}
	return ((semver__RawVersion){.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,.raw_ints = raw_ints,});
}
VV_LOC _option_semver__Version semver__RawVersion_validate(semver__RawVersion raw_ver) {
	if (!semver__RawVersion_is_valid(raw_ver)) {
		return (_option_semver__Version){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	_option_semver__Version _t2;
	builtin___option_ok(&(semver__Version[]) { semver__RawVersion_to_version(raw_ver) }, (_option*)(&_t2), sizeof(semver__Version));
	 
	return _t2;
}
VV_LOC semver__Version semver__RawVersion_to_version(semver__RawVersion raw_ver) {
	return ((semver__Version){.major = builtin__string_int((*(string*)builtin__array_get(raw_ver.raw_ints, _const_semver__ver_major))),.minor = builtin__string_int((*(string*)builtin__array_get(raw_ver.raw_ints, _const_semver__ver_minor))),.patch = builtin__string_int((*(string*)builtin__array_get(raw_ver.raw_ints, _const_semver__ver_patch))),.prerelease = raw_ver.prerelease,.metadata = raw_ver.metadata,});
}
VV_LOC bool semver__Range_satisfies(semver__Range r, semver__Version ver) {
	bool _t2 = false;
	Array_semver__ComparatorSet _t2_orig = r.comparator_sets;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		semver__ComparatorSet it = ((semver__ComparatorSet*) _t2_orig.data)[_t3];
		if (semver__ComparatorSet_satisfies(it, ver)) {
			_t2 = true;
			break;
		}
	}
	return _t2;
}
VV_LOC bool semver__ComparatorSet_satisfies(semver__ComparatorSet set, semver__Version ver) {
	for (int _t1 = 0; _t1 < set.comparators.len; ++_t1) {
		semver__Comparator comp = ((semver__Comparator*)set.comparators.data)[_t1];
		if (!semver__Comparator_satisfies(comp, ver)) {
			return false;
		}
	}
	return true;
}
VV_LOC bool semver__Comparator_satisfies(semver__Comparator c, semver__Version ver) {
	return ((c.op == (semver__Operator__gt))? (semver__Version__lt(c.ver, ver)) : (c.op == (semver__Operator__lt))? (semver__Version__lt(ver, c.ver)) : (c.op == (semver__Operator__ge))? (!semver__Version__lt(ver, c.ver)) : (c.op == (semver__Operator__le))? (!semver__Version__lt(c.ver, ver)) : (semver__Version__eq(ver, c.ver)));
}
VV_LOC _result_semver__Range semver__parse_range(string input) {
	Array_string raw_comparator_sets = builtin__string_split(input, _const_semver__comparator_set_sep);
	Array_semver__ComparatorSet comparator_sets = builtin____new_array_with_default(0, 0, sizeof(semver__ComparatorSet), 0);
	for (int _t1 = 0; _t1 < raw_comparator_sets.len; ++_t1) {
		string raw_comp_set = ((string*)raw_comparator_sets.data)[_t1];
		if (semver__can_expand(raw_comp_set)) {
			_option_semver__ComparatorSet _t2 = semver__expand_comparator_set(raw_comp_set);
			if (_t2.state != 0) {
				IError err = _t2.err;
				return (_result_semver__Range){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			semver__ComparatorSet s = (*(semver__ComparatorSet*)_t2.data);
			builtin__array_push((array*)&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		} else {
			_result_semver__ComparatorSet _t5 = semver__parse_comparator_set(raw_comp_set);
			if (_t5.is_error) {
				IError err = _t5.err;
				return (_result_semver__Range){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			semver__ComparatorSet s = (*(semver__ComparatorSet*)_t5.data);
			builtin__array_push((array*)&comparator_sets, _MOV((semver__ComparatorSet[]){ s }));
		}
	}
	_result_semver__Range _t8;
	builtin___result_ok(&(semver__Range[]) { ((semver__Range){.comparator_sets = comparator_sets,}) }, (_result*)(&_t8), sizeof(semver__Range));
	 
	return _t8;
}
VV_LOC _result_semver__ComparatorSet semver__parse_comparator_set(string input) {
	Array_string raw_comparators = builtin__string_split(input, _const_semver__comparator_sep);
	if (raw_comparators.len > 2) {
		return (_result_semver__ComparatorSet){ .is_error=true, .err=I_semver__InvalidComparatorFormatError_to_Interface_IError(((semver__InvalidComparatorFormatError*)builtin__memdup(&(semver__InvalidComparatorFormatError){.MessageError = ((MessageError){.msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Invalid format of comparator set for input \""), 0xfe10, {.d_s = input}}, {_S("\""), 0, { .d_c = 0 }}})),.code = 0,}),}, sizeof(semver__InvalidComparatorFormatError)))), .data={E_STRUCT} };
	}
	Array_semver__Comparator comparators = builtin____new_array_with_default(0, 0, sizeof(semver__Comparator), 0);
	for (int _t2 = 0; _t2 < raw_comparators.len; ++_t2) {
		string raw_comp = ((string*)raw_comparators.data)[_t2];
		_option_semver__Comparator _t3 = semver__parse_comparator(raw_comp);
		if (_t3.state != 0) {
			return (_result_semver__ComparatorSet){ .is_error=true, .err=I_semver__InvalidComparatorFormatError_to_Interface_IError(((semver__InvalidComparatorFormatError*)builtin__memdup(&(semver__InvalidComparatorFormatError){.MessageError = ((MessageError){.msg = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Invalid comparator \""), 0xfe10, {.d_s = raw_comp}}, {_S("\" in input \""), 0xfe10, {.d_s = input}}, {_S("\""), 0, { .d_c = 0 }}})),.code = 0,}),}, sizeof(semver__InvalidComparatorFormatError)))), .data={E_STRUCT} };
		}
		
 		semver__Comparator c = (*(semver__Comparator*)_t3.data);
		builtin__array_push((array*)&comparators, _MOV((semver__Comparator[]){ c }));
	}
	_result_semver__ComparatorSet _t6;
	builtin___result_ok(&(semver__ComparatorSet[]) { ((semver__ComparatorSet){.comparators = comparators,}) }, (_result*)(&_t6), sizeof(semver__ComparatorSet));
	 
	return _t6;
}
VV_LOC _option_semver__Comparator semver__parse_comparator(string input) {
	semver__Operator op = semver__Operator__eq;
	bool _t1 = true;
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	
	if (_t1 == (builtin__string_starts_with(input, _S(">=")))) {
		op = semver__Operator__ge;
		_t2 = builtin__string_substr(input, 2, 2147483647);
	}
	else if (_t1 == (builtin__string_starts_with(input, _S("<=")))) {
		op = semver__Operator__le;
		_t2 = builtin__string_substr(input, 2, 2147483647);
	}
	else if (_t1 == (builtin__string_starts_with(input, _S(">")))) {
		op = semver__Operator__gt;
		_t2 = builtin__string_substr(input, 1, 2147483647);
	}
	else if (_t1 == (builtin__string_starts_with(input, _S("<")))) {
		op = semver__Operator__lt;
		_t2 = builtin__string_substr(input, 1, 2147483647);
	}
	else if (_t1 == (builtin__string_starts_with(input, _S("=")))) {
		_t2 = builtin__string_substr(input, 1, 2147483647);
	}
	else {
		_t2 = input;
	}string raw_version = _t2;
	_result_semver__Version _t3 = semver__coerce_version(raw_version);
	if (_t3.is_error) {
		return (_option_semver__Comparator){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version version = (*(semver__Version*)_t3.data);
	_option_semver__Comparator _t5;
	builtin___option_ok(&(semver__Comparator[]) { ((semver__Comparator){.ver = version,.op = op,}) }, (_option*)(&_t5), sizeof(semver__Comparator));
	 
	return _t5;
}
VV_LOC _option_semver__Version semver__parse_xrange(string input) {
	semver__RawVersion raw_ver = semver__RawVersion_complete(semver__parse(input));
	for (int _t1 = 0; _t1 < _const_semver__versions.len; ++_t1) {
		int typ = ((int*)_const_semver__versions.data)[_t1];
		if (builtin__string_index_any((*(string*)builtin__array_get(raw_ver.raw_ints, typ)), _const_semver__x_range_symbols) == -1) {
			continue;
		}

		if (typ == (_const_semver__ver_major)) {
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_major, &(string[]) { _S("0") });
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_minor, &(string[]) { _S("0") });
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_patch, &(string[]) { _S("0") });
		}
		else if (typ == (_const_semver__ver_minor)) {
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_minor, &(string[]) { _S("0") });
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_patch, &(string[]) { _S("0") });
		}
		else if (typ == (_const_semver__ver_patch)) {
			builtin__array_set(&raw_ver.raw_ints, _const_semver__ver_patch, &(string[]) { _S("0") });
		}
		else {
		}
	}
	return semver__RawVersion_validate(raw_ver);
}
VV_LOC bool semver__can_expand(string input) {
	return builtin__string_at(input, 0) == '~' || builtin__string_at(input, 0) == '^' || builtin__string_contains(input, _const_semver__hyphen_range_sep) || builtin__string_index_any(input, _const_semver__x_range_symbols) > -1;
}
VV_LOC _option_semver__ComparatorSet semver__expand_comparator_set(string input) {
	u8 _t1 = builtin__string_at(input, 0);
		switch (_t1) {
		case '~': {
			return semver__expand_tilda(builtin__string_substr(input, 1, 2147483647));
		}
		case '^': {
			return semver__expand_caret(builtin__string_substr(input, 1, 2147483647));
		}
		default: {
			{
				break;
			}
		}
	}
	
	if (builtin__string_contains(input, _const_semver__hyphen_range_sep)) {
		return semver__expand_hyphen(input);
	}
	return semver__expand_xrange(input);
}
VV_LOC _option_semver__ComparatorSet semver__expand_tilda(string raw_version) {
	_result_semver__Version _t1 = semver__coerce_version(raw_version);
	if (_t1.is_error) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version min_ver = (*(semver__Version*)_t1.data);
	semver__Version max_ver = (min_ver.minor == 0 && min_ver.patch == 0 ? (semver__Version_increment(min_ver, semver__Increment__major)) : (semver__Version_increment(min_ver, semver__Increment__minor)));
	_option_semver__ComparatorSet _t3;
	builtin___option_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (_option*)(&_t3), sizeof(semver__ComparatorSet));
	 
	return _t3;
}
VV_LOC _option_semver__ComparatorSet semver__expand_caret(string raw_version) {
	_result_semver__Version _t1 = semver__coerce_version(raw_version);
	if (_t1.is_error) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version min_ver = (*(semver__Version*)_t1.data);
	semver__Version max_ver = (min_ver.major == 0 ? (semver__Version_increment(min_ver, semver__Increment__minor)) : (semver__Version_increment(min_ver, semver__Increment__major)));
	_option_semver__ComparatorSet _t3;
	builtin___option_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (_option*)(&_t3), sizeof(semver__ComparatorSet));
	 
	return _t3;
}
VV_LOC _option_semver__ComparatorSet semver__expand_hyphen(string raw_range) {
	Array_string raw_versions = builtin__string_split(raw_range, _const_semver__hyphen_range_sep);
	if (raw_versions.len != 2) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	_result_semver__Version _t2 = semver__coerce_version((*(string*)builtin__array_get(raw_versions, 0)));
	if (_t2.is_error) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version min_ver = (*(semver__Version*)_t2.data);
	semver__RawVersion raw_max_ver = semver__parse((*(string*)builtin__array_get(raw_versions, 1)));
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_major)) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	if (semver__RawVersion_is_missing(raw_max_ver, _const_semver__ver_minor)) {
		_result_semver__Version _t5 = semver__RawVersion_coerce(raw_max_ver);
		if (_t5.is_error) {
			return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		}
		
 		semver__Version max_ver = semver__Version_increment((*(semver__Version*)_t5.data), semver__Increment__minor);
		_option_semver__ComparatorSet _t7;
		builtin___option_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (_option*)(&_t7), sizeof(semver__ComparatorSet));
		 
		return _t7;
	}
	_result_semver__Version _t8 = semver__RawVersion_coerce(raw_max_ver);
	if (_t8.is_error) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version max_ver = (*(semver__Version*)_t8.data);
	_option_semver__ComparatorSet _t10;
	builtin___option_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_le(min_ver, max_ver) }, (_option*)(&_t10), sizeof(semver__ComparatorSet));
	 
	return _t10;
}
VV_LOC _option_semver__ComparatorSet semver__expand_xrange(string raw_range) {
	_option_semver__Version _t1 = semver__parse_xrange(raw_range);
	if (_t1.state != 0) {
		return (_option_semver__ComparatorSet){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	semver__Version min_ver = (*(semver__Version*)_t1.data);
	if (min_ver.major == 0) {
		_option_semver__ComparatorSet _t3;
		builtin___option_ok(&(semver__ComparatorSet[]) { ((semver__ComparatorSet){.comparators = builtin__new_array_from_c_array(1, 1, sizeof(semver__Comparator), _MOV((semver__Comparator[1]){((semver__Comparator){.ver = min_ver,.op = semver__Operator__ge,})})),}) }, (_option*)(&_t3), sizeof(semver__ComparatorSet));
		 
		return _t3;
	}
	semver__Version max_ver = (min_ver.minor == 0 ? (semver__Version_increment(min_ver, semver__Increment__major)) : (semver__Version_increment(min_ver, semver__Increment__minor)));
	_option_semver__ComparatorSet _t4;
	builtin___option_ok(&(semver__ComparatorSet[]) { semver__make_comparator_set_ge_lt(min_ver, max_ver) }, (_option*)(&_t4), sizeof(semver__ComparatorSet));
	 
	return _t4;
}
VV_LOC semver__ComparatorSet semver__make_comparator_set_ge_lt(semver__Version min, semver__Version max) {
	return ((semver__ComparatorSet){.comparators = builtin__new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){((semver__Comparator){.ver = min,.op = semver__Operator__ge,}), ((semver__Comparator){.ver = max,.op = semver__Operator__lt,})})),});
}
VV_LOC semver__ComparatorSet semver__make_comparator_set_ge_le(semver__Version min, semver__Version max) {
	return ((semver__ComparatorSet){.comparators = builtin__new_array_from_c_array(2, 2, sizeof(semver__Comparator), _MOV((semver__Comparator[2]){((semver__Comparator){.ver = min,.op = semver__Operator__ge,}), ((semver__Comparator){.ver = max,.op = semver__Operator__le,})})),});
}
string semver__EmptyInputError_msg(semver__EmptyInputError err) {
	return _S("Empty input");
}
string semver__InvalidVersionFormatError_msg(semver__InvalidVersionFormatError err) {
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Invalid version format for input \""), 0xfe10, {.d_s = err.input}}, {_S("\""), 0, { .d_c = 0 }}}));
}
_result_semver__Version semver__from(string input) {
	if (input.len == 0) {
		return (_result_semver__Version){ .is_error=true, .err=I_semver__EmptyInputError_to_Interface_IError(((semver__EmptyInputError*)builtin__memdup(&(semver__EmptyInputError){.Error = ((Error){E_STRUCT}),}, sizeof(semver__EmptyInputError)))), .data={E_STRUCT} };
	}
	semver__RawVersion raw_version = semver__parse(input);
	_option_semver__Version _t3 = semver__RawVersion_validate(raw_version);
	if (_t3.state != 0) {
		return (_result_semver__Version){ .is_error=true, .err=I_semver__InvalidVersionFormatError_to_Interface_IError(((semver__InvalidVersionFormatError*)builtin__memdup(&(semver__InvalidVersionFormatError){.Error = ((Error){E_STRUCT}),.input = input,}, sizeof(semver__InvalidVersionFormatError)))), .data={E_STRUCT} };
	}
	
 	_result_semver__Version _t2;
	builtin___result_ok(&(semver__Version[]) { (*(semver__Version*)_t3.data) }, (_result*)(&_t2), sizeof(semver__Version));
	 
	return _t2;
}
semver__Version semver__build(int major, int minor, int patch) {
	return ((semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = _S(""),.metadata = _S(""),});
}
semver__Version semver__Version_increment(semver__Version ver, semver__Increment typ) {
	return semver__increment_version(ver, typ);
}
bool semver__Version_satisfies(semver__Version ver, string input) {
	return semver__version_satisfies(ver, input);
}
bool semver__Version__eq(semver__Version v1, semver__Version v2) {
	return semver__compare_eq(v1, v2);
}
bool semver__Version__lt(semver__Version v1, semver__Version v2) {
	return semver__compare_lt(v1, v2);
}
string semver__Version_str(semver__Version ver) {
	string common_string = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ver.major}}, {_S("."), 0xfe07, {.d_i32 = ver.minor}}, {_S("."), 0xfe07, {.d_i32 = ver.patch}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string prerelease_string = (ver.prerelease.len > 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-"), 0xfe10, {.d_s = ver.prerelease}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_S("")));
	string metadata_string = (ver.metadata.len > 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("+"), 0xfe10, {.d_s = ver.metadata}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_S("")));
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = common_string}}, {_SLIT0, 0xfe10, {.d_s = prerelease_string}}, {_SLIT0, 0xfe10, {.d_s = metadata_string}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
_result_semver__Version semver__coerce(string input) {
	return semver__coerce_version(input);
}
bool semver__is_valid(string input) {
	return semver__is_version_valid(input);
}
inline VV_LOC bool semver__is_version_valid(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	return semver__RawVersion_is_valid(raw_ver);
}
inline VV_LOC _result_semver__Version semver__coerce_version(string input) {
	semver__RawVersion raw_ver = semver__parse(input);
	_result_semver__Version _t2 = semver__RawVersion_coerce(raw_ver);
	if (_t2.is_error) {
		return (_result_semver__Version){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Invalid version for input \""), 0xfe10, {.d_s = input}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	_result_semver__Version _t1;
	builtin___result_ok(&(semver__Version[]) { (*(semver__Version*)_t2.data) }, (_result*)(&_t1), sizeof(semver__Version));
	 
	return _t1;
}
inline VV_LOC semver__Version semver__increment_version(semver__Version ver, semver__Increment typ) {
	int major = ver.major;
	int minor = ver.minor;
	int patch = ver.patch;

	if (typ == (semver__Increment__major)) {
		major++;
		minor = 0;
		patch = 0;
	}
	else if (typ == (semver__Increment__minor)) {
		minor++;
		patch = 0;
	}
	else if (typ == (semver__Increment__patch)) {
		patch++;
	}
	return ((semver__Version){.major = major,.minor = minor,.patch = patch,.prerelease = ver.prerelease,.metadata = ver.metadata,});
}
VV_LOC bool semver__is_valid_string(string input) {
	for (int _t1 = 0; _t1 < input.len; ++_t1) {
		u8 c = input.str[_t1];
		if (!(builtin__u8_is_letter(c) || builtin__u8_is_digit(c) || c == '.' || c == '-')) {
			return false;
		}
	}
	return true;
}
VV_LOC bool semver__is_valid_number(string input) {
	for (int _t1 = 0; _t1 < input.len; ++_t1) {
		u8 c = input.str[_t1];
		if (!builtin__u8_is_digit(c)) {
			return false;
		}
	}
	return true;
}
void vphp__Context_return_int(vphp__Context ctx, i64 val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ctx.ret,});
		vphp__Val_set_int(out, val);
	}
}
void vphp__Context_return_string(vphp__Context ctx, string val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ctx.ret,});
		vphp__Val_set_string(out, val);
	}
}
void vphp__Context_return_map_f64(vphp__Context ctx, Map_string_f64 m) {
	vphp_return_array_start(ctx.ret);
	int _t2 = m.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = m.key_values.len - _t2;
		_t2 = m.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&m.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&m.key_values, _t1);
		k = builtin__string_clone(k);
		f64 v = (*(f64*)builtin__DenseArray_value(&m.key_values, _t1));
		vphp_array_add_assoc_double(ctx.ret, ((char*)(k.str)), v);
	}
}
void vphp__Context_return_map_int(vphp__Context ctx, Map_string_int m) {
	vphp_return_array_start(ctx.ret);
	int _t2 = m.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = m.key_values.len - _t2;
		_t2 = m.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&m.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&m.key_values, _t1);
		k = builtin__string_clone(k);
		int v = (*(int*)builtin__DenseArray_value(&m.key_values, _t1));
		vphp_array_add_assoc_long(ctx.ret, ((char*)(k.str)), ((i64)(v)));
	}
}
int vphp__Context_num_args(vphp__Context ctx) {
	return ((int)(vphp_get_num_args(ctx.ex)));
}
string vphp__Context_arg_T_string(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return (string){.str=(byteptr)"", .is_lit=1};
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if true
	{
		int len = 0;
		voidptr ptr = ((voidptr)(vphp_get_string_ptr(val.raw, &len)));
		return (ptr != 0 ? (builtin__char_vstring_with_len((((char*)(ptr))), len)) : (_S("")));
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
i64 vphp__Context_arg_T_i64(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return 0;
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if true
	{
		if (!vphp__Val_is_long(val) && !vphp__Val_is_double(val)) {
			vphp_throw(((char*)(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Argument "), 0xfe07, {.d_i32 = index}}, {_S(": expected integer, got "), 0xfe10, {.d_s = vphp__Val_type_name(val)}}, {_SLIT0, 0, { .d_c = 0 }}})).str)), 0);
			return 0;
		}
		return ((i64)(vphp_get_int(val.raw)));
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	return 0;
}
Array_string vphp__Context_arg_T_Array_string(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return builtin____new_array_with_default(0, 0, sizeof(string), 0);
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if true
	{
		if (!vphp__Val_is_array(val)) {
			vphp_throw(((char*)(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Expected array at index "), 0xfe07, {.d_i32 = index}}, {_SLIT0, 0, { .d_c = 0 }}})).str)), 0);
			return builtin____new_array_with_default(0, 0, sizeof(string), 0);
		}
		int count = vphp_array_count(raw_zval);
		Array_string res = builtin____new_array_with_default(0, count, sizeof(string), 0);
		for (int i = 0; i < count; ++i) {
			zval* item_zval = vphp_array_get_index(raw_zval, ((u32)(i)));
			if (item_zval != 0) {
				#if true
				{
					int len = 0;
					voidptr ptr = ((voidptr)(vphp_get_string_ptr(item_zval, &len)));
					if (ptr != 0) {
						builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(builtin__char_vstring_with_len((((char*)(ptr))), len)) }));
					} else {
						builtin__array_push((array*)&res, _MOV((string[]){ _S("") }));
					}
				}
				#elif false
				{
				}
				#elif false
				{
				}
				#elif false
				{
				}
				#endif
			}
		}
		return res;
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
Map_string_string vphp__Context_arg_T_Map_string_string(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
		;
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if true
	{
		vphp__MapContext m_ctx = ((vphp__MapContext){.m = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
		,});
		vphp_array_each(raw_zval, &m_ctx, ((voidptr)(vphp__map_callback)));
		return builtin__map_clone(&m_ctx.m);
	}
	#endif
	#if false
	{
	}
	#endif
	return builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
}
Array_f64 vphp__Context_arg_T_Array_f64(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return builtin____new_array_with_default(0, 0, sizeof(f64), 0);
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if true
	{
		if (!vphp__Val_is_array(val)) {
			vphp_throw(((char*)(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Expected array at index "), 0xfe07, {.d_i32 = index}}, {_SLIT0, 0, { .d_c = 0 }}})).str)), 0);
			return builtin____new_array_with_default(0, 0, sizeof(f64), 0);
		}
		int count = vphp_array_count(raw_zval);
		Array_f64 res = builtin____new_array_with_default(0, count, sizeof(f64), 0);
		for (int i = 0; i < count; ++i) {
			zval* item_zval = vphp_array_get_index(raw_zval, ((u32)(i)));
			if (item_zval != 0) {
				#if false
				{
				}
				#elif true
				{
					builtin__array_push((array*)&res, _MOV((f64[]){ vphp_get_double(item_zval) }));
				}
				#elif false
				{
				}
				#elif false
				{
				}
				#endif
			}
		}
		return res;
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	return builtin____new_array_with_default(0, 0, sizeof(f64), 0);
}
int vphp__Context_arg_T_int(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return 0;
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if true
	{
		if (!vphp__Val_is_long(val) && !vphp__Val_is_double(val)) {
			vphp_throw(((char*)(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Argument "), 0xfe07, {.d_i32 = index}}, {_S(": expected integer, got "), 0xfe10, {.d_s = vphp__Val_type_name(val)}}, {_SLIT0, 0, { .d_c = 0 }}})).str)), 0);
			return 0;
		}
		return ((int)(vphp_get_int(val.raw)));
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	return 0;
}
bool vphp__Context_arg_T_bool(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len) {
		return 0;
	}
	vphp__Val val = (*(vphp__Val*)builtin__array_get(args, index));
	zval* raw_zval = val.raw;
	#if false
	{
	}
	#endif
	#if true
	{
		if (!vphp__Val_is_bool(val)) {
			vphp_throw(((char*)(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Argument "), 0xfe07, {.d_i32 = index}}, {_S(" must be a boolean"), 0, { .d_c = 0 }}})).str)), 0);
			return false;
		}
		return vphp__Val_to_bool(val);
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	#if false
	{
	}
	#endif
	return 0;
}
void vphp__return_val_T_i64(vphp__Context ctx, i64 val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ctx.ret,});
		#if true
		{
			vphp__Val_set_int(out, val);
		}
		#elif false
		{
		}
		#endif
	}
}
void vphp__return_val_T_string(vphp__Context ctx, string val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ctx.ret,});
		#if false
		{
		}
		#elif true
		{
			vphp__Val_set_string(out, val);
		}
		#endif
	}
}
bool vphp__Context_has_exception(vphp__Context ctx) {
	return vphp_has_exception();
}
void vphp__Context_return_res(vphp__Context ctx, voidptr ptr, string label) {
	vphp_make_res(ctx.ret, ptr, ((char*)(label.str)));
}
void vphp__Context_return_map(vphp__Context ctx, Map_string_string m) {
	vphp_return_array_start(ctx.ret);
	int _t2 = m.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = m.key_values.len - _t2;
		_t2 = m.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&m.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&m.key_values, _t1);
		k = builtin__string_clone(k);
		string v = (*(string*)builtin__DenseArray_value(&m.key_values, _t1));
		vphp_array_add_assoc_string(ctx.ret, ((char*)(k.str)), ((char*)(v.str)));
	}
}
void vphp__Context_return_struct_T_main__MotionReport(vphp__Context ctx, main__MotionReport s) {
	vphp_return_array_start(ctx.ret);
	/* $for field in main.MotionReport.fields */ {
			FieldData field = {0};
		/* field 0 : user_name */ {
			field.name = _S("user_name");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 21;	// string
			field.unaliased_typ = 21;	// string
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			string val = s.user_name;
			#if true
			{
				vphp_array_add_assoc_string(ctx.ret, ((char*)(key.str)), ((char*)(val.str)));
			}
			#elif false
			{
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
		/* field 1 : max_hr */ {
			field.name = _S("max_hr");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 17;	// f64
			field.unaliased_typ = 17;	// f64
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			f64 val = s.max_hr;
			#if false
			{
			}
			#elif true
			{
				vphp_array_add_assoc_double(ctx.ret, ((char*)(key.str)), val);
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
		/* field 2 : min_hr */ {
			field.name = _S("min_hr");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 17;	// f64
			field.unaliased_typ = 17;	// f64
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			f64 val = s.min_hr;
			#if false
			{
			}
			#elif true
			{
				vphp_array_add_assoc_double(ctx.ret, ((char*)(key.str)), val);
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
		/* field 3 : avg_hr */ {
			field.name = _S("avg_hr");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 17;	// f64
			field.unaliased_typ = 17;	// f64
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			f64 val = s.avg_hr;
			#if false
			{
			}
			#elif true
			{
				vphp_array_add_assoc_double(ctx.ret, ((char*)(key.str)), val);
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
		/* field 4 : risk_level */ {
			field.name = _S("risk_level");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 21;	// string
			field.unaliased_typ = 21;	// string
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			string val = s.risk_level;
			#if true
			{
				vphp_array_add_assoc_string(ctx.ret, ((char*)(key.str)), ((char*)(val.str)));
			}
			#elif false
			{
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
		/* field 5 : device_mode */ {
			field.name = _S("device_mode");
			field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 21;	// string
			field.unaliased_typ = 21;	// string
			field.is_pub = false;
			field.is_mut = false;
			field.is_embed = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			string key = field.name;
			string val = s.device_mode;
			#if true
			{
				vphp_array_add_assoc_string(ctx.ret, ((char*)(key.str)), ((char*)(val.str)));
			}
			#elif false
			{
			}
			#elif false || false
			{
			}
			#elif false
			{
			}
			#endif
		}
	}// $for
}
void vphp__Context_return_list_T_main__HeartPoint(vphp__Context ctx, Array_main__HeartPoint list) {
	vphp_return_array_start(ctx.ret);
	if (list.len == 0) {
		return;
	}
	for (int _t1 = 0; _t1 < list.len; ++_t1) {
		main__HeartPoint item = ((main__HeartPoint*)list.data)[_t1];
		zval sub_zv = ((zval){.value = 0,.u1 = {0},});
		vphp_return_array_start(&sub_zv);
		/* $for field in main.HeartPoint.fields */ {
				FieldData field = {0};
			/* field 0 : timestamp */ {
				field.name = _S("timestamp");
				field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				field.typ = 8;	// int
				field.unaliased_typ = 8;	// int
				field.is_pub = false;
				field.is_mut = false;
				field.is_embed = false;
				field.is_shared = false;
				field.is_atomic = false;
				field.is_option = false;
				field.is_array = false;
				field.is_map = false;
				field.is_chan = false;
				field.is_struct = false;
				field.is_alias = false;
				field.is_enum = false;
				field.indirections = 0;
				string key = field.name;
				int val = item.timestamp;
				#if false
				{
				}
				#elif false
				{
				}
				#elif true || false
				{
					vphp_array_add_assoc_long(&sub_zv, ((char*)(key.str)), ((i64)(val)));
				}
				#elif false
				{
				}
				#endif
			}
			/* field 1 : hr */ {
				field.name = _S("hr");
				field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				field.typ = 17;	// f64
				field.unaliased_typ = 17;	// f64
				field.is_pub = false;
				field.is_mut = false;
				field.is_embed = false;
				field.is_shared = false;
				field.is_atomic = false;
				field.is_option = false;
				field.is_array = false;
				field.is_map = false;
				field.is_chan = false;
				field.is_struct = false;
				field.is_alias = false;
				field.is_enum = false;
				field.indirections = 0;
				string key = field.name;
				f64 val = item.hr;
				#if false
				{
				}
				#elif true
				{
					vphp_array_add_assoc_double(&sub_zv, ((char*)(key.str)), val);
				}
				#elif false || false
				{
				}
				#elif false
				{
				}
				#endif
			}
		}// $for
		vphp_array_add_next_zval(ctx.ret, &sub_zv);
	}
}
vphp__Val vphp__Context_arg_raw(vphp__Context ctx, int index) {
	Array_vphp__Val args = vphp__get_args(ctx.ex);
	if (index >= args.len || index < 0) {
		return ((vphp__Val){.raw = 0,});
	}
	return (*(vphp__Val*)builtin__array_get(args, index));
}
void vphp__Context_return_object(vphp__Context ctx, Map_string_string props) {
	{ // Unsafe block
		vphp_object_init(ctx.ret);
		int _t2 = props.key_values.len;
		for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
			int _t3 = props.key_values.len - _t2;
			_t2 = props.key_values.len;
			if (_t3 < 0) {
				_t1 = -1;
				continue;
			}
			if (!builtin__DenseArray_has_index(&props.key_values, _t1)) {continue;}
			string k = *(string*)builtin__DenseArray_key(&props.key_values, _t1);
			k = builtin__string_clone(k);
			string v = (*(string*)builtin__DenseArray_value(&props.key_values, _t1));
			vphp_update_property_string(ctx.ret, ((char*)(k.str)), k.len, ((char*)(v.str)));
		}
	}
}
void vphp__Context_sync_props_T_main__Article(vphp__Context ctx, main__Article* obj) {
	{ // Unsafe block
		/* $for field in main.Article.fields */ {
				FieldData field = {0};
			/* field 0 : id */ {
				field.name = _S("id");
				field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				field.typ = 8;	// int
				field.unaliased_typ = 8;	// int
				field.is_pub = true;
				field.is_mut = false;
				field.is_embed = false;
				field.is_shared = false;
				field.is_atomic = false;
				field.is_option = false;
				field.is_array = false;
				field.is_map = false;
				field.is_chan = false;
				field.is_struct = false;
				field.is_alias = false;
				field.is_enum = false;
				field.indirections = 0;
				string name = field.name;
				int val = obj->id;
				#if false
				{
				}
				#elif true || false
				{
					add_property_long(ctx.ret, ((char*)(name.str)), ((i64)(val)));
				}
				#elif false
				{
				}
				#endif
			}
			/* field 1 : title */ {
				field.name = _S("title");
				field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				field.typ = 21;	// string
				field.unaliased_typ = 21;	// string
				field.is_pub = true;
				field.is_mut = false;
				field.is_embed = false;
				field.is_shared = false;
				field.is_atomic = false;
				field.is_option = false;
				field.is_array = false;
				field.is_map = false;
				field.is_chan = false;
				field.is_struct = false;
				field.is_alias = false;
				field.is_enum = false;
				field.indirections = 0;
				string name = field.name;
				string val = obj->title;
				#if true
				{
					add_property_stringl(ctx.ret, ((char*)(name.str)), ((char*)(val.str)), val.len);
				}
				#elif false || false
				{
				}
				#elif false
				{
				}
				#endif
			}
			/* field 2 : is_top */ {
				field.name = _S("is_top");
				field.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				field.typ = 19;	// bool
				field.unaliased_typ = 19;	// bool
				field.is_pub = true;
				field.is_mut = false;
				field.is_embed = false;
				field.is_shared = false;
				field.is_atomic = false;
				field.is_option = false;
				field.is_array = false;
				field.is_map = false;
				field.is_chan = false;
				field.is_struct = false;
				field.is_alias = false;
				field.is_enum = false;
				field.indirections = 0;
				string name = field.name;
				bool val = obj->is_top;
				#if false
				{
				}
				#elif false || false
				{
				}
				#elif true
				{
					add_property_bool(ctx.ret, ((char*)(name.str)), val);
				}
				#endif
			}
		}// $for
	}
}
VV_LOC void vphp__vphp_framework_init(int module_number) {
	vphp__init_framework(module_number);
}
// export alias: vphp_framework_init -> vphp__vphp_framework_init
void vphp_framework_init(int module_number) {
	return vphp__vphp_framework_init(module_number);
}
void vphp__init_framework(int module_number) {
	vphp_init_resource_system(module_number);
}
void vphp__throw_exception(string msg, int code) {
	vphp_throw(((char*)(msg.str)), code);
}
VV_LOC vphp__TaskRegistry* vphp__get_registry(void) {
	{ // Unsafe block
		if (g_registry == 0) {
			g_registry = ((vphp__TaskRegistry*)builtin__memdup(&(vphp__TaskRegistry){.tasks = builtin__new_map(sizeof(string), sizeof(vphp__TaskCreator), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
			,}, sizeof(vphp__TaskRegistry)));
		}
		return g_registry;
	}
	return 0;
}
void vphp__ITask__static__register(string name, vphp__ITask (*creator)(string json_data)) {
	vphp__TaskRegistry* r = vphp__get_registry();
	builtin__map_set(&r->tasks, &(string[]){name}, &(voidptr[]) { (voidptr)creator });
}
_option_anon_fn_string__vphp__ITask vphp__ITask__static__get_creator(string name) {
	vphp__TaskRegistry* r = vphp__get_registry();
	if (_IN_MAP(ADDR(string, name), ADDR(map, r->tasks))) {
		_option_anon_fn_string__vphp__ITask _t1;
		builtin___option_ok(&(vphp__TaskCreator[]) { (vphp__ITask (*) (string json_data))(*(voidptr*)builtin__map_get(ADDR(map, r->tasks), &(string[]){name}, &(voidptr[]){ 0 })) }, (_option*)(&_t1), sizeof(vphp__TaskCreator));
		 
		return _t1;
	}
	return (_option_anon_fn_string__vphp__ITask){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
VV_LOC void vphp__framework_v_spawn(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	string task_name = vphp__Context_arg_T_string(ctx, 0);
	string json_params = vphp__Context_arg_T_string(ctx, 1);
	_option_anon_fn_string__vphp__ITask _t1 = vphp__ITask__static__get_creator(task_name);
	if (_t1.state != 0) {
		vphp__throw_exception(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Task "), 0xfe10, {.d_s = task_name}}, {_S(" not registered"), 0, { .d_c = 0 }}})), 0);
		return;
	}
	
 	vphp__ITask (*creator) (string json_data) = (*(vphp__TaskCreator*)_t1.data);
	vphp__ITask task_inst = creator(json_params);
	// start go
	thread_arg_vphp__ITask_run *arg__t2 = (thread_arg_vphp__ITask_run *) builtin___v_malloc(sizeof(thread_arg_vphp__ITask_run));
	arg__t2->arg0 = task_inst;
	pthread_t thread__t2;
	pthread_attr_t thread__t2_attributes;
	pthread_attr_init(&thread__t2_attributes);
	pthread_attr_setstacksize(&thread__t2_attributes, 8388608); // fn: run
	int _t2_thr_res = pthread_create(&thread__t2, &thread__t2_attributes, (void*)vphp__ITask_run_thread_wrapper, arg__t2);
	if (_t2_thr_res) builtin__panic_error_number(builtin__tos3("`go vphp__ITask_run()`: "), _t2_thr_res);
	// end go
	__v_thread_Array_f64 t = /*spawn (thread) */
thread__t2;
	{ // Unsafe block
		vphp__zend__AsyncResult* res = ((vphp__zend__AsyncResult*)(builtin___v_malloc(((int)(sizeof(vphp__zend__AsyncResult))))));
		res->handle = t;
		vphp__Context_return_res(ctx, res, _S("v_task"));
	}
}
// export alias: v_spawn -> vphp__framework_v_spawn
void v_spawn(zend_execute_data* ex, zval* retval) {
	return vphp__framework_v_spawn(ex, retval);
}
VV_LOC void vphp__framework_v_wait(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val res_val = vphp__Context_arg_raw(ctx, 0);
	{ // Unsafe block
		voidptr ptr = vphp__Val_to_res(res_val);
		if (ptr == ((void*)0)) {
			return;
		}
		vphp__zend__AsyncResult* task = ((vphp__zend__AsyncResult*)(ptr));
		Array_f64 results = __v_thread_Array_f64_wait(task->handle);
		vphp_return_array_start(retval);
		for (int _t1 = 0; _t1 < results.len; ++_t1) {
			f64 r = ((f64*)results.data)[_t1];
			vphp_array_push_double(retval, ((f64)(r)));
		}
	}
}
// export alias: v_wait -> vphp__framework_v_wait
void v_wait(zend_execute_data* ex, zval* retval) {
	return vphp__framework_v_wait(ex, retval);
}
int vphp__Val_type_id(vphp__Val v) {
	return vphp_get_type(v.raw);
}
bool vphp__Val_is_array(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__array));
}
bool vphp__Val_is_string(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__string));
}
bool vphp__Val_is_long(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__long));
}
bool vphp__Val_is_double(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__double));
}
bool vphp__Val_is_bool(vphp__Val v) {
	int tid = vphp__Val_type_id(v);
	return tid == ((int)(vphp__PHPType__false_)) || tid == ((int)(vphp__PHPType__true_));
}
bool vphp__Val_is_null(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__null));
}
bool vphp__Val_is_object(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__object));
}
vphp__Val vphp__Val_invoke(vphp__Val v, Array_vphp__Val args) {
	if (v.raw == 0) {
		return ((vphp__Val){.raw = 0,});
	}
	{ // Unsafe block
		zval* retval = ((zval*)(builtin___v_malloc(((int)(sizeof(zval))))));
		zval** p_args = ((zval**)(((void*)0)));
		if (args.len > 0) {
			p_args = &(*(vphp__Val*)builtin__array_get(args, 0)).raw;
		}
		int res = vphp_call_callable(v.raw, retval, args.len, p_args);
		if (res == -1) {
			return ((vphp__Val){.raw = 0,});
		}
		return ((vphp__Val){.raw = retval,});
	}
	return (vphp__Val){.raw = 0,};
}
voidptr vphp__Val_to_res(vphp__Val v) {
	return vphp_fetch_res(v.raw);
}
bool vphp__Val_to_bool(vphp__Val v) {
	return vphp__Val_type_id(v) == ((int)(vphp__PHPType__true_));
}
string vphp__Val_type_name(vphp__Val v) {
	int tid = vphp__Val_type_id(v);
	return ((tid == (((int)(vphp__PHPType__undef))))? (_S("undefined")) : (tid == (((int)(vphp__PHPType__null))))? (_S("null")) : (tid == (((int)(vphp__PHPType__false_))))? (_S("boolean")) : (tid == (((int)(vphp__PHPType__true_))))? (_S("boolean")) : (tid == (((int)(vphp__PHPType__long))))? (_S("integer")) : (tid == (((int)(vphp__PHPType__double))))? (_S("float")) : (tid == (((int)(vphp__PHPType__string))))? (_S("string")) : (tid == (((int)(vphp__PHPType__array))))? (_S("array")) : (tid == (((int)(vphp__PHPType__object))))? (_S("object")) : (_S("unknown")));
}
vphp__Val vphp__Val_call(vphp__Val v, string method, Array_vphp__Val args) {
	if (v.raw == 0 || !vphp__Val_is_object(v)) {
		return ((vphp__Val){.raw = 0,});
	}
	{ // Unsafe block
		zval* retval = ((zval*)(builtin___v_malloc(((int)(sizeof(zval))))));
		zval** p_args = ((zval**)(((void*)0)));
		if (args.len > 0) {
			p_args = &(*(vphp__Val*)builtin__array_get(args, 0)).raw;
		}
		int res = vphp_call_method(v.raw, ((char*)(method.str)), method.len, retval, args.len, p_args);
		if (res == -1) {
			return ((vphp__Val){.raw = 0,});
		}
		return ((vphp__Val){.raw = retval,});
	}
	return (vphp__Val){.raw = 0,};
}
_result_vphp__Val vphp__Val_get(vphp__Val v, string key) {
	if (v.raw == 0 || vphp_is_null(v.raw)) {
		return (_result_vphp__Val){ .is_error=true, .err=builtin___v_error(_S("invalid zval or not an array")), .data={E_STRUCT} };
	}
	{ // Unsafe block
		zval* res = vphp_array_get_key(v.raw, ((char*)(key.str)), key.len);
		if (res == 0 || vphp_is_null(res)) {
			return (_result_vphp__Val){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("key \""), 0xfe10, {.d_s = key}}, {_S("\" not found"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		_result_vphp__Val _t3;
		builtin___result_ok(&(vphp__Val[]) { ((vphp__Val){.raw = res,}) }, (_result*)(&_t3), sizeof(vphp__Val));
		 
		return _t3;
	}
	return (_result_vphp__Val){0};
}
string vphp__Val_to_string(vphp__Val v) {
	{ // Unsafe block
		char* p = vphp_get_strval(v.raw);
		int l = vphp_get_strlen(v.raw);
		return builtin__char_vstring_with_len(p, l);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
void vphp__Val_set_string(vphp__Val v, string s) {
	vphp_set_strval(v.raw, ((char*)(s.str)), s.len);
}
i64 vphp__Val_as_int(vphp__Val v) {
	return vphp_get_lval(v.raw);
}
vphp__Val vphp__Val_get_prop(vphp__Val v, string name) {
	if (!vphp__Val_is_object(v)) {
		return ((vphp__Val){.raw = 0,});
	}
	zend_object* obj = vphp_get_obj_from_zval(v.raw);
	zval rv = ((zval){.value = 0,.u1 = {0},});
	zval* res = vphp_read_property_compat(obj, ((char*)(name.str)), name.len, &rv);
	return ((vphp__Val){.raw = res,});
}
string vphp__Val_get_prop_string(vphp__Val v, string name) {
	vphp__Val prop = vphp__Val_get_prop(v, name);
	if (prop.raw == 0 || vphp__Val_is_null(prop)) {
		return _S("");
	}
	return vphp__Val_to_string(prop);
}
int vphp__Val_get_prop_int(vphp__Val v, string name) {
	vphp__Val prop = vphp__Val_get_prop(v, name);
	if (prop.raw == 0) {
		return 0;
	}
	return ((int)(vphp_get_int(prop.raw)));
}
void vphp__Val_set_int(vphp__Val v, i64 val) {
	vphp_set_lval(v.raw, val);
}
void vphp__Val_set_bool(vphp__Val* v, bool b) {
	ZVAL_BOOL(v->raw, b);
}
void vphp__report_error(int level, string msg) {
	vphp_error(level, ((char*)(msg.str)));
}
Array_vphp__Val vphp__get_args(zend_execute_data* ex) {
	int num = ((int)(vphp_get_num_args(ex)));
	Array_vphp__Val res = builtin____new_array_with_default(0, 0, sizeof(vphp__Val), 0);
	for (int i = 1; i < ((int)(num + 1)); ++i) {
		builtin__array_push((array*)&res, _MOV((vphp__Val[]){ ((vphp__Val){.raw = vphp_get_arg_ptr(ex, ((u32)(i))),}) }));
	}
	return res;
}
vphp__Context vphp__new_context(zend_execute_data* ex, zval* ret) {
	return ((vphp__Context){.ex = ex,.ret = ret,});
}
VV_LOC void vphp__map_callback(voidptr p_ctx, char* key, zval* val) {
	vphp__MapContext* ctx = ((vphp__MapContext*)(p_ctx));
	string v_key = builtin__char_vstring(key);
	string v_val = vphp__Val_to_string(((vphp__Val){.raw = val,}));
	builtin__map_set(&ctx->m, &(string[]){v_key}, &(string[]) { v_val });
}
vphp__Val vphp__call_php(string name, Array_vphp__Val args) {
	{ // Unsafe block
		zval retval = ((zval){.value = 0,.u1 = {0},});
		zval** p_args = ((zval**)(((void*)0)));
		if (args.len > 0) {
			p_args = &(*(vphp__Val*)builtin__array_get(args, 0)).raw;
		}
		vphp_call_php_func(((char*)(name.str)), name.len, &retval, args.len, p_args);
		return ((vphp__Val){.raw = &retval,});
	}
	return (vphp__Val){.raw = 0,};
}
void vphp__return_val_raw_T_i64(zval* ret, i64 val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ret,});
		#if true
		{
			vphp__Val_set_int(out, val);
		}
		#elif false
		{
		}
		#elif false
		{
		}
		#endif
	}
}
void vphp__return_val_raw_T_string(zval* ret, string val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ret,});
		#if false
		{
		}
		#elif true
		{
			vphp__Val_set_string(out, val);
		}
		#elif false
		{
		}
		#endif
	}
}
void vphp__return_val_raw_T_bool(zval* ret, bool val) {
	{ // Unsafe block
		vphp__Val out = ((vphp__Val){.raw = ret,});
		#if false
		{
		}
		#elif false
		{
		}
		#elif true
		{
			vphp__Val_set_bool(&out, val);
		}
		#endif
	}
}
Array_string os__args_after(string cut_word) {
	if (_const_os__args.len == 0) {
		return builtin____new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string cargs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (!(Array_string_contains(_const_os__args, cut_word))) {
		cargs = builtin__array_clone_to_depth(&_const_os__args, 1);
	} else {
		bool found = false;
		builtin__array_push((array*)&cargs, _MOV((string[]){ (*(string*)builtin__array_get(_const_os__args, 0)) }));
		Array_string _t3 = builtin__array_slice(_const_os__args, 1, 2147483647);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (builtin__string__eq(a, cut_word)) {
				found = true;
				continue;
			}
			if (!found) {
				continue;
			}
			builtin__array_push((array*)&cargs, _MOV((string[]){ builtin__string_clone(a) }));
		}
	}
	return cargs;
}
Array_string os__args_before(string cut_word) {
	if (_const_os__args.len == 0) {
		return builtin____new_array_with_default(0, 0, sizeof(string), 0);
	}
	Array_string cargs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (!(Array_string_contains(_const_os__args, cut_word))) {
		cargs = builtin__array_clone_to_depth(&_const_os__args, 1);
	} else {
		builtin__array_push((array*)&cargs, _MOV((string[]){ (*(string*)builtin__array_get(_const_os__args, 0)) }));
		Array_string _t3 = builtin__array_slice(_const_os__args, 1, 2147483647);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (builtin__string__eq(a, cut_word)) {
				break;
			}
			builtin__array_push((array*)&cargs, _MOV((string[]){ builtin__string_clone(a) }));
		}
	}
	return cargs;
}
_result_os__Command os__start_new_command(string cmd) {
	os__Command res = ((os__Command){.f = 0,.eof = 0,.exit_code = 0,.path = cmd,.redirect_stdout = 0,});
	_result_void _t1 = os__Command_start(&res);
	if (_t1.is_error) {
		_result_os__Command _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	_result_os__Command _t3;
	builtin___result_ok(&(os__Command[]) { res }, (_result*)(&_t3), sizeof(os__Command));
	 
	return _t3;
}
_result_void os__Command_start(os__Command* c) {
	string pcmd = builtin__string__plus(c->path, _S(" 2>&1"));
	c->f = os__vpopen(pcmd);
	if (builtin__isnil(c->f)) {
		_result_void _t1 = (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("exec(\""), 0xfe10, {.d_s = c->path}}, {_S("\") failed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			{ // defer begin
				builtin__string_free(&pcmd);
			} // defer end
		return _t1;
	}
		{ // defer begin
			builtin__string_free(&pcmd);
		} // defer end
	return (_result_void){0};
}
string os__Command_read_line(os__Command* c) {
	Array_fixed_u8_4096 buf = {0};
	strings__Builder res = strings__new_builder(1024);
	{ // Unsafe block
		u8* bufbp = &buf[0];
		for (;;) {
			if (!(fgets(((char*)(bufbp)), 4096, c->f) != 0)) break;
			int len = builtin__vstrlen(bufbp);
			for (int i = 0; i < len; ++i) {
				if (bufbp[i] == '\n') {
					strings__Builder_write_ptr(&res, bufbp, i);
					string final = strings__Builder_str(&res);
					string _t1 = final;
						{ // defer begin
							strings__Builder_free(&res);
						} // defer end
					return _t1;
				}
			}
			strings__Builder_write_ptr(&res, bufbp, len);
		}
	}
	c->eof = true;
	string final = strings__Builder_str(&res);
	string _t2 = final;
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	return _t2;
}
_result_void os__Command_close(os__Command* c) {
	c->exit_code = os__vpclose(c->f);
	c->f = ((void*)0);
	if (c->exit_code == 127) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(_S("error"), 127), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
bool os__debugger_present(void) {
	{
		int pid = os__fork();
		if (pid == 0) {
			int ppid = os__getppid();
			if (ptrace(PT_TRACE_ME, ppid, ((void*)0), 0) == 0) {
				waitpid(ppid, 0, 0);
				ptrace(PT_DETACH, ppid, 0, 0);
				builtin___v_exit(0);
				VUNREACHABLE();
			} else {
				builtin___v_exit(1);
				VUNREACHABLE();
			}
		} else {
			int status = 0;
			waitpid(pid, &status, 0);
			if (WEXITSTATUS(status) == 0) {
				return false;
			} else {
				return true;
			}
		}
	}
	return false;
}
string os__getenv(string key) {
	_option_string _t2 = os__getenv_opt(key);
	if (_t2.state != 0) {
		*(string*) _t2.data = _S("");
	}
	
 	return (*(string*)_t2.data);
}
_option_string os__getenv_opt(string key) {
	{ // Unsafe block
		#if defined(_WIN32)
		{
		}
		#else
		{
			char* s = getenv(((char*)(key.str)));
			if (s == ((void*)0)) {
				return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
			}
			_option_string _t3;
			builtin___option_ok(&(string[]) { builtin__cstring_to_vstring(s) }, (_option*)(&_t3), sizeof(string));
			 
			return _t3;
		}
		#endif
	}
	return (_option_string){.state=2, .err=_const_none__, .data={E_STRUCT}};
}
int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		{ // Unsafe block
			return setenv(((char*)(name.str)), ((char*)(value.str)), overwrite);
		}
	}
	#endif
	return 0;
}
int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return unsetenv(((char*)(name.str)));
	}
	#endif
	return 0;
}
Map_string_string os__environ(void) {
	Map_string_string res = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	#if defined(_WIN32)
	{
	}
	#else
	{
		char** start = ((char**)(((voidptr)(environ))));
		int i = 0;
		for (;;) {
			char* x = start[i];
			if (x == 0) {
				break;
			}
			string eline = builtin__cstring_to_vstring(x);
			int eq_index = builtin__string_index_u8(eline, '=');
			if (eq_index > 0) {
				builtin__map_set(&res, &(string[]){builtin__string_substr(eline, 0, eq_index)}, &(string[]) { builtin__string_substr(eline, (int)(eq_index + 1), 2147483647) });
			}
			i++;
		}
	}
	#endif
	return res;
}
#if !defined(_WIN32)
#endif
int os__fd_close(int fd) {
	if (fd == -1) {
		return 0;
	}
	return close(fd);
}
void os__fd_write(int fd, string s) {
	if (fd == -1) {
		return;
	}
	u8* sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = ((int)(write(fd, sp, remaining)));
		if (written < 0) {
			return;
		}
		remaining = (int)(remaining - written);
		sp = ((voidptr)((usize)(((usize)(sp)) + ((usize)(written)))));
	}
}
Array_string os__fd_slurp(int fd) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (fd == -1) {
		return res;
	}
	for (;;) {
		multi_return_string_int mr_905 = os__fd_read(fd, 4096);
		string s = mr_905.arg0;
		int b = mr_905.arg1;
		if (b <= 0) {
			break;
		}
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(s) }));
	}
	return res;
}
multi_return_string_int os__fd_read(int fd, int maxbytes) {
	if (fd == -1) {
		return (multi_return_string_int){.arg0=_S(""), .arg1=0};
	}
	{ // Unsafe block
		u8* buf = builtin__malloc_noscan((int)(maxbytes + 1));
		int nbytes = ((int)(read(fd, buf, maxbytes)));
		if (nbytes < 0) {
			builtin___v_free(buf);
			return (multi_return_string_int){.arg0=_S(""), .arg1=nbytes};
		}
		buf[nbytes] = 0;
		return (multi_return_string_int){.arg0=builtin__tos(buf, nbytes), .arg1=nbytes};
	}
	return (multi_return_string_int){0};
}
bool os__fd_is_pending(int fd) {
	fd_set read_set = ((fd_set){E_STRUCT});
	FD_ZERO(&read_set);
	FD_SET(fd, &read_set);
	struct timeval ts = ((struct timeval){.tv_sec = 0,.tv_usec = 0,});
	i32 res = select((int)(fd + 1), &read_set, NULL, NULL, &ts);
	if (res > 0) {
		if (FD_ISSET(fd, &read_set) != 0) {
			return true;
		}
	}
	return false;
}
VV_LOC string os__NotExpected_msg(os__NotExpected err) {
	return err.cause;
}
VV_LOC int os__NotExpected_code(os__NotExpected err) {
	return err.code;
}
VV_LOC string os__fix_windows_path(string path) {
	string p = path;
	return p;
}
__NOINLINE _result_os__File os__open_file(string path, string mode, Array_int options) {
	int flags = 0;
	bool seek_to_end = false;
	for (int _t1 = 0; _t1 < mode.len; ++_t1) {
		u8 m = mode.str[_t1];

		if (m == ('w')) {
			flags |= ((_const_os__o_create | _const_os__o_trunc) | _const_os__o_wronly);
		}
		else if (m == ('a')) {
			flags |= ((_const_os__o_create | _const_os__o_append) | _const_os__o_wronly);
			seek_to_end = true;
		}
		else if (m == ('r')) {
			flags |= _const_os__o_rdonly;
		}
		else if (m == ('b')) {
			flags |= _const_os__o_binary;
		}
		else if (m == ('s')) {
			flags |= _const_os__o_sync;
		}
		else if (m == ('n')) {
			flags |= _const_os__o_nonblock;
		}
		else if (m == ('c')) {
			flags |= _const_os__o_noctty;
		}
		else if (m == ('+')) {
			flags &= ~_const_os__o_wronly;
			flags |= _const_os__o_rdwr;
		}
		else {
		}
	}
	if (_SLIT_EQ(mode.str, mode.len, "r+")) {
		flags = _const_os__o_rdwr;
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = (*(int*)builtin__array_get(options, 0));
	}
	string p = os__fix_windows_path(path);
	i32 _t2;
	#if defined(_WIN32)
	#else
		_t2 = open(((char*)(p.str)), flags, permission);
		;
	#endif
		i32 fd = _t2;
	if (fd == -1) {
		return (_result_os__File){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
	}
	FILE* cfile = fdopen(fd, ((char*)(mode.str)));
	if (builtin__isnil(cfile)) {
		return (_result_os__File){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Failed to open or create file \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	os__File res = ((os__File){.cfile = (voidptr)cfile,.fd = fd,.is_opened = true,});
	if (seek_to_end) {
		_result_void _t5 = os__File_seek(&res, 0, os__SeekMode__end);
		(void)_t5;
 ;
	}
	_result_os__File _t6;
	builtin___result_ok(&(os__File[]) { res }, (_result*)(&_t6), sizeof(os__File));
	 
	return _t6;
}
_result_os__File os__open(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _S("rb"));
	if (_t1.is_error) {
		_result_os__File _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	FILE* cfile = (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3;
	builtin___result_ok(&(os__File[]) { ((os__File){.cfile = (voidptr)cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	 
	return _t3;
}
__NOINLINE _result_os__File os__create(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _S("wb"));
	if (_t1.is_error) {
		_result_os__File _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	FILE* cfile = (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3;
	builtin___result_ok(&(os__File[]) { ((os__File){.cfile = (voidptr)cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	 
	return _t3;
}
os__File os__stdin(void) {
	return ((os__File){.cfile = ((voidptr)(stdin)),.fd = 0,.is_opened = true,});
}
os__File os__stdout(void) {
	return ((os__File){.cfile = ((voidptr)(stdout)),.fd = 1,.is_opened = true,});
}
os__File os__stderr(void) {
	return ((os__File){.cfile = ((voidptr)(stderr)),.fd = 2,.is_opened = true,});
}
bool os__File_eof(os__File* f) {
	FILE* cfile = ((FILE*)(f->cfile));
	return feof(cfile) != 0;
}
_result_void os__File_reopen(os__File* f, string path, string mode) {
	string p = os__fix_windows_path(path);
	FILE* cfile = ((FILE*)(((void*)0)));
	#if defined(_WIN32)
	{
	}
	#else
	{
		cfile = freopen(((char*)(p.str)), ((char*)(mode.str)), f->cfile);
	}
	#endif
	if (builtin__isnil(cfile)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Failed to reopen file \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	f->cfile = cfile;
	return (_result_void){0};
}
_result_int os__File_read(os__File* f, Array_u8* buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)builtin__memdup(&(os__Eof){.Error = ((Error){E_STRUCT}),}, sizeof(os__Eof)))), .data={E_STRUCT} };
	}
	int nbytes = ((int)(fread(buf->data, 1, buf->len, ((FILE*)(f->cfile)))));
	if (nbytes <= 0) {
		if (feof(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)builtin__memdup(&(os__Eof){.Error = ((Error){E_STRUCT}),}, sizeof(os__Eof)))), .data={E_STRUCT} };
		}
		if (ferror(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__NotExpected_to_Interface_IError(((os__NotExpected*)builtin__memdup(&(os__NotExpected){.cause = _S("unexpected error from fread"),.code = -1,}, sizeof(os__NotExpected)))), .data={E_STRUCT} };
		}
	}
	_result_int _t5;
	builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t5), sizeof(int));
	 
	return _t5;
}
_result_int os__File_write(os__File* f, Array_u8 buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	int written = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("0 bytes written")), .data={E_STRUCT} };
	}
	_result_int _t3;
	builtin___result_ok(&(int[]) { written }, (_result*)(&_t3), sizeof(int));
	 
	return _t3;
}
_result_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	_result_int _t2 = os__File_write_string(f, s);
	if (_t2.is_error) {
		_result_int _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	int written = (*(int*)_t2.data);
	i32 x = fputs("\n", f->cfile);
	if (x < 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("could not add newline")), .data={E_STRUCT} };
	}
	_result_int _t5;
	builtin___result_ok(&(int[]) { (int)(written + 1) }, (_result*)(&_t5), sizeof(int));
	 
	return _t5;
}
_result_int os__File_write_string(os__File* f, string s) {
		_result_void _t1 = os__File_write_full_buffer(f, s.str, ((usize)(s.len)));
	if (_t1.is_error) {
		_result_int _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	_result_int _t3;
	builtin___result_ok(&(int[]) { s.len }, (_result*)(&_t3), sizeof(int));
	 
	return _t3;
}
_result_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	_result_void _t2 = os__File_seek(f, pos, os__SeekMode__start);
	(void)_t2;
 ;
	int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (res == 0 && buf.len != 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("0 bytes written")), .data={E_STRUCT} };
	}
	_result_void _t4 = os__File_seek(f, 0, os__SeekMode__end);
	(void)_t4;
 ;
	_result_int _t5;
	builtin___result_ok(&(int[]) { res }, (_result*)(&_t5), sizeof(int));
	 
	return _t5;
}
int os__File_write_ptr(os__File* f, voidptr data, int size) {
	return ((int)(fwrite(data, 1, size, f->cfile)));
}
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len) {
	if (buffer_len <= ((usize)(0))) {
		return (_result_void){0};
	}
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	u8* ptr = ((u8*)(buffer));
	i64 remaining_bytes = ((i64)(buffer_len));
	for (;;) {
		if (!(remaining_bytes > 0)) break;
		{ // Unsafe block
			errno = 0;
			i64 x = ((i64)(fwrite(ptr, 1, remaining_bytes, f->cfile)));
			int cerror = ((int)(errno));
			ptr += x;
			remaining_bytes -= x;
			if (cerror != 0) {
				if (cerror == EINTR) {
					continue;
				}
				if (((i64)(x)) != ((i64)(buffer_len))) {
					return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(cerror)), .data={E_STRUCT} };
				}
			}
			if (x <= 0) {
				return (_result_void){ .is_error=true, .err=builtin___v_error(_S("C.fwrite returned 0")), .data={E_STRUCT} };
			}
		}
	}
	return (_result_void){0};
}
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos) {
	_result_void _t1 = os__File_seek(f, pos, os__SeekMode__start);
	(void)_t1;
 ;
	int res = ((int)(fwrite(data, 1, size, f->cfile)));
	_result_void _t2 = os__File_seek(f, 0, os__SeekMode__end);
	(void)_t2;
 ;
	return res;
}
VV_LOC _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream) {
	int nbytes = ((int)(fread(ptr, item_size, items, stream)));
	if (nbytes <= 0) {
		if (feof(stream) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)builtin__memdup(&(os__Eof){.Error = ((Error){E_STRUCT}),}, sizeof(os__Eof)))), .data={E_STRUCT} };
		}
		if (ferror(stream) != 0) {
			return (_result_int){ .is_error=true, .err=builtin___v_error(_S("file read error")), .data={E_STRUCT} };
		}
	}
	_result_int _t3;
	builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t3), sizeof(int));
	 
	return _t3;
}
Array_u8 os__File_read_bytes(os__File* f, int size) {
	return os__File_read_bytes_at(f, size, 0);
}
Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos) {
	Array_u8 arr = builtin____new_array_with_default(size, 0, sizeof(u8), 0);
	_result_int _t1 = os__File_read_bytes_into(f, pos, &arr);
	if (_t1.is_error) {
		return builtin____new_array_with_default(0, 0, sizeof(u8), 0);
	}
	
 	int nreadbytes = (*(int*)_t1.data);
	return builtin__array_slice(arr, 0, nreadbytes);
}
_result_int os__File_read_bytes_with_newline(os__File* f, Array_u8* buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__string__plus(_S("read_bytes_with_newline"), _S(": `buf.len` == 0"))), .data={E_STRUCT} };
	}
	int newline = 10;
	int c = 0;
	int buf_ptr = 0;
	int nbytes = 0;
	FILE* stream = ((FILE*)(f->cfile));
	for (;;) {
		if (!((buf_ptr < buf->len))) break;
		c = getc(stream);

		if (c == (EOF)) {
			if (feof(stream) != 0) {
				_result_int _t3;
				builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t3), sizeof(int));
				 
				return _t3;
			}
			if (ferror(stream) != 0) {
				return (_result_int){ .is_error=true, .err=builtin___v_error(_S("file read error")), .data={E_STRUCT} };
			}
		}
		else if (c == (newline)) {
			builtin__array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			nbytes++;
			_result_int _t5;
			builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t5), sizeof(int));
			 
			return _t5;
		}
		else {
			builtin__array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			buf_ptr++;
			nbytes++;
		}
	}
	_result_int _t6;
	builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
	 
	return _t6;
}
_result_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__string__plus(_S("read_bytes_into"), _S(": `buf.len` == 0"))), .data={E_STRUCT} };
	}
		_result_void _t3 = os__File_seek(f, pos, os__SeekMode__start);
	(void)_t3;
 ;
	_result_int _t4 = os__fread(buf->data, 1, buf->len, f->cfile);
	if (_t4.is_error) {
		_result_int _t5 = {0};
		_t5.is_error = true;
		_t5.err = _t4.err;
		return _t5;
	}
	
 	int nbytes = (*(int*)_t4.data);
	_result_int _t6;
	builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
	 
	return _t6;
}
_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	if (buf->len == 0) {
		_result_int _t2;
		builtin___result_ok(&(int[]) { 0 }, (_result*)(&_t2), sizeof(int));
		 
		return _t2;
	}
		_result_void _t3 = os__File_seek(f, pos, os__SeekMode__start);
	(void)_t3;
 ;
	_result_int _t4 = os__fread(buf->data, 1, buf->len, f->cfile);
	if (_t4.is_error) {
		_result_int _t5 = {0};
		_t5.is_error = true;
		_t5.err = _t4.err;
		return _t5;
	}
	
 	int nbytes = (*(int*)_t4.data);
	_result_int _t6;
	builtin___result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
	 
	return _t6;
}
_result_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	return os__fread(ptr, 1, max_size, f->cfile);
}
void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}
string os__FileNotOpenedError_msg(os__FileNotOpenedError err) {
	return _S("os: file not opened");
}
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err) {
	return _S("os: size of type is 0");
}
VV_LOC IError os__error_file_not_opened(void) {
	return I_os__FileNotOpenedError_to_Interface_IError(((os__FileNotOpenedError*)builtin__memdup(&(os__FileNotOpenedError){.Error = ((Error){E_STRUCT}),}, sizeof(os__FileNotOpenedError))));
}
_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode) {
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	int whence = ((int)(mode));
	int res = 0;
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = fseeko(f->cfile, pos, whence);
		}
		#endif
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
_result_i64 os__File_tell(os__File* f) {
	if (!f->is_opened) {
		return (_result_i64){ .is_error=true, .err=os__error_file_not_opened(), .data={E_STRUCT} };
	}
	i64 pos = ((i64)(0));
	int ret = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		pos = ((i64)(ftell(f->cfile)));
	}
	#endif
	if (ret == -1 || pos == -1) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
	}
	_result_i64 _t4;
	builtin___result_ok(&(i64[]) { pos }, (_result*)(&_t4), sizeof(i64));
	 
	return _t4;
}
int os__File_setvbuf(os__File* f, char* buffer, os__FileBufferMode mode, usize size) {
	return setvbuf(f->cfile, buffer, ((int)(mode)), size);
}
int os__File_set_buffer(os__File* f, Array_u8* buffer, os__FileBufferMode mode) {
	return os__File_setvbuf(f, ((char*)(buffer->data)), mode, ((usize)(buffer->len)));
}
void os__File_set_line_buffered(os__File* f) {
	os__File_setvbuf(f, ((char*)(((void*)0))), os__FileBufferMode__line_buffered, ((usize)(0)));
}
void os__File_set_unbuffered(os__File* f) {
	os__File_setvbuf(f, ((char*)(((void*)0))), os__FileBufferMode__not_buffered, ((usize)(0)));
}
_result_void os__File_write_u8(os__File* f, u8 b) {
	errno = 0;
	_result_void _t1 = os__check_fwrite(fwrite(((voidptr)(&b)), 1, 1, f->cfile));
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_u8 os__File_read_u8(os__File* f) {
	u8 res = ((u8)(0));
	errno = 0;
	_result_void _t1 = os__check_fread(fread(((voidptr)(&res)), 1, 1, f->cfile));
	if (_t1.is_error) {
		_result_u8 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	_result_u8 _t3;
	builtin___result_ok(&(u8[]) { res }, (_result*)(&_t3), sizeof(u8));
	 
	return _t3;
}
VV_LOC _result_void os__check_cf(usize x, string label) {
	if (errno != 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
	}
	if (x == 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(label), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
VV_LOC _result_void os__check_fwrite(usize x) {
	_result_void _t1 = os__check_cf(x, _S("fwrite"));
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
VV_LOC _result_void os__check_fread(usize x) {
	_result_void _t1 = os__check_cf(x, _S("fread"));
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
bool os__is_abs_path(string path) {
	if ((path).len == 0) {
		return false;
	}
	return builtin__string_at(path, 0) == _const_os__fslash;
}
string os__abs_path(string path) {
	string wd = os__getwd();
	if ((path).len == 0) {
		return wd;
	}
	string npath = os__norm_path(path);
	if (_SLIT_EQ(npath.str, npath.len, ".")) {
		return wd;
	}
	if (!os__is_abs_path(npath)) {
		strings__Builder sb = strings__new_builder(npath.len);
		strings__Builder_write_string(&sb, wd);
		strings__Builder_write_string(&sb, _const_os__path_separator);
		strings__Builder_write_string(&sb, npath);
		return os__norm_path(strings__Builder_str(&sb));
	}
	return npath;
}
string os__norm_path(string path) {
	if ((path).len == 0) {
		return _const_os__dot_str;
	}
	bool rooted = os__is_abs_path(path);
	int volume_len = os__win_volume_len(path);
	string volume = builtin__string_substr(path, 0, volume_len);
	if (volume_len != 0 && builtin__string_contains(volume, _const_os__fslash_str)) {
		volume = builtin__string_replace(volume, _const_os__fslash_str, _const_os__path_separator);
	}
	string cpath = os__clean_path(builtin__string_substr(path, volume_len, 2147483647));
	if ((cpath).len == 0 && volume_len == 0) {
		return _const_os__dot_str;
	}
	Array_string spath = builtin__string_split(cpath, _const_os__path_separator);
	if (!(Array_string_contains(spath, _S("..")))) {
		return (volume_len != 0 ? (builtin__string__plus(volume, cpath)) : (cpath));
	}
	int spath_len = spath.len;
	strings__Builder sb = strings__new_builder(cpath.len);
	if (rooted) {
		strings__Builder_write_string(&sb, _const_os__path_separator);
	}
	Array_string new_path = builtin____new_array_with_default(0, spath_len, sizeof(string), 0);
	int backlink_count = 0;
	for (int i = (int)(spath_len - 1); i >= 0; i--) {
		string part = ((string*)spath.data)[i];
		if ((part).len == 0) {
			continue;
		}
		if (_SLIT_EQ(part.str, part.len, "..")) {
			backlink_count++;
			continue;
		}
		if (backlink_count != 0) {
			backlink_count--;
			continue;
		}
		builtin__array_prepend(&new_path, &(string[]){part});
	}
	if (backlink_count != 0 && !rooted) {
		for (int i = 0; i < backlink_count; ++i) {
			strings__Builder_write_string(&sb, _const_os__dot_dot);
			if (new_path.len == 0 && i == (int)(backlink_count - 1)) {
				break;
			}
			strings__Builder_write_string(&sb, _const_os__path_separator);
		}
	}
	strings__Builder_write_string(&sb, Array_string_join(new_path, _const_os__path_separator));
	string res = strings__Builder_str(&sb);
	if (res.len == 0) {
		if (volume_len != 0) {
			return volume;
		}
		if (!rooted) {
			return _const_os__dot_str;
		}
		return _const_os__path_separator;
	}
	if (volume_len != 0) {
		return builtin__string__plus(volume, res);
	}
	return res;
}
_result_string os__existing_path(string path) {
	IError err = builtin___v_error(_S("path does not exist"));
	if ((path).len == 0) {
		return (_result_string){ .is_error=true, .err=err, .data={E_STRUCT} };
	}
	if (os__exists(path)) {
		_result_string _t2;
		builtin___result_ok(&(string[]) { path }, (_result*)(&_t2), sizeof(string));
		 
		return _t2;
	}
	int volume_len = 0;
	if (volume_len > 0 && os__is_slash(builtin__string_at(path, (int)(volume_len - 1)))) {
		volume_len++;
	}
	strings__textscanner__TextScanner sc = strings__textscanner__new(builtin__string_substr(path, volume_len, 2147483647));
	string recent_path = builtin__string_substr(path, 0, volume_len);
	for (;;) {
		if (!(strings__textscanner__TextScanner_next(&sc) != -1)) break;
		u8 curr = ((u8)(strings__textscanner__TextScanner_current(&sc)));
		int peek = strings__textscanner__TextScanner_peek(&sc);
		int back = strings__textscanner__TextScanner_peek_back(&sc);
		if (os__is_curr_dir_ref(back, curr, peek)) {
			continue;
		}
		int range = (int)((int)(sc.ilen - strings__textscanner__TextScanner_remaining(&sc)) + volume_len);
		if (os__is_slash(curr) && !os__is_slash(((u8)(peek)))) {
			recent_path = builtin__string_substr(path, 0, range);
			continue;
		}
		if (!os__is_slash(curr) && (peek == -1 || os__is_slash(((u8)(peek))))) {
			string curr_path = builtin__string_substr(path, 0, range);
			if (os__exists(curr_path)) {
				recent_path = curr_path;
				continue;
			}
			if ((recent_path).len == 0) {
				break;
			}
			_result_string _t3;
			builtin___result_ok(&(string[]) { recent_path }, (_result*)(&_t3), sizeof(string));
			 
			return _t3;
		}
	}
	return (_result_string){ .is_error=true, .err=err, .data={E_STRUCT} };
}
VV_LOC string os__clean_path(string path) {
	if ((path).len == 0) {
		return _const_os__empty_str;
	}
	strings__Builder sb = strings__new_builder(path.len);
	strings__textscanner__TextScanner sc = strings__textscanner__new(path);
	for (;;) {
		if (!(strings__textscanner__TextScanner_next(&sc) != -1)) break;
		u8 curr = ((u8)(strings__textscanner__TextScanner_current(&sc)));
		int back = strings__textscanner__TextScanner_peek_back(&sc);
		int peek = strings__textscanner__TextScanner_peek(&sc);
		if (back != -1 && os__is_slash(((u8)(back))) && os__is_slash(curr)) {
			continue;
		}
		if (os__is_curr_dir_ref(back, curr, peek)) {
			if (peek != -1 && os__is_slash(((u8)(peek)))) {
				strings__textscanner__TextScanner_skip_n(&sc, 1);
			}
			continue;
		}
		strings__Builder_write_u8(&sb, ((u8)(strings__textscanner__TextScanner_current(&sc))));
	}
	string res = strings__Builder_str(&sb);
	if (res.len > 1 && os__is_slash(builtin__string_at(res, (int)(res.len - 1)))) {
		return builtin__string_substr(res, 0, (int)(res.len - 1));
	}
	return res;
}
string os__to_slash(string path) {
	string _t2;
	#if defined(_WIN32)
	#else
		_t2 = path;
		;
	#endif
		return _t2;
}
string os__from_slash(string path) {
	string _t2;
	#if defined(_WIN32)
	#else
		_t2 = path;
		;
	#endif
		return _t2;
}
VV_LOC int os__win_volume_len(string path) {
	#if !defined(_WIN32)
	{
		return 0;
	}
	#endif
	int plen = path.len;
	if (plen < 2) {
		return 0;
	}
	if (os__has_drive_letter(path)) {
		return 2;
	}
	if (plen >= 5 && os__starts_w_slash_slash(path) && !os__is_slash(builtin__string_at(path, 2))) {
		for (int i = 3; i < plen; i++) {
			if (os__is_slash(builtin__string_at(path, i))) {
				if ((int)(i + 1) >= plen || os__is_slash(builtin__string_at(path, (int)(i + 1)))) {
					break;
				}
				i++;
				for (; i < plen; i++) {
					if (os__is_slash(builtin__string_at(path, i))) {
						return i;
					}
				}
				return i;
			}
		}
	}
	return 0;
}
VV_LOC bool os__is_slash(u8 b) {
	return b == _const_os__fslash;
}
VV_LOC bool os__has_drive_letter(string path) {
	return path.len >= 2 && builtin__u8_is_letter(builtin__string_at(path, 0)) && builtin__string_at(path, 1) == ':';
}
VV_LOC bool os__starts_w_slash_slash(string path) {
	return path.len >= 2 && os__is_slash(builtin__string_at(path, 0)) && os__is_slash(builtin__string_at(path, 1));
}
VV_LOC bool os__is_curr_dir_ref(int byte_one, int byte_two, int byte_three) {
	if (((u8)(byte_two)) != _const_os__dot) {
		return false;
	}
	return (byte_one < 0 || os__is_slash(((u8)(byte_one)))) && (byte_three < 0 || os__is_slash(((u8)(byte_three))));
}
u32 os__FilePermission_bitmask(os__FilePermission p) {
	u32 mask = ((u32)(0));
	if (p.read) {
		mask |= 4;
	}
	if (p.write) {
		mask |= 2;
	}
	if (p.execute) {
		mask |= 1;
	}
	return mask;
}
u32 os__FileMode_bitmask(os__FileMode m) {
	return (((os__FilePermission_bitmask(m.owner) << 6) | (os__FilePermission_bitmask(m.group) << 3)) | os__FilePermission_bitmask(m.others));
}
os__FileInfo os__inode(string path) {
	_result_os__Stat _t1 = os__lstat(path);
	if (_t1.is_error) {
		*(os__Stat*) _t1.data = ((os__Stat){.dev = 0,.inode = 0,.mode = 0,.nlink = 0,.uid = 0,.gid = 0,.rdev = 0,.size = 0,.atime = 0,.mtime = 0,.ctime = 0,});
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	os__FileMode fm = os__Stat_get_mode(attr);
	return ((os__FileInfo){
		.FileMode = ((os__FileMode){.typ = fm.typ,.owner = fm.owner,.group = fm.group,.others = fm.others,}),
		.size = attr.size,
		.mtime = attr.mtime,
	});
}
_result_Array_u8 os__read_bytes(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _S("rb"));
	if (_t1.is_error) {
		_result_Array_u8 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	FILE* fp = (*(FILE**)_t1.data);
	_result_int _t3 = os__find_cfile_size(fp);
	if (_t3.is_error) {
		{ // defer begin
			fclose(fp);
		} // defer end
		_result_Array_u8 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	int fsize = (*(int*)_t3.data);
	if (fsize == 0) {
		_result_strings__Builder _t5 = os__slurp_file_in_builder(fp);
		if (_t5.is_error) {
			{ // defer begin
				fclose(fp);
			} // defer end
			_result_Array_u8 _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 		strings__Builder sb = (*(strings__Builder*)_t5.data);
		_result_Array_u8 _t7;
		builtin___result_ok(&(Array_u8[]) { strings__Builder_reuse_as_plain_u8_array(&sb) }, (_result*)(&_t7), sizeof(Array_u8));
		 
			{ // defer begin
				fclose(fp);
			} // defer end
		return _t7;
	}
	Array_u8 res = builtin____new_array_with_default(fsize, 0, sizeof(u8), 0);
	int nr_read_elements = ((int)(fread(res.data, 1, fsize, fp)));
	if (nr_read_elements == 0 && fsize > 0) {
		_result_Array_u8 _t8 = (_result_Array_u8){ .is_error=true, .err=builtin___v_error(_S("fread failed")), .data={E_STRUCT} };
			{ // defer begin
				fclose(fp);
			} // defer end
		return _t8;
	}
	builtin__array_trim(&res, nr_read_elements);
	_result_Array_u8 _t9;
	builtin___result_ok(&(Array_u8[]) { res }, (_result*)(&_t9), sizeof(Array_u8));
	 
		{ // defer begin
			fclose(fp);
		} // defer end
	return _t9;
}
_result_void os__write_bytes(string path, Array_u8 bytes) {
	_result_void _t1 = os__write_file_array(path, bytes);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
VV_LOC _result_int os__find_cfile_size(FILE* fp) {
	i32 cseek = fseek(fp, 0, SEEK_END);
	isize raw_fsize = ftell(fp);
	if (raw_fsize != 0 && cseek != 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("fseek failed")), .data={E_STRUCT} };
	}
	if (cseek != 0 && raw_fsize < 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("ftell failed")), .data={E_STRUCT} };
	}
	int len = ((int)(raw_fsize));
	if (((i64)(len)) < raw_fsize) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("int("), 0xfe09, {.d_i64 = raw_fsize}}, {_S(") cast results in "), 0xfe07, {.d_i32 = len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	rewind(fp);
	_result_int _t4;
	builtin___result_ok(&(int[]) { len }, (_result*)(&_t4), sizeof(int));
	 
	return _t4;
}
VV_LOC _result_strings__Builder os__slurp_file_in_builder(FILE* fp) {
	Array_fixed_u8_4096 buf = {0};
	strings__Builder sb = strings__new_builder(_const_os__buf_size);
	for (;;) {
		_result_int _t1 = os__fread(&buf[0], 1, _const_os__buf_size, fp);
		if (_t1.is_error) {
			IError err = _t1.err;
			if ((err)._typ == _IError_os__Eof_index) {
				break;
			}
			strings__Builder_free(&sb);
			return (_result_strings__Builder){ .is_error=true, .err=err, .data={E_STRUCT} };
		}
		
 		int read_bytes = (*(int*)_t1.data);
		strings__Builder_write_ptr(&sb, &buf[0], read_bytes);
	}
	_result_strings__Builder _t3;
	builtin___result_ok(&(strings__Builder[]) { sb }, (_result*)(&_t3), sizeof(strings__Builder));
	 
	return _t3;
}
_result_string os__read_file(string path) {
	string mode = _S("rb");
	_result_FILE_ptr _t1 = os__vfopen(path, mode);
	if (_t1.is_error) {
		_result_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	FILE* fp = (*(FILE**)_t1.data);
	_result_int _t3 = os__find_cfile_size(fp);
	if (_t3.is_error) {
		{ // defer begin
			fclose(fp);
		} // defer end
		_result_string _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	int allocate = (*(int*)_t3.data);
	if (allocate == 0) {
		_result_strings__Builder _t5 = os__slurp_file_in_builder(fp);
		if (_t5.is_error) {
			{ // defer begin
				fclose(fp);
			} // defer end
			_result_string _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 		strings__Builder sb = (*(strings__Builder*)_t5.data);
		string res = strings__Builder_str(&sb);
		strings__Builder_free(&sb);
		_result_string _t7;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t7), sizeof(string));
		 
			{ // defer begin
				fclose(fp);
			} // defer end
		return _t7;
	}
	{ // Unsafe block
		u8* str = builtin__malloc_noscan((int)(allocate + 1));
		int nelements = ((int)(fread(str, 1, allocate, fp)));
		int is_eof = ((int)(feof(fp)));
		int is_error = ((int)(ferror(fp)));
		if (is_eof == 0 && is_error != 0) {
			builtin___v_free(str);
			_result_string _t8 = (_result_string){ .is_error=true, .err=builtin___v_error(_S("fread failed")), .data={E_STRUCT} };
				{ // defer begin
					fclose(fp);
				} // defer end
			return _t8;
		}
		str[nelements] = 0;
		if (nelements == 0) {
			_result_string _t9;
			builtin___result_ok(&(string[]) { builtin__u8_vstring(str) }, (_result*)(&_t9), sizeof(string));
			 
				{ // defer begin
					fclose(fp);
				} // defer end
			return _t9;
		}
		_result_string _t10;
		builtin___result_ok(&(string[]) { builtin__u8_vstring_with_len(str, nelements) }, (_result*)(&_t10), sizeof(string));
		 
			{ // defer begin
				fclose(fp);
			} // defer end
		return _t10;
	}
	return (_result_string){0};
}
_result_void os__truncate(string path, u64 len) {
	i32 _t1;
	#if defined(_WIN32)
	#else
		_t1 = open(((char*)(path.str)), (_const_os__o_wronly | _const_os__o_trunc), 0);
		;
	#endif
		i32 fp = _t1;
	if (fp < 0) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (ftruncate(fp, len) != 0) {
			_result_void _t4 = (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
				{ // defer begin
					close(fp);
				} // defer end
			return _t4;
		}
	}
	#endif
		{ // defer begin
			close(fp);
		} // defer end
	return (_result_void){0};
}
u64 os__file_size(string path) {
	_result_os__Stat _t1 = os__stat(path);
	if (_t1.is_error) {
		builtin__eprintln(builtin__string__plus(_S("os.file_size() Cannot determine file-size: "), os__posix_get_error_msg(errno)));
		return 0;
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	return attr.size;
}
_result_void os__rename_dir(string src, string dst) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		i32 ret = rename(((char*)(src.str)), ((char*)(dst.str)));
		if (ret != 0) {
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("failed to rename "), 0xfe10, {.d_s = src}}, {_S(" to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ret), .data={E_STRUCT} };
		}
	}
	#endif
	return (_result_void){0};
}
_result_void os__rename(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path_single(builtin__string_trim_right(rdst, _const_os__path_separator), os__file_name(builtin__string_trim_right(src, _const_os__path_separator)));
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		i32 ret = rename(((char*)(src.str)), ((char*)(rdst.str)));
		if (ret != 0) {
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("failed to rename "), 0xfe10, {.d_s = src}}, {_S(" to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ret), .data={E_STRUCT} };
		}
	}
	#endif
	return (_result_void){0};
}
_result_void os__cp(string src, string dst, os__CopyParams config) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		string w_dst = dst;
		if (os__is_dir(dst)) {
			w_dst = os__join_path_single(w_dst, os__file_name(src));
		}
		i32 fp_from = open(((char*)(src.str)), O_RDONLY, 0);
		if (fp_from < 0) {
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cp: failed to open "), 0xfe10, {.d_s = src}}, {_S(" for reading"), 0, { .d_c = 0 }}})), ((int)(fp_from))), .data={E_STRUCT} };
		}
		int mode_flags = (S_IWUSR | S_IRUSR);
		int open_flags = ((O_WRONLY | O_CREAT) | O_TRUNC);
		if (config.fail_if_exists) {
			open_flags |= O_EXCL;
		}
		i32 fp_to = open(((char*)(w_dst.str)), open_flags, mode_flags);
		if (fp_to < 0) {
			close(fp_from);
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cp: failed to open "), 0xfe10, {.d_s = w_dst}}, {_S(" for writing"), 0, { .d_c = 0 }}})), ((int)(fp_to))), .data={E_STRUCT} };
		}
		Array_fixed_u8_1024 buf = {0};
		int count = ((int)(0));
		for (;;) {
			count = ((int)(read(fp_from, &buf[0], sizeof(Array_fixed_u8_1024))));
			if (count == 0) {
				break;
			}
			if (write(fp_to, &buf[0], count) < 0) {
				close(fp_to);
				close(fp_from);
				return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cp: failed to write to "), 0xfe10, {.d_s = w_dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(-1))), .data={E_STRUCT} };
			}
		}
		_result_os__Stat _t5 = os__stat(src);
		if (_t5.is_error) {
			_result_void _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 		os__Stat from_attr = (*(os__Stat*)_t5.data);
		if (chmod(((char*)(w_dst.str)), from_attr.mode) < 0) {
			close(fp_to);
			close(fp_from);
			return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to set permissions for "), 0xfe10, {.d_s = w_dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(-1))), .data={E_STRUCT} };
		}
		close(fp_to);
		close(fp_from);
	}
	#endif
	return (_result_void){0};
}
_result_FILE_ptr os__vfopen(string path, string mode) {
	if ((path).len == 0) {
		return (_result_FILE_ptr){ .is_error=true, .err=builtin___v_error(_S("vfopen called with \"\"")), .data={E_STRUCT} };
	}
	voidptr fp = ((void*)0);
	#if defined(_WIN32)
	{
	}
	#else
	{
		fp = fopen(((char*)(path.str)), ((char*)(mode.str)));
	}
	#endif
	if (builtin__isnil(((voidptr)(fp)))) {
		return (_result_FILE_ptr){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to open file \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}})),.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	} else {
		_result_FILE_ptr _t4;
		builtin___result_ok(&(FILE*[]) { fp }, (_result*)(&_t4), sizeof(FILE*));
		 
		return _t4;
	}
	return (_result_FILE_ptr){0};
}
int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		FILE* cfile_casted = ((FILE*)(((void*)0)));
		cfile_casted = cfile;
		return fileno(cfile_casted);
	}
	#endif
	return 0;
}
VV_LOC voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		u8* cpath = path.str;
		return popen(((char*)(cpath)), "r");
	}
	#endif
	return 0;
}
VV_LOC multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int ret = 0;
		bool is_signaled = true;
		if (WIFEXITED(waitret)) {
			ret = WEXITSTATUS(waitret);
			is_signaled = false;
		} else if (WIFSIGNALED(waitret)) {
			ret = WTERMSIG(waitret);
			is_signaled = true;
		}
		return (multi_return_int_bool){.arg0=ret, .arg1=is_signaled};
	}
	#endif
	return (multi_return_int_bool){0};
}
string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		return _S("");
	}
	return builtin__tos3(ptr_text);
}
VV_LOC int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		multi_return_int_bool mr_10526 = os__posix_wait4_to_exit_status(pclose(f));
		int ret = mr_10526.arg0;
		return ret;
	}
	#endif
	return 0;
}
int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		#if defined(__TARGET_IOS__)
		{
		}
		#else
		{
			{ // Unsafe block
				ret = system(((char*)(cmd.str)));
			}
		}
		#endif
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	#if !defined(_WIN32)
	{
		multi_return_int_bool mr_11570 = os__posix_wait4_to_exit_status(ret);
		int pret = mr_11570.arg0;
		bool is_signaled = mr_11570.arg1;
		ret = pret;
		if (is_signaled) {
			builtin__eprintln(builtin__string__plus(builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Terminated by signal "), 0x4fe27, {.d_i32 = pret}}, {_S(" ("), 0, { .d_c = 0 }}})), os__sigint_to_signal_name(pret)), _S(")")));
			ret = (int)(pret + 128);
		}
	}
	#endif
	return ret;
}
bool os__exists(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return access(((char*)(path.str)), _const_os__f_ok) != -1;
	}
	#endif
	return 0;
}
bool os__is_executable(string path) {
	return access(((char*)(path.str)), _const_os__x_ok) != -1;
}
bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return access(((char*)(path.str)), _const_os__w_ok) != -1;
	}
	#endif
	return 0;
}
bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return access(((char*)(path.str)), _const_os__r_ok) != -1;
	}
	#endif
	return 0;
}
_result_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		rc = remove(((char*)(path.str)));
	}
	#endif
	if (rc == -1) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Failed to remove \""), 0xfe10, {.d_s = path}}, {_S("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno)),.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
_result_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		i32 rc = rmdir(((char*)(path.str)));
		if (rc == -1) {
			return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
		}
	}
	#endif
	return (_result_void){0};
}
VV_LOC void os__print_c_errno(void) {
	int e = errno;
	string se = builtin__tos_clone(((u8*)(strerror(e))));
	builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("errno="), 0xfe07, {.d_i32 = e}}, {_S(" err="), 0xfe10, {.d_s = se}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		usize max = ((usize)(0));
		u8* buf = ((u8*)(((void*)0)));
		string str = _S("");
		i32 nr_chars = getline(((voidptr)(&buf)), &max, stdin);
		#if defined(__OpenBSD__)
		{
		}
		#else
		{
			str = builtin__tos(buf, (nr_chars < 0 ? (0) : (nr_chars)));
		}
		#endif
		string ret = builtin__string_clone(str);
		#if !defined(_VAUTOFREE)
		{
			{ // Unsafe block
				if (nr_chars > 0 && buf != 0) {
					free(buf);
				}
			}
		}
		#endif
		return ret;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
Array_u8 os__get_raw_stdin(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		usize max = ((usize)(0));
		u8* buf = ((u8*)(((void*)0)));
		i32 nr_chars = getline(((voidptr)(&buf)), &max, stdin);
		return ((array){.data = ((voidptr)(buf)),.offset = 0,.len = (nr_chars < 0 ? (0) : (nr_chars)),.cap = ((int)(max)),.flags = 0,.element_size = 1,});
	}
	#endif
	return builtin____new_array(0, 0, sizeof(u8));
}
string os__executable(void) {
	Array_fixed_u8_4096 result = {0};
	{
		char* self_path = ((char*)(_dyld_get_image_name(((u32)(0)))));
		if (self_path == NULL) {
			return os__executable_fallback();
		}
		return builtin__cstring_to_vstring(self_path);
	}
	return os__executable_fallback();
}
_result_void os__chdir(string path) {
	i32 _t1;
	#if defined(_WIN32)
	#else
		_t1 = chdir(((char*)(path.str)));
		;
	#endif
		i32 ret = _t1;
	if (ret == -1) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
string os__getwd(void) {
	{ // Unsafe block
		#if defined(_WIN32)
		{
		}
		#else
		{
			char* cwd_ptr = getcwd(0, 4096);
			if (cwd_ptr == 0) {
				return _S("");
			}
			string res = builtin__tos_clone(((byteptr)(cwd_ptr)));
			free(cwd_ptr);
			return res;
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string os__real_path(string fpath) {
	Array_fixed_u8_4096 fullpath = {0};
	string res = _S("");
	#if defined(_WIN32)
	{
	}
	#else
	{
		char* ret = ((char*)(realpath(((char*)(fpath.str)), ((char*)(&fullpath[0])))));
		if (ret == 0) {
			builtin__string_free(&res);
			return builtin__string_clone(fpath);
		}
		builtin__string_free(&res);
		res = builtin__tos_clone(&fullpath[0]);
	}
	#endif
	os__normalize_drive_letter(res);
	return res;
}
VV_LOC void os__normalize_drive_letter(string path) {
	#if !defined(_WIN32)
	{
		return;
	}
	#endif
	if (path.len > 2 && path.str[ 0] >= 'a' && path.str[ 0] <= 'z' && path.str[ 1] == ':' && path.str[ 2] == _const_os__path_separator.str[ 0]) {
		{ // Unsafe block
			u8* x = &path.str[0];
			*x = (u8)(*x - 32);
		}
	}
}
int os__fork(void) {
	int pid = -1;
	#if !defined(_WIN32)
	{
		pid = fork();
	}
	#endif
	return pid;
}
int os__wait(void) {
	int pid = -1;
	#if !defined(_WIN32)
	{
		#if !defined(CUSTOM_DEFINE_emscripten)
		{
			pid = wait(0);
		}
		#endif
	}
	#endif
	return pid;
}
i64 os__file_last_mod_unix(string path) {
	_result_os__Stat _t1;
	if (_t1 = os__stat(path), !_t1.is_error) {
		os__Stat attr = *(os__Stat*)_t1.data;
		return attr.mtime;
	}
	return 0;
}
void os__flush(void) {
	fflush(stdout);
}
_result_void os__chmod(string path, int mode) {
	if (chmod(((char*)(path.str)), mode) != 0) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = builtin__string__plus(_S("chmod failed: "), os__posix_get_error_msg(errno)),.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
_result_void os__chown(string path, int owner, int group) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (chown(((char*)(path.str)), owner, group) != 0) {
			return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
		}
	}
	#endif
	return (_result_void){0};
}
_result_os__File os__open_append(string path) {
	os__File file = ((os__File){.cfile = 0,.fd = 0,.is_opened = 0,});
	#if defined(_WIN32)
	{
	}
	#else
	{
		u8* cpath = path.str;
		file = ((os__File){.cfile = (voidptr)fopen(((char*)(cpath)), "ab"),.fd = 0,.is_opened = 0,});
	}
	#endif
	if (builtin__isnil(file.cfile)) {
		return (_result_os__File){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to create(append) file \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}})),.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	file.is_opened = true;
	_result_os__File _t3;
	builtin___result_ok(&(os__File[]) { file }, (_result*)(&_t3), sizeof(os__File));
	 
	return _t3;
}
_result_void os__execvp(string cmdpath, Array_string cmdargs) {
	Array_char_ptr cargs = builtin____new_array_with_default(0, 0, sizeof(char*), 0);
	builtin__array_push((array*)&cargs, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		builtin__array_push((array*)&cargs, _MOV((char*[]){ ((char*)((*(string*)builtin__array_get(cmdargs, i)).str)) }));
	}
	builtin__array_push((array*)&cargs, _MOV((char*[]){ ((char*)(((void*)0))) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		res = execvp(((char*)(cmdpath.str)), cargs.data);
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	builtin___v_exit(res);
	VUNREACHABLE();
	return (_result_void){0};
}
_result_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs) {
	Array_char_ptr cargv = builtin____new_array_with_default(0, 0, sizeof(char*), 0);
	Array_char_ptr cenvs = builtin____new_array_with_default(0, 0, sizeof(char*), 0);
	builtin__array_push((array*)&cargv, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		builtin__array_push((array*)&cargv, _MOV((char*[]){ ((char*)((*(string*)builtin__array_get(cmdargs, i)).str)) }));
	}
	for (int i = 0; i < envs.len; ++i) {
		builtin__array_push((array*)&cenvs, _MOV((char*[]){ ((char*)((*(string*)builtin__array_get(envs, i)).str)) }));
	}
	builtin__array_push((array*)&cargv, _MOV((char*[]){ ((char*)(((void*)0))) }));
	builtin__array_push((array*)&cenvs, _MOV((char*[]){ ((char*)(((void*)0))) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		res = execve(((char*)(cmdpath.str)), cargv.data, cenvs.data);
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
int os__is_atty(int fd) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return isatty(fd);
	}
	#endif
	return 0;
}
_result_void os__write_file_array(string path, array buffer) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	os__File f = (*(os__File*)_t1.data);
		_result_void _t3 = os__File_write_full_buffer(&f, buffer.data, ((usize)((int)(buffer.len * buffer.element_size))));
	if (_t3.is_error) {
		_result_void _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (_result_void){0};
}
_result_Array_string os__glob(Array_string patterns) {
	Array_string matches = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < patterns.len; ++_t1) {
		string pattern = ((string*)patterns.data)[_t1];
		_result_void _t2 = os__native_glob_pattern(pattern, &matches);
		if (_t2.is_error) {
			_result_Array_string _t3 = {0};
			_t3.is_error = true;
			_t3.err = _t2.err;
			return _t3;
		}
		
 ;
	}
	if (matches.len > 0) { qsort(matches.data, matches.len, matches.element_size, (voidptr)compare_1065768667300548517_string); }
	;
	_result_Array_string _t4;
	builtin___result_ok(&(Array_string[]) { matches }, (_result*)(&_t4), sizeof(Array_string));
	 
	return _t4;
}
IError os__last_error(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int code = errno;
		string msg = os__posix_get_error_msg(code);
		return builtin__error_with_code(msg, code);
	}
	#endif
	return (IError){0};
}
inline IError os__error_posix(os__SystemError e) {
	int code = (e.code == _const_os__error_code_not_set ? (errno) : (e.code));
	string message = ((e.msg).len == 0 ? (os__posix_get_error_msg(code)) : (e.msg));
	return builtin__error_with_code(message, code);
}
inline IError os__error_win32(os__SystemError e) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		builtin___v_panic(_S("Win32 API not available on this platform."));
		VUNREACHABLE();
	}
	#endif
	return (IError){0};
}
void os__Result_free(os__Result* result) {
	builtin__string_free(&result->output);
}
VV_LOC string os__executable_fallback(void) {
	if (_const_os__args.len == 0) {
		return _S("");
	}
	string exepath = (*(string*)builtin__array_get(_const_os__args, 0));
	if (!os__is_abs_path(exepath)) {
		string _t2;
		#if defined(_WIN32)
		#else
			_t2 = _S("\\");
			;
		#endif
				string other_separator = _t2;
		string rexepath = builtin__string_replace(exepath, other_separator, _const_os__path_separator);
		if (builtin__string_contains(rexepath, _const_os__path_separator)) {
			exepath = os__join_path_single(_const_os__wd_at_startup, exepath);
		} else {
			_result_string _t3 = os__find_abs_path_of_executable(exepath);
			if (_t3.is_error) {
				*(string*) _t3.data = _S("");
			}
			
 			string foundpath = (*(string*)_t3.data);
			if ((foundpath).len != 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	return exepath;
}
_result_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("Source path doesn't exist")), .data={E_STRUCT} };
	}
	if (!os__is_dir(source_path)) {
		string fname = os__file_name(source_path);
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path_single(dest_path, fname)) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				_result_void _t2 = os__rm(adjusted_path);
				if (_t2.is_error) {
					_result_void _t3 = {0};
					_t3.is_error = true;
					_t3.err = _t2.err;
					return _t3;
				}
				
 ;
			} else {
				return (_result_void){ .is_error=true, .err=builtin___v_error(_S("Destination file path already exist")), .data={E_STRUCT} };
			}
		}
		_result_void _t5 = os__cp(source_path, adjusted_path, ((os__CopyParams){.fail_if_exists = 0,}));
		if (_t5.is_error) {
			_result_void _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 ;
		return (_result_void){0};
	}
	if (!os__exists(dest_path)) {
		_result_void _t7 = os__mkdir(dest_path, ((os__MkdirParams){.mode = 0777,}));
		if (_t7.is_error) {
			_result_void _t8 = {0};
			_t8.is_error = true;
			_t8.err = _t7.err;
			return _t8;
		}
		
 ;
	}
	if (!os__is_dir(dest_path)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("Destination path is not a valid directory")), .data={E_STRUCT} };
	}
	_result_Array_string _t10 = os__ls(source_path);
	if (_t10.is_error) {
		_result_void _t11 = {0};
		_t11.is_error = true;
		_t11.err = _t10.err;
		return _t11;
	}
	
 	Array_string files = (*(Array_string*)_t10.data);
	for (int _t12 = 0; _t12 < files.len; ++_t12) {
		string file = ((string*)files.data)[_t12];
		string sp = os__join_path_single(source_path, file);
		string dp = os__join_path_single(dest_path, file);
		if (os__is_dir(sp)) {
			if (!os__exists(dp)) {
				_result_void _t13 = os__mkdir(dp, ((os__MkdirParams){.mode = 0777,}));
				if (_t13.is_error) {
					_result_void _t14 = {0};
					_t14.is_error = true;
					_t14.err = _t13.err;
					return _t14;
				}
				
 ;
			}
		}
		_result_void _t15 = os__cp_all(sp, dp, overwrite);
		if (_t15.is_error) {
			IError err = _t15.err;
			_result_void _t16 = os__rmdir(dp);
			if (_t16.is_error) {
				IError err = _t16.err;
				return (_result_void){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 ;
			return (_result_void){ .is_error=true, .err=err, .data={E_STRUCT} };
		}
		
 ;
	}
	return (_result_void){0};
}
_result_void os__mv_by_cp(string source, string target, os__MvParams opts) {
	_result_void _t1 = os__cp_all(source, target, opts.overwrite);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	if (os__is_dir(source)) {
		_result_void _t3 = os__rmdir_all(source);
		if (_t3.is_error) {
			_result_void _t4 = {0};
			_t4.is_error = true;
			_t4.err = _t3.err;
			return _t4;
		}
		
 ;
		return (_result_void){0};
	}
	_result_void _t5 = os__rm(source);
	if (_t5.is_error) {
		_result_void _t6 = {0};
		_t6.is_error = true;
		_t6.err = _t5.err;
		return _t6;
	}
	
 ;
	return (_result_void){0};
}
_result_void os__mv(string source, string target, os__MvParams opts) {
	if (!opts.overwrite && os__exists(target)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("target path already exist")), .data={E_STRUCT} };
	}
	_result_void _t2 = os__rename(source, target);
	if (_t2.is_error) {
		_result_void _t3 = os__mv_by_cp(source, target, opts);
		if (_t3.is_error) {
			_result_void _t4 = {0};
			_t4.is_error = true;
			_t4.err = _t3.err;
			return _t4;
		}
		
 ;
	;
	}
	
 ;
	return (_result_void){0};
}
_result_Array_string os__read_lines(string path) {
	_result_string _t1 = os__read_file(path);
	if (_t1.is_error) {
		_result_Array_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	string buf = (*(string*)_t1.data);
	Array_string res = builtin__string_split_into_lines(buf);
	builtin__string_free(&buf);
	_result_Array_string _t3;
	builtin___result_ok(&(Array_string[]) { res }, (_result*)(&_t3), sizeof(Array_string));
	 
	return _t3;
}
_result_void os__write_lines(string path, Array_string lines) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	os__File f = (*(os__File*)_t1.data);
	for (int _t3 = 0; _t3 < lines.len; ++_t3) {
		string line = ((string*)lines.data)[_t3];
		_result_int _t4 = os__File_writeln(&f, line);
		if (_t4.is_error) {
			{ // defer begin
				os__File_close(&f);
			} // defer end
			_result_void _t5 = {0};
			_t5.is_error = true;
			_t5.err = _t4.err;
			return _t5;
		}
		
 ;
	}
		{ // defer begin
			os__File_close(&f);
		} // defer end
	return (_result_void){0};
}
string os__sigint_to_signal_name(int si) {
	switch (si) {
		case 1: {
			return _S("SIGHUP");
		}
		case 2: {
			return _S("SIGINT");
		}
		case 3: {
			return _S("SIGQUIT");
		}
		case 4: {
			return _S("SIGILL");
		}
		case 6: {
			return _S("SIGABRT");
		}
		case 8: {
			return _S("SIGFPE");
		}
		case 9: {
			return _S("SIGKILL");
		}
		case 11: {
			return _S("SIGSEGV");
		}
		case 13: {
			return _S("SIGPIPE");
		}
		case 14: {
			return _S("SIGALRM");
		}
		case 15: {
			return _S("SIGTERM");
		}
		default: {
			{
				break;
			}
		}
	}
	
	return _S("unknown");
}
_result_void os__rmdir_all(string path) {
	string err_msg = _S("");
	int err_code = -1;
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	Array_string items = (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < items.len; ++_t3) {
		string item = ((string*)items.data)[_t3];
		string fullpath = os__join_path_single(path, item);
		if (os__is_dir(fullpath) && !os__is_link(fullpath)) {
			_result_void _t4 = os__rmdir_all(fullpath);
			if (_t4.is_error) {
				IError err = _t4.err;
				err_msg = IError_name_table[err._typ]._method_msg(err._object);
				err_code = IError_name_table[err._typ]._method_code(err._object);
			}
			
 ;
		} else {
			_result_void _t5 = os__rm(fullpath);
			if (_t5.is_error) {
				IError err = _t5.err;
				err_msg = IError_name_table[err._typ]._method_msg(err._object);
				err_code = IError_name_table[err._typ]._method_code(err._object);
			}
			
 ;
		}
	}
	_result_void _t6 = os__rmdir(path);
	if (_t6.is_error) {
		IError err = _t6.err;
		err_msg = IError_name_table[err._typ]._method_msg(err._object);
		err_code = IError_name_table[err._typ]._method_code(err._object);
	}
	
 ;
	if ((err_msg).len != 0) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(err_msg, err_code), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
bool os__is_dir_empty(string path) {
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		return true;
	}
	
 	Array_string items = (*(Array_string*)_t1.data);
	bool res = items.len == 0;
	Array_string_free(&items);
	return res;
}
string os__file_ext(string opath) {
	if (opath.len < 3) {
		return _S("");
	}
	string path = os__file_name(opath);
	int pos = builtin__string_last_index_u8(path, '.');
	if (pos == -1) {
		return _S("");
	}
	if ((int)(pos + 1) >= path.len || pos == 0) {
		return _S("");
	}
	return builtin__string_substr(path, pos, 2147483647);
}
string os__dir(string path) {
	if ((path).len == 0) {
		return _S(".");
	}
	string detected_path_separator = (builtin__string_contains(path, _S("/")) ? (_S("/")) : (_S("\\")));
	_option_int _t2 = builtin__string_last_index(path, detected_path_separator);
	if (_t2.state != 0) {
		return _S(".");
	}
	
 	int pos = (*(int*)_t2.data);
	if (pos == 0) {
		return detected_path_separator;
	}
	return builtin__string_substr(path, 0, pos);
}
string os__base(string path) {
	if ((path).len == 0) {
		return _S(".");
	}
	string detected_path_separator = (builtin__string_contains(path, _S("/")) ? (_S("/")) : (_S("\\")));
	if (builtin__string__eq(path, detected_path_separator)) {
		return detected_path_separator;
	}
	if (builtin__string_ends_with(path, detected_path_separator)) {
		string path2 = builtin__string_substr(path, 0, (int)(path.len - 1));
		_option_int _t3 = builtin__string_last_index(path2, detected_path_separator);
		if (_t3.state != 0) {
			return builtin__string_clone(path2);
		}
		
 		int pos = (*(int*)_t3.data);
		return builtin__string_substr(path2, (int)(pos + 1), 2147483647);
	}
	_option_int _t6 = builtin__string_last_index(path, detected_path_separator);
	if (_t6.state != 0) {
		return builtin__string_clone(path);
	}
	
 	int pos = (*(int*)_t6.data);
	return builtin__string_substr(path, (int)(pos + 1), 2147483647);
}
string os__file_name(string path) {
	string detected_path_separator = (builtin__string_contains(path, _S("/")) ? (_S("/")) : (_S("\\")));
	return builtin__string_all_after_last(path, detected_path_separator);
}
multi_return_string_string_string os__split_path(string path) {
	if ((path).len == 0) {
		return (multi_return_string_string_string){.arg0=_S("."), .arg1=_S(""), .arg2=_S("")};
	} else if (_SLIT_EQ(path.str, path.len, ".")) {
		return (multi_return_string_string_string){.arg0=_S("."), .arg1=_S(""), .arg2=_S("")};
	} else if (_SLIT_EQ(path.str, path.len, "..")) {
		return (multi_return_string_string_string){.arg0=_S(".."), .arg1=_S(""), .arg2=_S("")};
	}
	string detected_path_separator = (builtin__string_contains(path, _S("/")) ? (_S("/")) : (_S("\\")));
	if (builtin__string__eq(path, detected_path_separator)) {
		return (multi_return_string_string_string){.arg0=detected_path_separator, .arg1=_S(""), .arg2=_S("")};
	}
	if (builtin__string_ends_with(path, detected_path_separator)) {
		return (multi_return_string_string_string){.arg0=builtin__string_substr(path, 0, (int)(path.len - 1)), .arg1=_S(""), .arg2=_S("")};
	}
	string dir = _S(".");
	_option_int _t6 = builtin__string_last_index(path, detected_path_separator);
	if (_t6.state != 0) {
		*(int*) _t6.data = -1;
	}
	
 	int pos = (*(int*)_t6.data);
	if (pos == -1) {
		dir = _S(".");
	} else if (pos == 0) {
		dir = detected_path_separator;
	} else {
		dir = builtin__string_substr(path, 0, pos);
	}
	string file_name = builtin__string_all_after_last(path, detected_path_separator);
	int pos_ext = builtin__string_last_index_u8(file_name, '.');
	if (pos_ext == -1 || pos_ext == 0 || (int)(pos_ext + 1) >= file_name.len) {
		return (multi_return_string_string_string){.arg0=dir, .arg1=file_name, .arg2=_S("")};
	}
	return (multi_return_string_string_string){.arg0=dir, .arg1=builtin__string_substr(file_name, 0, pos_ext), .arg2=builtin__string_substr(file_name, pos_ext, 2147483647)};
}
_option_string os__input_opt(string prompt) {
	builtin__print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		_option_string _t1;
		builtin___option_ok(&(string[]) { builtin__string_trim_right(res, _S("\r\n")) }, (_option*)(&_t1), sizeof(string));
		 
		return _t1;
	}
	return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
string os__input(string prompt) {
	_option_string _t1 = os__input_opt(prompt);
	if (_t1.state != 0) {
		return _S("<EOF>");
	}
	
 	string res = (*(string*)_t1.data);
	return res;
}
string os__get_line(void) {
	string str = os__get_raw_line();
	return builtin__string_trim_right(str, _S("\n"));
}
Array_string os__get_lines(void) {
	string line = _S("");
	Array_string inputstr = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = builtin__string_trim_space(line);
		builtin__array_push((array*)&inputstr, _MOV((string[]){ builtin__string_clone(line) }));
	}
	return inputstr;
}
string os__get_lines_joined(void) {
	return Array_string_join(os__get_lines(), _S(""));
}
Array_string os__get_raw_lines(void) {
	string line = _S("");
	Array_string lines = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		builtin__array_push((array*)&lines, _MOV((string[]){ builtin__string_clone(line) }));
	}
	return lines;
}
string os__get_raw_lines_joined(void) {
	return Array_string_join(os__get_raw_lines(), _S(""));
}
Array_string os__get_trimmed_lines(void) {
	Array_string lines = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		string line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		int end = line.len;
		if (end > 0 && builtin__string_at(line, (int)(end - 1)) == '\n') {
			end--;
		}
		if (end > 0 && builtin__string_at(line, (int)(end - 1)) == '\r') {
			end--;
		}
		builtin__array_push((array*)&lines, _MOV((string[]){ builtin__string_substr_ni(line, 0, end) }));
	}
	return lines;
}
string os__user_os(void) {
	{
		return _S("macos");
	}
	if ((os__getenv(_S("TERMUX_VERSION"))).len != 0) {
		return _S("termux");
	}
	return _S("unknown");
}
_result_Array_string os__user_names(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		_result_Array_string _t2 = os__read_lines(_S("/etc/passwd"));
		if (_t2.is_error) {
			_result_Array_string _t3 = {0};
			_t3.is_error = true;
			_t3.err = _t2.err;
			return _t3;
		}
		
 		Array_string lines = (*(Array_string*)_t2.data);
		Array_string users = builtin____new_array_with_default(0, lines.len, sizeof(string), 0);
		for (int _t4 = 0; _t4 < lines.len; ++_t4) {
			string line = ((string*)lines.data)[_t4];
			_option_int _t5 = builtin__string_index(line, _S(":"));
			if (_t5.state != 0) {
				*(int*) _t5.data = line.len;
			}
			
 			int end_name = (*(int*)_t5.data);
			builtin__array_push((array*)&users, _MOV((string[]){ builtin__string_substr(line, 0, end_name) }));
		}
		_result_Array_string _t7;
		builtin___result_ok(&(Array_string[]) { users }, (_result*)(&_t7), sizeof(Array_string));
		 
		return _t7;
	}
	#endif
	return (_result_Array_string){0};
}
string os__home_dir(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return os__getenv(_S("HOME"));
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
string os__expand_tilde_to_home(string path) {
	if (_SLIT_EQ(path.str, path.len, "~")) {
		string hdir = os__home_dir();
		return builtin__string_trim_right(hdir, _const_os__path_separator);
	}
	string source = _S("~/");
	if (builtin__string_starts_with(path, source)) {
		string hdir = os__home_dir();
		string trimmed = builtin__string_trim_right(hdir, _const_os__path_separator);
		string final = builtin__string__plus(trimmed, _S("/"));
		string result = builtin__string_replace_once(path, source, final);
		return result;
	}
	return path;
}
_result_void os__write_file(string path, string text) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	os__File f = (*(os__File*)_t1.data);
		_result_void _t3 = os__File_write_full_buffer(&f, text.str, ((usize)(text.len)));
	if (_t3.is_error) {
		_result_void _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (_result_void){0};
}
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err) {
	return _S("os: failed to find executable");
}
VV_LOC IError os__error_failed_to_find_executable(void) {
	return I_os__ExecutableNotFoundError_to_Interface_IError(((os__ExecutableNotFoundError*)builtin__memdup(&(os__ExecutableNotFoundError){.Error = ((Error){E_STRUCT}),}, sizeof(os__ExecutableNotFoundError))));
}
_result_string os__find_abs_path_of_executable(string exe_name) {
	if ((exe_name).len == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("expected non empty `exe_name`")), .data={E_STRUCT} };
	}
	for (int _t2 = 0; _t2 < _const_os__executable_suffixes.len; ++_t2) {
		string suffix = ((string*)_const_os__executable_suffixes.data)[_t2];
		string fexepath = builtin__string__plus(exe_name, suffix);
		if (os__is_abs_path(fexepath)) {
			_result_string _t3;
			builtin___result_ok(&(string[]) { fexepath }, (_result*)(&_t3), sizeof(string));
			 
			return _t3;
		}
		string res = _S("");
		string path = os__getenv(_S("PATH"));
		Array_string paths = builtin__string_split(path, _const_os__path_delimiter);
		for (int _t4 = 0; _t4 < paths.len; ++_t4) {
			string p = ((string*)paths.data)[_t4];
			string found_abs_path = os__join_path_single(p, fexepath);
			if (os__is_file(found_abs_path) && os__is_executable(found_abs_path)) {
				res = found_abs_path;
				break;
			}
		}
		if (res.len > 0) {
			_result_string _t5;
			builtin___result_ok(&(string[]) { os__abs_path(res) }, (_result*)(&_t5), sizeof(string));
			 
			return _t5;
		}
	}
	return (_result_string){ .is_error=true, .err=os__error_failed_to_find_executable(), .data={E_STRUCT} };
}
bool os__exists_in_system_path(string prog) {
	_result_string _t1 = os__find_abs_path_of_executable(prog);
	if (_t1.is_error) {
		return false;
	}
	
 ;
	return true;
}
bool os__is_file(string path) {
	return os__exists(path) && !os__is_dir(path);
}
string os__join_path(string base, Array_string dirs) {
	strings__Builder sb = strings__new_builder((int)(base.len + (int)(dirs.len * 50)));
	string sbase = builtin__string_trim_right(base, _S("\\/"));
	strings__Builder_write_string(&sb, sbase);
	for (int _t1 = 0; _t1 < dirs.len; ++_t1) {
		string d = ((string*)dirs.data)[_t1];
		if ((d).len != 0) {
			strings__Builder_write_string(&sb, _const_os__path_separator);
			strings__Builder_write_string(&sb, d);
		}
	}
	os__normalize_path_in_builder((voidptr)&sb);
	string res = strings__Builder_str(&sb);
	if ((base).len == 0) {
		res = builtin__string_trim_left(res, _const_os__path_separator);
	}
	string _t2 = res;
		{ // defer begin
			builtin__string_free(&sbase);
		} // defer end
		{ // defer begin
			strings__Builder_free(&sb);
		} // defer end
	return _t2;
}
string os__join_path_single(string base, string elem) {
	strings__Builder sb = strings__new_builder((int)((int)(base.len + elem.len) + 1));
	string sbase = builtin__string_trim_right(base, _S("\\/"));
	strings__Builder_write_string(&sb, sbase);
	if ((elem).len != 0) {
		strings__Builder_write_string(&sb, _const_os__path_separator);
		strings__Builder_write_string(&sb, elem);
	}
	os__normalize_path_in_builder((voidptr)&sb);
	string res = strings__Builder_str(&sb);
	if ((base).len == 0) {
		res = builtin__string_trim_left(res, _const_os__path_separator);
	}
	string _t1 = res;
		{ // defer begin
			builtin__string_free(&sbase);
		} // defer end
		{ // defer begin
			strings__Builder_free(&sb);
		} // defer end
	return _t1;
}
VV_LOC void os__normalize_path_in_builder(strings__Builder* sb) {
	rune fs = '\\';
	rune rs = '/';
	for (int idx = 0; idx < sb->len; ++idx) {
		{ // Unsafe block
			if (((u8*)sb->data)[idx] == fs) {
				((u8*)sb->data)[idx] = rs;
			}
		}
	}
	for (int idx = 0; idx < (int)(sb->len - 3); ++idx) {
		if (((u8*)sb->data)[idx] == rs && ((u8*)sb->data)[(int_literal)(idx + 1)] == '.' && ((u8*)sb->data)[(int_literal)(idx + 2)] == rs) {
			{ // Unsafe block
				for (int j = (int_literal)(idx + 1); j < (int)(sb->len - 2); j++) {
					((u8*)sb->data)[j] = ((u8*)sb->data)[(int)(j + 2)];
				}
				sb->len -= 2;
			}
		}
		if (((u8*)sb->data)[idx] == rs && ((u8*)sb->data)[(int_literal)(idx + 1)] == rs) {
			{ // Unsafe block
				for (int j = (int_literal)(idx + 1); j < (int)(sb->len - 1); j++) {
					((u8*)sb->data)[j] = ((u8*)sb->data)[(int)(j + 1)];
				}
				sb->len -= 1;
			}
		}
	}
}
Array_string os__walk_ext(string path, string ext, os__WalkParams opts) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	os__impl_walk_ext(path, ext, &res, opts);
	return res;
}
VV_LOC void os__impl_walk_ext(string path, string ext, Array_string* out, os__WalkParams opts) {
	if (!os__is_dir(path)) {
		return;
	}
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		return;
	}
	
 	Array_string files = (*(Array_string*)_t1.data);
	string separator = (builtin__string_ends_with(path, _const_os__path_separator) ? (_S("")) : (_const_os__path_separator));
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		if (!opts.hidden && builtin__string_starts_with(file, _S("."))) {
			continue;
		}
		string p = builtin__string__plus(builtin__string__plus(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__impl_walk_ext(p, ext, out, opts);
		} else if (builtin__string_ends_with(file, ext)) {
			builtin__array_push((array*)out, _MOV((string[]){ builtin__string_clone(p) }));
		}
	}
}
void os__walk(string path, void (*f)(string )) {
	if ((path).len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Array_string remaining = builtin____new_array_with_default(0, 1000, sizeof(string), 0);
	string clean_path = builtin__string_trim_right(path, _const_os__path_separator);
	#if defined(_WIN32)
	{
	}
	#else
	{
		builtin__array_push((array*)&remaining, _MOV((string[]){ builtin__string_clone(clean_path) }));
	}
	#endif
	for (;;) {
		if (!(remaining.len > 0)) break;
		string cpath = (*(string*)builtin__array_pop(&remaining));
		os__PathKind pkind = os__kind_of_existing_path(cpath);
		if (pkind.is_link || !pkind.is_dir) {
			f(cpath);
			continue;
		}
		_result_Array_string _t3 = os__ls(cpath);
		if (_t3.is_error) {
			continue;
		}
		
 		Array_string files = (*(Array_string*)_t3.data);
		for (int idx = (int)(files.len - 1); idx >= 0; idx--) {
			builtin__array_push((array*)&remaining, _MOV((string[]){ builtin__string__plus(builtin__string__plus(cpath, _S("/")), (*(string*)builtin__array_get(files, idx))) }));
		}
	}
}
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string )) {
	if ((path).len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Array_string remaining = builtin____new_array_with_default(0, 1000, sizeof(string), 0);
	string clean_path = builtin__string_trim_right(path, _const_os__path_separator);
	#if defined(_WIN32)
	{
	}
	#else
	{
		builtin__array_push((array*)&remaining, _MOV((string[]){ builtin__string_clone(clean_path) }));
	}
	#endif
	int loops = 0;
	for (;;) {
		if (!(remaining.len > 0)) break;
		loops++;
		string cpath = (*(string*)builtin__array_pop(&remaining));
		if (loops > 1) {
			fcb(context, cpath);
		}
		os__PathKind pkind = os__kind_of_existing_path(cpath);
		if (pkind.is_link || !pkind.is_dir) {
			continue;
		}
		_result_Array_string _t3 = os__ls(cpath);
		if (_t3.is_error) {
			continue;
		}
		
 		Array_string files = (*(Array_string*)_t3.data);
		for (int idx = (int)(files.len - 1); idx >= 0; idx--) {
			builtin__array_push((array*)&remaining, _MOV((string[]){ builtin__string__plus(builtin__string__plus(cpath, _S("/")), (*(string*)builtin__array_get(files, idx))) }));
		}
	}
}
void os__log(string s) {
	builtin__println(builtin__string__plus(_S("os.log: "), s));
}
_result_void os__mkdir_all(string opath, os__MkdirParams params) {
	if (os__exists(opath)) {
		if (os__is_dir(opath)) {
			return (_result_void){0};
		}
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("path `"), 0xfe10, {.d_s = opath}}, {_S("` already exists, and is not a folder"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	string _t2;
	#if defined(_WIN32)
	#else
		_t2 = _S("\\");
		;
	#endif
		string other_separator = _t2;
	string path = builtin__string_replace(opath, other_separator, _const_os__path_separator);
	string p = (builtin__string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (_S("")));
	Array_string path_parts = builtin__string_split(builtin__string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	for (int _t3 = 0; _t3 < path_parts.len; ++_t3) {
		string subdir = ((string*)path_parts.data)[_t3];
		p = builtin__string__plus(p, builtin__string__plus(subdir, _S("/")));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		_result_void _t4 = os__mkdir(p, params);
		if (_t4.is_error) {
			IError err = _t4.err;
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("folder: "), 0xfe10, {.d_s = p}}, {_S(", error: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		
 ;
	}
	return (_result_void){0};
}
VV_LOC void os__create_folder_when_it_does_not_exist(string path) {
	if (os__is_dir(path) || os__is_link(path)) {
		return;
	}
	string error_msg = _S("");
	for (int _t1 = 0; _t1 < 10; ++_t1) {
		_result_void _t2 = os__mkdir_all(path, ((os__MkdirParams){.mode = 0700,}));
		if (_t2.is_error) {
			IError err = _t2.err;
			if (os__is_dir(path) || os__is_link(path)) {
				return;
			}
			error_msg = IError_name_table[err._typ]._method_msg(err._object);
			os__sleep_ms(1);
			continue;
		}
		
 ;
		break;
	}
	if (os__is_dir(path) || os__is_link(path)) {
		return;
	}
	builtin___v_panic(error_msg);
	VUNREACHABLE();
}
VV_LOC string os__xdg_home_folder(string ename, string lpath) {
	string xdg_folder = os__getenv(ename);
	string dir = ((xdg_folder).len != 0 ? (xdg_folder) : (os__join_path_single(os__home_dir(), lpath)));
	os__create_folder_when_it_does_not_exist(dir);
	return dir;
}
string os__cache_dir(void) {
	return os__xdg_home_folder(_S("XDG_CACHE_HOME"), _S(".cache"));
}
string os__data_dir(void) {
	return os__xdg_home_folder(_S("XDG_DATA_HOME"), _S(".local/share"));
}
string os__state_dir(void) {
	return os__xdg_home_folder(_S("XDG_STATE_HOME"), _S(".local/state"));
}
string os__local_bin_dir(void) {
	return os__xdg_home_folder(_S("LOCAL_BIN_DIR"), _S(".local/bin"));
}
string os__temp_dir(void) {
	string path = os__getenv(_S("TMPDIR"));
	{
		return _S("/tmp");
	}
	if ((path).len == 0) {
		path = _S("/tmp");
	}
	return path;
}
string os__vtmp_dir(void) {
	string vtmp = os__getenv(_S("VTMP"));
	if (vtmp.len > 0) {
		os__create_folder_when_it_does_not_exist(vtmp);
		return vtmp;
	}
	int uid = os__getuid();
	vtmp = os__join_path_single(os__temp_dir(), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("v_"), 0xfe07, {.d_i32 = uid}}, {_SLIT0, 0, { .d_c = 0 }}})));
	os__create_folder_when_it_does_not_exist(vtmp);
	os__setenv(_S("VTMP"), vtmp, true);
	return vtmp;
}
VV_LOC string os__default_vmodules_path(void) {
	string hdir = os__home_dir();
	string res = os__join_path_single(hdir, _S(".vmodules"));
	return res;
}
string os__vmodules_dir(void) {
	Array_string paths = os__vmodules_paths();
	if (paths.len > 0) {
		return (*(string*)builtin__array_get(paths, 0));
	}
	return os__default_vmodules_path();
}
Array_string os__vmodules_paths(void) {
	string path = os__getenv(_S("VMODULES"));
	if ((path).len == 0) {
		path = os__default_vmodules_path();
	}
	Array_string splitted = builtin__string_split(path, _const_os__path_delimiter);
	Array_string list = builtin____new_array_with_default(0, splitted.len, sizeof(string), 0);
	for (int i = 0; i < splitted.len; ++i) {
		string si = (*(string*)builtin__array_get(splitted, i));
		string trimmed = builtin__string_trim_right(si, _const_os__path_separator);
		builtin__array_push((array*)&list, _MOV((string[]){ builtin__string_clone(trimmed) }));
	}
	Array_string _t2 = list;
		{ // defer begin
		} // defer end
		{ // defer begin
		} // defer end
	return _t2;
}
string os__resource_abs_path(string path) {
	string exe = os__executable();
	string dexe = os__dir(exe);
	string base_path = os__real_path(dexe);
	string vresource = os__getenv(_S("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		builtin__string_free(&base_path);
		base_path = vresource;
	}
	string fp = os__join_path_single(base_path, path);
	string res = os__real_path(fp);
	{ // Unsafe block
		builtin__string_free(&fp);
		builtin__string_free(&vresource);
		builtin__string_free(&base_path);
		builtin__string_free(&dexe);
		builtin__string_free(&exe);
	}
	return res;
}
os__Result os__execute_or_panic(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin___v_panic(res.output);
		VUNREACHABLE();
	}
	return res;
}
os__Result os__execute_or_exit(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__eprintln(res.output);
		builtin___v_exit(1);
		VUNREACHABLE();
	}
	return res;
}
_result_os__Result os__execute_opt(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		return (_result_os__Result){ .is_error=true, .err=builtin___v_error(res.output), .data={E_STRUCT} };
	}
	_result_os__Result _t2;
	builtin___result_ok(&(os__Result[]) { res }, (_result*)(&_t2), sizeof(os__Result));
	 
	return _t2;
}
string os__quoted_path(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("'"), 0xfe10, {.d_s = path}}, {_S("'"), 0, { .d_c = 0 }}}));
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
_result_string os__config_dir(void) {
	#if defined(_WIN32)
	{
	}
	#elif defined(__APPLE__) || defined(__DARWIN__) || defined(__TARGET_IOS__)
	{
		string home = os__home_dir();
		if ((home).len != 0) {
			_result_string _t2;
			builtin___result_ok(&(string[]) { builtin__string__plus(home, _S("/Library/Application Support")) }, (_result*)(&_t2), sizeof(string));
			 
			return _t2;
		}
	}
	#else
	{
	}
	#endif
	return (_result_string){ .is_error=true, .err=builtin___v_error(_S("Cannot find config directory")), .data={E_STRUCT} };
}
VV_LOC Array_string os__glob_match(string dir, string pattern, string next_pattern, Array_string* matches) {
	Array_string subdirs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (os__is_file(dir)) {
		return subdirs;
	}
	_result_Array_string _t2 = os__ls(dir);
	if (_t2.is_error) {
		return subdirs;
	}
	
 	Array_string files = (*(Array_string*)_t2.data);
	os__GlobMatch mode = os__GlobMatch__exact;
	string pat = pattern;
	if (_SLIT_EQ(pat.str, pat.len, "*")) {
		mode = os__GlobMatch__any;
		if (!builtin__string__eq(next_pattern, pattern) && (next_pattern).len != 0) {
			for (int _t4 = 0; _t4 < files.len; ++_t4) {
				string file = ((string*)files.data)[_t4];
				if (os__is_dir(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_S("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})))) {
					builtin__array_push((array*)&subdirs, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_S("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
				}
			}
			return subdirs;
		}
	}
	if (_SLIT_EQ(pat.str, pat.len, "**")) {
		files = os__walk_ext(dir, _S(""), ((os__WalkParams){.hidden = 0,}));
		pat = next_pattern;
	}
	if (builtin__string_starts_with(pat, _S("*"))) {
		mode = os__GlobMatch__ends_with;
		pat = builtin__string_substr(pat, 1, 2147483647);
	}
	if (builtin__string_ends_with(pat, _S("*"))) {
		mode = (mode == os__GlobMatch__ends_with ? (os__GlobMatch__contains) : (os__GlobMatch__starts_with));
		pat = builtin__string_substr(pat, 0, (int)(pat.len - 1));
	}
	if (builtin__string_contains(pat, _S("*"))) {
		mode = os__GlobMatch__start_and_ends_with;
	}
	for (int _t7 = 0; _t7 < files.len; ++_t7) {
		string file = ((string*)files.data)[_t7];
		string fpath = file;
		string _t8; /* if prepend */
		if (builtin__string_contains(file, _const_os__path_separator)) {
			Array_string pathwalk = builtin__string_split(file, _const_os__path_separator);
			_t8 = (*(string*)builtin__array_get(pathwalk, (int)(pathwalk.len - 1)));
			goto _t9;
		};
		{
			fpath = (_SLIT_EQ(dir.str, dir.len, ".") ? (file) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_S("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			_t8 = file;
		}
	_t9: {};
				string f = _t8;
		if ((_SLIT_EQ(f.str, f.len, ".") || _SLIT_EQ(f.str, f.len, "..")) || (f).len == 0) {
			continue;
		}
		bool _t10 = 0;
		
		if (mode == (os__GlobMatch__any)) {
			_t10 = true;
		}
		else if (mode == (os__GlobMatch__exact)) {
			_t10 = builtin__string__eq(f, pat);
		}
		else if (mode == (os__GlobMatch__starts_with)) {
			_t10 = builtin__string_starts_with(f, pat);
		}
		else if (mode == (os__GlobMatch__ends_with)) {
			_t10 = builtin__string_ends_with(f, pat);
		}
		else if (mode == (os__GlobMatch__start_and_ends_with)) {
			Array_string p = builtin__string_split(pat, _S("*"));
			_t10 = builtin__string_starts_with(f, (*(string*)builtin__array_get(p, 0))) && builtin__string_ends_with(f, (*(string*)builtin__array_get(p, 1)));
		}
		else if (mode == (os__GlobMatch__contains)) {
			_t10 = builtin__string_contains(f, pat);
		}bool hit = _t10;
		if (hit) {
			if (os__is_dir(fpath)) {
				builtin__array_push((array*)&subdirs, _MOV((string[]){ builtin__string_clone(fpath) }));
				if (builtin__string__eq(next_pattern, pattern) && (next_pattern).len != 0) {
					builtin__array_push((array*)matches, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fpath}}, {_SLIT0, 0xfe10, {.d_s = _const_os__path_separator}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
				}
			} else {
				builtin__array_push((array*)matches, _MOV((string[]){ builtin__string_clone(fpath) }));
			}
		}
	}
	return subdirs;
}
VV_LOC _result_void os__native_glob_pattern(string pattern, Array_string* matches) {
	Array_string steps = builtin__string_split(pattern, _const_os__path_separator);
	string cwd = (builtin__string_starts_with(pattern, _const_os__path_separator) ? (_const_os__path_separator) : (_S(".")));
	Array_string subdirs = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(cwd)}));
	for (int i = 0; i < steps.len; i++) {
		string step = (*(string*)builtin__array_get(steps, i));
		string step2 = ((int)(i + 1) == steps.len ? (step) : ((*(string*)builtin__array_get(steps, (int)(i + 1)))));
		if ((step).len == 0) {
			continue;
		}
		if (os__is_dir(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_SLIT0, 0xfe10, {.d_s = _const_os__path_separator}}, {_SLIT0, 0xfe10, {.d_s = step}}, {_SLIT0, 0, { .d_c = 0 }}})))) {
			string dd = (_SLIT_EQ(cwd.str, cwd.len, "/") ? (step) : ((_SLIT_EQ(cwd.str, cwd.len, ".") || (cwd).len == 0 ? (step) : ((_SLIT_EQ(step.str, step.len, ".") || _SLIT_EQ(step.str, step.len, "/") ? (cwd) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_S("/"), 0xfe10, {.d_s = step}}, {_SLIT0, 0, { .d_c = 0 }}}))))))));
			if ((int)(i + 1) != steps.len) {
				if (!(Array_string_contains(subdirs, dd))) {
					builtin__array_push((array*)&subdirs, _MOV((string[]){ builtin__string_clone(dd) }));
				}
			}
		}
		Array_string subs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		for (int _t2 = 0; _t2 < subdirs.len; ++_t2) {
			string sd = ((string*)subdirs.data)[_t2];
			string d = (_SLIT_EQ(cwd.str, cwd.len, "/") ? (sd) : ((_SLIT_EQ(cwd.str, cwd.len, ".") || (cwd).len == 0 ? (sd) : ((_SLIT_EQ(sd.str, sd.len, ".") || _SLIT_EQ(sd.str, sd.len, "/") ? (cwd) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_S("/"), 0xfe10, {.d_s = sd}}, {_SLIT0, 0, { .d_c = 0 }}}))))))));
			_PUSH_MANY(&subs, (os__glob_match(builtin__string_replace(d, _S("//"), _S("/")), step, step2, matches)), _t3, Array_string);
		}
		subdirs = builtin__array_clone_to_depth(&subs, 1);
	}
	return (_result_void){0};
}
_result_void os__utime(string path, int actime, int modtime) {
	struct utimbuf u = ((struct utimbuf){.actime = actime,.modtime = modtime,});
	if (utime(((char*)(path.str)), &u) != 0) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(os__posix_get_error_msg(errno), errno), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
os__Uname os__uname(void) {
	os__Uname u = ((os__Uname){.sysname = (string){.str=(byteptr)"", .is_lit=1},.nodename = (string){.str=(byteptr)"", .is_lit=1},.release = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.machine = (string){.str=(byteptr)"", .is_lit=1},});
	{ // Unsafe block
		struct utsname* d = ((struct utsname*)(builtin__malloc_noscan(((int)(sizeof(struct utsname))))));
		if (uname(d) == 0) {
			u.sysname = builtin__cstring_to_vstring(d->sysname);
			u.nodename = builtin__cstring_to_vstring(d->nodename);
			u.release = builtin__cstring_to_vstring(d->release);
			u.version = builtin__cstring_to_vstring(d->version);
			u.machine = builtin__cstring_to_vstring(d->machine);
		}
		builtin___v_free(d);
	}
	return u;
}
_result_string os__hostname(void) {
	string hstnme = _S("");
	int size = 256;
	char* buf = ((char*)(builtin__malloc_noscan(size)));
	if (gethostname(buf, size) == 0) {
		hstnme = builtin__cstring_to_vstring(buf);
		builtin___v_free(buf);
		_result_string _t1;
		builtin___result_ok(&(string[]) { hstnme }, (_result*)(&_t1), sizeof(string));
		 
		return _t1;
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
}
_result_string os__loginname(void) {
	char* x = getlogin();
	if (!builtin__isnil(x)) {
		_result_string _t1;
		builtin___result_ok(&(string[]) { builtin__cstring_to_vstring(x) }, (_result*)(&_t1), sizeof(string));
		 
		return _t1;
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
}
_result_Array_string os__ls(string path) {
	if ((path).len == 0) {
		return (_result_Array_string){ .is_error=true, .err=builtin___v_error(_S("ls() expects a folder, not an empty string")), .data={E_STRUCT} };
	}
	Array_string res = builtin____new_array_with_default(0, 50, sizeof(string), 0);
	DIR* dir = opendir(((char*)(path.str)));
	if (builtin__isnil(dir)) {
		return (_result_Array_string){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ls() couldnt open dir \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}})),.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
	}
	struct dirent* ent = ((struct dirent*)(((void*)0)));
	for (;;) {
		ent = readdir(dir);
		if (builtin__isnil(ent)) {
			break;
		}
		{ // Unsafe block
			u8* bptr = ((u8*)(&ent->d_name[0]));
			if (bptr[0] == 0 || (bptr[0] == '.' && bptr[1] == 0) || (bptr[0] == '.' && bptr[1] == '.' && bptr[2] == 0)) {
				continue;
			}
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__tos_clone(bptr) }));
		}
	}
	closedir(dir);
	_result_Array_string _t4;
	builtin___result_ok(&(Array_string[]) { res }, (_result*)(&_t4), sizeof(Array_string));
	 
	return _t4;
}
_result_void os__mkdir(string path, os__MkdirParams params) {
	if (_SLIT_EQ(path.str, path.len, ".")) {
		return (_result_void){0};
	}
	string apath = os__real_path(path);
	i32 r = mkdir(((char*)(apath.str)), params.mode);
	if (r == -1) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
os__Result os__execute(string cmd) {
	string pcmd = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("exec 2>&1;"), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}}));
	voidptr f = os__vpopen(pcmd);
	if (builtin__isnil(f)) {
		os__Result _t1 = ((os__Result){.exit_code = -1,.output = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("exec(\""), 0xfe10, {.d_s = cmd}}, {_S("\") failed"), 0, { .d_c = 0 }}})),});
			{ // defer begin
				builtin__string_free(&pcmd);
			} // defer end
		return _t1;
	}
	int fd = os__fileno(f);
	strings__Builder res = strings__new_builder(1024);
	Array_fixed_u8_4096 buf = {0};
	{ // Unsafe block
		u8* pbuf = &buf[0];
		for (;;) {
			int len = ((int)(read(fd, pbuf, 4096)));
			if (len == 0) {
				break;
			}
			strings__Builder_write_ptr(&res, pbuf, len);
		}
	}
	string soutput = strings__Builder_str(&res);
	int exit_code = os__vpclose(f);
	os__Result _t2 = ((os__Result){.exit_code = exit_code,.output = soutput,});
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
		{ // defer begin
			builtin__string_free(&pcmd);
		} // defer end
	return _t2;
}
os__Result os__raw_execute(string cmd) {
	return os__execute(cmd);
}
_result_void os__symlink(string target, string link_name) {
	i32 res = symlink(((char*)(target.str)), ((char*)(link_name.str)));
	if (res == 0) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
}
_result_string os__readlink(string path) {
	Array_fixed_u8_4096 buf = {0};
	i32 res = readlink(((char*)(path.str)), ((char*)(&buf[0])), _const_os__max_path_buffer_size);
	if (res < 0) {
		return (_result_string){ .is_error=true, .err=os__last_error(), .data={E_STRUCT} };
	}
	if (res < _const_os__max_path_buffer_size) {
		_result_string _t2;
		builtin___result_ok(&(string[]) { builtin__string_clone(builtin__u8_vstring_with_len((&buf[0]), res)) }, (_result*)(&_t2), sizeof(string));
		 
		return _t2;
	}
	int size = _const_os__max_path_buffer_size;
	for (;;) {
		size *= 2;
		char* buf2 = ((char*)(builtin__malloc_noscan(size)));
		i32 res2 = readlink(((char*)(path.str)), buf2, size);
		if (res2 < 0) {
			return (_result_string){ .is_error=true, .err=os__last_error(), .data={E_STRUCT} };
		}
		if (res2 < size) {
			_result_string _t4;
			builtin___result_ok(&(string[]) { builtin__tos(((u8*)(&buf2[0])), res2) }, (_result*)(&_t4), sizeof(string));
			 
			return _t4;
		}
		builtin___v_free(buf2);
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _S("readlink")}}, {_S(" unreachable code"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
_result_void os__link(string origin, string target) {
	i32 res = link(((char*)(origin.str)), ((char*)(target.str)));
	if (res == 0) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=builtin___v_error(os__posix_get_error_msg(errno)), .data={E_STRUCT} };
}
string os__get_error_msg(int code) {
	return os__posix_get_error_msg(code);
}
void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}
_result_void os__ensure_folder_is_writable(string folder) {
	if (!os__exists(folder)) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = folder}}, {_S("` does not exist"), 0, { .d_c = 0 }}})), 1), .data={E_STRUCT} };
	}
	if (!os__is_dir(folder)) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = folder}}, {_S("` is not a folder"), 0, { .d_c = 0 }}})), 2), .data={E_STRUCT} };
	}
	string tmp_perm_check = os__join_path_single(folder, _S("XXXXXX"));
	{ // Unsafe block
		i32 x = mkstemp(((char*)(tmp_perm_check.str)));
		if (-1 == x) {
			_result_void _t3 = (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("folder `"), 0xfe10, {.d_s = folder}}, {_S("` is not writable"), 0, { .d_c = 0 }}})), 3), .data={E_STRUCT} };
				{ // defer begin
					builtin__string_free(&tmp_perm_check);
				} // defer end
			return _t3;
		}
		close(x);
	}
	_result_void _t4 = os__rm(tmp_perm_check);
	if (_t4.is_error) {
		{ // defer begin
			builtin__string_free(&tmp_perm_check);
		} // defer end
		_result_void _t5 = {0};
		_t5.is_error = true;
		_t5.err = _t4.err;
		return _t5;
	}
	
 ;
		{ // defer begin
			builtin__string_free(&tmp_perm_check);
		} // defer end
	return (_result_void){0};
}
inline int os__getpid(void) {
	return getpid();
}
inline int os__getppid(void) {
	return getppid();
}
inline int os__getuid(void) {
	return getuid();
}
inline int os__geteuid(void) {
	return geteuid();
}
inline int os__getgid(void) {
	return getgid();
}
inline int os__getegid(void) {
	return getegid();
}
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable) {
	u32 new_mode = ((u32)(0));
	_result_os__Stat _t1;
	if (_t1 = os__stat(path_s), !_t1.is_error) {
		os__Stat s = *(os__Stat*)_t1.data;
		new_mode = s.mode;
	}

	if (enable == (true)) {
		new_mode |= mode;
	}
	else if (enable == (false)) {
		new_mode &= ((u32)(07777 - mode));
	}
	chmod(((char*)(path_s.str)), ((int)(new_mode)));
}
int os__page_size(void) {
	return ((int)(sysconf(_SC_PAGESIZE)));
}
_result_os__DiskUsage os__disk_usage(string path) {
	string mpath = ((path).len == 0 ? (_S(".")) : (path));
	struct statvfs vfs = ((struct statvfs){.f_bsize = 0,.f_blocks = 0,.f_bfree = 0,.f_bavail = 0,});
	i32 ret = statvfs(((char*)(mpath.str)), &vfs);
	if (ret == -1) {
		_result_os__DiskUsage _t1 = (_result_os__DiskUsage){ .is_error=true, .err=builtin___v_error(_S("cannot get disk usage of path")), .data={E_STRUCT} };
			{ // defer begin
				builtin__string_free(&mpath);
			} // defer end
		return _t1;
	}
	u64 f_bsize = ((u64)(vfs.f_bsize));
	u64 f_blocks = ((u64)(vfs.f_blocks));
	u64 f_bavail = ((u64)(vfs.f_bavail));
	u64 f_bfree = ((u64)(vfs.f_bfree));
	_result_os__DiskUsage _t2;
	builtin___result_ok(&(os__DiskUsage[]) { ((os__DiskUsage){.total = (u64)(f_bsize * f_blocks),.available = (u64)(f_bsize * f_bavail),.used = (u64)(f_bsize * ((u64)(f_blocks - f_bfree))),}) }, (_result*)(&_t2), sizeof(os__DiskUsage));
	 
		{ // defer begin
			builtin__string_free(&mpath);
		} // defer end
	return _t2;
}
_result_string os__input_password(string prompt) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("Could not obtain password discretely.")), .data={E_STRUCT} };
	}
	term__termios__Termios old_state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&old_state) != 0) {
		return (_result_string){ .is_error=true, .err=os__last_error(), .data={E_STRUCT} };
	}
	term__termios__Termios new_state = old_state;
	term__termios__Termios_disable_echo(&new_state);
	term__termios__set_state(0, new_state);
	_option_string _t3 = os__input_opt(prompt);
	if (_t3.state != 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("Failed to read password")), .data={E_STRUCT} };
	}
	
 	string password = (*(string*)_t3.data);
	term__termios__set_state(0, old_state);
	builtin__println(_S(""));
	_result_string _t5;
	builtin___result_ok(&(string[]) { password }, (_result*)(&_t5), sizeof(string));
	 
	return _t5;
}
int os__fd_dup(int fd) {
	i32 _t2;
	#if defined(_WIN32)
	#else
		_t2 = dup(fd);
		;
	#endif
		return _t2;
}
int os__fd_dup2(int fd1, int fd2) {
	i32 _t2;
	#if defined(_WIN32)
	#else
		_t2 = dup2(fd1, fd2);
		;
	#endif
		return _t2;
}
_result_os__Pipe os__pipe(void) {
	Array_fixed_int_2 fds = {0};
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (pipe(&fds[0]) == -1) {
			return (_result_os__Pipe){ .is_error=true, .err=builtin___v_error(_S("Failed to create pipe")), .data={E_STRUCT} };
		}
	}
	#endif
	_result_os__Pipe _t3;
	builtin___result_ok(&(os__Pipe[]) { ((os__Pipe){.read_fd = fds[0],.write_fd = fds[1],}) }, (_result*)(&_t3), sizeof(os__Pipe));
	 
	return _t3;
}
void os__Pipe_close(os__Pipe* p) {
	if (p->read_fd != -1) {
		os__fd_close(p->read_fd);
		p->read_fd = -1;
	}
	if (p->write_fd != -1) {
		os__fd_close(p->write_fd);
		p->write_fd = -1;
	}
}
_result_int os__Pipe_read(os__Pipe* p, Array_u8* buffer) {
	i32 result = read(p->read_fd, buffer->data, buffer->len);
	if (result == -1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("Read failed")), .data={E_STRUCT} };
	}
	_result_int _t2;
	builtin___result_ok(&(int[]) { ((int)(result)) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
_result_int os__Pipe_write(os__Pipe* p, Array_u8 buffer) {
	i32 result = write(p->write_fd, buffer.data, buffer.len);
	if (result == -1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("Write failed")), .data={E_STRUCT} };
	}
	_result_int _t2;
	builtin___result_ok(&(int[]) { ((int)(result)) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
_result_int os__Pipe_write_string(os__Pipe* p, string s) {
	i32 result = write(p->write_fd, ((voidptr)(s.str)), s.len);
	if (result == -1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("Write failed")), .data={E_STRUCT} };
	}
	_result_int _t2;
	builtin___result_ok(&(int[]) { ((int)(result)) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
Array_string os__Pipe_slurp(os__Pipe* p) {
	os__fd_close(p->write_fd);
	p->write_fd = -1;
	Array_string result = os__fd_slurp(p->read_fd);
	os__fd_close(p->read_fd);
	p->read_fd = -1;
	return result;
}
_result_os__IOCapture os__stdio_capture(void) {
	os__IOCapture c = ((os__IOCapture){.__v_stdout = ((os__Pipe){.read_fd = -1,.write_fd = -1,}),.__v_stderr = ((os__Pipe){.read_fd = -1,.write_fd = -1,}),.original_stdout_fd = -1,.original_stderr_fd = -1,});
	_result_os__Pipe _t1 = os__pipe();
	if (_t1.is_error) {
		_result_os__IOCapture _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	os__Pipe pipe_stdout = (*(os__Pipe*)_t1.data);
	_result_os__Pipe _t3 = os__pipe();
	if (_t3.is_error) {
		_result_os__IOCapture _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	os__Pipe pipe_stderr = (*(os__Pipe*)_t3.data);
	c.original_stdout_fd = os__fd_dup(_const_os__fd_stdout);
	c.original_stderr_fd = os__fd_dup(_const_os__fd_stderr);
	if (os__fd_dup2(pipe_stdout.write_fd, _const_os__fd_stdout) == -1) {
		os__Pipe_close(&pipe_stdout);
		os__Pipe_close(&pipe_stderr);
		return (_result_os__IOCapture){ .is_error=true, .err=builtin___v_error(_S("Failed to redirect stdout")), .data={E_STRUCT} };
	}
	if (os__fd_dup2(pipe_stderr.write_fd, _const_os__fd_stderr) == -1) {
		os__fd_dup2(c.original_stdout_fd, _const_os__fd_stdout);
		os__Pipe_close(&pipe_stdout);
		os__Pipe_close(&pipe_stderr);
		return (_result_os__IOCapture){ .is_error=true, .err=builtin___v_error(_S("Failed to redirect stderr")), .data={E_STRUCT} };
	}
	os__fd_close(pipe_stdout.write_fd);
	os__fd_close(pipe_stderr.write_fd);
	pipe_stdout.write_fd = -1;
	pipe_stderr.write_fd = -1;
	c.__v_stdout = pipe_stdout;
	c.__v_stderr = pipe_stderr;
	_result_os__IOCapture _t7;
	builtin___result_ok(&(os__IOCapture[]) { c }, (_result*)(&_t7), sizeof(os__IOCapture));
	 
	return _t7;
}
void os__IOCapture_stop(os__IOCapture* c) {
	if (c->original_stdout_fd != -1) {
		os__fd_dup2(c->original_stdout_fd, _const_os__fd_stdout);
		os__fd_close(c->original_stdout_fd);
		c->original_stdout_fd = -1;
	}
	if (c->original_stderr_fd != -1) {
		os__fd_dup2(c->original_stderr_fd, _const_os__fd_stderr);
		os__fd_close(c->original_stderr_fd);
		c->original_stderr_fd = -1;
	}
}
void os__IOCapture_close(os__IOCapture* c) {
	os__Pipe_close(&c->__v_stdout);
	os__Pipe_close(&c->__v_stderr);
}
multi_return_Array_string_Array_string os__IOCapture_finish(os__IOCapture* c) {
	os__IOCapture_stop(c);
	Array_string stdout_str = os__Pipe_slurp(&c->__v_stdout);
	Array_string stderr_str = os__Pipe_slurp(&c->__v_stderr);
	os__IOCapture_close(c);
	return (multi_return_Array_string_Array_string){.arg0=stdout_str, .arg1=stderr_str};
}
void os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState__aborted;
}
void os__Process_signal_term(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_term(p);
}
void os__Process_signal_pgkill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_pgkill(p);
}
void os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState__running) {
		return;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState__stopped;
}
void os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState__stopped) {
		return;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState__running;
}
void os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState__not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__wait(p);
}
void os__Process_close(os__Process* p) {
	if (p->status == os__ProcessState__not_started || p->status == os__ProcessState__closed) {
		return;
	}
	p->status = os__ProcessState__closed;
	#if !defined(_WIN32)
	{
		for (int i = 0; i < 3; ++i) {
			if (p->stdio_fd[builtin__v_fixed_index(i, 3)] != 0) {
				os__fd_close(p->stdio_fd[builtin__v_fixed_index(i, 3)]);
			}
		}
	}
	#endif
}
void os__Process_free(os__Process* p) {
	os__Process_close(p);
	{ // Unsafe block
		builtin__string_free(&p->filename);
		builtin__string_free(&p->err);
		Array_string_free(&p->args);
		Array_string_free(&p->env);
	}
}
VV_LOC int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		Map_string_string current_environment = os__environ();
		int _t2 = current_environment.key_values.len;
		for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
			int _t3 = current_environment.key_values.len - _t2;
			_t2 = current_environment.key_values.len;
			if (_t3 < 0) {
				_t1 = -1;
				continue;
			}
			if (!builtin__DenseArray_has_index(&current_environment.key_values, _t1)) {continue;}
			string k = *(string*)builtin__DenseArray_key(&current_environment.key_values, _t1);
			k = builtin__string_clone(k);
			string v = (*(string*)builtin__DenseArray_value(&current_environment.key_values, _t1));
			builtin__array_push((array*)&p->env, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_S("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		pid = os__Process_unix_spawn_process(p);
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState__running;
	return 0;
}
bool os__Process_is_alive(os__Process* p) {
	bool res = false;
	if (p->status == os__ProcessState__running || p->status == os__ProcessState__stopped) {
		res = os__Process__is_alive(p);
	}
	return res;
}
void os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
}
void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, _S("Process.stdin_write"));
	os__Process__write_to(p, os__ChildProcessPipeKind__stdin, s);
}
string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _S("Process.stdout_slurp"));
	string res = os__Process__slurp_from(p, os__ChildProcessPipeKind__stdout);
	return res;
}
string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _S("Process.stderr_slurp"));
	string res = os__Process__slurp_from(p, os__ChildProcessPipeKind__stderr);
	return res;
}
string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, _S("Process.stdout_read"));
	string res = os__Process__read_from(p, os__ChildProcessPipeKind__stdout);
	return res;
}
string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, _S("Process.stderr_read"));
	string res = os__Process__read_from(p, os__ChildProcessPipeKind__stderr);
	return res;
}
_option_string os__Process_pipe_read(os__Process* p, os__ChildProcessPipeKind pkind) {
	os__Process__check_redirection_call(p, _S("Process.pipe_read"));
	if (!os__Process__is_pending(p, pkind)) {
		return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	string res = os__Process__read_from(p, pkind);
	_option_string _t2;
	builtin___option_ok(&(string[]) { res }, (_option*)(&_t2), sizeof(string));
	 
	return _t2;
}
bool os__Process_is_pending(os__Process* p, os__ChildProcessPipeKind pkind) {
	os__Process__check_redirection_call(p, _S("Process.is_pending"));
	bool res = os__Process__is_pending(p, pkind);
	return res;
}
VV_LOC string os__Process__read_from(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		multi_return_string_int mr_6450 = os__fd_read(p->stdio_fd[builtin__v_fixed_index(pkind, 3)], 4096);
		string s = mr_6450.arg0;
		return s;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string os__Process__slurp_from(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return Array_string_join(os__fd_slurp(p->stdio_fd[builtin__v_fixed_index(pkind, 3)]), _S(""));
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC void os__Process__write_to(os__Process* p, os__ChildProcessPipeKind pkind, string s) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__fd_write(p->stdio_fd[builtin__v_fixed_index(pkind, 3)], s);
	}
	#endif
}
VV_LOC bool os__Process__is_pending(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return os__fd_is_pending(p->stdio_fd[builtin__v_fixed_index(pkind, 3)]);
	}
	#endif
	return false;
}
VV_LOC void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		builtin___v_panic(builtin__string__plus(_S("Call p.set_redirect_stdio() before calling p."), fn_name));
		VUNREACHABLE();
	}
	if (p->status == os__ProcessState__not_started) {
		builtin___v_panic(builtin__string__plus(builtin__string__plus(_S("Call p."), fn_name), _S("() after you have called p.run()")));
		VUNREACHABLE();
	}
}
VV_LOC void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_stop_process(p);
	}
	#endif
}
VV_LOC void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_resume_process(p);
	}
	#endif
}
VV_LOC void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_kill_process(p);
	}
	#endif
}
VV_LOC void os__Process__signal_term(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_term_process(p);
	}
	#endif
}
VV_LOC void os__Process__signal_pgkill(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_kill_pgroup(p);
	}
	#endif
}
VV_LOC void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_wait(p);
	}
	#endif
}
VV_LOC bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return os__Process_unix_is_alive(p);
	}
	#endif
	return 0;
}
void os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	os__Process__spawn(p);
}
os__Process* os__new_process(string filename) {
	return ((os__Process*)builtin__memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState__not_started,.err = (string){.str=(byteptr)"", .is_lit=1},.args = builtin____new_array(0, 0, sizeof(string)),.work_folder = (string){.str=(byteptr)"", .is_lit=1},.env_is_custom = 0,.env = builtin____new_array(0, 0, sizeof(string)),.use_stdio_ctl = 0,.use_pgroup = 0,.stdio_fd = {-1, -1, -1},.wdata = 0,.create_no_window = 0,}, sizeof(os__Process)));
}
void os__Process_set_args(os__Process* p, Array_string pargs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->args = pargs;
	return;
}
void os__Process_set_work_folder(os__Process* p, string path) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->work_folder = os__real_path(path);
	return;
}
void os__Process_set_environment(os__Process* p, Map_string_string envs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->env_is_custom = true;
	p->env = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	int _t2 = envs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = envs.key_values.len - _t2;
		_t2 = envs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&envs.key_values, _t1)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&envs.key_values, _t1);
		k = builtin__string_clone(k);
		string v = (*(string*)builtin__DenseArray_value(&envs.key_values, _t1));
		builtin__array_push((array*)&p->env, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_S("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	return;
}
VV_LOC int os__Process_unix_spawn_process(os__Process* p) {
	Array_fixed_int_6 pipeset = {0};
	if (p->use_stdio_ctl) {
		i32 dont_care = pipe(&pipeset[0]);
		dont_care = pipe(&pipeset[2]);
		dont_care = pipe(&pipeset[4]);
		{i32 _ = dont_care;}
		;
	}
	int pid = os__fork();
	if (pid != 0) {
		if (p->use_stdio_ctl) {
			p->stdio_fd[0] = pipeset[1];
			p->stdio_fd[1] = pipeset[2];
			p->stdio_fd[2] = pipeset[4];
			os__fd_close(pipeset[0]);
			os__fd_close(pipeset[3]);
			os__fd_close(pipeset[5]);
		}
		return pid;
	}
	if (p->use_pgroup) {
		setpgid(0, 0);
	}
	if (p->use_stdio_ctl) {
		os__fd_close(pipeset[1]);
		os__fd_close(pipeset[2]);
		os__fd_close(pipeset[4]);
		dup2(pipeset[0], 0);
		dup2(pipeset[3], 1);
		dup2(pipeset[5], 2);
		os__fd_close(pipeset[0]);
		os__fd_close(pipeset[3]);
		os__fd_close(pipeset[5]);
	}
	if ((p->work_folder).len != 0) {
		if (!os__is_abs_path(p->filename)) {
			p->filename = os__abs_path(p->filename);
		}
		_result_void _t2 = os__chdir(p->work_folder);
		(void)_t2;
 ;
	}
	_result_void _t3 = os__execve(p->filename, p->args, p->env);
	if (_t3.is_error) {
		IError err = _t3.err;
		builtin__eprintln(builtin__IError_str(err));
		builtin___v_exit(1);
		VUNREACHABLE();
	;
	}
	
 ;
	return 0;
}
VV_LOC void os__Process_unix_stop_process(os__Process* p) {
	kill(p->pid, SIGSTOP);
}
VV_LOC void os__Process_unix_resume_process(os__Process* p) {
	kill(p->pid, SIGCONT);
}
VV_LOC void os__Process_unix_term_process(os__Process* p) {
	kill(p->pid, SIGTERM);
}
VV_LOC void os__Process_unix_kill_process(os__Process* p) {
	kill(p->pid, SIGKILL);
}
VV_LOC void os__Process_unix_kill_pgroup(os__Process* p) {
	kill(-p->pid, SIGKILL);
}
VV_LOC void os__Process_unix_wait(os__Process* p) {
	os__Process_impl_check_pid_status(p, false, 0);
}
VV_LOC bool os__Process_unix_is_alive(os__Process* p) {
	return os__Process_impl_check_pid_status(p, true, WNOHANG);
}
VV_LOC bool os__Process_impl_check_pid_status(os__Process* p, bool exit_early_on_ret0, int waitpid_options) {
	int cstatus = 0;
	int ret = -1;
	#if !defined(CUSTOM_DEFINE_emscripten)
	{
		ret = waitpid(p->pid, &cstatus, waitpid_options);
	}
	#endif
	p->code = ret;
	if (ret == -1) {
		p->err = os__posix_get_error_msg(errno);
		return false;
	}
	if (exit_early_on_ret0 && ret == 0) {
		return true;
	}
	multi_return_int_bool mr_3008 = os__posix_wait4_to_exit_status(cstatus);
	int pret = mr_3008.arg0;
	bool is_signaled = mr_3008.arg1;
	if (is_signaled) {
		p->status = os__ProcessState__aborted;
		p->err = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Terminated by signal "), 0x4fe27, {.d_i32 = pret}}, {_S(" ("), 0xfe10, {.d_s = os__sigint_to_signal_name(pret)}}, {_S(")"), 0, { .d_c = 0 }}}));
		pret += 128;
	} else {
		p->status = os__ProcessState__exited;
	}
	p->code = pret;
	return false;
}
_result_anon_fn_os__signal os__signal_opt(os__Signal signum, void (*handler)(os__Signal )) {
	errno = 0;
	voidptr prev_handler = signal(((int)(signum)), (voidptr)handler);
	if (prev_handler == SIG_ERR) {
		return (_result_anon_fn_os__signal){ .is_error=true, .err=builtin__error_with_code(os__posix_get_error_msg(EINVAL), EINVAL), .data={E_STRUCT} };
	}
	_result_anon_fn_os__signal _t2;
	builtin___result_ok(&(os__SignalHandler[]) { (voidptr)((os__SignalHandler)(prev_handler)) }, (_result*)(&_t2), sizeof(os__SignalHandler));
	 
	return _t2;
}
VV_LOC void os__ignore_signal_handler(os__Signal _signal) {
}
void os__signal_ignore(Array_os__Signal args) {
	if (os__is_main_thread()) {
		#if !defined(_WIN32)
		{
			for (int _t2 = 0; _t2 < args.len; ++_t2) {
				os__Signal arg = ((os__Signal*)args.data)[_t2];
				_result_anon_fn_os__signal _t3 = os__signal_opt(arg, (voidptr)os__ignore_signal_handler);
				(void)_t3;
 ;
			}
		}
		#endif
	} else {
		os__signal_ignore_internal(args);
	}
}
bool os__is_main_thread(void) {
	return g_main_thread_id == ((u64)(pthread_self()));
}
VV_LOC void os__signal_ignore_internal(Array_os__Signal args) {
	u32 mask1 = ((u32)(0));
	sigemptyset(&mask1);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		os__Signal arg = ((os__Signal*)args.data)[_t1];
		sigaddset(&mask1, ((int)(arg)));
	}
	sigprocmask(SIG_BLOCK, &mask1, ((void*)0));
}
VV_LOC void os__sleep_ms(i64 ms) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct timespec req = ((struct timespec){.tv_sec = (i64)(ms / 1000),.tv_nsec = (i64)(1000000 * ((i64)(ms % 1000))),});
		struct timespec rem = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
		for (;;) {
			if (!(nanosleep(&req, &rem) < 0)) break;
			if (errno == EINTR) {
				req = rem;
			} else {
				break;
			}
		}
	}
	#endif
}
_result_void os__open_uri(string uri) {
	string vopen_uri_cmd = os__getenv(_S("VOPEN_URI_CMD"));
	if ((vopen_uri_cmd).len == 0) {
		#if defined(__APPLE__)
		{
			vopen_uri_cmd = _S("open");
		}
		#elif defined(__FreeBSD__) || defined(__OpenBSD__)
		{
		}
		#elif defined(__linux__)
		{
		}
		#endif
	}
	if ((vopen_uri_cmd).len == 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("unsupported platform")), .data={E_STRUCT} };
	}
	os__Result result = os__execute(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vopen_uri_cmd}}, {_S(" \""), 0xfe10, {.d_s = uri}}, {_S("\""), 0, { .d_c = 0 }}})));
	if (result.exit_code != 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unable to open url: "), 0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
_result_os__Stat os__stat(string path) {
	struct stat s;
	{ // Unsafe block
		i32 res = stat(((char*)(path.str)), &s);
		if (res != 0) {
			return (_result_os__Stat){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
		}
		_result_os__Stat _t2;
		builtin___result_ok(&(os__Stat[]) { ((os__Stat){
			.dev = s.st_dev,
			.inode = s.st_ino,
			.mode = s.st_mode,
			.nlink = s.st_nlink,
			.uid = s.st_uid,
			.gid = s.st_gid,
			.rdev = s.st_rdev,
			.size = s.st_size,
			.atime = s.st_atime,
			.mtime = s.st_mtime,
			.ctime = s.st_ctime,
		}) }, (_result*)(&_t2), sizeof(os__Stat));
		 
		return _t2;
	}
	return (_result_os__Stat){0};
}
_result_os__Stat os__lstat(string path) {
	struct stat s;
	{ // Unsafe block
		i32 res = lstat(((char*)(path.str)), &s);
		if (res != 0) {
			return (_result_os__Stat){ .is_error=true, .err=os__error_posix(((os__SystemError){.msg = (string){.str=(byteptr)"", .is_lit=1},.code = _const_os__error_code_not_set,})), .data={E_STRUCT} };
		}
		_result_os__Stat _t2;
		builtin___result_ok(&(os__Stat[]) { ((os__Stat){
			.dev = s.st_dev,
			.inode = s.st_ino,
			.mode = s.st_mode,
			.nlink = s.st_nlink,
			.uid = s.st_uid,
			.gid = s.st_gid,
			.rdev = s.st_rdev,
			.size = s.st_size,
			.atime = s.st_atime,
			.mtime = s.st_mtime,
			.ctime = s.st_ctime,
		}) }, (_result*)(&_t2), sizeof(os__Stat));
		 
		return _t2;
	}
	return (_result_os__Stat){0};
}
os__FileType os__Stat_get_filetype(os__Stat st) {
	u32 _t1 = (st.mode & ((u32)(S_IFMT)));
	
	if (_t1 == (((u32)(S_IFREG)))) {
		return os__FileType__regular;
	}
	else if (_t1 == (((u32)(S_IFDIR)))) {
		return os__FileType__directory;
	}
	else if (_t1 == (((u32)(S_IFCHR)))) {
		return os__FileType__character_device;
	}
	else if (_t1 == (((u32)(S_IFBLK)))) {
		return os__FileType__block_device;
	}
	else if (_t1 == (((u32)(S_IFIFO)))) {
		return os__FileType__fifo;
	}
	else if (_t1 == (((u32)(S_IFLNK)))) {
		return os__FileType__symbolic_link;
	}
	else if (_t1 == (((u32)(S_IFSOCK)))) {
		return os__FileType__socket;
	}
	else {
		return os__FileType__unknown;
	}
	return 0;
}
os__FileMode os__Stat_get_mode(os__Stat st) {
	return ((os__FileMode){.typ = os__Stat_get_filetype(st),.owner = ((os__FilePermission){.read = ((st.mode & ((u32)(S_IRUSR)))) != 0,.write = ((st.mode & ((u32)(S_IWUSR)))) != 0,.execute = ((st.mode & ((u32)(S_IXUSR)))) != 0,}),.group = ((os__FilePermission){.read = ((st.mode & ((u32)(S_IRGRP)))) != 0,.write = ((st.mode & ((u32)(S_IWGRP)))) != 0,.execute = ((st.mode & ((u32)(S_IXGRP)))) != 0,}),.others = ((os__FilePermission){.read = ((st.mode & ((u32)(S_IROTH)))) != 0,.write = ((st.mode & ((u32)(S_IWOTH)))) != 0,.execute = ((st.mode & ((u32)(S_IXOTH)))) != 0,}),});
}
bool os__is_dir(string path) {
	_result_os__Stat _t1 = os__stat(path);
	if (_t1.is_error) {
		return false;
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	return os__Stat_get_filetype(attr) == os__FileType__directory;
}
bool os__is_link(string path) {
	_result_os__Stat _t1 = os__lstat(path);
	if (_t1.is_error) {
		return false;
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	return os__Stat_get_filetype(attr) == os__FileType__symbolic_link;
}
VV_LOC os__PathKind os__kind_of_existing_path(string path) {
	os__PathKind res = ((os__PathKind){.is_file = 0,.is_dir = 0,.is_link = 0,});
	_result_os__Stat _t1 = os__lstat(path);
	if (_t1.is_error) {
		return res;
	}
	
 	os__Stat attr = (*(os__Stat*)_t1.data);
	res.is_file = os__Stat_get_filetype(attr) == os__FileType__regular;
	res.is_dir = os__Stat_get_filetype(attr) == os__FileType__directory;
	res.is_link = os__Stat_get_filetype(attr) == os__FileType__symbolic_link;
	return res;
}
os__filelock__FileLock os__filelock__new(string fileName) {
	return ((os__filelock__FileLock){.name = fileName,.fd = -1,});
}
bool os__filelock__FileLock_wait_acquire(os__filelock__FileLock* l, time__Duration timeout) {
	time__Time fin = time__Time_add(time__now(), timeout);
	for (;;) {
		if (!(time__Time__lt(time__now(), fin))) break;
		if (os__filelock__FileLock_try_acquire(l)) {
			return true;
		}
		time__sleep(1 * _const_time__millisecond);
	}
	return false;
}
bool os__filelock__FileLock_release(os__filelock__FileLock* l) {
	if (l->fd != -1) {
		os__filelock__FileLock_unlink(l);
		return true;
	}
	return false;
}
void os__filelock__FileLock_unlink(os__filelock__FileLock* l) {
	if (l->fd != -1) {
		close(l->fd);
		l->fd = -1;
	}
	unlink(((char*)(l->name.str)));
}
_result_void os__filelock__FileLock_acquire(os__filelock__FileLock* l) {
	if (l->fd != -1) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(_S("lock already acquired by this instance"), 1), .data={E_STRUCT} };
	}
	int fd = os__filelock__open_lockfile(l->name);
	if (fd == -1) {
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot create lock file "), 0xfe10, {.d_s = l->name}}, {_SLIT0, 0, { .d_c = 0 }}})), -1), .data={E_STRUCT} };
	}
	if (flock(fd, LOCK_EX) == -1) {
		close(fd);
		return (_result_void){ .is_error=true, .err=builtin__error_with_code(_S("cannot lock"), -2), .data={E_STRUCT} };
	}
	l->fd = fd;
	return (_result_void){0};
}
VV_LOC int os__filelock__open_lockfile(string f) {
	i32 fd = open(((char*)(f.str)), O_CREAT, 0644);
	if (fd == -1) {
		fd = open(((char*)(f.str)), O_RDONLY, 0);
	}
	return fd;
}
bool os__filelock__FileLock_try_acquire(os__filelock__FileLock* l) {
	if (l->fd != -1) {
		return true;
	}
	int fd = os__filelock__open_lockfile(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = l->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (fd != -1) {
		i32 err = flock(fd, (LOCK_EX | LOCK_NB));
		if (err == -1) {
			close(fd);
			return false;
		}
		l->fd = fd;
		return true;
	}
	return false;
}
inline VV_LOC u32 rand__seed__nr_next(u32 prev) {
	return (u32)((u32)(prev * 1664525) + 1013904223);
}
Array_u32 rand__seed__time_seed_array(int count) {
	u64 ctime = time__sys_mono_now();
	u32 seed = ((u32)(((ctime >> 32) ^ ((ctime & 0x00000000FFFFFFFFU)))));
	Array_u32 seed_data = builtin____new_array_with_default(0, count, sizeof(u32), 0);
	for (int _t1 = 0; _t1 < count; ++_t1) {
		seed = rand__seed__nr_next(seed);
		builtin__array_push((array*)&seed_data, _MOV((u32[]){ rand__seed__nr_next(seed) }));
	}
	return seed_data;
}
u32 rand__seed__time_seed_32(void) {
	Array_u32 sa = rand__seed__time_seed_array(1);
	u32 res = (*(u32*)builtin__array_get(sa, 0));
	builtin__array_free(&sa);
	return res;
}
u64 rand__seed__time_seed_64(void) {
	Array_u32 seed_data = rand__seed__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)builtin__array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)builtin__array_get(seed_data, 1))));
	builtin__array_free(&seed_data);
	u64 res = (lower | ((upper << 32)));
	return res;
}
string v__cflag__CFlag_str(v__cflag__CFlag* c) {
	return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("CFlag{ name: \""), 0xfe10, {.d_s = c->name}}, {_S("\" value: \""), 0xfe10, {.d_s = c->value}}, {_S("\" mod: \""), 0xfe10, {.d_s = c->mod}}, {_S("\" os: \""), 0xfe10, {.d_s = c->os}}, {_S("\" cached: \""), 0xfe10, {.d_s = c->cached}}, {_S("\" }"), 0, { .d_c = 0 }}}));
}
VV_LOC multi_return_bool_string_int_Array_string v__cflag__find_first_existing_path(string remainder, string literal) {
	string sparams = builtin__string_all_before(builtin__string_substr(remainder, (int)(literal.len + 1), 2147483647), _S(")"));
	int delta_i = (int)((int)(sparams.len + literal.len) + 1);
	Array_string _t1 = {0};
	Array_string _t1_orig = builtin__string_split_into_lines(builtin__string_replace(sparams, _S(","), _S("\n")));
	int _t1_len = _t1_orig.len;
	_t1 = builtin____new_array(0, _t1_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
		string it = ((string*) _t1_orig.data)[_t3];
		string _t2 = builtin__string_trim(it, _S("\t \'\""));
		builtin__array_push((array*)&_t1, &_t2);
	}
	Array_string svalues =_t1;
	for (int _t4 = 0; _t4 < svalues.len; ++_t4) {
		string spath = ((string*)svalues.data)[_t4];
		if (os__exists(spath)) {
			return (multi_return_bool_string_int_Array_string){.arg0=true, .arg1=spath, .arg2=delta_i, .arg3=builtin____new_array_with_default(0, 0, sizeof(string), 0)};
		}
	}
	return (multi_return_bool_string_int_Array_string){.arg0=false, .arg1=_S(""), .arg2=delta_i, .arg3=svalues};
}
_option_string v__cflag__CFlag_eval(v__cflag__CFlag* cf) {
	strings__Builder value_builder = strings__new_builder((int)(10 * cf->value.len));
	cflag_eval_outer_loop:
	for (int i = 0; i < cf->value.len; i++) {
		u8 x = builtin__string_at(cf->value, i);
		if (x == '$') {
			string remainder = builtin__string_substr(cf->value, i, 2147483647);
			if (builtin__string_starts_with(remainder, _const_v__cflag__fexisting_literal)) {
				multi_return_bool_string_int_Array_string mr_1491 = v__cflag__find_first_existing_path(remainder, _const_v__cflag__fexisting_literal);
				bool found = mr_1491.arg0;
				string spath = mr_1491.arg1;
				int delta_i = mr_1491.arg2;
				Array_string svalues = mr_1491.arg3;
				if (found) {
					strings__Builder_write_string(&value_builder, spath);
					i += delta_i;
					continue;
				}
				builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(">> error: none of the paths "), 0xfe10, {.d_s = Array_string_str(svalues)}}, {_S(" exist"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
			if (builtin__string_starts_with(remainder, _const_v__cflag__wexisting_literal)) {
				multi_return_bool_string_int_Array_string mr_1787 = v__cflag__find_first_existing_path(remainder, _const_v__cflag__wexisting_literal);
				bool found = mr_1787.arg0;
				string spath = mr_1787.arg1;
				int delta_i = mr_1787.arg2;
				if (found) {
					strings__Builder_write_string(&value_builder, spath);
					i += delta_i;
					continue;
				}
				return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
			}
		}
		strings__Builder_write_string(&value_builder, builtin__u8_ascii_str(x));
	cflag_eval_outer_loop__continue: {}
	}
	cflag_eval_outer_loop__break: {}
	_option_string _t2;
	builtin___option_ok(&(string[]) { strings__Builder_str(&value_builder) }, (_option*)(&_t2), sizeof(string));
	 
	return _t2;
}
_option_string v__cflag__CFlag_format(v__cflag__CFlag* cf) {
	string value = _S("");
	if ((cf->cached).len != 0) {
		value = cf->cached;
	} else {
		_option_string _t1 = v__cflag__CFlag_eval(cf);
		if (_t1.state != 0) {
			_option_string _t2;
			memcpy(&_t2, &_t1, sizeof(_option));
			return _t2;
		}
		
 		value = (*(string*)_t1.data);
	}
	if ((builtin__fast_string_eq(cf->name, _S("-l")) || builtin__fast_string_eq(cf->name, _S("-Wa")) || builtin__fast_string_eq(cf->name, _S("-Wl")) || builtin__fast_string_eq(cf->name, _S("-Wp"))) && (value).len != 0) {
		_option_string _t3;
		builtin___option_ok(&(string[]) { builtin__string_trim_space(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cf->name}}, {_SLIT0, 0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}}))) }, (_option*)(&_t3), sizeof(string));
		 
		return _t3;
	}
	if (builtin__fast_string_eq(cf->name, _S("-I")) || builtin__fast_string_eq(cf->name, _S("-L")) || builtin__string_ends_with(value, _S(".o"))) {
		value = builtin__string__plus(builtin__string__plus(_S("\""), os__real_path(value)), _S("\""));
	}
	_option_string _t4;
	builtin___option_ok(&(string[]) { builtin__string_trim_space(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cf->name}}, {_S(" "), 0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}}))) }, (_option*)(&_t4), sizeof(string));
	 
	return _t4;
}
Array_string Array_v__cflag__CFlag_c_options_before_target_msvc(Array_v__cflag__CFlag cflags) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
Array_string Array_v__cflag__CFlag_c_options_after_target_msvc(Array_v__cflag__CFlag cflags) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
Array_string Array_v__cflag__CFlag_c_options_before_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_2806 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string defines = mr_2806.arg0;
	Array_string others = mr_2806.arg1;
	Array_string args = builtin____new_array_with_default(0, (int)(defines.len + others.len), sizeof(string), 0);
	_PUSH_MANY(&args, (defines), _t1, Array_string);
	_PUSH_MANY(&args, (others), _t2, Array_string);
	return v__cflag__uniq_non_empty(args);
}
Array_string Array_v__cflag__CFlag_c_options_after_target(Array_v__cflag__CFlag cflags) {
	multi_return_Array_string_Array_string_Array_string mr_3028 = Array_v__cflag__CFlag_defines_others_libs(cflags);
	Array_string libs = mr_3028.arg2;
	return libs;
}
Array_string Array_v__cflag__CFlag_c_options_without_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (builtin__string_ends_with(flag.value, _S(".o")) || builtin__string_ends_with(flag.value, _S(".obj"))) {
			continue;
		}
		_option_string _t3 = v__cflag__CFlag_format(&flag);
		if (_t3.state != 0) {
			continue;
		}
		
 		builtin__array_push((array*)&args, _MOV((string[]){ (*(string*)_t3.data) }));
	}
	return v__cflag__uniq_non_empty(args);
}
Array_string Array_v__cflag__CFlag_c_options_only_object_files(Array_v__cflag__CFlag cflags) {
	Array_string args = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < cflags.len; ++_t1) {
		v__cflag__CFlag flag = ((v__cflag__CFlag*)cflags.data)[_t1];
		if (builtin__string_ends_with(flag.value, _S(".o")) || builtin__string_ends_with(flag.value, _S(".obj")) || (builtin__fast_string_eq(flag.name, _S("-l")) && builtin__fast_string_eq(flag.value, _S("pq")))) {
			_option_string _t3 = v__cflag__CFlag_format(&flag);
			if (_t3.state != 0) {
				continue;
			}
			
 			builtin__array_push((array*)&args, _MOV((string[]){ (*(string*)_t3.data) }));
		}
	}
	return v__cflag__uniq_non_empty(args);
}
multi_return_Array_string_Array_string_Array_string Array_v__cflag__CFlag_defines_others_libs(Array_v__cflag__CFlag cflags) {
	Array_string copts_without_obj_files = Array_v__cflag__CFlag_c_options_without_object_files(cflags);
	Array_string defines = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_string others = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_string libs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < copts_without_obj_files.len; ++_t1) {
		string copt = ((string*)copts_without_obj_files.data)[_t1];
		if (builtin__string_ends_with(copt, _S("@START_LIBS"))) {
			builtin__array_insert(&libs, 0, &(string[]){builtin__string_all_before(copt, _S("@START_LIBS"))});
			continue;
		}
		if (builtin__string_starts_with(copt, _S("-l"))) {
			builtin__array_push((array*)&libs, _MOV((string[]){ builtin__string_clone(copt) }));
			continue;
		}
		if (builtin__string_ends_with(copt, _S(".a"))) {
			builtin__array_push((array*)&libs, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\""), 0xfe10, {.d_s = copt}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			continue;
		}
		if (builtin__string_ends_with(copt, _S("@START_DEFINES"))) {
			builtin__array_insert(&defines, 0, &(string[]){builtin__string_all_before(copt, _S("@START_DEFINES"))});
			continue;
		}
		if (builtin__string_starts_with(copt, _S("-D"))) {
			builtin__array_push((array*)&defines, _MOV((string[]){ builtin__string_clone(copt) }));
			continue;
		}
		if (builtin__string_ends_with(copt, _S("@START_OTHERS"))) {
			builtin__array_insert(&others, 0, &(string[]){builtin__string_all_before(copt, _S("@START_OTHERS"))});
			continue;
		}
		builtin__array_push((array*)&others, _MOV((string[]){ builtin__string_clone(copt) }));
	}
	return (multi_return_Array_string_Array_string_Array_string){.arg0=v__cflag__uniq_non_empty(defines), .arg1=v__cflag__uniq_non_empty(others), .arg2=v__cflag__uniq_non_empty(libs)};
}
VV_LOC Array_string v__cflag__uniq_non_empty(Array_string args) {
	Array_string uniq_args = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		string a = ((string*)args.data)[_t1];
		if ((a).len == 0) {
			continue;
		}
		if (!(Array_string_contains(uniq_args, a))) {
			builtin__array_push((array*)&uniq_args, _MOV((string[]){ builtin__string_clone(a) }));
		}
	}
	return uniq_args;
}
VV_LOC void v__vcache__remove_old_cache_folder(void) {
	string old_cache_folder = os__join_path(os__vmodules_dir(), builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("cache")})));
	if (os__exists(old_cache_folder)) {
		string old_readme_file = os__join_path(old_cache_folder, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("README.md")})));
		if (os__file_size(old_readme_file) == 254) {
			_result_void _t1 = os__rmdir_all(old_cache_folder);
			(void)_t1;
 ;
			;
		}
	}
}
v__vcache__CacheManager v__vcache__new_cache_manager(Array_string opts) {
	_option_string _t1 = os__getenv_opt(_S("VCACHE"));
	if (_t1.state != 0) {
		*(string*) _t1.data = os__join_path(os__vmodules_dir(), builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S(".cache")})));
	}
	
 	string vcache_basepath = (*(string*)_t1.data);
	;
	;
	if (!os__is_dir(vcache_basepath)) {
		v__vcache__remove_old_cache_folder();
		_result_void _t2 = os__mkdir_all(vcache_basepath, ((os__MkdirParams){.mode = 0700,}));
		if (_t2.is_error) {
			IError err = _t2.err;
			builtin___v_panic(builtin__IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		;
	}
	string readme_file = os__join_path(vcache_basepath, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("README.md")})));
	if (!os__is_file(readme_file)) {
		string readme_content = builtin__string_strip_margin(_S("This folder contains cached build artifacts from the V build system.\n\011\011|You can safely delete it, if it is getting too large.\n\011\011|It will be recreated the next time you compile something with V.\n\011\011|You can change its location with the VCACHE environment variable.\n\011\011"));
		_result_void _t3 = os__write_file(readme_file, readme_content);
		if (_t3.is_error) {
			IError err = _t3.err;
			builtin___v_panic(builtin__IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
		;
	}
	Map_string_bool deduped_opts = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t4 = 0; _t4 < opts.len; ++_t4) {
		string o = ((string*)opts.data)[_t4];
		builtin__map_set(&deduped_opts, &(string[]){o}, &(bool[]) { true });
	}
	Array_string _t5 = {0};
	Array_string _t5_orig = builtin__map_keys(&deduped_opts);
	int _t5_len = _t5_orig.len;
	_t5 = builtin____new_array(0, _t5_len, sizeof(string));

	for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
		string it = ((string*) _t5_orig.data)[_t6];
		if ((it).len != 0 && !builtin__string_starts_with(it, _S("['gcboehm', "))) {
			builtin__array_push((array*)&_t5, &it);
		}
	}
	Array_string deduped_opts_keys =_t5;
	string original_vopts = Array_string_join(deduped_opts_keys, _S("|"));
	return ((v__vcache__CacheManager){.basepath = vcache_basepath,.original_vopts = original_vopts,.vopts = original_vopts,.k2cpath = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
}
void v__vcache__CacheManager_set_temporary_options(v__vcache__CacheManager* cm, Array_string new_opts) {
	cm->vopts = builtin__string__plus(builtin__string__plus(cm->original_vopts, _S("#")), Array_string_join(new_opts, _S("|")));
	;
}
string v__vcache__CacheManager_key2cpath(v__vcache__CacheManager* cm, string key) {
	string* _t2 = (string*)(builtin__map_get_check(ADDR(map, cm->k2cpath), &(string[]){key}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t1.state != 0) {
		*(string*) _t1.data = _S("");
	}
	
	string cpath = (*(string*)_t1.data);
	if ((cpath).len == 0) {
		string hk = builtin__string__plus(cm->vopts, key);
		string a = builtin__u64_hex_full(hash__sum64_string(hk, 5));
		string b = builtin__u64_hex_full(hash__sum64_string(hk, 7));
		string khash = builtin__string__plus(a, b);
		string prefix = builtin__string_substr(khash, 0, 2);
		string cprefix_folder = os__join_path(cm->basepath, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){prefix})));
		cpath = os__join_path(cprefix_folder, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){khash})));
		if (!os__is_dir(cprefix_folder)) {
			_result_void _t3 = os__mkdir_all(cprefix_folder, ((os__MkdirParams){.mode = 0777,}));
			if (_t3.is_error) {
				IError err = _t3.err;
				if (!os__is_dir(cprefix_folder)) {
					builtin___v_panic(builtin__IError_str(err));
					VUNREACHABLE();
				}
			;
			}
			
 ;
		}
		;
		;
		;
		;
		builtin__map_set(&cm->k2cpath, &(string[]){key}, &(string[]) { cpath });
	}
	;
	return cpath;
}
string v__vcache__CacheManager_postfix_with_key2cpath(v__vcache__CacheManager* cm, string postfix, string key) {
	string prefix = v__vcache__CacheManager_key2cpath(cm, key);
	string res = builtin__string__plus(prefix, postfix);
	return res;
}
VV_LOC string v__vcache__normalise_mod(string mod) {
	return builtin__string_trim(builtin__string_replace(builtin__string_replace(builtin__string_replace(mod, _S("/"), _S(".")), _S("\\"), _S(".")), _S("vlib."), _S("")), _S("."));
}
string v__vcache__CacheManager_mod_postfix_with_key2cpath(v__vcache__CacheManager* cm, string mod, string postfix, string key) {
	string prefix = v__vcache__CacheManager_key2cpath(cm, key);
	string res = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = prefix}}, {_S(".module."), 0xfe10, {.d_s = v__vcache__normalise_mod(mod)}}, {_SLIT0, 0xfe10, {.d_s = postfix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return res;
}
_result_string v__vcache__CacheManager_exists(v__vcache__CacheManager* cm, string postfix, string key) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	;
	if (!os__exists(fpath)) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("does not exist yet")), .data={E_STRUCT} };
	}
	_result_string _t2;
	builtin___result_ok(&(string[]) { fpath }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
_result_string v__vcache__CacheManager_mod_exists(v__vcache__CacheManager* cm, string mod, string postfix, string key) {
	string fpath = v__vcache__CacheManager_mod_postfix_with_key2cpath(cm, mod, postfix, key);
	;
	if (!os__exists(fpath)) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("does not exist yet")), .data={E_STRUCT} };
	}
	_result_string _t2;
	builtin___result_ok(&(string[]) { fpath }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
_result_string v__vcache__CacheManager_save(v__vcache__CacheManager* cm, string postfix, string key, string content) {
	string fpath = v__vcache__CacheManager_postfix_with_key2cpath(cm, postfix, key);
	_result_void _t1 = os__write_file(fpath, content);
	if (_t1.is_error) {
		_result_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	;
	_result_string _t3;
	builtin___result_ok(&(string[]) { fpath }, (_result*)(&_t3), sizeof(string));
	 
	return _t3;
}
_result_string v__vcache__CacheManager_mod_save(v__vcache__CacheManager* cm, string mod, string postfix, string key, string content) {
	string fpath = v__vcache__CacheManager_mod_postfix_with_key2cpath(cm, mod, postfix, key);
	_result_void _t1 = os__write_file(fpath, content);
	if (_t1.is_error) {
		_result_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	;
	_result_string _t3;
	builtin___result_ok(&(string[]) { fpath }, (_result*)(&_t3), sizeof(string));
	 
	return _t3;
}
_result_string v__vcache__CacheManager_load(v__vcache__CacheManager* cm, string postfix, string key) {
	_result_string _t1 = v__vcache__CacheManager_exists(cm, postfix, key);
	if (_t1.is_error) {
		_result_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	string fpath = (*(string*)_t1.data);
	_result_string _t3 = os__read_file(fpath);
	if (_t3.is_error) {
		_result_string _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	string content = (*(string*)_t3.data);
	;
	_result_string _t5;
	builtin___result_ok(&(string[]) { content }, (_result*)(&_t5), sizeof(string));
	 
	return _t5;
}
_result_string v__vcache__CacheManager_mod_load(v__vcache__CacheManager* cm, string mod, string postfix, string key) {
	_result_string _t1 = v__vcache__CacheManager_mod_exists(cm, mod, postfix, key);
	if (_t1.is_error) {
		_result_string _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	string fpath = (*(string*)_t1.data);
	_result_string _t3 = os__read_file(fpath);
	if (_t3.is_error) {
		_result_string _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	string content = (*(string*)_t3.data);
	;
	_result_string _t5;
	builtin___result_ok(&(string[]) { content }, (_result*)(&_t5), sizeof(string));
	 
	return _t5;
}
VV_LOC void v__vcache__xlog(string fname, string s) {
	int pid = v__vcache__mypid();
	if (builtin__string_at(fname, 0) != '|') {
		builtin__eprintln(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("> VCache | pid: "), 0xfe07, {.d_i32 = pid}}, {_S(" | CacheManager."), 0xfe10, {.d_s = fname}}, {_S(" "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	} else {
		builtin__eprintln(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("> VCache | pid: "), 0xfe07, {.d_i32 = pid}}, {_S(" "), 0xfe10, {.d_s = fname}}, {_S(" "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}
VV_LOC int v__vcache__mypid(void) {
	static int pid = 0;
	if (pid == 0) {
		pid = os__getpid();
	}
	return pid;
}
VV_LOC _result_string v__pkgconfig__desc(string mod) {
	v__pkgconfig__Options options = ((v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = true,.use_default_paths = true,});
	_result_v__pkgconfig__PkgConfig_ptr _t1 = v__pkgconfig__load(mod, options);
	if (_t1.is_error) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("cannot parse")), .data={E_STRUCT} };
	}
	
 	v__pkgconfig__PkgConfig* pc = (*(v__pkgconfig__PkgConfig**)_t1.data);
	_result_string _t3;
	builtin___result_ok(&(string[]) { pc->description }, (_result*)(&_t3), sizeof(string));
	 
	return _t3;
}
_result_v__pkgconfig__Main_ptr v__pkgconfig__main(Array_string args) {
	flag__FlagParser* fp = flag__new_flag_parser(args);
	flag__FlagParser_application(fp, _S("pkgconfig"));
	flag__FlagParser_version(fp, _const_v__pkgconfig__version);
	v__pkgconfig__Main* m = ((v__pkgconfig__Main*)builtin__memdup(&(v__pkgconfig__Main){.opt = v__pkgconfig__parse_options(fp),.res = (string){.str=(byteptr)"", .is_lit=1},.has_actions = 0,}, sizeof(v__pkgconfig__Main)));
	v__pkgconfig__MainOptions* opt = m->opt;
	if (opt->help) {
		m->res = flag__FlagParser_usage(fp);
	} else if (opt->version) {
		m->res = _const_v__pkgconfig__version;
	} else if (opt->listall) {
		Array_string modules = v__pkgconfig__list();
		if (modules.len > 0) { qsort(modules.data, modules.len, modules.element_size, (voidptr)compare_8913308454256331878_string); }
		;
		if (opt->description) {
			for (int _t1 = 0; _t1 < modules.len; ++_t1) {
				string mod = ((string*)modules.data)[_t1];
				_result_string _t2 = v__pkgconfig__desc(mod);
				if (_t2.is_error) {
					continue;
				}
				
 				string d = (*(string*)_t2.data);
				string pad = strings__repeat(' ', (int)(20 - mod.len));
				m->res = builtin__string__plus(m->res, builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_S(" "), 0xfe10, {.d_s = pad}}, {_S(" "), 0xfe10, {.d_s = d}}, {_S("\n"), 0, { .d_c = 0 }}})));
			}
		} else {
			m->res = Array_string_join(modules, _S("\n"));
		}
	} else if (opt->args.len == 0) {
		return (_result_v__pkgconfig__Main_ptr){ .is_error=true, .err=builtin___v_error(_S("No packages given")), .data={E_STRUCT} };
	}
	_result_v__pkgconfig__Main_ptr _t4;
	builtin___result_ok(&(v__pkgconfig__Main*[]) { m }, (_result*)(&_t4), sizeof(v__pkgconfig__Main*));
	 
	return _t4;
}
_result_string v__pkgconfig__Main_run(v__pkgconfig__Main* m) {
	v__pkgconfig__Options options = ((v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = m->opt->debug,.norecurse = 0,.only_description = 0,.use_default_paths = true,});
	v__pkgconfig__MainOptions* opt = m->opt;
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)(((void*)0)));
	string res = m->res;
	for (int _t1 = 0; _t1 < opt->args.len; ++_t1) {
		string arg = ((string*)opt->args.data)[_t1];
		_result_v__pkgconfig__PkgConfig_ptr _t2 = v__pkgconfig__load(arg, options);
		if (_t2.is_error) {
			IError err = _t2.err;
			if (!opt->exists) {
				return (_result_string){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			continue;
		}
		
 		v__pkgconfig__PkgConfig* pcdep = (*(v__pkgconfig__PkgConfig**)_t2.data);
		if (opt->description) {
			if ((res).len != 0) {
				res = builtin__string__plus(res, _S("\n"));
			}
			res = builtin__string__plus(res, pcdep->description);
		}
		if (pc != 0) {
			v__pkgconfig__PkgConfig_extend(pc, pcdep);
		} else {
			pc = pcdep;
		}
	}
	if (opt->exists) {
		_result_string _t4;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t4), sizeof(string));
		 
		return _t4;
	}
	if ((opt->exactversion).len != 0) {
		if (!builtin__string__eq(pc->version, opt->exactversion)) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(_S("version mismatch")), .data={E_STRUCT} };
		}
		_result_string _t6;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t6), sizeof(string));
		 
		return _t6;
	}
	if ((opt->atleast).len != 0) {
		if (v__pkgconfig__PkgConfig_atleast(pc, opt->atleast)) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(_S("version mismatch")), .data={E_STRUCT} };
		}
		_result_string _t8;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t8), sizeof(string));
		 
		return _t8;
	}
	if ((opt->atleastpc).len != 0) {
		if (v__pkgconfig__atleast(opt->atleastpc)) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(_S("version mismatch")), .data={E_STRUCT} };
		}
		_result_string _t10;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t10), sizeof(string));
		 
		return _t10;
	}
	if (opt->variables) {
		res = Array_string_join(builtin__map_keys(&pc->vars), _S("\n"));
	}
	if (opt->__v_requires) {
		res = builtin__string__plus(res, Array_string_join(pc->__v_requires, _S("\n")));
	}
	Array_string r = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (opt->cflags_only_path) {
		builtin__array_push((array*)&r, _MOV((string[]){ v__pkgconfig__filter(pc->cflags, _S("-I"), _S("")) }));
	}
	if (opt->cflags_only_other) {
		builtin__array_push((array*)&r, _MOV((string[]){ v__pkgconfig__filter(pc->cflags, _S("-I"), _S("-I")) }));
	}
	if (opt->cflags) {
		builtin__array_push((array*)&r, _MOV((string[]){ Array_string_join(pc->cflags, _S(" ")) }));
	}
	if (opt->libs_only_link) {
		builtin__array_push((array*)&r, _MOV((string[]){ v__pkgconfig__filter(pc->libs, _S("-l"), _S("")) }));
	}
	if (opt->libs_only_path) {
		builtin__array_push((array*)&r, _MOV((string[]){ v__pkgconfig__filter(pc->libs, _S("-L"), _S("")) }));
	}
	if (opt->libs_only_other) {
		builtin__array_push((array*)&r, _MOV((string[]){ v__pkgconfig__filter(pc->libs, _S("-l"), _S("-L")) }));
	}
	if (opt->libs) {
		if (opt->stat1c) {
			builtin__array_push((array*)&r, _MOV((string[]){ Array_string_join(pc->libs_private, _S(" ")) }));
		} else {
			builtin__array_push((array*)&r, _MOV((string[]){ Array_string_join(pc->libs, _S(" ")) }));
		}
	}
	if (opt->modversion) {
		builtin__array_push((array*)&r, _MOV((string[]){ builtin__string_clone(pc->version) }));
	}
	_result_string _t20;
	builtin___result_ok(&(string[]) { builtin__string__plus(res, Array_string_join(r, _S(" "))) }, (_result*)(&_t20), sizeof(string));
	 
	return _t20;
}
VV_LOC string v__pkgconfig__filter(Array_string libs, string prefix, string prefix2) {
	string res = _S("");
	if ((prefix2).len != 0) {
		for (int _t1 = 0; _t1 < libs.len; ++_t1) {
			string lib = ((string*)libs.data)[_t1];
			if (!builtin__string_starts_with(lib, prefix) && !builtin__string_starts_with(lib, prefix2)) {
				res = builtin__string__plus(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = lib}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	} else {
		for (int _t2 = 0; _t2 < libs.len; ++_t2) {
			string lib = ((string*)libs.data)[_t2];
			if (builtin__string_starts_with(lib, prefix)) {
				res = builtin__string__plus(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = lib}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
	}
	return res;
}
VV_LOC v__pkgconfig__MainOptions* v__pkgconfig__parse_options(flag__FlagParser* fp) {
	return ((v__pkgconfig__MainOptions*)builtin__memdup(&(v__pkgconfig__MainOptions){.modversion = flag__FlagParser_bool(fp, _S("modversion"), 'V', false, _S("show version of module"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.description = flag__FlagParser_bool(fp, _S("description"), 'd', false, _S("show pkg module description"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.help = flag__FlagParser_bool(fp, _S("help"), 'h', false, _S("show this help message"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.debug = flag__FlagParser_bool(fp, _S("debug"), 'D', false, _S("show debug information"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.listall = flag__FlagParser_bool(fp, _S("list-all"), 'p', false, _S("list all pkgmodules"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.exists = flag__FlagParser_bool(fp, _S("exists"), 'e', false, _S("return 0 if pkg exists"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.variables = flag__FlagParser_bool(fp, _S("print-variables"), 'P', false, _S("display variable names"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.__v_requires = flag__FlagParser_bool(fp, _S("print-requires"), 'r', false, _S("display requires of the module"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.atleast = flag__FlagParser_string(fp, _S("atleast-version"), 'a', _S(""), _S("return 0 if pkg version is at least the given one"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.atleastpc = flag__FlagParser_string(fp, _S("atleast-pkgconfig-version"), 'A', _S(""), _S("return 0 if pkgconfig version is at least the given one"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.exactversion = flag__FlagParser_string(fp, _S("exact-version"), ' ', _S(""), _S("return 0 if pkg version is at least the given one"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.version = flag__FlagParser_bool(fp, _S("version"), 'v', false, _S("show version of this tool"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.cflags = flag__FlagParser_bool(fp, _S("cflags"), 'c', false, _S("output all pre-processor and compiler flags"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.cflags_only_path = flag__FlagParser_bool(fp, _S("cflags-only-I"), 'I', false, _S("show only -I flags from CFLAGS"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.cflags_only_other = flag__FlagParser_bool(fp, _S("cflags-only-other"), ' ', false, _S("show cflags without -I"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.stat1c = flag__FlagParser_bool(fp, _S("static"), 's', false, _S("show --libs for static linking"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.libs = flag__FlagParser_bool(fp, _S("libs"), 'l', false, _S("output all linker flags"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.libs_only_link = flag__FlagParser_bool(fp, _S("libs-only-l"), ' ', false, _S("show only -l from ldflags"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.libs_only_path = flag__FlagParser_bool(fp, _S("libs-only-L"), 'L', false, _S("show only -L from ldflags"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.libs_only_other = flag__FlagParser_bool(fp, _S("libs-only-other"), ' ', false, _S("show flags not containing -l or -L"), ((flag__FlagConfig){.val_desc = (string){.str=(byteptr)"", .is_lit=1},})),
		.args = fp->args,
	}, sizeof(v__pkgconfig__MainOptions)));
}
VV_LOC Array_string v__pkgconfig__PkgConfig_parse_list_no_comma(v__pkgconfig__PkgConfig* pc, string s) {
	return v__pkgconfig__PkgConfig_parse_list(pc, builtin__string_replace(s, _S(","), _S(" ")));
}
VV_LOC Array_string v__pkgconfig__PkgConfig_parse_list(v__pkgconfig__PkgConfig* pc, string s) {
	Array_string operators = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("="), _S("<"), _S(">"), _S(">="), _S("<=")}));
	Array_string r = builtin__string_split(v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_replace(builtin__string_replace(s, _S("  "), _S(" ")), _S(", "), _S(" "))), _S(" "));
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	bool skip = false;
	for (int _t1 = 0; _t1 < r.len; ++_t1) {
		string a = ((string*)r.data)[_t1];
		string b = builtin__string_trim_space(a);
		if (skip) {
			skip = false;
		} else if ((Array_string_contains(operators, b))) {
			skip = true;
		} else if ((b).len != 0) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(b) }));
		}
	}
	return res;
}
VV_LOC string v__pkgconfig__PkgConfig_parse_line(v__pkgconfig__PkgConfig* pc, string s) {
	string r = (*(string*)builtin__array_get(builtin__string_split(s, _S("#")), 0));
	for (;;) {
		if (!(builtin__string_contains(r, _S("${")))) break;
		_option_int _t1 = builtin__string_index(r, _S("${"));
		if (_t1.state != 0) {
			break;
		}
		
 		int tok0 = (*(int*)_t1.data);
		_option_int _t2 = builtin__string_index(builtin__string_substr(r, tok0, 2147483647), _S("}"));
		if (_t2.state != 0) {
			break;
		}
		
 		int tok1 = (*(int*)_t2.data);
		tok1 += tok0;
		string v = builtin__string_substr(r, (int)(tok0 + 2), tok1);
		r = builtin__string_replace(r, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("${"), 0xfe10, {.d_s = v}}, {_S("}"), 0, { .d_c = 0 }}})), (*(string*)builtin__map_get(ADDR(map, pc->vars), &(string[]){v}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	}
	return builtin__string_trim_space(r);
}
VV_LOC void v__pkgconfig__PkgConfig_setvar(v__pkgconfig__PkgConfig* pc, string line) {
	Array_string kv = builtin__string_split(builtin__string_trim_space(line), _S("="));
	if (kv.len == 2) {
		string k = (*(string*)builtin__array_get(kv, 0));
		string v = v__pkgconfig__PkgConfig_parse_line(pc, (*(string*)builtin__array_get(kv, 1)));
		builtin__map_set(&pc->vars, &(string[]){k}, &(string[]) { v__pkgconfig__PkgConfig_parse_line(pc, v) });
	}
}
VV_LOC bool v__pkgconfig__PkgConfig_parse(v__pkgconfig__PkgConfig* pc, string file) {
	pc->file_path = file;
	builtin__map_set(&pc->vars, &(string[]){_S("pcfiledir")}, &(string[]) { os__real_path(os__dir(file)) });
	_result_string _t1 = os__read_file(file);
	if (_t1.is_error) {
		return false;
	}
	
 	string data = (*(string*)_t1.data);
	if (pc->options.debug) {
		builtin__eprintln(data);
	}
	Array_string lines = builtin__string_split(data, _S("\n"));
	if (pc->options.only_description) {
		for (int _t3 = 0; _t3 < lines.len; ++_t3) {
			string line = ((string*)lines.data)[_t3];
			if (builtin__string_starts_with(line, _S("Description: "))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_substr(line, 13, 2147483647));
			}
		}
	} else {
		for (int _t4 = 0; _t4 < lines.len; ++_t4) {
			string oline = ((string*)lines.data)[_t4];
			string line = builtin__string_trim_space(oline);
			if (builtin__string_starts_with(line, _S("#"))) {
				continue;
			}
			if (builtin__string_contains(line, _S("=")) && !builtin__string_contains(line, _S(" "))) {
				v__pkgconfig__PkgConfig_setvar(pc, line);
				continue;
			}
			if (builtin__string_starts_with(line, _S("Name:"))) {
				pc->name = v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_substr(line, 5, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Description:"))) {
				pc->description = v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_substr(line, 12, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Version:"))) {
				pc->version = v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_substr(line, 8, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Requires:"))) {
				pc->__v_requires = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, builtin__string_substr(line, 9, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Requires.private:"))) {
				pc->requires_private = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, builtin__string_substr(line, 17, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Conflicts:"))) {
				pc->conflicts = v__pkgconfig__PkgConfig_parse_list_no_comma(pc, builtin__string_substr(line, 10, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Cflags:"))) {
				pc->cflags = v__pkgconfig__PkgConfig_parse_list(pc, builtin__string_substr(line, 7, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Libs:"))) {
				pc->libs = v__pkgconfig__PkgConfig_parse_list(pc, builtin__string_substr(line, 5, 2147483647));
			} else if (builtin__string_starts_with(line, _S("Libs.private:"))) {
				pc->libs_private = v__pkgconfig__PkgConfig_parse_list(pc, builtin__string_substr(line, 13, 2147483647));
			} else if (builtin__string_starts_with(line, _S("URL:"))) {
				pc->url = v__pkgconfig__PkgConfig_parse_line(pc, builtin__string_substr(line, 4, 2147483647));
			}
		}
	}
	return true;
}
VV_LOC _result_string v__pkgconfig__PkgConfig_resolve(v__pkgconfig__PkgConfig* pc, string pkgname) {
	if (builtin__string_ends_with(pkgname, _S(".pc"))) {
		if (os__exists(pkgname)) {
			_result_string _t1;
			builtin___result_ok(&(string[]) { pkgname }, (_result*)(&_t1), sizeof(string));
			 
			return _t1;
		}
	} else {
		if (pc->paths.len == 0) {
			builtin__array_push((array*)&pc->paths, _MOV((string[]){ _S(".") }));
		}
		for (int _t3 = 0; _t3 < pc->paths.len; ++_t3) {
			string path = ((string*)pc->paths.data)[_t3];
			string file = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_S("/"), 0xfe10, {.d_s = pkgname}}, {_S(".pc"), 0, { .d_c = 0 }}}));
			if (os__exists(file)) {
				_result_string _t4;
				builtin___result_ok(&(string[]) { file }, (_result*)(&_t4), sizeof(string));
				 
				return _t4;
			}
		}
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Cannot find \""), 0xfe10, {.d_s = pkgname}}, {_S("\" pkgconfig file"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
bool v__pkgconfig__atleast(string v) {
	_result_semver__Version _t1 = semver__from(_const_v__pkgconfig__version);
	if (_t1.is_error) {
		return false;
	}
	
 	semver__Version v0 = (*(semver__Version*)_t1.data);
	_result_semver__Version _t3 = semver__from(v);
	if (_t3.is_error) {
		return false;
	}
	
 	semver__Version v1 = (*(semver__Version*)_t3.data);
	return semver__Version__lt(v1, v0);
}
bool v__pkgconfig__PkgConfig_atleast(v__pkgconfig__PkgConfig* pc, string v) {
	_result_semver__Version _t1 = semver__from(pc->version);
	if (_t1.is_error) {
		return false;
	}
	
 	semver__Version v0 = (*(semver__Version*)_t1.data);
	_result_semver__Version _t3 = semver__from(v);
	if (_t3.is_error) {
		return false;
	}
	
 	semver__Version v1 = (*(semver__Version*)_t3.data);
	return semver__Version__lt(v1, v0);
}
string v__pkgconfig__PkgConfig_extend(v__pkgconfig__PkgConfig* pc, v__pkgconfig__PkgConfig* pcdep) {
	for (int _t1 = 0; _t1 < pcdep->cflags.len; ++_t1) {
		string flag = ((string*)pcdep->cflags.data)[_t1];
		if (Array_string_index(pc->cflags, flag) == -1) {
			builtin__array_push((array*)&pc->cflags, _MOV((string[]){ builtin__string_clone(flag) }));
		}
	}
	for (int _t3 = 0; _t3 < pcdep->libs.len; ++_t3) {
		string lib = ((string*)pcdep->libs.data)[_t3];
		if (Array_string_index(pc->libs, lib) == -1) {
			builtin__array_push((array*)&pc->libs, _MOV((string[]){ builtin__string_clone(lib) }));
		}
	}
	for (int _t5 = 0; _t5 < pcdep->libs_private.len; ++_t5) {
		string lib = ((string*)pcdep->libs_private.data)[_t5];
		if (Array_string_index(pc->libs_private, lib) == -1) {
			builtin__array_push((array*)&pc->libs_private, _MOV((string[]){ builtin__string_clone(lib) }));
		}
	}
	return _S("");
}
VV_LOC _result_void v__pkgconfig__PkgConfig_load_requires(v__pkgconfig__PkgConfig* pc) {
	for (int _t1 = 0; _t1 < pc->__v_requires.len; ++_t1) {
		string dep = ((string*)pc->__v_requires.data)[_t1];
		_result_void _t2 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t2.is_error) {
			_result_void _t3 = {0};
			_t3.is_error = true;
			_t3.err = _t2.err;
			return _t3;
		}
		
 ;
	}
	for (int _t4 = 0; _t4 < pc->requires_private.len; ++_t4) {
		string dep = ((string*)pc->requires_private.data)[_t4];
		_result_void _t5 = v__pkgconfig__PkgConfig_load_require(pc, dep);
		if (_t5.is_error) {
			_result_void _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 ;
	}
	return (_result_void){0};
}
VV_LOC _result_void v__pkgconfig__PkgConfig_load_require(v__pkgconfig__PkgConfig* pc, string dep) {
	if ((Array_string_contains(pc->loaded, dep))) {
		return (_result_void){0};
	}
	builtin__array_push((array*)&pc->loaded, _MOV((string[]){ builtin__string_clone(dep) }));
	v__pkgconfig__PkgConfig pcdep = ((v__pkgconfig__PkgConfig){.file_path = (string){.str=(byteptr)"", .is_lit=1},.options = ((v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = 0,.use_default_paths = true,}),.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = builtin____new_array(0, 0, sizeof(string)),.libs_private = builtin____new_array(0, 0, sizeof(string)),.cflags = builtin____new_array(0, 0, sizeof(string)),.paths = pc->paths,.vars = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.__v_requires = builtin____new_array(0, 0, sizeof(string)),.requires_private = builtin____new_array(0, 0, sizeof(string)),.conflicts = builtin____new_array(0, 0, sizeof(string)),.loaded = pc->loaded,});
	_result_string _t2 = v__pkgconfig__PkgConfig_resolve(&pcdep, dep);
	if (_t2.is_error) {
		if (pc->options.debug) {
			builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot resolve "), 0xfe10, {.d_s = dep}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("could not resolve dependency "), 0xfe10, {.d_s = dep}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	string depfile = (*(string*)_t2.data);
	if (!v__pkgconfig__PkgConfig_parse(&pcdep, depfile)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("required file \""), 0xfe10, {.d_s = depfile}}, {_S("\" could not be parsed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (!pc->options.norecurse) {
		_result_void _t5 = v__pkgconfig__PkgConfig_load_requires(&pcdep);
		if (_t5.is_error) {
			_result_void _t6 = {0};
			_t6.is_error = true;
			_t6.err = _t5.err;
			return _t6;
		}
		
 ;
	}
	v__pkgconfig__PkgConfig_extend(pc, (voidptr)&pcdep);
	return (_result_void){0};
}
VV_LOC void v__pkgconfig__PkgConfig_add_path(v__pkgconfig__PkgConfig* pc, string path) {
	if ((path).len == 0) {
		return;
	}
	string p = builtin__string_trim_right(path, _S("/"));
	if (!os__exists(p)) {
		return;
	}
	if (Array_string_index(pc->paths, p) == -1) {
		builtin__array_push((array*)&pc->paths, _MOV((string[]){ builtin__string_clone(p) }));
	}
}
VV_LOC void v__pkgconfig__PkgConfig_load_paths(v__pkgconfig__PkgConfig* pc) {
	string _t1;
	#if defined(_WIN32)
	#else
		_t1 = _S(":");
		;
	#endif
		string split_c = _t1;
	string config_path_override = os__getenv(_S("PKG_CONFIG_PATH_DEFAULTS"));
	if ((config_path_override).len != 0) {
		Array_string _t2 = builtin__string_split(config_path_override, split_c);
		for (int _t3 = 0; _t3 < _t2.len; ++_t3) {
			string path = ((string*)_t2.data)[_t3];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	} else {
		if (pc->options.use_default_paths) {
			for (int _t4 = 0; _t4 < _const_v__pkgconfig__default_paths.len; ++_t4) {
				string path = ((string*)_const_v__pkgconfig__default_paths.data)[_t4];
				v__pkgconfig__PkgConfig_add_path(pc, path);
			}
		}
	}
	Array_string _t5 = builtin__string_split(pc->options.path, split_c);
	for (int _t6 = 0; _t6 < _t5.len; ++_t6) {
		string path = ((string*)_t5.data)[_t6];
		v__pkgconfig__PkgConfig_add_path(pc, path);
	}
	string env_var = os__getenv(_S("PKG_CONFIG_PATH"));
	if ((env_var).len != 0) {
		Array_string env_paths = builtin__string_split(builtin__string_trim_space(env_var), split_c);
		for (int _t7 = 0; _t7 < env_paths.len; ++_t7) {
			string path = ((string*)env_paths.data)[_t7];
			v__pkgconfig__PkgConfig_add_path(pc, path);
		}
	}
}
_result_v__pkgconfig__PkgConfig_ptr v__pkgconfig__load(string pkgname, v__pkgconfig__Options options) {
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)builtin__memdup(&(v__pkgconfig__PkgConfig){.file_path = (string){.str=(byteptr)"", .is_lit=1},.options = options,.name = (string){.str=(byteptr)"", .is_lit=1},.modname = pkgname,.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = builtin____new_array(0, 0, sizeof(string)),.libs_private = builtin____new_array(0, 0, sizeof(string)),.cflags = builtin____new_array(0, 0, sizeof(string)),.paths = builtin____new_array(0, 0, sizeof(string)),.vars = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.__v_requires = builtin____new_array(0, 0, sizeof(string)),.requires_private = builtin____new_array(0, 0, sizeof(string)),.conflicts = builtin____new_array(0, 0, sizeof(string)),.loaded = builtin____new_array(0, 0, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig)));
	v__pkgconfig__PkgConfig_load_paths(pc);
	_result_string _t1 = v__pkgconfig__PkgConfig_resolve(pc, pkgname);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_v__pkgconfig__PkgConfig_ptr){ .is_error=true, .err=err, .data={E_STRUCT} };
	}
	
 	string file = (*(string*)_t1.data);
	if (!v__pkgconfig__PkgConfig_parse(pc, file)) {
		return (_result_v__pkgconfig__PkgConfig_ptr){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("file \""), 0xfe10, {.d_s = file}}, {_S("\" could not be parsed"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (!options.norecurse) {
		_result_void _t4 = v__pkgconfig__PkgConfig_load_requires(pc);
		if (_t4.is_error) {
			_result_v__pkgconfig__PkgConfig_ptr _t5 = {0};
			_t5.is_error = true;
			_t5.err = _t4.err;
			return _t5;
		}
		
 ;
	}
	_result_v__pkgconfig__PkgConfig_ptr _t6;
	builtin___result_ok(&(v__pkgconfig__PkgConfig*[]) { pc }, (_result*)(&_t6), sizeof(v__pkgconfig__PkgConfig*));
	 
	return _t6;
}
Array_string v__pkgconfig__list(void) {
	v__pkgconfig__PkgConfig* pc = ((v__pkgconfig__PkgConfig*)builtin__memdup(&(v__pkgconfig__PkgConfig){.file_path = (string){.str=(byteptr)"", .is_lit=1},.options = ((v__pkgconfig__Options){.path = (string){.str=(byteptr)"", .is_lit=1},.debug = 0,.norecurse = 0,.only_description = 0,.use_default_paths = true,}),.name = (string){.str=(byteptr)"", .is_lit=1},.modname = (string){.str=(byteptr)"", .is_lit=1},.url = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.libs = builtin____new_array(0, 0, sizeof(string)),.libs_private = builtin____new_array(0, 0, sizeof(string)),.cflags = builtin____new_array(0, 0, sizeof(string)),.paths = builtin____new_array(0, 0, sizeof(string)),.vars = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.__v_requires = builtin____new_array(0, 0, sizeof(string)),.requires_private = builtin____new_array(0, 0, sizeof(string)),.conflicts = builtin____new_array(0, 0, sizeof(string)),.loaded = builtin____new_array(0, 0, sizeof(string)),}, sizeof(v__pkgconfig__PkgConfig)));
	v__pkgconfig__PkgConfig_load_paths(pc);
	Array_string modules = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < pc->paths.len; ++_t1) {
		string path = ((string*)pc->paths.data)[_t1];
		_result_Array_string _t2 = os__ls(path);
		if (_t2.is_error) {
			continue;
		}
		
 		Array_string files = (*(Array_string*)_t2.data);
		for (int _t3 = 0; _t3 < files.len; ++_t3) {
			string file = ((string*)files.data)[_t3];
			if (builtin__string_ends_with(file, _S(".pc"))) {
				string name = builtin__string_replace(file, _S(".pc"), _S(""));
				if (Array_string_index(modules, name) == -1) {
					builtin__array_push((array*)&modules, _MOV((string[]){ builtin__string_clone(name) }));
				}
			}
		}
	}
	return modules;
}
string term__format_esc(string code) {
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\033["), 0xfe10, {.d_s = code}}, {_S("m"), 0, { .d_c = 0 }}}));
}
string term__format(string msg, string open, string close) {
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_S("\033["), 0xfe10, {.d_s = open}}, {_S("m"), 0xfe10, {.d_s = msg}}, {_S("\033["), 0xfe10, {.d_s = close}}, {_S("m"), 0, { .d_c = 0 }}}));
}
string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	return builtin__str_intp(7, _MOV((StrIntpData[]){{_S("\033["), 0xfe10, {.d_s = open}}, {_S(";2;"), 0xfe07, {.d_i32 = r}}, {_S(";"), 0xfe07, {.d_i32 = g}}, {_S(";"), 0xfe07, {.d_i32 = b}}, {_S("m"), 0xfe10, {.d_s = msg}}, {_S("\033["), 0xfe10, {.d_s = close}}, {_S("m"), 0, { .d_c = 0 }}}));
}
string term__rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, _S("38"), _S("39"));
}
string term__bg_rgb(int r, int g, int b, string msg) {
	return term__format_rgb(r, g, b, msg, _S("48"), _S("49"));
}
string term__hex(int hex, string msg) {
	return term__format_rgb((hex >> 16), (((hex >> 8)) & 0xFF), (hex & 0xFF), msg, _S("38"), _S("39"));
}
string term__bg_hex(int hex, string msg) {
	return term__format_rgb((hex >> 16), (((hex >> 8)) & 0xFF), (hex & 0xFF), msg, _S("48"), _S("49"));
}
string term__reset(string msg) {
	return term__format(msg, _S("0"), _S("0"));
}
string term__bold(string msg) {
	return term__format(msg, _S("1"), _S("22"));
}
string term__dim(string msg) {
	return term__format(msg, _S("2"), _S("22"));
}
string term__italic(string msg) {
	return term__format(msg, _S("3"), _S("23"));
}
string term__underline(string msg) {
	return term__format(msg, _S("4"), _S("24"));
}
string term__slow_blink(string msg) {
	return term__format(msg, _S("5"), _S("25"));
}
string term__rapid_blink(string msg) {
	return term__format(msg, _S("6"), _S("26"));
}
string term__inverse(string msg) {
	return term__format(msg, _S("7"), _S("27"));
}
string term__hidden(string msg) {
	return term__format(msg, _S("8"), _S("28"));
}
string term__strikethrough(string msg) {
	return term__format(msg, _S("9"), _S("29"));
}
string term__black(string msg) {
	return term__format(msg, _S("30"), _S("39"));
}
string term__red(string msg) {
	return term__format(msg, _S("31"), _S("39"));
}
string term__green(string msg) {
	return term__format(msg, _S("32"), _S("39"));
}
string term__yellow(string msg) {
	return term__format(msg, _S("33"), _S("39"));
}
string term__blue(string msg) {
	return term__format(msg, _S("34"), _S("39"));
}
string term__magenta(string msg) {
	return term__format(msg, _S("35"), _S("39"));
}
string term__cyan(string msg) {
	return term__format(msg, _S("36"), _S("39"));
}
string term__white(string msg) {
	return term__format(msg, _S("37"), _S("39"));
}
string term__bg_black(string msg) {
	return term__format(msg, _S("40"), _S("49"));
}
string term__bg_red(string msg) {
	return term__format(msg, _S("41"), _S("49"));
}
string term__bg_green(string msg) {
	return term__format(msg, _S("42"), _S("49"));
}
string term__bg_yellow(string msg) {
	return term__format(msg, _S("43"), _S("49"));
}
string term__bg_blue(string msg) {
	return term__format(msg, _S("44"), _S("49"));
}
string term__bg_magenta(string msg) {
	return term__format(msg, _S("45"), _S("49"));
}
string term__bg_cyan(string msg) {
	return term__format(msg, _S("46"), _S("49"));
}
string term__bg_white(string msg) {
	return term__format(msg, _S("47"), _S("49"));
}
string term__gray(string msg) {
	return term__bright_black(msg);
}
string term__bright_black(string msg) {
	return term__format(msg, _S("90"), _S("39"));
}
string term__bright_red(string msg) {
	return term__format(msg, _S("91"), _S("39"));
}
string term__bright_green(string msg) {
	return term__format(msg, _S("92"), _S("39"));
}
string term__bright_yellow(string msg) {
	return term__format(msg, _S("93"), _S("39"));
}
string term__bright_blue(string msg) {
	return term__format(msg, _S("94"), _S("39"));
}
string term__bright_magenta(string msg) {
	return term__format(msg, _S("95"), _S("39"));
}
string term__bright_cyan(string msg) {
	return term__format(msg, _S("96"), _S("39"));
}
string term__bright_white(string msg) {
	return term__format(msg, _S("97"), _S("39"));
}
string term__bright_bg_black(string msg) {
	return term__format(msg, _S("100"), _S("49"));
}
string term__bright_bg_red(string msg) {
	return term__format(msg, _S("101"), _S("49"));
}
string term__bright_bg_green(string msg) {
	return term__format(msg, _S("102"), _S("49"));
}
string term__bright_bg_yellow(string msg) {
	return term__format(msg, _S("103"), _S("49"));
}
string term__bright_bg_blue(string msg) {
	return term__format(msg, _S("104"), _S("49"));
}
string term__bright_bg_magenta(string msg) {
	return term__format(msg, _S("105"), _S("49"));
}
string term__bright_bg_cyan(string msg) {
	return term__format(msg, _S("106"), _S("49"));
}
string term__bright_bg_white(string msg) {
	return term__format(msg, _S("107"), _S("49"));
}
string term__highlight_command(string command) {
	return term__bright_white(term__bg_cyan(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = command}}, {_S(" "), 0, { .d_c = 0 }}}))));
}
void term__write_color(strings__Builder* b, string s, term__ColorConfig config) {
	Array_string codes = builtin____new_array_with_default(0, 3, sizeof(string), 0);
	for (int _t1 = 0; _t1 < config.styles.len; ++_t1) {
		term__TextStyle style = ((term__TextStyle*)config.styles.data)[_t1];
		builtin__array_push((array*)&codes, _MOV((string[]){ builtin__int_str(((int)(style))) }));
	}
	_option_term__FgColor _t3;
	if (_t3 = config.fg, _t3.state == 0) {
		term__FgColor fg = *(term__FgColor*)_t3.data;
		builtin__array_push((array*)&codes, _MOV((string[]){ builtin__int_str(((int)(fg))) }));
	}
	_option_term__BgColor _t5;
	if (_t5 = config.bg, _t5.state == 0) {
		term__BgColor bg = *(term__BgColor*)_t5.data;
		builtin__array_push((array*)&codes, _MOV((string[]){ builtin__int_str(((int)(bg))) }));
	}
	if ((config.custom).len != 0) {
		builtin__array_push((array*)&codes, _MOV((string[]){ builtin__string_clone(config.custom) }));
	}
	if (codes.len > 0) {
		string code_str = Array_string_join(codes, _S(";"));
		{
			strings__Builder_write_string(b, _S("\033["));
			strings__Builder_write_string(b, code_str);
			strings__Builder_write_string(b, _S("m"));
			strings__Builder_write_string(b, s);
			strings__Builder_write_string(b, _S("\033[0m"));
		}
	} else {
		strings__Builder_write_string(b, s);
	}
}
void term__writeln_color(strings__Builder* b, string s, term__ColorConfig color) {
	term__write_color(b, s, color);
	strings__Builder_writeln(b, _S(""));
}
void term__set_cursor_position(term__Coord c) {
	builtin__print(builtin__string__plus(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("\033["), 0xfe07, {.d_i32 = c.y}}, {_S(";"), 0xfe07, {.d_i32 = c.x}}, {_SLIT0, 0, { .d_c = 0 }}})), _S("H")));
	builtin__flush_stdout();
}
void term__move(int n, string direction) {
	builtin__print(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("\033["), 0xfe07, {.d_i32 = n}}, {_SLIT0, 0xfe10, {.d_s = direction}}, {_SLIT0, 0, { .d_c = 0 }}})));
	builtin__flush_stdout();
}
void term__cursor_up(int n) {
	term__move(n, _S("A"));
}
void term__cursor_down(int n) {
	term__move(n, _S("B"));
}
void term__cursor_forward(int n) {
	term__move(n, _S("C"));
}
void term__cursor_back(int n) {
	term__move(n, _S("D"));
}
void term__erase_display(string t) {
	builtin__print(builtin__string__plus(builtin__string__plus(_S("\033["), t), _S("J")));
	builtin__flush_stdout();
}
void term__erase_toend(void) {
	term__erase_display(_S("0"));
}
void term__erase_tobeg(void) {
	term__erase_display(_S("1"));
}
void term__erase_clear(void) {
	builtin__print(_S("\033[H\033[J"));
	builtin__flush_stdout();
}
void term__erase_del_clear(void) {
	term__erase_display(_S("3"));
}
void term__erase_line(string t) {
	builtin__print(builtin__string__plus(builtin__string__plus(_S("\033["), t), _S("K")));
	builtin__flush_stdout();
}
void term__erase_line_toend(void) {
	term__erase_line(_S("0"));
}
void term__erase_line_tobeg(void) {
	term__erase_line(_S("1"));
}
void term__erase_line_clear(void) {
	term__erase_line(_S("2"));
}
void term__show_cursor(void) {
	builtin__print(_S("\033[?25h"));
	builtin__flush_stdout();
}
void term__hide_cursor(void) {
	builtin__print(_S("\033[?25l"));
	builtin__flush_stdout();
}
void term__clear_previous_line(void) {
	builtin__print(_S("\r\033[1A\033[2K"));
	builtin__flush_stdout();
}
bool term__can_show_color_on_stdout(void) {
	switch (can_show_color_on_stdout_cache) {
		case 1: {
			return true;
		}
		case -1: {
			return false;
		}
		default: {
			{
				break;
			}
		}
	}
	
	bool status = term__supports_escape_sequences(1);
	can_show_color_on_stdout_cache = (status ? (1) : (-1));
	return status;
}
bool term__can_show_color_on_stderr(void) {
	switch (can_show_color_on_stderr_cache) {
		case 1: {
			return true;
		}
		case -1: {
			return false;
		}
		default: {
			{
				break;
			}
		}
	}
	
	bool status = term__supports_escape_sequences(2);
	can_show_color_on_stderr_cache = (status ? (1) : (-1));
	return status;
}
string term__failed(string s) {
	if (term__can_show_color_on_stdout()) {
		return term__bg_red(term__bold(term__white(s)));
	}
	return s;
}
string term__ok_message(string s) {
	if (term__can_show_color_on_stdout()) {
		return term__green(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = s}}, {_S(" "), 0, { .d_c = 0 }}})));
	}
	return s;
}
string term__fail_message(string s) {
	return term__failed(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = s}}, {_S(" "), 0, { .d_c = 0 }}})));
}
string term__warn_message(string s) {
	if (term__can_show_color_on_stdout()) {
		return term__bright_yellow(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = s}}, {_S(" "), 0, { .d_c = 0 }}})));
	}
	return s;
}
string term__colorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stdout()) {
		return cfn(s);
	}
	return s;
}
string term__ecolorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stderr()) {
		return cfn(s);
	}
	return s;
}
string term__strip_ansi(string text) {
	strings__textscanner__TextScanner input = strings__textscanner__new(text);
	Array_u8 output = builtin____new_array_with_default(0, text.len, sizeof(u8), 0);
	int ch = 0;
	for (;;) {
		if (!(ch != -1)) break;
		ch = strings__textscanner__TextScanner_next(&input);
		if (ch == 27) {
			ch = strings__textscanner__TextScanner_next(&input);
			if (ch == '[') {
				for (;;) {
					ch = strings__textscanner__TextScanner_next(&input);
					if ((ch == ';' || ch == '?') || (ch >= '0' && ch <= '9')) {
						continue;
					}
					break;
				}
			} else if (ch == ']') {
				ch = strings__textscanner__TextScanner_next(&input);
				if (ch >= '0' && ch <= '9') {
					for (;;) {
						ch = strings__textscanner__TextScanner_next(&input);
						if (ch == -1 || ch == 7) {
							break;
						}
						if (ch == 27) {
							ch = strings__textscanner__TextScanner_next(&input);
							break;
						}
					}
				}
			} else if (ch == '%') {
				ch = strings__textscanner__TextScanner_next(&input);
			}
		} else if (ch != -1) {
			builtin__array_push((array*)&output, _MOV((u8[]){ ((u8)(ch)) }));
		}
	}
	return Array_u8_bytestr(output);
}
string term__h_divider(string divider) {
	multi_return_int_int mr_3736 = term__get_terminal_size();
	int cols = mr_3736.arg0;
	string result = _S("");
	if (divider.len > 0) {
		result = builtin__string_repeat(divider, (int)(1 + ((int)(cols / divider.len))));
	} else {
		result = builtin__string_repeat(_S(" "), (int)(1 + cols));
	}
	return builtin__string_substr(result, 0, cols);
}
string term__header_left(string text, string divider) {
	string plain_text = term__strip_ansi(text);
	multi_return_int_int mr_4181 = term__get_terminal_size();
	int xcols = mr_4181.arg0;
	int cols = term__imax(1, xcols);
	string relement = (divider.len > 0 ? (divider) : (_S(" ")));
	string hstart = builtin__string_substr(builtin__string_repeat(relement, 4), 0, 4);
	int remaining_cols = term__imax(0, ((int)(cols - ((int)((int)((int)(hstart.len + 1) + plain_text.len) + 1)))));
	string hend = builtin__string_substr(builtin__string_repeat(relement, (int)(((int)(remaining_cols + 1)) / relement.len)), 0, remaining_cols);
	return builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = hstart}}, {_S(" "), 0xfe10, {.d_s = text}}, {_S(" "), 0xfe10, {.d_s = hend}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string term__header(string text, string divider) {
	if (text.len == 0) {
		return term__h_divider(divider);
	}
	multi_return_int_int mr_4807 = term__get_terminal_size();
	int xcols = mr_4807.arg0;
	int cols = term__imax(1, xcols);
	int tlimit = term__imax(1, (cols > (int)((int)(text.len + 2) + (int)(2 * divider.len)) ? (text.len) : ((int)((int)(cols - 3) - (int)(2 * divider.len)))));
	int tlimit_aligned = (((int)(tlimit % 2)) != ((int)(cols % 2)) ? ((int)(tlimit + 1)) : (tlimit));
	int tstart = term__imax(0, (int)(((int)(cols - tlimit_aligned)) / 2));
	string ln = _S("");
	if (divider.len > 0) {
		ln = builtin__string_substr(builtin__string_repeat(divider, (int)(1 + (int)(cols / divider.len))), 0, cols);
	} else {
		ln = builtin__string_repeat(_S(" "), (int)(1 + cols));
	}
	if (ln.len == 1) {
		return builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(ln, _S(" ")), builtin__string_substr(text, 0, tlimit)), _S(" ")), ln);
	}
	return builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string_substr(ln, 0, tstart), _S(" ")), builtin__string_substr(text, 0, tlimit)), _S(" ")), builtin__string_substr(ln, (int)((int)(tstart + tlimit) + 2), cols));
}
VV_LOC int term__imax(int x, int y) {
	return (x > y ? (x) : (y));
}
VV_LOC bool term__supports_escape_sequences(int fd) {
	string vcolors_override = os__getenv(_S("VCOLORS"));
	if (_SLIT_EQ(vcolors_override.str, vcolors_override.len, "always")) {
		bool _t1 = true;
			{ // defer begin
				builtin__string_free(&vcolors_override);
			} // defer end
		return _t1;
	}
	if (_SLIT_EQ(vcolors_override.str, vcolors_override.len, "never")) {
		bool _t2 = false;
			{ // defer begin
				builtin__string_free(&vcolors_override);
			} // defer end
		return _t2;
	}
	string env_term = os__getenv(_S("TERM"));
	if (_SLIT_EQ(env_term.str, env_term.len, "dumb")) {
		bool _t3 = false;
			{ // defer begin
				builtin__string_free(&env_term);
			} // defer end
			{ // defer begin
				builtin__string_free(&vcolors_override);
			} // defer end
		return _t3;
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		bool _t5 = os__is_atty(fd) > 0;
			{ // defer begin
				builtin__string_free(&env_term);
			} // defer end
			{ // defer begin
				builtin__string_free(&vcolors_override);
			} // defer end
		return _t5;
	}
	#endif
	return 0;
}
multi_return_int_int term__get_terminal_size(void) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return (multi_return_int_int){.arg0=_const_term__default_columns_size, .arg1=_const_term__default_rows_size};
	}
	struct winsize w = ((struct winsize){.ws_row = 0,.ws_col = 0,.ws_xpixel = 0,.ws_ypixel = 0,});
	ioctl(1, ((u64)(TIOCGWINSZ)), &w);
	return (multi_return_int_int){.arg0=((int)(w.ws_col)), .arg1=((int)(w.ws_row))};
}
_result_term__Coord term__get_cursor_position(void) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		_result_term__Coord _t1;
		builtin___result_ok(&(term__Coord[]) { ((term__Coord){.x = 0,.y = 0,}) }, (_result*)(&_t1), sizeof(term__Coord));
		 
		return _t1;
	}
	term__termios__Termios old_state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&old_state) != 0) {
		return (_result_term__Coord){ .is_error=true, .err=os__last_error(), .data={E_STRUCT} };
	}
	term__termios__Termios state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&state) != 0) {
		_result_term__Coord _t3 = (_result_term__Coord){ .is_error=true, .err=os__last_error(), .data={E_STRUCT} };
			{ // defer begin
				term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
			} // defer end
		return _t3;
	}
	state.c_lflag &= term__termios__invert((((u32)(ICANON)) | ((u32)(ECHO))));
	term__termios__tcsetattr(0, TCSANOW, (voidptr)&state);
	builtin__print(_S("\e[6n"));
	builtin__flush_stdout();
	int x = 0;
	int y = 0;
	u8 stage = ((u8)(0));
	for (;;) {
		i32 w = getchar();
		if (w < 0) {
			_result_term__Coord _t4 = (_result_term__Coord){ .is_error=true, .err=builtin__error_with_code(_S("Failed to read from stdin"), 888), .data={E_STRUCT} };
				{ // defer begin
					term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
				} // defer end
			return _t4;
		} else if (w == '[' || w == ';') {
			stage++;
		} else if ('0' <= w && w <= '9') {

			if (stage == (1)) {
				y = (int)((int)(y * 10) + ((int)((rune)(w - '0'))));
			}
			else if (stage == (2)) {
				x = (int)((int)(x * 10) + ((int)((rune)(w - '0'))));
			}
			else {
			}
		} else if (w == 'R') {
			break;
		}
	}
	_result_term__Coord _t5;
	builtin___result_ok(&(term__Coord[]) { ((term__Coord){.x = x,.y = y,}) }, (_result*)(&_t5), sizeof(term__Coord));
	 
		{ // defer begin
			term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
		} // defer end
	return _t5;
}
bool term__set_terminal_title(string title) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return false;
	}
	builtin__print(_S("\033]0;"));
	builtin__print(title);
	builtin__print(_S("\007"));
	builtin__flush_stdout();
	return true;
}
bool term__set_tab_title(string title) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return false;
	}
	builtin__print(_S("\033]30;"));
	builtin__print(title);
	builtin__print(_S("\007"));
	builtin__flush_stdout();
	return true;
}
bool term__clear(void) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return false;
	}
	builtin__print(_S("\033[2J"));
	builtin__print(_S("\033[H"));
	builtin__flush_stdout();
	return true;
}
bool term__supports_sixel(void) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return false;
	}
	if (builtin__string__eq(os__getenv(_S("TERM")), _S("yaft"))) {
		return true;
	}
	term__termios__Termios old_state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&old_state) != 0) {
		return false;
	}
	term__termios__Termios state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&state) != 0) {
		bool _t4 = false;
			{ // defer begin
				term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
			} // defer end
		return _t4;
	}
	state.c_lflag &= term__termios__invert((((u32)(ICANON)) | ((u32)(ECHO))));
	term__termios__tcsetattr(0, TCSANOW, (voidptr)&state);
	builtin__print(_S("\e[c"));
	builtin__flush_stdout();
	Array_u8 buf = builtin____new_array_with_default(0, 64, sizeof(u8), 0);
	for (;;) {
		i32 w = getchar();
		if (w < 0) {
			bool _t5 = false;
				{ // defer begin
					term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
				} // defer end
			return _t5;
		} else if (w == 'c') {
			break;
		} else {
			builtin__array_push((array*)&buf, _MOV((u8[]){ ((u8)(w)) }));
		}
	}
	Array_string sa = builtin__string_split(builtin__string_all_after(Array_u8_bytestr(buf), _S("?")), _S(";"));
	bool _t7 = (Array_string_contains(sa, _S("4")));
		{ // defer begin
			term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
		} // defer end
	return _t7;
}
u16 term__graphics_num_colors(void) {
	if (os__is_atty(1) <= 0 || builtin__string__eq(os__getenv(_S("TERM")), _S("dumb"))) {
		return 0;
	}
	if (builtin__string__eq(os__getenv(_S("TERM")), _S("yaft"))) {
		return 256;
	}
	term__termios__Termios old_state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&old_state) != 0) {
		return 0;
	}
	term__termios__Termios state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&state) != 0) {
		u16 _t4 = 0;
			{ // defer begin
				term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
			} // defer end
		return _t4;
	}
	state.c_lflag &= term__termios__invert((((u32)(ICANON)) | ((u32)(ECHO))));
	term__termios__tcsetattr(0, TCSANOW, (voidptr)&state);
	builtin__print(_S("\e[?1;1;0S"));
	builtin__flush_stdout();
	Array_u8 buf = builtin____new_array_with_default(0, 20, sizeof(u8), 0);
	for (;;) {
		i32 w = getchar();
		if (w < 0) {
			u16 _t5 = 0;
				{ // defer begin
					term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
				} // defer end
			return _t5;
		} else if (w == 'S') {
			break;
		} else if (w == ';') {
			builtin__array_clear(&buf);
		} else {
			builtin__array_push((array*)&buf, _MOV((u8[]){ ((u8)(w)) }));
		}
	}
	u16 _t7 = builtin__string_u16(Array_u8_bytestr(buf));
		{ // defer begin
			term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
		} // defer end
	return _t7;
}
void term__enable_echo(bool enable) {
	term__termios__Termios state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	term__termios__tcgetattr(0, (voidptr)&state);
	if (enable) {
		state.c_lflag |= ECHO;
	} else {
		state.c_lflag &= ~ECHO;
	}
	term__termios__tcsetattr(0, TCSANOW, (voidptr)&state);
}
i64 term__key_pressed(term__KeyPressedParams params) {
	term__termios__Termios state = ((term__termios__Termios){.c_iflag = 0,.c_oflag = 0,.c_cflag = 0,.c_lflag = 0,.c_cc = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_ispeed = 0,.c_ospeed = 0,});
	if (term__termios__tcgetattr(0, (voidptr)&state) != 0) {
		return -1;
	}
	term__termios__Termios old_state = state;
	state.c_lflag &= ~ICANON;
	if (params.echo) {
		state.c_lflag |= ECHO;
	} else {
		state.c_lflag &= ~ECHO;
	}
	term__termios__tcsetattr(0, TCSANOW, (voidptr)&state);
	i64 ret = ((i64)(0));
	for (;;) {
		bool pending = os__fd_is_pending(0);
		if (pending) {
			i32 r = read(0, &ret, 8);
			if (r < 0) {
				i64 _t2 = r;
					{ // defer begin
						term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
					} // defer end
				return _t2;
			} else {
				i64 _t3 = ret;
					{ // defer begin
						term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
					} // defer end
				return _t3;
			}
		}
		if (!params.blocking) {
			i64 _t4 = -1;
				{ // defer begin
					term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
				} // defer end
			return _t4;
		}
		time__sleep(1 * _const_time__millisecond);
	}
	i64 _t5 = ret;
		{ // defer begin
			term__termios__tcsetattr(0, TCSANOW, (voidptr)&old_state);
		} // defer end
	return _t5;
}
_option_rune term__utf8_getchar(void) {
	int c = builtin__input_character();
	if (c == -1) {
		return (_option_rune){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int len = term__utf8_len(((u8)(~c)));
	if (c < 0) {
		_option_rune _t2;
		builtin___option_ok(&(rune[]) { 0 }, (_option*)(&_t2), sizeof(rune));
		 
		return _t2;
	} else if (len == 0) {
		_option_rune _t3;
		builtin___option_ok(&(rune[]) { c }, (_option*)(&_t3), sizeof(rune));
		 
		return _t3;
	} else if (len == 1) {
		_option_rune _t4;
		builtin___option_ok(&(rune[]) { -1 }, (_option*)(&_t4), sizeof(rune));
		 
		return _t4;
	} else {
		int uc = (c & ((int_literal)(((1 << ((int)(7 - len)))) - 1)));
		for (int i = 0; (int)(i + 1) < len; i++) {
			int c2 = builtin__input_character();
			if (c2 != -1 && ((c2 >> 6)) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				_option_rune _t5;
				builtin___option_ok(&(rune[]) { 0 }, (_option*)(&_t5), sizeof(rune));
				 
				return _t5;
			} else {
				_option_rune _t6;
				builtin___option_ok(&(rune[]) { -1 }, (_option*)(&_t6), sizeof(rune));
				 
				return _t6;
			}
		}
		_option_rune _t7;
		builtin___option_ok(&(rune[]) { uc }, (_option*)(&_t7), sizeof(rune));
		 
		return _t7;
	}
	return (_option_rune){.state=2, .err=_const_none__, .data={E_STRUCT}};
}
int term__utf8_len(u8 c) {
	int b = 0;
	u8 x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}
string v__util__recompilation__disabling_file(string vroot) {
	string tools_folder = os__join_path(vroot, builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("cmd"), _S("tools")})));
	string res = os__join_path_single(tools_folder, _S(".disable_autorecompilation"));
	return res;
}
void v__util__recompilation__must_be_enabled(string vroot, string error_message) {
	string file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(file);
	if (is_recompilation_disabled) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Recompilation is disabled, since there is a \""), 0xfe10, {.d_s = file}}, {_S("\" file present."), 0, { .d_c = 0 }}})));
		builtin__eprintln(error_message);
		builtin___v_exit(1);
		VUNREACHABLE();
	}
}
Array_string v__util__vflags__join_env_vflags_and_os_args(void) {
	string vosargs = os__getenv(_S("VOSARGS"));
	if ((vosargs).len != 0) {
		return v__util__vflags__tokenize_to_args(vosargs);
	}
	string vflags = os__getenv(_S("VFLAGS"));
	if ((vflags).len != 0) {
		Array_string args = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		builtin__array_push((array*)&args, _MOV((string[]){ (*(string*)builtin__array_get(_const_os__args, 0)) }));
		_PUSH_MANY(&args, (v__util__vflags__tokenize_to_args(vflags)), _t3, Array_string);
		_PUSH_MANY(&args, (builtin__array_slice_ni(_const_os__args, 1, 2147483647)), _t4, Array_string);
		return args;
	}
	return _const_os__args;
}
Array_string v__util__vflags__tokenize_to_args(string s) {
	Array_string tokens = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	strings__Builder ctoken = strings__new_builder(20);
	bool in_quotes = false;
	rune quote_char = ' ';
	for (int i = 0; i < s.len; ++i) {
		u8 c = builtin__string_at(s, i);
		if (!in_quotes && (c == '"' || c == '\'')) {
			in_quotes = true;
			quote_char = c;
		} else if (in_quotes && c == quote_char) {
			if (i > 0 && builtin__string_at(s, (int_literal)(i - 1)) == '\\') {
				strings__Builder_go_back(&ctoken, 1);
				strings__Builder_write_rune(&ctoken, c);
			} else {
				in_quotes = false;
				builtin__array_push((array*)&tokens, _MOV((string[]){ strings__Builder_str(&ctoken) }));
			}
		} else if (builtin__u8_is_space(c) && !in_quotes) {
			if (ctoken.len > 0) {
				builtin__array_push((array*)&tokens, _MOV((string[]){ strings__Builder_str(&ctoken) }));
			}
		} else {
			strings__Builder_write_rune(&ctoken, c);
		}
	}
	if (ctoken.len > 0) {
		builtin__array_push((array*)&tokens, _MOV((string[]){ strings__Builder_str(&ctoken) }));
	}
	return tokens;
}
VV_LOC _result_usize runtime__free_memory_impl(void) {
	{
		vm_statistics64_data_t hs = ((vm_statistics64_data_t){.free_count = 0,.purgeable_count = 0,.speculative_count = 0,.external_page_count = 0,});
		u32 vmsz = ((u32)(HOST_VM_INFO64_COUNT));
		u32 hps = ((u32)(0));
		host_t host = mach_host_self();
		{ // Unsafe block
			i32 retval_1 = host_statistics64(host, HOST_VM_INFO64, ((int*)(&hs)), &vmsz);
			if (retval_1 != KERN_SUCCESS) {
				_result_usize _t1 = (_result_usize){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("free_memory: `C.host_statistics64()` return = "), 0xfe07, {.d_i32 = retval_1}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
					{ // defer begin
						mach_port_deallocate(mach_task_self(), host);
					} // defer end
				return _t1;
			}
			i32 retval_2 = host_page_size(host, ((vm_size_t*)(&hps)));
			if (retval_2 != KERN_SUCCESS) {
				_result_usize _t2 = (_result_usize){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("free_memory: `C.host_page_size()` return = "), 0xfe07, {.d_i32 = retval_2}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
					{ // defer begin
						mach_port_deallocate(mach_task_self(), host);
					} // defer end
				return _t2;
			}
		}
		_result_usize _t3;
		builtin___result_ok(&(usize[]) { ((usize)((u64)(((u64)(hs.free_count)) * ((u64)(hps))))) }, (_result*)(&_t3), sizeof(usize));
		 
			{ // defer begin
				mach_port_deallocate(mach_task_self(), host);
			} // defer end
		return _t3;
		{ // defer begin
			mach_port_deallocate(mach_task_self(), host);
		} // defer end
	}
	_result_usize _t4 = (_result_usize){ .is_error=true, .err=builtin___v_error(_S("free_memory: not implemented")), .data={E_STRUCT} };
	return _t4;
}
int runtime__nr_jobs(void) {
	int cpus = (int)(runtime__nr_cpus() - 1);
	int vjobs = builtin__string_int(os__getenv(_S("VJOBS")));
	if (vjobs > 0) {
		cpus = vjobs;
	}
	if (cpus == 0) {
		return 1;
	}
	return cpus;
}
bool runtime__is_32bit(void) {
	return false;
}
bool runtime__is_64bit(void) {
	#if defined(TARGET_IS_64BIT)
	{
		return true;
	}
	#endif
	return false;
}
bool runtime__is_little_endian(void) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		return true;
	}
	#endif
	return false;
}
bool runtime__is_big_endian(void) {
	return false;
}
int runtime__nr_cpus(void) {
	return ((int)(sysconf(_SC_NPROCESSORS_ONLN)));
}
_result_usize runtime__total_memory(void) {
	usize page_size = ((usize)(sysconf(_SC_PAGESIZE)));
	int c_errno_1 = errno;
	if (page_size == ((usize)(-1))) {
		return (_result_usize){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("total_memory: `C.sysconf(C._SC_PAGESIZE)` return error code = "), 0xfe07, {.d_i32 = c_errno_1}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	usize phys_pages = ((usize)(sysconf(_SC_PHYS_PAGES)));
	int c_errno_2 = errno;
	if (phys_pages == ((usize)(-1))) {
		return (_result_usize){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("total_memory: `C.sysconf(C._SC_PHYS_PAGES)` return error code = "), 0xfe07, {.d_i32 = c_errno_2}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_usize _t3;
	builtin___result_ok(&(usize[]) { (usize)(page_size * phys_pages) }, (_result*)(&_t3), sizeof(usize));
	 
	return _t3;
}
_result_usize runtime__free_memory(void) {
	_result_usize _t2 = runtime__free_memory_impl();
	if (_t2.is_error) {
		_result_usize _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_usize _t1;
	builtin___result_ok(&(usize[]) { (*(usize*)_t2.data) }, (_result*)(&_t1), sizeof(usize));
	 
	return _t1;
}
_result_u64 runtime__used_memory(void) {
	struct task_basic_info info = ((struct task_basic_info){.resident_size = 0,});
	u64 count = ((u64)(MACH_TASK_BASIC_INFO_COUNT));
	if (task_info(mach_task_self(), TASK_BASIC_INFO, &info, &count) == KERN_SUCCESS) {
		_result_u64 _t1;
		builtin___result_ok(&(u64[]) { info.resident_size }, (_result*)(&_t1), sizeof(u64));
		 
		return _t1;
	}
	_result_u64 _t2;
	builtin___result_ok(&(u64[]) { 0 }, (_result*)(&_t2), sizeof(u64));
	 
	return _t2;
}
VV_LOC string v__vmod__quote(string input) {
	if (builtin__string_contains(input, _S("'"))) {
		return builtin__string__plus(builtin__string__plus(_S("\""), input), _S("\""));
	}
	return builtin__string__plus(builtin__string__plus(_S("'"), input), _S("'"));
}
VV_LOC void v__vmod__encode_array(strings__Builder* b, Array_string input) {
	bool _t1 = Array_string_join(input, _S("")).len > 60;
	
	if (_t1) {
		strings__Builder_writeln(b, _S("["));
		for (int _t2 = 0; _t2 < input.len; ++_t2) {
			string item = ((string*)input.data)[_t2];
			strings__Builder_write_string(b, _S("\t\t"));
			strings__Builder_write_string(b, v__vmod__quote(item));
			strings__Builder_writeln(b, _S(","));
		}
		strings__Builder_writeln(b, _S("\t]"));
	} else {
		Array_string quoted = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		for (int _t3 = 0; _t3 < input.len; ++_t3) {
			string item = ((string*)input.data)[_t3];
			builtin__array_push((array*)&quoted, _MOV((string[]){ v__vmod__quote(item) }));
		}
		strings__Builder_write_string(b, _S("["));
		strings__Builder_write_string(b, Array_string_join(quoted, _S(", ")));
		strings__Builder_writeln(b, _S("]"));
	}
}
string v__vmod__encode(v__vmod__Manifest manifest) {
	strings__Builder b = strings__new_builder(512);
	strings__Builder_writeln(&b, _S("Module {"));
	strings__Builder_write_string(&b, _S("\tname: "));
	strings__Builder_writeln(&b, v__vmod__quote(manifest.name));
	strings__Builder_write_string(&b, _S("\tdescription: "));
	strings__Builder_writeln(&b, v__vmod__quote(manifest.description));
	strings__Builder_write_string(&b, _S("\tversion: "));
	strings__Builder_writeln(&b, v__vmod__quote(manifest.version));
	strings__Builder_write_string(&b, _S("\tlicense: "));
	strings__Builder_writeln(&b, v__vmod__quote(manifest.license));
	if ((manifest.repo_url).len != 0) {
		strings__Builder_write_string(&b, _S("\trepo_url: "));
		strings__Builder_writeln(&b, v__vmod__quote(manifest.repo_url));
	}
	if ((manifest.author).len != 0) {
		strings__Builder_write_string(&b, _S("\tauthor: "));
		strings__Builder_writeln(&b, v__vmod__quote(manifest.author));
	}
	strings__Builder_write_string(&b, _S("\tdependencies: "));
	v__vmod__encode_array((voidptr)&b, manifest.dependencies);
	Map_string_Array_string _t1 = manifest.unknown;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string key = *(string*)builtin__DenseArray_key(&_t1.key_values, _t2);
		key = builtin__string_clone(key);
		Array_string values = (*(Array_string*)builtin__DenseArray_value(&_t1.key_values, _t2));
		strings__Builder_write_string(&b, _S("\t"));
		strings__Builder_write_string(&b, key);
		strings__Builder_write_string(&b, _S(": "));
		v__vmod__encode_array((voidptr)&b, values);
	}
	strings__Builder_write_string(&b, _S("}"));
	return strings__Builder_str(&b);
}
_result_v__vmod__Manifest v__vmod__from_file(string vmod_path) {
	if (!os__exists(vmod_path)) {
		return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(_S("v.mod: v.mod file not found.")), .data={E_STRUCT} };
	}
	_result_string _t2 = os__read_file(vmod_path);
	if (_t2.is_error) {
		*(string*) _t2.data = _S("");
	}
	
 	string contents = (*(string*)_t2.data);
	return v__vmod__decode(contents);
}
_result_v__vmod__Manifest v__vmod__decode(string contents) {
	v__vmod__Parser parser = ((v__vmod__Parser){.file_path = (string){.str=(byteptr)"", .is_lit=1},.scanner = ((v__vmod__Scanner){.pos = 0,.line = 1,.text = contents,.inside_text = 0,.tokens = builtin____new_array(0, 0, sizeof(v__vmod__Token)),}),});
	return v__vmod__Parser_parse(&parser);
}
VV_LOC void v__vmod__Scanner_tokenize(v__vmod__Scanner* s, v__vmod__TokenKind t_type, string val) {
	builtin__array_push((array*)&s->tokens, _MOV((v__vmod__Token[]){ ((v__vmod__Token){.typ = t_type,.val = val,.line = s->line,}) }));
}
VV_LOC bool v__vmod__is_name_alpha(u8 chr) {
	return builtin__u8_is_letter(chr) || chr == '_';
}
VV_LOC string v__vmod__Scanner_create_string(v__vmod__Scanner* s, u8 q) {
	string str = _S("");
	for (;;) {
		if (!(s->pos < s->text.len && builtin__string_at(s->text, s->pos) != q)) break;
		if (builtin__string_at(s->text, s->pos) == '\\' && builtin__string_at(s->text, (int)(s->pos + 1)) == q) {
			str = builtin__string__plus(str, builtin__string_substr(s->text, s->pos, (int)(s->pos + 1)));
			s->pos += 2;
		} else {
			str = builtin__string__plus(str, builtin__u8_ascii_str(builtin__string_at(s->text, s->pos)));
			s->pos++;
		}
	}
	return str;
}
VV_LOC string v__vmod__Scanner_create_ident(v__vmod__Scanner* s) {
	string text = _S("");
	for (;;) {
		if (!(s->pos < s->text.len && v__vmod__is_name_alpha(builtin__string_at(s->text, s->pos)))) break;
		text = builtin__string__plus(text, builtin__u8_ascii_str(builtin__string_at(s->text, s->pos)));
		s->pos++;
	}
	return text;
}
VV_LOC bool v__vmod__Scanner_peek_char(v__vmod__Scanner* s, u8 c) {
	return (int)(s->pos - 1) < s->text.len && builtin__string_at(s->text, (int)(s->pos - 1)) == c;
}
VV_LOC void v__vmod__Scanner_scan_all(v__vmod__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = builtin__string_at(s->text, s->pos);
		if (builtin__u8_is_space(c) || c == '\\') {
			s->pos++;
			if (c == '\n') {
				s->line++;
			}
			continue;
		}
		if (v__vmod__is_name_alpha(c)) {
			string name = v__vmod__Scanner_create_ident(s);
			if (_SLIT_EQ(name.str, name.len, "Module")) {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__module_keyword, name);
				s->pos++;
				continue;
			} else if (s->pos < s->text.len && builtin__string_at(s->text, s->pos) == ':') {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__field_key, builtin__string__plus(name, _S(":")));
				s->pos += 2;
				continue;
			} else {
				v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__ident, name);
				s->pos++;
				continue;
			}
		}
		if ((c == '\'' || c == '\"') && !v__vmod__Scanner_peek_char(s, '\\')) {
			s->pos++;
			string str = v__vmod__Scanner_create_string(s, c);
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__str, str);
			s->pos++;
			continue;
		}

		if (c == ('{')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__lcbr, builtin__u8_ascii_str(c));
		}
		else if (c == ('}')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__rcbr, builtin__u8_ascii_str(c));
		}
		else if (c == ('[')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__labr, builtin__u8_ascii_str(c));
		}
		else if (c == (']')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__rabr, builtin__u8_ascii_str(c));
		}
		else if (c == (':')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__colon, builtin__u8_ascii_str(c));
		}
		else if (c == (',')) {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__comma, builtin__u8_ascii_str(c));
		}
		else {
			v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__unknown, builtin__u8_ascii_str(c));
		}
		s->pos++;
	}
	v__vmod__Scanner_tokenize(s, v__vmod__TokenKind__eof, _S("eof"));
}
VV_LOC _result_multi_return_Array_string_int v__vmod__get_array_content(Array_v__vmod__Token tokens, int st_idx) {
	Array_string vals = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	int idx = st_idx;
	if ((*(v__vmod__Token*)builtin__array_get(tokens, idx)).typ != v__vmod__TokenKind__labr) {
		return (_result_multi_return_Array_string_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" not a valid array, at line "), 0xfe07, {.d_i32 = (*(v__vmod__Token*)builtin__array_get(tokens, idx)).line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	idx++;
	for (;;) {
		v__vmod__Token tok = (*(v__vmod__Token*)builtin__array_get(tokens, idx));

		if (tok.typ == (v__vmod__TokenKind__str)) {
			builtin__array_push((array*)&vals, _MOV((string[]){ builtin__string_clone(tok.val) }));
			if (!((*(v__vmod__Token*)builtin__array_get(tokens, (int)(idx + 1))).typ == v__vmod__TokenKind__comma || (*(v__vmod__Token*)builtin__array_get(tokens, (int)(idx + 1))).typ == v__vmod__TokenKind__rabr)) {
				return (_result_multi_return_Array_string_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" invalid separator \""), 0xfe10, {.d_s = (*(v__vmod__Token*)builtin__array_get(tokens, (int)(idx + 1))).val}}, {_S("\", at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			idx += ((*(v__vmod__Token*)builtin__array_get(tokens, (int)(idx + 1))).typ == v__vmod__TokenKind__comma ? (2) : (1));
		}
		else if (tok.typ == (v__vmod__TokenKind__rabr)) {
			idx++;
			break;
		}
		else {
			return (_result_multi_return_Array_string_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" invalid token \""), 0xfe10, {.d_s = tok.val}}, {_S("\", at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	_result_multi_return_Array_string_int _t5;
	builtin___result_ok(&(multi_return_Array_string_int[]) { (multi_return_Array_string_int){.arg0=vals, .arg1=idx} }, (_result*)(&_t5), sizeof(multi_return_Array_string_int));
	return _t5;
}
VV_LOC _result_v__vmod__Manifest v__vmod__Parser_parse(v__vmod__Parser* p) {
	if (p->scanner.text.len == 0) {
		return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" no content."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	v__vmod__Scanner_scan_all(&p->scanner);
	Array_v__vmod__Token tokens = p->scanner.tokens;
	v__vmod__Manifest mn = ((v__vmod__Manifest){.name = (string){.str=(byteptr)"", .is_lit=1},.description = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.license = (string){.str=(byteptr)"", .is_lit=1},.repo_url = (string){.str=(byteptr)"", .is_lit=1},.repo_branch = _S("master"),.author = (string){.str=(byteptr)"", .is_lit=1},.dependencies = builtin____new_array(0, 0, sizeof(string)),.unknown = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
	if ((*(v__vmod__Token*)builtin__array_get(tokens, 0)).typ != v__vmod__TokenKind__module_keyword) {
		return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" v.mod files should start with Module, at line "), 0xfe07, {.d_i32 = (*(v__vmod__Token*)builtin__array_get(tokens, 0)).line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	int i = 1;
	for (;;) {
		if (!(i < tokens.len)) break;
		v__vmod__Token tok = (*(v__vmod__Token*)builtin__array_get(tokens, i));

		if (tok.typ == (v__vmod__TokenKind__lcbr)) {
			if (!((*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ == v__vmod__TokenKind__field_key || (*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ == v__vmod__TokenKind__rcbr)) {
				return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" invalid content after opening brace, at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			i++;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind__rcbr)) {
			break;
		}
		else if (tok.typ == (v__vmod__TokenKind__field_key)) {
			string field_name = builtin__string_trim_right(tok.val, _S(":"));
			if (!((*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ == v__vmod__TokenKind__str || (*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ == v__vmod__TokenKind__labr)) {
				return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" value of field \""), 0xfe10, {.d_s = field_name}}, {_S("\" must be either string or an array of strings, at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			string field_value = (*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).val;

			if (_SLIT_EQ(field_name.str, field_name.len, "name")) {
				mn.name = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "version")) {
				mn.version = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "license")) {
				mn.license = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "repo_url")) {
				mn.repo_url = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "repo_branch")) {
				mn.repo_branch = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "description")) {
				mn.description = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "author")) {
				mn.author = field_value;
			}
			else if (_SLIT_EQ(field_name.str, field_name.len, "dependencies")) {
				_result_multi_return_Array_string_int _t5 = v__vmod__get_array_content(tokens, (int)(i + 1));
				if (_t5.is_error) {
					_result_v__vmod__Manifest _t6 = {0};
					_t6.is_error = true;
					_t6.err = _t5.err;
					return _t6;
				}
				
 				multi_return_Array_string_int mr_4907 = (*(multi_return_Array_string_int*)_t5.data);
				Array_string deps = mr_4907.arg0;
				int idx = mr_4907.arg1;
				mn.dependencies = deps;
				i = idx;
				continue;
			}
			else {
				if ((*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ == v__vmod__TokenKind__labr) {
					_result_multi_return_Array_string_int _t7 = v__vmod__get_array_content(tokens, (int)(i + 1));
					if (_t7.is_error) {
						_result_v__vmod__Manifest _t8 = {0};
						_t8.is_error = true;
						_t8.err = _t7.err;
						return _t8;
					}
					
 					multi_return_Array_string_int mr_5076 = (*(multi_return_Array_string_int*)_t7.data);
					Array_string vals = mr_5076.arg0;
					int idx = mr_5076.arg1;
					(*(Array_string*)builtin__map_get_and_set((map*)&mn.unknown, &(string[]){field_name}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = vals;
					i = idx;
					continue;
				}
				(*(Array_string*)builtin__map_get_and_set((map*)&mn.unknown, &(string[]){field_name}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(field_value)}));
			}
			i += 2;
			continue;
		}
		else if (tok.typ == (v__vmod__TokenKind__comma)) {
			if (!((*(v__vmod__Token*)builtin__array_get(tokens, (int)(i - 1))).typ == v__vmod__TokenKind__str || (*(v__vmod__Token*)builtin__array_get(tokens, (int)(i - 1))).typ == v__vmod__TokenKind__rabr) || (*(v__vmod__Token*)builtin__array_get(tokens, (int)(i + 1))).typ != v__vmod__TokenKind__field_key) {
				return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" invalid comma placement, at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			i++;
			continue;
		}
		else {
			return (_result_v__vmod__Manifest){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = _const_v__vmod__err_label}}, {_S(" invalid token \""), 0xfe10, {.d_s = tok.val}}, {_S("\", at line "), 0xfe07, {.d_i32 = tok.line}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	_result_v__vmod__Manifest _t11;
	builtin___result_ok(&(v__vmod__Manifest[]) { mn }, (_result*)(&_t11), sizeof(v__vmod__Manifest));
	 
	return _t11;
}
v__vmod__ModFileCacher* v__vmod__get_cache(void) {
	return _const_v__vmod__private_file_cacher;
}
v__vmod__ModFileCacher* v__vmod__new_mod_file_cacher(void) {
	return ((v__vmod__ModFileCacher*)builtin__memdup(&(v__vmod__ModFileCacher){.cache = builtin__new_map(sizeof(string), sizeof(v__vmod__ModFileAndFolder), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.folder_files = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.hits = 0,.misses = 0,.get_files_hits = 0,.get_files_misses = 0,}, sizeof(v__vmod__ModFileCacher)));
}
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_file(v__vmod__ModFileCacher* mcache, string vfile) {
	return v__vmod__ModFileCacher_get_by_folder(mcache, os__dir(vfile));
}
v__vmod__ModFileAndFolder v__vmod__ModFileCacher_get_by_folder(v__vmod__ModFileCacher* mcache, string vfolder) {
	string mfolder = os__real_path(vfolder);
	if (_IN_MAP(ADDR(string, mfolder), ADDR(map, mcache->cache))) {
		mcache->hits++;
		return (*(v__vmod__ModFileAndFolder*)builtin__map_get(ADDR(map, mcache->cache), &(string[]){mfolder}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} }));
	}
	multi_return_Array_string_v__vmod__ModFileAndFolder mr_2650 = v__vmod__ModFileCacher_traverse(mcache, mfolder);
	Array_string traversed_folders = mr_2650.arg0;
	v__vmod__ModFileAndFolder res = mr_2650.arg1;
	for (int _t2 = 0; _t2 < traversed_folders.len; ++_t2) {
		string tfolder = ((string*)traversed_folders.data)[_t2];
		v__vmod__ModFileCacher_add(mcache, tfolder, res);
	}
	mcache->misses++;
	return res;
}
VV_LOC void v__vmod__ModFileCacher_add(v__vmod__ModFileCacher* cacher, string path, v__vmod__ModFileAndFolder result) {
	(*(v__vmod__ModFileAndFolder*)builtin__map_get_and_set((map*)&cacher->cache, &(string[]){path}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} })) = result;
}
VV_LOC multi_return_Array_string_v__vmod__ModFileAndFolder v__vmod__ModFileCacher_traverse(v__vmod__ModFileCacher* mcache, string mfolder) {
	string cfolder = mfolder;
	Array_string folders_so_far = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(cfolder)}));
	int levels = 0;
	for (;;) {
		if (levels > 255) {
			break;
		}
		if (_SLIT_EQ(cfolder.str, cfolder.len, "/") || (cfolder).len == 0) {
			break;
		}
		if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->cache))) {
			mcache->hits++;
			v__vmod__ModFileAndFolder res = (*(v__vmod__ModFileAndFolder*)builtin__map_get(ADDR(map, mcache->cache), &(string[]){cfolder}, &(v__vmod__ModFileAndFolder[]){ (v__vmod__ModFileAndFolder){.vmod_file = (string){.str=(byteptr)"", .is_lit=1},.vmod_folder = (string){.str=(byteptr)"", .is_lit=1},} }));
			if (res.vmod_file.len == 0) {
				v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
			} else {
				v__vmod__ModFileCacher_mark_folders_with_vmod(mcache, folders_so_far, res);
			}
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=builtin____new_array_with_default(0, 0, sizeof(string), 0), .arg1=res};
		}
		Array_string files = v__vmod__ModFileCacher_get_files(mcache, cfolder);
		if ((Array_string_contains(files, _S("v.mod")))) {
			v__vmod__ModFileAndFolder res = ((v__vmod__ModFileAndFolder){.vmod_file = os__join_path(cfolder, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("v.mod")}))),.vmod_folder = cfolder,});
			return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=folders_so_far, .arg1=res};
		}
		if (v__vmod__ModFileCacher_check_for_stop(mcache, files)) {
			break;
		}
		cfolder = os__dir(cfolder);
		builtin__array_push((array*)&folders_so_far, _MOV((string[]){ builtin__string_clone(cfolder) }));
		levels++;
	}
	v__vmod__ModFileCacher_mark_folders_as_vmod_free(mcache, folders_so_far);
	return (multi_return_Array_string_v__vmod__ModFileAndFolder){.arg0=builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(mfolder)})), .arg1=((v__vmod__ModFileAndFolder){.vmod_file = _S(""),.vmod_folder = mfolder,})};
}
VV_LOC void v__vmod__ModFileCacher_mark_folders_with_vmod(v__vmod__ModFileCacher* mcache, Array_string folders_so_far, v__vmod__ModFileAndFolder vmod) {
	for (int _t1 = 0; _t1 < folders_so_far.len; ++_t1) {
		string f = ((string*)folders_so_far.data)[_t1];
		v__vmod__ModFileCacher_add(mcache, f, vmod);
	}
}
VV_LOC void v__vmod__ModFileCacher_mark_folders_as_vmod_free(v__vmod__ModFileCacher* mcache, Array_string folders_so_far) {
	for (int _t1 = 0; _t1 < folders_so_far.len; ++_t1) {
		string f = ((string*)folders_so_far.data)[_t1];
		v__vmod__ModFileCacher_add(mcache, f, ((v__vmod__ModFileAndFolder){.vmod_file = _S(""),.vmod_folder = f,}));
	}
}
VV_LOC bool v__vmod__ModFileCacher_check_for_stop(v__vmod__ModFileCacher* mcache, Array_string files) {
	for (int _t1 = 0; _t1 < _const_v__vmod__mod_file_stop_paths.len; ++_t1) {
		string i = ((string*)_const_v__vmod__mod_file_stop_paths.data)[_t1];
		if ((Array_string_contains(files, i))) {
			return true;
		}
	}
	return false;
}
VV_LOC Array_string v__vmod__ModFileCacher_get_files(v__vmod__ModFileCacher* mcache, string cfolder) {
	if (_IN_MAP(ADDR(string, cfolder), ADDR(map, mcache->folder_files))) {
		mcache->get_files_hits++;
		return (*(Array_string*)builtin__map_get(ADDR(map, mcache->folder_files), &(string[]){cfolder}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) }));
	}
	mcache->get_files_misses++;
	Array_string files = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (os__exists(cfolder) && os__is_dir(cfolder)) {
		_result_Array_string _t2;
		if (_t2 = os__ls(cfolder), !_t2.is_error) {
			Array_string listing = *(Array_string*)_t2.data;
			files = builtin__array_clone_to_depth(&listing, 1);
		}
	}
	(*(Array_string*)builtin__map_get_and_set((map*)&mcache->folder_files, &(string[]){cfolder}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = files;
	return files;
}
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data) {
	if (seed_data.len != 2) {
		builtin__eprintln(_S("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		builtin___v_exit(1);
		VUNREACHABLE();
	}
	rng->state = ((*(u32*)builtin__array_get(seed_data, 0)) | ((((u64)((*(u32*)builtin__array_get(seed_data, 1)))) << 32)));
	rng->bytes_left = 0;
	rng->buffer = 0;
}
inline u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 1) {
		rng->bytes_left -= 1;
		u8 value = ((u8)(rng->buffer));
		rng->buffer >>= 8;
		return value;
	}
	rng->buffer = rand__wyrand__WyRandRNG_u64(rng);
	rng->bytes_left = 7;
	u8 value = ((u8)(rng->buffer));
	rng->buffer >>= 8;
	return value;
}
inline u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 2) {
		rng->bytes_left -= 2;
		u16 value = ((u16)(rng->buffer));
		rng->buffer >>= 16;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 16);
	rng->bytes_left = 6;
	return ((u16)(ans));
}
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 4) {
		rng->bytes_left -= 4;
		u32 value = ((u32)(rng->buffer));
		rng->buffer >>= 32;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 32);
	rng->bytes_left = 4;
	return ((u32)(ans));
}
inline int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng) {
	return 64;
}
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng) {
	builtin___v_free(rng);
}
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		return _wymix((seed1 ^ _const_rand__wyrand__wyp1), seed1);
	}
	return 0;
}
inline VV_LOC f64 rand__msqrt(f64 a) {
	if (a == 0) {
		return a;
	}
	f64 x = a;
	multi_return_f64_int mr_867 = rand__frexp(x);
	f64 z = mr_867.arg0;
	int ex = mr_867.arg1;
	f64 w = x;
	x = (f64)(((f64)(4.173075996388649989089e-1)) + (f64)(((f64)(5.9016206709064458299663e-1)) * z));
	if (((ex & 1)) != 0) {
		x *= _const_rand__sqrt2;
	}
	x = rand__scalbn(x, (ex >> 1));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	return x;
}
VV_LOC f64 rand__mlog(f64 a) {
	f64 ln2_lo = 1.90821492927058770002e-10;
	f64 ln2_hi = 0.693147180369123816490;
	f64 l1 = 0.6666666666666735130;
	f64 l2 = 0.3999999999940941908;
	f64 l3 = 0.2857142874366239149;
	f64 l4 = 0.2222219843214978396;
	f64 l5 = 0.1818357216161805012;
	f64 l6 = 0.1531383769920937332;
	f64 l7 = 0.1479819860511658591;
	f64 x = a;
	multi_return_f64_int mr_1639 = rand__frexp(x);
	f64 f1 = mr_1639.arg0;
	int ki = mr_1639.arg1;
	if (f1 < ((f64)((float_literal)(1.41421356237309504880168872420969807856967187537694807317667974 / 2)))) {
		f1 *= 2;
		ki--;
	}
	f64 f = (f64)(f1 - 1);
	f64 k = ((f64)(ki));
	f64 s = (f64)(f / ((f64)(2 + f)));
	f64 s2 = (f64)(s * s);
	f64 s4 = (f64)(s2 * s2);
	f64 t1 = (f64)(s2 * ((f64)(l1 + (f64)(s4 * ((f64)(l3 + (f64)(s4 * ((f64)(l5 + (f64)(s4 * l7))))))))));
	f64 t2 = (f64)(s4 * ((f64)(l2 + (f64)(s4 * ((f64)(l4 + (f64)(s4 * l6)))))));
	f64 r = (f64)(t1 + t2);
	f64 hfsq = (f64)((f64)(((f64)(0.5)) * f) * f);
	return (f64)((f64)(k * ln2_hi) - ((f64)(((f64)(hfsq - ((f64)((f64)(s * ((f64)(hfsq + r))) + (f64)(k * ln2_lo))))) - f)));
}
VV_LOC multi_return_f64_int rand__frexp(f64 x) {
	u64 y = rand__f64_bits(x);
	int ee = ((int)((((y >> 52)) & 0x7ff)));
	if (ee == 0) {
		if (x != ((f64)(0.0))) {
			f64 x1p64 = rand__f64_from_bits(((u64)(0x43f0000000000000LL)));
			multi_return_f64_int mr_2130 = rand__frexp((f64)(x * x1p64));
			f64 z = mr_2130.arg0;
			int e_ = mr_2130.arg1;
			return (multi_return_f64_int){.arg0=z, .arg1=(int)(e_ - 64)};
		}
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	} else if (ee == 0x7ff) {
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	}
	int e_ = (int)(ee - 0x3fe);
	y &= ((u64)(0x800fffffffffffffULL));
	y |= ((u64)(0x3fe0000000000000LL));
	return (multi_return_f64_int){.arg0=rand__f64_from_bits(y), .arg1=e_};
}
VV_LOC f64 rand__scalbn(f64 x, int n_) {
	int n = n_;
	f64 x1p1023 = rand__f64_from_bits(((u64)(0x7fe0000000000000LL)));
	f64 x1p53 = rand__f64_from_bits(((u64)(0x4340000000000000LL)));
	f64 x1p_1022 = rand__f64_from_bits(((u64)(0x0010000000000000LL)));
	f64 y = x;
	if (n > 1023) {
		y *= x1p1023;
		n -= 1023;
		if (n > 1023) {
			y *= x1p1023;
			n -= 1023;
			if (n > 1023) {
				n = 1023;
			}
		}
	} else if (n < -1022) {
		y *= (f64)(x1p_1022 * x1p53);
		n += 969;
		if (n < -1022) {
			y *= (f64)(x1p_1022 * x1p53);
			n += 969;
			if (n < -1022) {
				n = -1022;
			}
		}
	}
	return (f64)(y * rand__f64_from_bits((((u64)(((int)(0x3ff + n)))) << 52)));
}
inline VV_LOC f64 rand__f64_from_bits(u64 b) {
	return *((f64*)(&b));
}
inline VV_LOC u64 rand__f64_bits(f64 f) {
	return *((u64*)(&f));
}
string rand__uuid_v4(void) {
	u64 rand_1 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	u64 rand_2 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	return rand__internal_uuid(4, rand_1, rand_2);
}
inline VV_LOC string rand__internal_uuid(u8 version, u64 rand_1, u64 rand_2) {
	Array_fixed_u16_8 parts = {0};
	parts[0] = ((u16)((rand_1 >> 48)));
	parts[1] = ((u16)((rand_1 >> 32)));
	parts[2] = ((u16)((rand_1 >> 16)));
	parts[3] = ((u16)(rand_1));
	parts[4] = ((u16)((rand_2 >> 48)));
	parts[5] = ((u16)((rand_2 >> 32)));
	parts[6] = ((u16)((rand_2 >> 16)));
	parts[7] = ((u16)(rand_2));
	parts[3] = (((parts[3] & 0x0FFF)) | ((((u16)(version)) << 12)));
	parts[4] = (((parts[4] & 0x3FFF)) | 0x8000);
	u8* buf = builtin__malloc_noscan(37);
	int start = 0;
	{ // Unsafe block
		for (int i = 0; i < 8; ++i) {
			u16 val = parts[i];
			buf[start] = _const_rand__hex_chars.str[ (((val >> 12)) & 0xF)];
			buf[(int)(start + 1)] = _const_rand__hex_chars.str[ (((val >> 8)) & 0xF)];
			buf[(int)(start + 2)] = _const_rand__hex_chars.str[ (((val >> 4)) & 0xF)];
			buf[(int)(start + 3)] = _const_rand__hex_chars.str[ (val & 0xF)];
			start += 4;
			if (start == 8 || start == 13 || start == 18 || start == 23) {
				buf[start] = '-';
				start++;
			}
		}
		buf[36] = 0;
		return builtin__u8_vstring_with_len(buf, 36);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string rand__uuid_v7(void) {
	u64 timestamp_48 = (((u64)(time__Time_unix_milli(time__now()))) << 16);
	u64 rand_1 = (timestamp_48 | rand__PRNG_name_table[default_rng->_typ]._method_u16(default_rng->_object));
	u64 rand_2 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	return rand__internal_uuid(7, rand_1, rand_2);
}
rand__UUIDSession rand__new_uuid_v7_session(void) {
	return ((rand__UUIDSession){.counter = 0,});
}
string rand__UUIDSession_next(rand__UUIDSession* u) {
	u64 timestamp = ((u64)(time__Time_unix_nano(time__now())));
	u64 timestamp_shift_4bits = (((timestamp & 0xFFFFFFFFFFFF0000ULL)) | ((((timestamp & 0x000000000000FFFF)) >> 4)));
	u64 rand_1 = (((timestamp_shift_4bits & 0xFFFFFFFFFFFFFFC0ULL)) | ((u64)((u->counter & 0x3F))));
	u64 rand_2 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	u->counter++;
	return rand__internal_uuid(7, rand_1, rand_2);
}
VV_LOC string rand__internal_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli) {
	int buflen = 26;
	u8* buf = builtin__malloc_noscan(27);
	u64 t = unix_time_milli;
	int i = 9;
	for (;;) {
		if (!(i >= 0)) break;
		{ // Unsafe block
			buf[i] = _const_rand__ulid_encoding.str[ (t & 0x1F)];
		}
		t = (t >> 5);
		i--;
	}
	u64 x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	i = 10;
	for (;;) {
		if (!(i < 19)) break;
		{ // Unsafe block
			buf[i] = _const_rand__ulid_encoding.str[ (x & 0x1F)];
		}
		x = (x >> 5);
		i++;
	}
	x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	for (;;) {
		if (!(i < 26)) break;
		{ // Unsafe block
			buf[i] = _const_rand__ulid_encoding.str[ (x & 0x1F)];
		}
		x = (x >> 5);
		i++;
	}
	{ // Unsafe block
		buf[26] = 0;
		return builtin__u8_vstring_with_len(buf, buflen);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string rand__internal_string_from_set(rand__PRNG* rng, string charset, int len) {
	if (len == 0) {
		return _S("");
	}
	u8* buf = builtin__malloc_noscan((int)(len + 1));
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			buf[i] = charset.str[ (u32)(rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) % ((u32)(charset.len)))];
		}
	}
	{ // Unsafe block
		buf[len] = 0;
	}
	return builtin__u8_vstring_with_len(buf, len);
}
VV_LOC void rand__internal_fill_buffer_from_set(rand__PRNG* rng, string charset, Array_u8* buf) {
	if (buf->len == 0) {
		return;
	}
	int blen = buf->len;
	for (int i = 0; i < blen; ++i) {
		{ // Unsafe block
			((u8*)buf->data)[i] = charset.str[ (u32)(rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) % ((u32)(charset.len)))];
		}
	}
}
VV_LOC void rand__deinit(void) {
	{ // Unsafe block
		rand__PRNG_name_table[default_rng->_typ]._method__v_free(default_rng->_object);
		builtin___v_free(default_rng);
	}
}
VV_LOC void rand__init(void) {
	default_rng = rand__new_default(((rand__config__PRNGConfigStruct){.seed_ = rand__seed__time_seed_array(2),}));
	_result_void _t1 = builtin__at_exit((voidptr)rand__deinit);
	(void)_t1;
 ;
}
VV_LOC void rand__read_32(rand__PRNG* rng, Array_u8* buf) {
	u32* p32 = ((u32*)(buf->data));
	int u32s = (int)(buf->len / 4);
	for (int i = 0; i < u32s; ++i) {
		{ // Unsafe block
			*(p32 + i) = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
		}
	}
	for (int i = (int)(u32s * 4); i < buf->len; ++i) {
		((u8*)buf->data)[i] = rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object);
	}
}
VV_LOC void rand__read_64(rand__PRNG* rng, Array_u8* buf) {
	u64* p64 = ((u64*)(buf->data));
	if ((((u64)(p64)) & 0xF) != 0) {
		for (int i = 0; i < buf->len; ++i) {
			((u8*)buf->data)[i] = rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object);
		}
		return;
	}
	int u64s = (int)(buf->len / 8);
	for (int i = 0; i < u64s; ++i) {
		{ // Unsafe block
			*(p64 + i) = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
		}
	}
	for (int i = (int)(u64s * 8); i < buf->len; ++i) {
		((u8*)buf->data)[i] = rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object);
	}
}
VV_LOC void rand__read_internal(rand__PRNG* rng, Array_u8* buf) {
	int _t1 = rand__PRNG_name_table[rng->_typ]._method_block_size(rng->_object);
		switch (_t1) {
		case 32: {
			rand__read_32(rng, buf);
			break;
		}
		case 64: {
			rand__read_64(rng, buf);
			break;
		}
		default: {
			{
				for (int i = 0; i < buf->len; ++i) {
					((u8*)buf->data)[i] = rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object);
				}
				break;
			}
		}
	}
	
}
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_) {
	rand__wyrand__WyRandRNG* rng = ((rand__wyrand__WyRandRNG*)builtin__memdup(&(rand__wyrand__WyRandRNG){.PRNGBuffer = ((rand__buffer__PRNGBuffer){.bytes_left = 0,.buffer = 0,}),.state = rand__seed__time_seed_64(),.bytes_left = 0,.buffer = 0,}, sizeof(rand__wyrand__WyRandRNG)));
	rand__wyrand__WyRandRNG_seed(rng, config_.seed_);
	builtin__array_free(&config_.seed_);
	return HEAP(rand__PRNG, I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rng));
}
rand__PRNG* rand__get_current_rng(void) {
	return default_rng;
}
void rand__set_rng(rand__PRNG* rng) {
	default_rng = rng;
}
void rand__seed(Array_u32 seed) {
	rand__PRNG_name_table[default_rng->_typ]._method_seed(default_rng->_object, seed);
}
inline _result_Array_u8 rand__PRNG_bytes(rand__PRNG* rng, int bytes_needed) {
	if (bytes_needed < 0) {
		return (_result_Array_u8){ .is_error=true, .err=builtin___v_error(_S("can not read < 0 random bytes")), .data={E_STRUCT} };
	}
	Array_u8 buffer = builtin____new_array_with_default(bytes_needed, 0, sizeof(u8), 0);
	rand__read_internal(rng, &buffer);
	_result_Array_u8 _t2;
	builtin___result_ok(&(Array_u8[]) { buffer }, (_result*)(&_t2), sizeof(Array_u8));
	 
	return _t2;
}
void rand__PRNG_read(rand__PRNG* rng, Array_u8* buf) {
	rand__read_internal(rng, buf);
}
inline _result_i32 rand__PRNG_i32n(rand__PRNG* rng, i32 max) {
	_result_int _t2 = rand__PRNG_intn(rng, max);
	if (_t2.is_error) {
		_result_i32 _t3 = {0};
		_t3.is_error = true;
		_t3.err = _t2.err;
		return _t3;
	}
	
 	_result_i32 _t1;
	builtin___result_ok(&(i32[]) { ((i32)((*(int*)_t2.data))) }, (_result*)(&_t1), sizeof(i32));
	 
	return _t1;
}
inline _result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max) {
	if (max == 0) {
		return (_result_u32){ .is_error=true, .err=builtin___v_error(_S("max must be positive integer")), .data={E_STRUCT} };
	}
	int bit_len = math__bits__len_32(max);
	if (_unlikely_(bit_len == 32)) {
		for (;;) {
			u32 value = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
			if (value < max) {
				_result_u32 _t2;
				builtin___result_ok(&(u32[]) { value }, (_result*)(&_t2), sizeof(u32));
				 
				return _t2;
			}
		}
	} else {
		u32 mask = (_unlikely_(bit_len == 31) ? (((u32)(0x7FFFFFFF))) : ((u32)(((((u32)(1)) << ((int)(bit_len + 1)))) - 1)));
		for (;;) {
			u32 value = (rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) & mask);
			if (value < max) {
				_result_u32 _t3;
				builtin___result_ok(&(u32[]) { value }, (_result*)(&_t3), sizeof(u32));
				 
				return _t3;
			}
		}
	}
	_result_u32 _t4;
	builtin___result_ok(&(u32[]) { ((u32)(0)) }, (_result*)(&_t4), sizeof(u32));
	 
	return _t4;
}
inline _result_u64 rand__PRNG_u64n(rand__PRNG* rng, u64 max) {
	if (max == 0) {
		return (_result_u64){ .is_error=true, .err=builtin___v_error(_S("max must be positive integer")), .data={E_STRUCT} };
	}
	int bit_len = math__bits__len_64(max);
	if (_unlikely_(bit_len == 64)) {
		for (;;) {
			u64 value = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
			if (value < max) {
				_result_u64 _t2;
				builtin___result_ok(&(u64[]) { value }, (_result*)(&_t2), sizeof(u64));
				 
				return _t2;
			}
		}
	} else {
		u64 mask = (_unlikely_(bit_len == 63) ? (((u64)(0x7FFFFFFFFFFFFFFFLL))) : ((u64)(((((u64)(1)) << ((int)(bit_len + 1)))) - 1)));
		for (;;) {
			u64 value = (rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) & mask);
			if (value < max) {
				_result_u64 _t3;
				builtin___result_ok(&(u64[]) { value }, (_result*)(&_t3), sizeof(u64));
				 
				return _t3;
			}
		}
	}
	_result_u64 _t4;
	builtin___result_ok(&(u64[]) { ((u64)(0)) }, (_result*)(&_t4), sizeof(u64));
	 
	return _t4;
}
inline _result_u32 rand__PRNG_u32_in_range(rand__PRNG* rng, u32 min, u32 max) {
	if (max <= min) {
		return (_result_u32){ .is_error=true, .err=builtin___v_error(_S("max must be greater than min")), .data={E_STRUCT} };
	}
	_result_u32 _t3 = rand__PRNG_u32n(rng, (u32)(max - min));
	if (_t3.is_error) {
		_result_u32 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_u32 _t2;
	builtin___result_ok(&(u32[]) { (u32)(min + (*(u32*)_t3.data)) }, (_result*)(&_t2), sizeof(u32));
	 
	return _t2;
}
inline _result_u64 rand__PRNG_u64_in_range(rand__PRNG* rng, u64 min, u64 max) {
	if (max <= min) {
		return (_result_u64){ .is_error=true, .err=builtin___v_error(_S("max must be greater than min")), .data={E_STRUCT} };
	}
	_result_u64 _t3 = rand__PRNG_u64n(rng, (u64)(max - min));
	if (_t3.is_error) {
		_result_u64 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_u64 _t2;
	builtin___result_ok(&(u64[]) { (u64)(min + (*(u64*)_t3.data)) }, (_result*)(&_t2), sizeof(u64));
	 
	return _t2;
}
inline i8 rand__PRNG_i8(rand__PRNG* rng) {
	return ((i8)(rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object)));
}
inline i16 rand__PRNG_i16(rand__PRNG* rng) {
	return ((i16)(rand__PRNG_name_table[rng->_typ]._method_u16(rng->_object)));
}
inline i32 rand__PRNG_i32(rand__PRNG* rng) {
	return ((i32)(rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object)));
}
inline int rand__PRNG_int(rand__PRNG* rng) {
	return ((int)(rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object)));
}
inline i64 rand__PRNG_i64(rand__PRNG* rng) {
	return ((i64)(rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object)));
}
inline int rand__PRNG_int31(rand__PRNG* rng) {
	return ((int)((rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) & ((u32)(0x7FFFFFFF)))));
}
inline i64 rand__PRNG_int63(rand__PRNG* rng) {
	return ((i64)((rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) & ((u64)(0x7FFFFFFFFFFFFFFFLL)))));
}
inline _result_int rand__PRNG_intn(rand__PRNG* rng, int max) {
	if (max <= 0) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("max has to be positive.")), .data={E_STRUCT} };
	}
	_result_u32 _t3 = rand__PRNG_u32n(rng, ((u32)(max)));
	if (_t3.is_error) {
		_result_int _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_int _t2;
	builtin___result_ok(&(int[]) { ((int)((*(u32*)_t3.data))) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
inline _result_i64 rand__PRNG_i64n(rand__PRNG* rng, i64 max) {
	if (max <= 0) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("max has to be positive.")), .data={E_STRUCT} };
	}
	_result_u64 _t3 = rand__PRNG_u64n(rng, ((u64)(max)));
	if (_t3.is_error) {
		_result_i64 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_i64 _t2;
	builtin___result_ok(&(i64[]) { ((i64)((*(u64*)_t3.data))) }, (_result*)(&_t2), sizeof(i64));
	 
	return _t2;
}
inline _result_int rand__PRNG_int_in_range(rand__PRNG* rng, int min, int max) {
	if (max <= min) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(_S("max must be greater than min")), .data={E_STRUCT} };
	}
	_result_int _t3 = rand__PRNG_intn(rng, (int)(max - min));
	if (_t3.is_error) {
		_result_int _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_int _t2;
	builtin___result_ok(&(int[]) { (int)(min + (*(int*)_t3.data)) }, (_result*)(&_t2), sizeof(int));
	 
	return _t2;
}
inline _result_i32 rand__PRNG_i32_in_range(rand__PRNG* rng, i32 min, i32 max) {
	if (max <= min) {
		return (_result_i32){ .is_error=true, .err=builtin___v_error(_S("max must be greater than min")), .data={E_STRUCT} };
	}
	_result_int _t3 = rand__PRNG_intn(rng, (i32)(max - min));
	if (_t3.is_error) {
		_result_i32 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_i32 _t2;
	builtin___result_ok(&(i32[]) { (i32)(min + ((i32)((*(int*)_t3.data)))) }, (_result*)(&_t2), sizeof(i32));
	 
	return _t2;
}
inline _result_i64 rand__PRNG_i64_in_range(rand__PRNG* rng, i64 min, i64 max) {
	if (max <= min) {
		return (_result_i64){ .is_error=true, .err=builtin___v_error(_S("max must be greater than min")), .data={E_STRUCT} };
	}
	_result_i64 _t3 = rand__PRNG_i64n(rng, (i64)(max - min));
	if (_t3.is_error) {
		_result_i64 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_i64 _t2;
	builtin___result_ok(&(i64[]) { (i64)(min + (*(i64*)_t3.data)) }, (_result*)(&_t2), sizeof(i64));
	 
	return _t2;
}
inline f32 rand__PRNG_f32(rand__PRNG* rng) {
	return ((f32)((f64)(((rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) >> 9)) * _const_rand__reciprocal_2_23rd)));
}
inline f32 rand__PRNG_f32cp(rand__PRNG* rng) {
	u32 x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
	u32 exp = ((u32)(126));
	u32 mask = (((u32)(1)) << 31);
	if (_unlikely_(x == 0)) {
		x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
		exp -= 31;
	}
	for (;;) {
		if ((x & mask) != 0) {
			mask >>= 1;
			exp -= 1;
		} else {
			break;
		}
	}
	if (exp < 118) {
		x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
	}
	x = (((exp << 23)) | (((x >> 8)) & _const_rand__ieee754_mantissa_f32_mask));
	return math__bits__f32_from_bits(x);
}
inline f64 rand__PRNG_f64(rand__PRNG* rng) {
	return ((f64)((f64)(((rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) >> 12)) * _const_rand__reciprocal_2_52nd)));
}
inline f64 rand__PRNG_f64cp(rand__PRNG* rng) {
	u64 x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	u64 exp = ((u64)(1022));
	u64 mask = (((u64)(1)) << 63);
	u32 bitcount = ((u32)(0));
	if (_unlikely_(x == 0)) {
		x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
		exp -= 31;
	}
	for (;;) {
		if ((x & mask) != 0) {
			mask >>= 1;
			bitcount += 1;
		} else {
			break;
		}
	}
	exp -= bitcount;
	if (bitcount > 11) {
		x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	}
	x = (((exp << 52)) | ((x & _const_rand__ieee754_mantissa_f64_mask)));
	return math__bits__f64_from_bits(x);
}
inline _result_f32 rand__PRNG_f32n(rand__PRNG* rng, f32 max) {
	if (max < 0) {
		return (_result_f32){ .is_error=true, .err=builtin___v_error(_S("max has to be non-negative.")), .data={E_STRUCT} };
	}
	_result_f32 _t2;
	builtin___result_ok(&(f32[]) { (f32)(rand__PRNG_f32(rng) * max) }, (_result*)(&_t2), sizeof(f32));
	 
	return _t2;
}
inline _result_f64 rand__PRNG_f64n(rand__PRNG* rng, f64 max) {
	if (max < 0) {
		return (_result_f64){ .is_error=true, .err=builtin___v_error(_S("max has to be non-negative.")), .data={E_STRUCT} };
	}
	_result_f64 _t2;
	builtin___result_ok(&(f64[]) { (f64)(rand__PRNG_f64(rng) * max) }, (_result*)(&_t2), sizeof(f64));
	 
	return _t2;
}
inline _result_f32 rand__PRNG_f32_in_range(rand__PRNG* rng, f32 min, f32 max) {
	if (max < min) {
		return (_result_f32){ .is_error=true, .err=builtin___v_error(_S("max must be greater than or equal to min")), .data={E_STRUCT} };
	}
	_result_f32 _t3 = rand__PRNG_f32n(rng, (f32)(max - min));
	if (_t3.is_error) {
		_result_f32 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_f32 _t2;
	builtin___result_ok(&(f32[]) { (f32)(min + (*(f32*)_t3.data)) }, (_result*)(&_t2), sizeof(f32));
	 
	return _t2;
}
inline _result_f64 rand__PRNG_f64_in_range(rand__PRNG* rng, f64 min, f64 max) {
	if (max < min) {
		return (_result_f64){ .is_error=true, .err=builtin___v_error(_S("max must be greater than or equal to min")), .data={E_STRUCT} };
	}
	_result_f64 _t3 = rand__PRNG_f64n(rng, (f64)(max - min));
	if (_t3.is_error) {
		_result_f64 _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 	_result_f64 _t2;
	builtin___result_ok(&(f64[]) { (f64)(min + (*(f64*)_t3.data)) }, (_result*)(&_t2), sizeof(f64));
	 
	return _t2;
}
string rand__PRNG_ulid(rand__PRNG* rng) {
	return rand__internal_ulid_at_millisecond(rng, ((u64)(time__Time_unix_milli(time__utc()))));
}
string rand__PRNG_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli) {
	return rand__internal_ulid_at_millisecond(rng, unix_time_milli);
}
string rand__PRNG_string_from_set(rand__PRNG* rng, string charset, int len) {
	return rand__internal_string_from_set(rng, charset, len);
}
string rand__PRNG_string(rand__PRNG* rng, int len) {
	return rand__internal_string_from_set(rng, _const_rand__english_letters, len);
}
string rand__PRNG_hex(rand__PRNG* rng, int len) {
	return rand__internal_string_from_set(rng, _const_rand__hex_chars, len);
}
string rand__PRNG_ascii(rand__PRNG* rng, int len) {
	return rand__internal_string_from_set(rng, _const_rand__ascii_chars, len);
}
inline void rand__PRNG_fill_buffer_from_set(rand__PRNG* rng, string charset, Array_u8* buf) {
	rand__internal_fill_buffer_from_set(rng, charset, buf);
}
_result_bool rand__PRNG_bernoulli(rand__PRNG* rng, f64 p) {
	if (p < 0 || p > 1) {
		return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x1fe0f, {.d_f64 = p}}, {_S(" is not a valid probability value."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_bool _t2;
	builtin___result_ok(&(bool[]) { rand__PRNG_f64(rng) <= p }, (_result*)(&_t2), sizeof(bool));
	 
	return _t2;
}
_result_f64 rand__PRNG_normal(rand__PRNG* rng, rand__config__NormalConfigStruct conf) {
	_result_multi_return_f64_f64 _t1 = rand__PRNG_normal_pair(rng, conf);
	if (_t1.is_error) {
		_result_f64 _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 	multi_return_f64_f64 mr_12773 = (*(multi_return_f64_f64*)_t1.data);
	f64 x = mr_12773.arg0;
	_result_f64 _t3;
	builtin___result_ok(&(f64[]) { x }, (_result*)(&_t3), sizeof(f64));
	 
	return _t3;
}
_result_multi_return_f64_f64 rand__PRNG_normal_pair(rand__PRNG* rng, rand__config__NormalConfigStruct conf) {
	if (conf.sigma <= 0) {
		return (_result_multi_return_f64_f64){ .is_error=true, .err=builtin___v_error(_S("Standard deviation must be positive")), .data={E_STRUCT} };
	}
	for (;;) {
		_result_f64 _t2 = rand__PRNG_f64_in_range(rng, -1, 1);
		if (_t2.is_error) {
			*(f64*) _t2.data = 0.0;
		}
		
 		f64 u = (*(f64*)_t2.data);
		_result_f64 _t3 = rand__PRNG_f64_in_range(rng, -1, 1);
		if (_t3.is_error) {
			*(f64*) _t3.data = 0.0;
		}
		
 		f64 v = (*(f64*)_t3.data);
		f64 s = (f64)((f64)(u * u) + (f64)(v * v));
		if (s >= 1 || s == 0) {
			continue;
		}
		f64 t = rand__msqrt((f64)((f64)(-2 * rand__mlog(s)) / s));
		f64 x = (f64)(conf.mu + (f64)((f64)(conf.sigma * t) * u));
		f64 y = (f64)(conf.mu + (f64)((f64)(conf.sigma * t) * v));
		_result_multi_return_f64_f64 _t4;
		builtin___result_ok(&(multi_return_f64_f64[]) { (multi_return_f64_f64){.arg0=x, .arg1=y} }, (_result*)(&_t4), sizeof(multi_return_f64_f64));
		return _t4;
	}
	return (_result_multi_return_f64_f64){ .is_error=true, .err=builtin___v_error(_S("Implementation error. Please file an issue.")), .data={E_STRUCT} };
}
_result_int rand__PRNG_binomial(rand__PRNG* rng, int n, f64 p) {
	if (p < 0 || p > 1) {
		return (_result_int){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x1fe0f, {.d_f64 = p}}, {_S(" is not a valid probability value."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	int count = 0;
	for (int _t2 = 0; _t2 < n; ++_t2) {
		_result_bool _t3 = rand__PRNG_bernoulli(rng, p);
		if (_t3.is_error) {
			_result_int _t4 = {0};
			_t4.is_error = true;
			_t4.err = _t3.err;
			return _t4;
		}
		
 		if ((*(bool*)_t3.data)) {
			count++;
		}
	}
	_result_int _t5;
	builtin___result_ok(&(int[]) { count }, (_result*)(&_t5), sizeof(int));
	 
	return _t5;
}
f64 rand__PRNG_exponential(rand__PRNG* rng, f64 lambda) {
	if (lambda <= 0) {
		builtin___v_panic(_S("The rate (lambda) must be positive."));
		VUNREACHABLE();
	}
	return (f64)(-rand__mlog(rand__PRNG_f64(rng)) / lambda);
}
u8 rand__u8(void) {
	return rand__PRNG_name_table[default_rng->_typ]._method_u8(default_rng->_object);
}
u16 rand__u16(void) {
	return rand__PRNG_name_table[default_rng->_typ]._method_u16(default_rng->_object);
}
u32 rand__u32(void) {
	return rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object);
}
u64 rand__u64(void) {
	return rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
}
_result_u32 rand__u32n(u32 max) {
	return rand__PRNG_u32n(default_rng, max);
}
_result_u64 rand__u64n(u64 max) {
	return rand__PRNG_u64n(default_rng, max);
}
_result_u32 rand__u32_in_range(u32 min, u32 max) {
	return rand__PRNG_u32_in_range(default_rng, min, max);
}
_result_u64 rand__u64_in_range(u64 min, u64 max) {
	return rand__PRNG_u64_in_range(default_rng, min, max);
}
i8 rand__i8(void) {
	return rand__PRNG_i8(default_rng);
}
i16 rand__i16(void) {
	return rand__PRNG_i16(default_rng);
}
i32 rand__i32(void) {
	return rand__PRNG_i32(default_rng);
}
int rand__int(void) {
	return rand__PRNG_int(default_rng);
}
_result_i32 rand__i32n(i32 max) {
	return rand__PRNG_i32n(default_rng, max);
}
_result_int rand__intn(int max) {
	return rand__PRNG_intn(default_rng, max);
}
_result_int rand__int_in_range(int min, int max) {
	return rand__PRNG_int_in_range(default_rng, min, max);
}
_result_i32 rand__i32_in_range(i32 min, i32 max) {
	return rand__PRNG_i32_in_range(default_rng, min, max);
}
int rand__int31(void) {
	return rand__PRNG_int31(default_rng);
}
i64 rand__i64(void) {
	return rand__PRNG_i64(default_rng);
}
_result_i64 rand__i64n(i64 max) {
	return rand__PRNG_i64n(default_rng, max);
}
_result_i64 rand__i64_in_range(i64 min, i64 max) {
	return rand__PRNG_i64_in_range(default_rng, min, max);
}
i64 rand__int63(void) {
	return rand__PRNG_int63(default_rng);
}
f32 rand__f32(void) {
	return rand__PRNG_f32(default_rng);
}
f32 rand__f32cp(void) {
	return rand__PRNG_f32cp(default_rng);
}
f64 rand__f64(void) {
	return rand__PRNG_f64(default_rng);
}
f64 rand__f64cp(void) {
	return rand__PRNG_f64cp(default_rng);
}
_result_f32 rand__f32n(f32 max) {
	return rand__PRNG_f32n(default_rng, max);
}
_result_f64 rand__f64n(f64 max) {
	return rand__PRNG_f64n(default_rng, max);
}
_result_f32 rand__f32_in_range(f32 min, f32 max) {
	return rand__PRNG_f32_in_range(default_rng, min, max);
}
_result_f64 rand__f64_in_range(f64 min, f64 max) {
	return rand__PRNG_f64_in_range(default_rng, min, max);
}
_result_Array_u8 rand__bytes(int bytes_needed) {
	return rand__PRNG_bytes(default_rng, bytes_needed);
}
void rand__read(Array_u8* buf) {
	rand__read_internal(default_rng, buf);
}
string rand__ulid(void) {
	return rand__PRNG_ulid(default_rng);
}
string rand__ulid_at_millisecond(u64 unix_time_milli) {
	return rand__PRNG_ulid_at_millisecond(default_rng, unix_time_milli);
}
string rand__string_from_set(string charset, int len) {
	return rand__PRNG_string_from_set(default_rng, charset, len);
}
inline void rand__fill_buffer_from_set(string charset, Array_u8* buf) {
	rand__PRNG_fill_buffer_from_set(default_rng, charset, buf);
}
string rand__string(int len) {
	return rand__string_from_set(_const_rand__english_letters, len);
}
string rand__hex(int len) {
	return rand__string_from_set(_const_rand__hex_chars, len);
}
string rand__ascii(int len) {
	return rand__string_from_set(_const_rand__ascii_chars, len);
}
_result_bool rand__bernoulli(f64 p) {
	return rand__PRNG_bernoulli(default_rng, p);
}
_result_f64 rand__normal(rand__config__NormalConfigStruct config_) {
	return rand__PRNG_normal(default_rng, config_);
}
_result_multi_return_f64_f64 rand__normal_pair(rand__config__NormalConfigStruct config_) {
	return rand__PRNG_normal_pair(default_rng, config_);
}
_result_int rand__binomial(int n, f64 p) {
	return rand__PRNG_binomial(default_rng, n, p);
}
f64 rand__exponential(f64 lambda) {
	return rand__PRNG_exponential(default_rng, lambda);
}
v__pref__Arch v__pref__get_host_arch(void) {
	if (__V_architecture <= ((int)(v__pref__Arch___auto)) || __V_architecture >= ((int)(v__pref__Arch___max))) {
		return v__pref__Arch__amd64;
	}
	return ((v__pref__Arch)(__V_architecture));
}
_result_v__pref__Arch v__pref__arch_from_string(string arch_str) {

	if (_SLIT_EQ(arch_str.str, arch_str.len, "amd64") || _SLIT_EQ(arch_str.str, arch_str.len, "x86_64") || _SLIT_EQ(arch_str.str, arch_str.len, "x64") || _SLIT_EQ(arch_str.str, arch_str.len, "x86")) {
		_result_v__pref__Arch _t1;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__amd64 }, (_result*)(&_t1), sizeof(v__pref__Arch));
		 
		return _t1;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "aarch64") || _SLIT_EQ(arch_str.str, arch_str.len, "arm64")) {
		_result_v__pref__Arch _t2;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__arm64 }, (_result*)(&_t2), sizeof(v__pref__Arch));
		 
		return _t2;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "aarch32") || _SLIT_EQ(arch_str.str, arch_str.len, "arm32") || _SLIT_EQ(arch_str.str, arch_str.len, "arm")) {
		_result_v__pref__Arch _t3;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__arm32 }, (_result*)(&_t3), sizeof(v__pref__Arch));
		 
		return _t3;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "rv64") || _SLIT_EQ(arch_str.str, arch_str.len, "riscv64") || _SLIT_EQ(arch_str.str, arch_str.len, "risc-v64") || _SLIT_EQ(arch_str.str, arch_str.len, "riscv") || _SLIT_EQ(arch_str.str, arch_str.len, "risc-v")) {
		_result_v__pref__Arch _t4;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__rv64 }, (_result*)(&_t4), sizeof(v__pref__Arch));
		 
		return _t4;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "rv32") || _SLIT_EQ(arch_str.str, arch_str.len, "riscv32")) {
		_result_v__pref__Arch _t5;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__rv32 }, (_result*)(&_t5), sizeof(v__pref__Arch));
		 
		return _t5;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "x86_32") || _SLIT_EQ(arch_str.str, arch_str.len, "x32") || _SLIT_EQ(arch_str.str, arch_str.len, "i386") || _SLIT_EQ(arch_str.str, arch_str.len, "IA-32") || _SLIT_EQ(arch_str.str, arch_str.len, "ia-32") || _SLIT_EQ(arch_str.str, arch_str.len, "ia32")) {
		_result_v__pref__Arch _t6;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__i386 }, (_result*)(&_t6), sizeof(v__pref__Arch));
		 
		return _t6;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "s390x")) {
		_result_v__pref__Arch _t7;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__s390x }, (_result*)(&_t7), sizeof(v__pref__Arch));
		 
		return _t7;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "loongarch64")) {
		_result_v__pref__Arch _t8;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__loongarch64 }, (_result*)(&_t8), sizeof(v__pref__Arch));
		 
		return _t8;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "ppc64le")) {
		_result_v__pref__Arch _t9;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__ppc64le }, (_result*)(&_t9), sizeof(v__pref__Arch));
		 
		return _t9;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "js") || _SLIT_EQ(arch_str.str, arch_str.len, "js_node")) {
		_result_v__pref__Arch _t10;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__js_node }, (_result*)(&_t10), sizeof(v__pref__Arch));
		 
		return _t10;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "js_browser")) {
		_result_v__pref__Arch _t11;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__js_browser }, (_result*)(&_t11), sizeof(v__pref__Arch));
		 
		return _t11;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "js_freestanding")) {
		_result_v__pref__Arch _t12;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__js_freestanding }, (_result*)(&_t12), sizeof(v__pref__Arch));
		 
		return _t12;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "wasm32") || _SLIT_EQ(arch_str.str, arch_str.len, "wasm")) {
		_result_v__pref__Arch _t13;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch__wasm32 }, (_result*)(&_t13), sizeof(v__pref__Arch));
		 
		return _t13;
	}
	else if (_SLIT_EQ(arch_str.str, arch_str.len, "")) {
		_result_v__pref__Arch _t14;
		builtin___result_ok(&(v__pref__Arch[]) { v__pref__Arch___auto }, (_result*)(&_t14), sizeof(v__pref__Arch));
		 
		return _t14;
	}
	else {
		return (_result_v__pref__Arch){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid arch: "), 0xfe10, {.d_s = arch_str}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_v__pref__Arch){0};
}
multi_return_Array_string_Array_string v__pref__get_build_facts_and_defines(void) {
	Array_string facts = builtin__string_split_any(os__getenv(_S("VBUILD_FACTS")), _S(","));
	Array_string defines = builtin__string_split_any(os__getenv(_S("VBUILD_DEFINES")), _S(","));
	return (multi_return_Array_string_Array_string){.arg0=facts, .arg1=defines};
}
void v__pref__set_build_flags_and_defines(Array_string facts, Array_string defines) {
	string sfacts = Array_string_join(facts, _S(","));
	string sdefines = Array_string_join(defines, _S(","));
	os__setenv(_S("VBUILD_FACTS"), sfacts, true);
	os__setenv(_S("VBUILD_DEFINES"), sdefines, true);
	builtin__string_free(&sdefines);
	builtin__string_free(&sfacts);
}
v__pref__Preferences* v__pref__new_preferences(void) {
	v__pref__Preferences* p = ((v__pref__Preferences*)builtin__memdup(&(v__pref__Preferences){.cache_manager = ((v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.linfo = ((v__pref__LineInfo){.method = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.vars_printed = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.compile_values = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.file_list = builtin____new_array(0, 0, sizeof(string)),.compile_defines = builtin____new_array(0, 0, sizeof(string)),.compile_defines_all = builtin____new_array(0, 0, sizeof(string)),.profile_fns = builtin____new_array(0, 0, sizeof(string)),.run_only = builtin____new_array(0, 0, sizeof(string)),.cleanup_files = builtin____new_array(0, 0, sizeof(string)),.trace_fns = builtin____new_array(0, 0, sizeof(string)),.run_args = builtin____new_array(0, 0, sizeof(string)),.printfn_list = builtin____new_array(0, 0, sizeof(string)),.vmodules_paths = builtin____new_array(0, 0, sizeof(string)),.build_options = builtin____new_array(0, 0, sizeof(string)),.lookup_path = builtin____new_array(0, 0, sizeof(string)),.exclude = builtin____new_array(0, 0, sizeof(string)),.dump_defines = (string){.str=(byteptr)"", .is_lit=1},.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.line_info = (string){.str=(byteptr)"", .is_lit=1},.ldflags = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.cppcompiler = (string){.str=(byteptr)"", .is_lit=1},.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.coverage_dir = (string){.str=(byteptr)"", .is_lit=1},.raw_vsh_tmp_prefix = (string){.str=(byteptr)"", .is_lit=1},.print_autofree_vars_in_fn = (string){.str=(byteptr)"", .is_lit=1},.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.dump_modules = (string){.str=(byteptr)"", .is_lit=1},.dump_files = (string){.str=(byteptr)"", .is_lit=1},.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.vlib = (string){.str=(byteptr)"", .is_lit=1},.eval_argument = (string){.str=(byteptr)"", .is_lit=1},.cmain = (string){.str=(byteptr)"", .is_lit=1},.test_runner = (string){.str=(byteptr)"", .is_lit=1},.macosx_version_min = _S("0"),.cflags = (string){.str=(byteptr)"", .is_lit=1},.vroot = (string){.str=(byteptr)"", .is_lit=1},.message_limit = 200,.checker_match_exhaustive_cutoff_limit = 12,.thread_stack_size = 8388608,.wasm_stack_top = (int_literal)(1024 + 16384),.os = 0,.arch = 0,.backend = 0,.ccompiler_type = 0,.gc_mode = v__pref__GarbageCollectionMode__unknown,.assert_failure_mode = 0,.subsystem = 0,.use_color = 0,.output_mode = v__pref__OutputMode__stdout,.build_mode = 0,.building_v = 0,.no_bounds_checking = 0,.force_bounds_checking = 0,.autofree = 0,.print_autofree_vars = 0,.trace_calls = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_bare = 0,.no_preludes = 0,.no_closures = 0,.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.print_v_files = 0,.print_watched_files = 0,.skip_running = 0,.skip_warnings = 0,.skip_notes = 0,.warn_impure_v = 0,.warns_are_errors = 0,.notes_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.no_parallel = 0,.parallel_cc = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.nofloat = 0,.use_coroutines = 0,.fast_math = 0,.wasm_validate = 0,.warn_about_allocs = 0,.div_by_zero_is_zero = 0,.relaxed_gcc14 = true,.is_vls = 0,.json_errors = 0,.new_transform = 0,.new_generic_solver = 0,.backend_set_by_flag = 0,.is_verbose = 0,.is_glibc = 0,.is_musl = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.is_prod = 0,.no_prod_options = 0,.is_repl = 0,.is_eval_argument = 0,.is_run = 0,.is_crun = 0,.is_debug = 0,.is_vlines = 0,.is_stats = 0,.show_asserts = 0,.show_timings = 0,.is_fmt = 0,.is_vet = 0,.is_vweb = 0,.is_ios_simulator = 0,.is_apk = 0,.is_help = 0,.is_quiet = 0,.is_cstrict = 0,.is_callstack = 0,.is_trace = 0,.is_coverage = 0,.is_check_return = 0,.is_check_overflow = 0,.profile_no_inline = 0,.translated = 0,.translated_go = true,.obfuscate_removed = 0,.hide_auto_str = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.show_unused_params = 0,.use_cache = 0,.retry_compilation = true,.use_os_system_to_run = 0,.m64 = 0,}, sizeof(v__pref__Preferences)));
	v__pref__Preferences_fill_with_defaults(p);
	return p;
}
VV_LOC void v__pref__Preferences_expand_lookup_paths(v__pref__Preferences* p) {
	if ((p->vroot).len == 0) {
		p->vroot = os__dir(v__pref__vexe_path());
	}
	p->vlib = os__join_path(p->vroot, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("vlib")})));
	p->vmodules_paths = os__vmodules_paths();
	if (p->lookup_path.len == 0) {
		p->lookup_path = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("@vlib"), _S("@vmodules")}));
	}
	Array_string expanded_paths = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < p->lookup_path.len; ++_t1) {
		string path = ((string*)p->lookup_path.data)[_t1];

		if (_SLIT_EQ(path.str, path.len, "@vlib")) {
			builtin__array_push((array*)&expanded_paths, _MOV((string[]){ builtin__string_clone(p->vlib) }));
		}
		else if (_SLIT_EQ(path.str, path.len, "@vmodules")) {
			_PUSH_MANY(&expanded_paths, (p->vmodules_paths), _t3, Array_string);
		}
		else {
			builtin__array_push((array*)&expanded_paths, _MOV((string[]){ builtin__string_replace(path, _S("@vroot"), p->vroot) }));
		}
	}
	p->lookup_path = expanded_paths;
}
VV_LOC void v__pref__Preferences_expand_exclude_paths(v__pref__Preferences* p) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_string static_replacement_list = builtin__new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_S("@vroot"), builtin__string_clone(p->vroot), _S("@vlib"), builtin__string_clone(p->vlib)}));
	for (int _t1 = 0; _t1 < p->exclude.len; ++_t1) {
		string x = ((string*)p->exclude.data)[_t1];
		string y = builtin__string_replace_each(x, static_replacement_list);
		if (builtin__string_contains(y, _S("@vmodules"))) {
			for (int _t2 = 0; _t2 < p->vmodules_paths.len; ++_t2) {
				string vmp = ((string*)p->vmodules_paths.data)[_t2];
				builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_replace(y, _S("@vmodules"), vmp) }));
			}
			continue;
		}
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(y) }));
	}
	p->exclude = res;
}
VV_LOC void v__pref__Preferences_setup_os_and_arch_when_not_explicitly_set(v__pref__Preferences* p) {
	if (p->os == v__pref__OS__wasm32_emscripten) {
		v__pref__Preferences_parse_define(p, _S("emscripten"));
	}
	v__pref__OS host_os = (p->backend == v__pref__Backend__wasm ? (v__pref__OS__wasi) : (v__pref__get_host_os()));
	if (p->os == v__pref__OS___auto) {
		p->os = host_os;
		builtin__array_push((array*)&p->build_options, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-os "), 0xfe10, {.d_s = v__pref__OS_lower(host_os)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	if (!p->output_cross_c) {
		if (p->os != host_os) {
			if (host_os == v__pref__OS__macos && p->os == v__pref__OS__linux) {
				if (p->arch == v__pref__Arch___auto) {
					p->arch = v__pref__Arch__amd64;
					builtin__array_push((array*)&p->build_options, _MOV((string[]){ _S("-arch amd64") }));
				}
				v__pref__Preferences_parse_define(p, _S("use_bundled_libgc"));
			}
		}
	}
	if (p->arch == v__pref__Arch___auto) {
		p->arch = v__pref__get_host_arch();
		builtin__array_push((array*)&p->build_options, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-arch "), 0xfe10, {.d_s = v__pref__Arch_str(p->arch)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
}
string v__pref__Preferences_defines_map_unique_keys(v__pref__Preferences* p) {
	Map_string_bool defines_map = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t1 = 0; _t1 < p->compile_defines.len; ++_t1) {
		string d = ((string*)p->compile_defines.data)[_t1];
		builtin__map_set(&defines_map, &(string[]){d}, &(bool[]) { true });
	}
	for (int _t2 = 0; _t2 < p->compile_defines_all.len; ++_t2) {
		string d = ((string*)p->compile_defines_all.data)[_t2];
		builtin__map_set(&defines_map, &(string[]){d}, &(bool[]) { true });
	}
	Array_string keys = builtin__map_keys(&defines_map);
	Array_string _t3 = builtin__array_clone_to_depth(ADDR(Array_string,keys), 1);
	if (_t3.len > 0) { qsort(_t3.data, _t3.len, _t3.element_size, (voidptr)compare_3952967824979149813_string); }
	;
	Array_string skeys =_t3;
	return Array_string_join(skeys, _S(","));
}
void v__pref__Preferences_fill_with_defaults(v__pref__Preferences* p) {
	v__pref__Preferences_setup_os_and_arch_when_not_explicitly_set(p);
	v__pref__Preferences_expand_lookup_paths(p);
	v__pref__Preferences_expand_exclude_paths(p);
	string rpath = os__real_path(p->path);
	if ((p->out_name).len == 0) {
		string filename = builtin__string_trim_space(os__file_name(rpath));
		string base = builtin__string_all_before_last(filename, _S("."));
		if (Array_string_contains(builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S(".c"), _S(".js"), _S(".wasm")})), os__file_ext(base))) {
			base = builtin__string_all_before_last(base, _S("."));
		}
		if ((base).len == 0) {
			base = filename;
		}
		string target_dir = (os__is_dir(rpath) ? (rpath) : (os__dir(rpath)));
		if ((p->raw_vsh_tmp_prefix).len != 0) {
			p->out_name = os__join_path(target_dir, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string__plus(builtin__string__plus(p->raw_vsh_tmp_prefix, _S(".")), base)})));
		} else {
			p->out_name = os__join_path(target_dir, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){base})));
		}
	}
	string npath = builtin__string_replace(rpath, _S("\\"), _S("/"));
	p->building_v = !p->is_repl && (builtin__string_ends_with(npath, _S("cmd/v")) || builtin__string_ends_with(npath, _S("cmd/tools/vfmt.v")));
	if (p->os == v__pref__OS__linux) {
		#if !defined(__linux__)
		{
			v__pref__Preferences_parse_define(p, _S("cross_compile"));
		}
		#endif
	}
	if (p->output_cross_c) {
		p->gc_mode = v__pref__GarbageCollectionMode__no_gc;
		p->use_cache = false;
		p->skip_unused = false;
		v__pref__Preferences_parse_define(p, _S("no_backtrace"));
		v__pref__Preferences_parse_define(p, _S("cross"));
	}
	if (p->gc_mode == v__pref__GarbageCollectionMode__unknown) {
		if (p->backend != v__pref__Backend__c || p->building_v || p->is_bare) {
			p->gc_mode = v__pref__GarbageCollectionMode__no_gc;
			_PUSH_MANY(&p->build_options, (builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("-gc"), _S("none")}))), _t2, Array_string);
		} else {
			p->gc_mode = v__pref__GarbageCollectionMode__boehm_full_opt;
			v__pref__Preferences_parse_define(p, _S("gcboehm"));
			v__pref__Preferences_parse_define(p, _S("gcboehm_full"));
			v__pref__Preferences_parse_define(p, _S("gcboehm_opt"));
		}
	}
	if (p->is_debug) {
		v__pref__Preferences_parse_define(p, _S("debug"));
	}
	v__pref__Preferences_try_to_use_tcc_by_default(p);
	if ((p->ccompiler).len == 0) {
		v__pref__Preferences_default_c_compiler(p);
	}
	if ((p->cppcompiler).len == 0) {
		v__pref__Preferences_default_cpp_compiler(p);
	}
	v__pref__Preferences_find_cc_if_cross_compiling(p);
	p->ccompiler_type = v__pref__cc_from_string(p->ccompiler);
	p->is_test = builtin__string_ends_with(p->path, _S("_test.v")) || builtin__string_ends_with(p->path, _S("_test.vv")) || builtin__string_ends_with(builtin__string_all_before_last(builtin__string_all_before_last(p->path, _S(".v")), _S(".")), _S("_test"));
	p->is_vsh = builtin__string_ends_with(p->path, _S(".vsh")) || (p->raw_vsh_tmp_prefix).len != 0;
	p->is_script = p->is_vsh || builtin__string_ends_with(p->path, _S(".v")) || builtin__string_ends_with(p->path, _S(".vv"));
	if ((p->third_party_option).len == 0) {
		p->third_party_option = p->cflags;
		#if !defined(_WIN32)
		{
			if (!builtin__string_contains(p->third_party_option, _S("-fPIC"))) {
				p->third_party_option = builtin__string__plus(p->third_party_option, _S(" -fPIC"));
			}
		}
		#endif
	}
	string final_os = v__pref__OS_lower(p->os);
	v__pref__Preferences_parse_define(p, final_os);
	string vhash = _S("6fa4008a2aa1f7ee94b4ef4e5471af5a0a7ed016");
	p->cache_manager = v__vcache__new_cache_manager(builtin__new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){builtin__string_clone(vhash), builtin__str_intp(6, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__pref__Backend_str(p->backend)}}, {_S(" | "), 0xfe10, {.d_s = final_os}}, {_S(" | "), 0xfe10, {.d_s = p->ccompiler}}, {_S(" | "), 0xfe10, {.d_s = p->is_prod ? _S("true") : _S("false")}}, {_S(" | "), 0xfe10, {.d_s = p->sanitize ? _S("true") : _S("false")}}, {_SLIT0, 0, { .d_c = 0 }}})), v__pref__Preferences_defines_map_unique_keys(p), builtin__string_trim_space(p->cflags), builtin__string_trim_space(p->third_party_option), Array_string_str(p->lookup_path)})));
	if (builtin__string__eq(os__user_os(), _S("windows"))) {
		p->use_cache = false;
	}
	if (p->build_mode == v__pref__BuildMode__build_module) {
		p->use_cache = false;
	}
	if (p->is_shared) {
		p->use_cache = false;
	}
	if ((p->bare_builtin_dir).len == 0 && p->os == v__pref__OS__wasm32) {
		p->bare_builtin_dir = os__join_path(p->vroot, builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("vlib"), _S("builtin"), _S("wasm_bare")})));
	} else if ((p->bare_builtin_dir).len == 0) {
		p->bare_builtin_dir = os__join_path(p->vroot, builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("vlib"), _S("builtin"), _S("linux_bare")})));
	}
}
VV_LOC void v__pref__Preferences_find_cc_if_cross_compiling(v__pref__Preferences* p) {
	if (p->os == v__pref__get_host_os()) {
		return;
	}
	if (p->os == v__pref__OS__windows && builtin__fast_string_eq(p->ccompiler, _S("msvc"))) {
		return;
	}
	p->ccompiler = v__pref__Preferences_vcross_compiler_name(p);
}
VV_LOC void v__pref__Preferences_try_to_use_tcc_by_default(v__pref__Preferences* p) {
	if (builtin__fast_string_eq(p->ccompiler, _S("tcc"))) {
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
	if ((p->ccompiler).len == 0) {
		{
			return;
		}
		if (p->is_prod) {
			return;
		}
		p->ccompiler = v__pref__default_tcc_compiler();
		return;
	}
}
string v__pref__default_tcc_compiler(void) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	string vtccexe = os__join_path(vroot, builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("thirdparty"), _S("tcc"), _S("tcc.exe")})));
	if (os__exists(vtccexe)) {
		return vtccexe;
	}
	return _S("");
}
void v__pref__Preferences_default_c_compiler(v__pref__Preferences* p) {
	if (p->os == v__pref__OS__ios) {
		#if !defined(__TARGET_IOS__)
		{
			string ios_sdk = (p->is_ios_simulator ? (_S("iphonesimulator")) : (_S("iphoneos")));
			os__Result ios_sdk_path_res = os__execute_or_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("xcrun --sdk "), 0xfe10, {.d_s = ios_sdk}}, {_S(" --show-sdk-path"), 0, { .d_c = 0 }}})));
			string isysroot = builtin__string_replace(ios_sdk_path_res.output, _S("\n"), _S(""));
			string arch = (p->is_ios_simulator ? (_S("-arch x86_64 -arch arm64")) : (_S("-arch armv7 -arch armv7s -arch arm64")));
			p->ccompiler = _S("/usr/bin/cc");
			p->cflags = builtin__string__plus(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("-isysroot "), 0xfe10, {.d_s = isysroot}}, {_S(" "), 0xfe10, {.d_s = arch}}, {_SLIT0, 0, { .d_c = 0 }}})), p->cflags);
			return;
		}
		#endif
	}
	p->ccompiler = _S("cc");
	return;
}
void v__pref__Preferences_default_cpp_compiler(v__pref__Preferences* p) {
	if (builtin__string_contains(p->ccompiler, _S("clang"))) {
		p->cppcompiler = _S("clang++");
		return;
	}
	p->cppcompiler = _S("c++");
}
string v__pref__vexe_path(void) {
	string vexe = os__getenv(_S("VEXE"));
	if ((vexe).len != 0) {
		return vexe;
	}
	string myexe = os__executable();
	string real_vexe_path = myexe;
	for (;;) {
		real_vexe_path = os__real_path(real_vexe_path);
		break;
	}
	os__setenv(_S("VEXE"), real_vexe_path, true);
	return real_vexe_path;
}
string v__pref__Preferences_vcross_linker_name(v__pref__Preferences* p) {
	string vlname = os__getenv(_S("VCROSS_LINKER_NAME"));
	if ((vlname).len != 0) {
		return vlname;
	}
	{
		return _S("/opt/homebrew/opt/llvm/bin/ld.lld");
	}
	return _S("ld.lld");
}
string v__pref__Preferences_vcross_compiler_name(v__pref__Preferences* p) {
	string vccname = os__getenv(_S("VCROSS_COMPILER_NAME"));
	if ((vccname).len != 0) {
		return vccname;
	}
	if (p->os == v__pref__OS__windows) {
		if (p->os == v__pref__OS__freebsd) {
			return _S("clang");
		}
		if (p->m64) {
			return _S("x86_64-w64-mingw32-gcc");
		}
		return _S("i686-w64-mingw32-gcc");
	}
	if (p->os == v__pref__OS__linux) {
		return _S("clang");
	}
	if (p->os == v__pref__OS__freebsd) {
		return _S("clang");
	}
	if (p->os == v__pref__OS__wasm32_emscripten) {
		if (builtin__string__eq(os__user_os(), _S("windows"))) {
			return _S("emcc.bat");
		}
		return _S("emcc");
	}
	if (p->backend == v__pref__Backend__c && !builtin__string_ends_with(p->out_name, _S(".c"))) {
		builtin__eprintln(_S("Note: V can only cross compile to Windows and Linux for now by default."));
		builtin__eprintln(_S("It will use `cc` as a cross compiler for now, although that will probably fail."));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Set `VCROSS_COMPILER_NAME` to the name of your cross compiler, for your target OS: "), 0xfe10, {.d_s = v__pref__OS_str(p->os)}}, {_S(" ."), 0, { .d_c = 0 }}})));
	}
	return _S("cc");
}
string v__pref__Preferences_vroot_file(v__pref__Preferences* p, string path) {
	string full_path = os__join_path(p->vroot, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){path})));
	_result_string _t2 = os__read_file(full_path);
	if (_t2.is_error) {
		*(string*) _t2.data = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("/* missing @VEXEROOT content of path: "), 0xfe10, {.d_s = full_path}}, {_S(" */"), 0, { .d_c = 0 }}}));
	}
	
 	return (*(string*)_t2.data);
}
VV_LOC void v__pref__Preferences_parse_line_info(v__pref__Preferences* p, string line) {
	string format_err = _S("wrong format, use `-line-info \"file.v:24:7\"");
	Array_string vals = builtin__string_split(line, _S(":"));
	if (vals.len < 3) {
		builtin__eprintln(format_err);
		return;
	}
	string file_name = Array_string_join(builtin__array_slice(vals, 0, (int)(vals.len - 2)), _S(":"));
	int line_nr = builtin__string_int((*(string*)builtin__array_get(vals, (int)(vals.len - 2))));
	if ((!builtin__string_ends_with(file_name, _S(".v")) && !builtin__string_ends_with(file_name, _S(".vv"))) || line_nr == -1) {
		builtin__eprintln(format_err);
		return;
	}
	string third = (*(string*)builtin__array_get(vals, (int)(vals.len - 1)));
	int col = 0;
	v__pref__Method _t1; /* if prepend */
	if (builtin__string_starts_with(third, _S("fn^"))) {
		col = (int)(builtin__string_int(builtin__string_substr(third, 3, 2147483647)) - 1);
		_t1 = v__pref__Method__signature_help;
		goto _t2;
	};
	if (builtin__string_starts_with(third, _S("gd^"))) {
		col = (int)(builtin__string_int(builtin__string_substr(third, 3, 2147483647)) - 1);
		_t1 = v__pref__Method__definition;
		goto _t2;
	};
	if (builtin__u8_is_digit(builtin__string_at(third, 0))) {
		col = (int)(builtin__string_int(third) - 1);
		_t1 = v__pref__Method__completion;
		goto _t2;
	};
	{
		_t1 = v__pref__Method__unknown;
	}
	_t2: {};
		v__pref__Method method = _t1;
	p->linfo = ((v__pref__LineInfo){.method = method,.path = file_name,.line_nr = (int)(line_nr - 1),.col = col,.vars_printed = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
}
_result_v__pref__OS v__pref__os_from_string(string os_str) {
	string lcased_os_str = builtin__string_to_lower_ascii(os_str);

	if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "")) {
		_result_v__pref__OS _t1;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS___auto }, (_result*)(&_t1), sizeof(v__pref__OS));
		 
		return _t1;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "linux")) {
		_result_v__pref__OS _t2;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__linux }, (_result*)(&_t2), sizeof(v__pref__OS));
		 
		return _t2;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "nix")) {
		_result_v__pref__OS _t3;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__linux }, (_result*)(&_t3), sizeof(v__pref__OS));
		 
		return _t3;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "windows")) {
		_result_v__pref__OS _t4;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__windows }, (_result*)(&_t4), sizeof(v__pref__OS));
		 
		return _t4;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "ios")) {
		_result_v__pref__OS _t5;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__ios }, (_result*)(&_t5), sizeof(v__pref__OS));
		 
		return _t5;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "macos")) {
		_result_v__pref__OS _t6;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__macos }, (_result*)(&_t6), sizeof(v__pref__OS));
		 
		return _t6;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "darwin")) {
		_result_v__pref__OS _t7;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__macos }, (_result*)(&_t7), sizeof(v__pref__OS));
		 
		return _t7;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "freebsd")) {
		_result_v__pref__OS _t8;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__freebsd }, (_result*)(&_t8), sizeof(v__pref__OS));
		 
		return _t8;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "openbsd")) {
		_result_v__pref__OS _t9;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__openbsd }, (_result*)(&_t9), sizeof(v__pref__OS));
		 
		return _t9;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "netbsd")) {
		_result_v__pref__OS _t10;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__netbsd }, (_result*)(&_t10), sizeof(v__pref__OS));
		 
		return _t10;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "dragonfly")) {
		_result_v__pref__OS _t11;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__dragonfly }, (_result*)(&_t11), sizeof(v__pref__OS));
		 
		return _t11;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "js") || _SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "js_node")) {
		_result_v__pref__OS _t12;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__js_node }, (_result*)(&_t12), sizeof(v__pref__OS));
		 
		return _t12;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "js_freestanding")) {
		_result_v__pref__OS _t13;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__js_freestanding }, (_result*)(&_t13), sizeof(v__pref__OS));
		 
		return _t13;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "js_browser")) {
		_result_v__pref__OS _t14;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__js_browser }, (_result*)(&_t14), sizeof(v__pref__OS));
		 
		return _t14;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "solaris")) {
		_result_v__pref__OS _t15;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__solaris }, (_result*)(&_t15), sizeof(v__pref__OS));
		 
		return _t15;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "serenity")) {
		_result_v__pref__OS _t16;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__serenity }, (_result*)(&_t16), sizeof(v__pref__OS));
		 
		return _t16;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "qnx")) {
		_result_v__pref__OS _t17;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__qnx }, (_result*)(&_t17), sizeof(v__pref__OS));
		 
		return _t17;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "plan9")) {
		_result_v__pref__OS _t18;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__plan9 }, (_result*)(&_t18), sizeof(v__pref__OS));
		 
		return _t18;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "vinix")) {
		_result_v__pref__OS _t19;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__vinix }, (_result*)(&_t19), sizeof(v__pref__OS));
		 
		return _t19;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "android")) {
		_result_v__pref__OS _t20;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__android }, (_result*)(&_t20), sizeof(v__pref__OS));
		 
		return _t20;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "termux")) {
		_result_v__pref__OS _t21;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__termux }, (_result*)(&_t21), sizeof(v__pref__OS));
		 
		return _t21;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "haiku")) {
		_result_v__pref__OS _t22;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__haiku }, (_result*)(&_t22), sizeof(v__pref__OS));
		 
		return _t22;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "raw")) {
		_result_v__pref__OS _t23;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__raw }, (_result*)(&_t23), sizeof(v__pref__OS));
		 
		return _t23;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "wasm32")) {
		_result_v__pref__OS _t24;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__wasm32 }, (_result*)(&_t24), sizeof(v__pref__OS));
		 
		return _t24;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "wasm32_wasi")) {
		_result_v__pref__OS _t25;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__wasm32_wasi }, (_result*)(&_t25), sizeof(v__pref__OS));
		 
		return _t25;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "wasm32_emscripten")) {
		_result_v__pref__OS _t26;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__wasm32_emscripten }, (_result*)(&_t26), sizeof(v__pref__OS));
		 
		return _t26;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "browser")) {
		_result_v__pref__OS _t27;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__browser }, (_result*)(&_t27), sizeof(v__pref__OS));
		 
		return _t27;
	}
	else if (_SLIT_EQ(lcased_os_str.str, lcased_os_str.len, "wasi")) {
		_result_v__pref__OS _t28;
		builtin___result_ok(&(v__pref__OS[]) { v__pref__OS__wasi }, (_result*)(&_t28), sizeof(v__pref__OS));
		 
		return _t28;
	}
	else {
		return (_result_v__pref__OS){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("bad OS "), 0xfe10, {.d_s = os_str}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_v__pref__OS){0};
}
string v__pref__OS_lower(v__pref__OS o) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (o) {
		case v__pref__OS___auto: {
			_t2 = _S("");
			break;
		}
		case v__pref__OS__linux: {
			_t2 = _S("linux");
			break;
		}
		case v__pref__OS__windows: {
			_t2 = _S("windows");
			break;
		}
		case v__pref__OS__macos: {
			_t2 = _S("macos");
			break;
		}
		case v__pref__OS__ios: {
			_t2 = _S("ios");
			break;
		}
		case v__pref__OS__freebsd: {
			_t2 = _S("freebsd");
			break;
		}
		case v__pref__OS__openbsd: {
			_t2 = _S("openbsd");
			break;
		}
		case v__pref__OS__netbsd: {
			_t2 = _S("netbsd");
			break;
		}
		case v__pref__OS__dragonfly: {
			_t2 = _S("dragonfly");
			break;
		}
		case v__pref__OS__js_node: {
			_t2 = _S("js");
			break;
		}
		case v__pref__OS__js_freestanding: {
			_t2 = _S("js_freestanding");
			break;
		}
		case v__pref__OS__js_browser: {
			_t2 = _S("js_browser");
			break;
		}
		case v__pref__OS__solaris: {
			_t2 = _S("solaris");
			break;
		}
		case v__pref__OS__serenity: {
			_t2 = _S("serenity");
			break;
		}
		case v__pref__OS__qnx: {
			_t2 = _S("qnx");
			break;
		}
		case v__pref__OS__plan9: {
			_t2 = _S("plan9");
			break;
		}
		case v__pref__OS__vinix: {
			_t2 = _S("vinix");
			break;
		}
		case v__pref__OS__android: {
			_t2 = _S("android");
			break;
		}
		case v__pref__OS__termux: {
			_t2 = _S("termux");
			break;
		}
		case v__pref__OS__haiku: {
			_t2 = _S("haiku");
			break;
		}
		case v__pref__OS__raw: {
			_t2 = _S("raw");
			break;
		}
		case v__pref__OS__wasm32: {
			_t2 = _S("wasm32");
			break;
		}
		case v__pref__OS__wasm32_wasi: {
			_t2 = _S("wasm32_wasi");
			break;
		}
		case v__pref__OS__wasm32_emscripten: {
			_t2 = _S("wasm32_emscripten");
			break;
		}
		case v__pref__OS__browser: {
			_t2 = _S("browser");
			break;
		}
		case v__pref__OS__wasi: {
			_t2 = _S("wasi");
			break;
		}
		case v__pref__OS__all: {
			_t2 = _S("all");
			break;
		}
	}
	return _t2;
}
string v__pref__OS_str(v__pref__OS o) {
	switch (o) {
		case v__pref__OS___auto: {
			return _S("RESERVED: AUTO");
		}
		case v__pref__OS__ios: {
			return _S("iOS");
		}
		case v__pref__OS__macos: {
			return _S("MacOS");
		}
		case v__pref__OS__linux: {
			return _S("Linux");
		}
		case v__pref__OS__windows: {
			return _S("Windows");
		}
		case v__pref__OS__freebsd: {
			return _S("FreeBSD");
		}
		case v__pref__OS__openbsd: {
			return _S("OpenBSD");
		}
		case v__pref__OS__netbsd: {
			return _S("NetBSD");
		}
		case v__pref__OS__dragonfly: {
			return _S("Dragonfly");
		}
		case v__pref__OS__js_node: {
			return _S("NodeJS");
		}
		case v__pref__OS__js_freestanding: {
			return _S("JavaScript");
		}
		case v__pref__OS__js_browser: {
			return _S("JavaScript(Browser)");
		}
		case v__pref__OS__android: {
			return _S("Android");
		}
		case v__pref__OS__termux: {
			return _S("Termux");
		}
		case v__pref__OS__solaris: {
			return _S("Solaris");
		}
		case v__pref__OS__qnx: {
			return _S("QNX");
		}
		case v__pref__OS__serenity: {
			return _S("SerenityOS");
		}
		case v__pref__OS__plan9: {
			return _S("Plan9");
		}
		case v__pref__OS__vinix: {
			return _S("Vinix");
		}
		case v__pref__OS__haiku: {
			return _S("Haiku");
		}
		case v__pref__OS__wasm32: {
			return _S("WebAssembly");
		}
		case v__pref__OS__wasm32_emscripten: {
			return _S("WebAssembly(Emscripten)");
		}
		case v__pref__OS__wasm32_wasi: {
			return _S("WebAssembly(WASI)");
		}
		case v__pref__OS__browser: {
			return _S("browser");
		}
		case v__pref__OS__wasi: {
			return _S("wasi");
		}
		case v__pref__OS__raw: {
			return _S("Raw");
		}
		case v__pref__OS__all: {
			return _S("all");
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}
v__pref__OS v__pref__get_host_os(void) {
	if ((os__getenv(_S("TERMUX_VERSION"))).len != 0) {
		return v__pref__OS__termux;
	}
	{
		return v__pref__OS__macos;
	}
	return v__pref__OS___auto;
}
bool v__pref__Backend_is_js(v__pref__Backend b) {
	return (b == v__pref__Backend__js_node || b == v__pref__Backend__js_browser || b == v__pref__Backend__js_freestanding);
}
multi_return_ref_v__pref__Preferences_string v__pref__parse_args(Array_string known_external_commands, Array_string args) {
	return v__pref__parse_args_and_show_errors(known_external_commands, args, false);
}
VNORETURN VV_LOC void v__pref__run_code_in_tmp_vfile_and_exit(Array_string args, v__pref__Preferences* res, string option_name, string extension, string content) {
	string tmp_file_path = rand__ulid();
	string tmp_exe_file_path = res->out_name;
	string output_option = _S("");
	if ((tmp_exe_file_path).len == 0) {
		tmp_exe_file_path = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_file_path}}, {_S(".exe"), 0, { .d_c = 0 }}}));
		output_option = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-o "), 0xfe10, {.d_s = os__quoted_path(tmp_exe_file_path)}}, {_S(" "), 0, { .d_c = 0 }}}));
	}
	string tmp_v_file_path = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tmp_file_path}}, {_S("."), 0xfe10, {.d_s = extension}}, {_SLIT0, 0, { .d_c = 0 }}}));
	_result_void _t1 = os__write_file(tmp_v_file_path, content);
	if (_t1.is_error) {
		builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Failed to create temporary file "), 0xfe10, {.d_s = tmp_v_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
 ;
	string run_options = Array_string_join(os__cmdline__options_before(args, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(option_name)}))), _S(" "));
	string command_options = Array_string_join(builtin__array_slice_ni(os__cmdline__options_after(args, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(option_name)}))), 1, 2147483647), _S(" "));
	string vexe = v__pref__vexe_path();
	string tmp_cmd = builtin__str_intp(6, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" "), 0xfe10, {.d_s = output_option}}, {_S(" "), 0xfe10, {.d_s = run_options}}, {_S(" run "), 0xfe10, {.d_s = os__quoted_path(tmp_v_file_path)}}, {_S(" "), 0xfe10, {.d_s = command_options}}, {_SLIT0, 0, { .d_c = 0 }}}));
	v__pref__Preferences_vrun_elog(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("tmp_cmd: "), 0xfe10, {.d_s = tmp_cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
	int tmp_result = os__system(tmp_cmd);
	v__pref__Preferences_vrun_elog(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("exit code: "), 0xfe07, {.d_i32 = tmp_result}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if ((output_option).len != 0) {
		v__pref__Preferences_vrun_elog(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("remove tmp exe file: "), 0xfe10, {.d_s = tmp_exe_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_result_void _t2 = os__rm(tmp_exe_file_path);
		(void)_t2;
 ;
	}
	v__pref__Preferences_vrun_elog(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("remove tmp v file: "), 0xfe10, {.d_s = tmp_v_file_path}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_result_void _t3 = os__rm(tmp_v_file_path);
	(void)_t3;
 ;
	builtin___v_exit(tmp_result);
	VUNREACHABLE();
	while(1);
}
multi_return_ref_v__pref__Preferences_string v__pref__parse_args_and_show_errors(Array_string known_external_commands, Array_string args, bool show_output) {
	v__pref__Preferences* res = ((v__pref__Preferences*)builtin__memdup(&(v__pref__Preferences){.cache_manager = ((v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.linfo = ((v__pref__LineInfo){.method = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.vars_printed = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.compile_values = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.file_list = builtin____new_array(0, 0, sizeof(string)),.compile_defines = builtin____new_array(0, 0, sizeof(string)),.compile_defines_all = builtin____new_array(0, 0, sizeof(string)),.profile_fns = builtin____new_array(0, 0, sizeof(string)),.run_only = builtin____new_array(0, 0, sizeof(string)),.cleanup_files = builtin____new_array(0, 0, sizeof(string)),.trace_fns = builtin____new_array(0, 0, sizeof(string)),.run_args = builtin____new_array(0, 0, sizeof(string)),.printfn_list = builtin____new_array(0, 0, sizeof(string)),.vmodules_paths = builtin____new_array(0, 0, sizeof(string)),.build_options = builtin____new_array(0, 0, sizeof(string)),.lookup_path = builtin____new_array(0, 0, sizeof(string)),.exclude = builtin____new_array(0, 0, sizeof(string)),.dump_defines = (string){.str=(byteptr)"", .is_lit=1},.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.line_info = (string){.str=(byteptr)"", .is_lit=1},.ldflags = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.cppcompiler = (string){.str=(byteptr)"", .is_lit=1},.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.coverage_dir = (string){.str=(byteptr)"", .is_lit=1},.raw_vsh_tmp_prefix = (string){.str=(byteptr)"", .is_lit=1},.print_autofree_vars_in_fn = (string){.str=(byteptr)"", .is_lit=1},.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.dump_modules = (string){.str=(byteptr)"", .is_lit=1},.dump_files = (string){.str=(byteptr)"", .is_lit=1},.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.vlib = (string){.str=(byteptr)"", .is_lit=1},.eval_argument = (string){.str=(byteptr)"", .is_lit=1},.cmain = (string){.str=(byteptr)"", .is_lit=1},.test_runner = (string){.str=(byteptr)"", .is_lit=1},.macosx_version_min = _S("0"),.cflags = (string){.str=(byteptr)"", .is_lit=1},.vroot = (string){.str=(byteptr)"", .is_lit=1},.message_limit = 200,.checker_match_exhaustive_cutoff_limit = 12,.thread_stack_size = 8388608,.wasm_stack_top = (int_literal)(1024 + 16384),.os = 0,.arch = 0,.backend = 0,.ccompiler_type = 0,.gc_mode = v__pref__GarbageCollectionMode__unknown,.assert_failure_mode = 0,.subsystem = 0,.use_color = 0,.output_mode = v__pref__OutputMode__stdout,.build_mode = 0,.building_v = 0,.no_bounds_checking = 0,.force_bounds_checking = 0,.autofree = 0,.print_autofree_vars = 0,.trace_calls = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_bare = 0,.no_preludes = 0,.no_closures = 0,.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.print_v_files = 0,.print_watched_files = 0,.skip_running = 0,.skip_warnings = 0,.skip_notes = 0,.warn_impure_v = 0,.warns_are_errors = 0,.notes_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.no_parallel = 0,.parallel_cc = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.nofloat = 0,.use_coroutines = 0,.fast_math = 0,.wasm_validate = 0,.warn_about_allocs = 0,.div_by_zero_is_zero = 0,.relaxed_gcc14 = true,.is_vls = 0,.json_errors = 0,.new_transform = 0,.new_generic_solver = 0,.backend_set_by_flag = 0,.is_verbose = 0,.is_glibc = 0,.is_musl = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.is_prod = 0,.no_prod_options = 0,.is_repl = 0,.is_eval_argument = 0,.is_run = 0,.is_crun = 0,.is_debug = 0,.is_vlines = 0,.is_stats = 0,.show_asserts = 0,.show_timings = 0,.is_fmt = 0,.is_vet = 0,.is_vweb = 0,.is_ios_simulator = 0,.is_apk = 0,.is_help = 0,.is_quiet = 0,.is_cstrict = 0,.is_callstack = 0,.is_trace = 0,.is_coverage = 0,.is_check_return = 0,.is_check_overflow = 0,.profile_no_inline = 0,.translated = 0,.translated_go = true,.obfuscate_removed = 0,.hide_auto_str = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.show_unused_params = 0,.use_cache = 0,.retry_compilation = true,.use_os_system_to_run = 0,.m64 = 0,}, sizeof(v__pref__Preferences)));
	;
	#if defined(TARGET_IS_64BIT)
	{
		res->m64 = true;
	}
	#endif
	res->run_only = builtin__string_split_any(os__getenv(_S("VTEST_ONLY_FN")), _S(","));
	if ((os__getenv(_S("VQUIET"))).len != 0) {
		res->is_quiet = true;
	}
	if ((os__getenv(_S("VNORUN"))).len != 0) {
		res->skip_running = true;
	}
	string coverage_dir_from_env = os__getenv(_S("VCOVDIR"));
	if ((coverage_dir_from_env).len != 0) {
		res->coverage_dir = coverage_dir_from_env;
	}
	bool no_skip_unused = false;
	string command = _S("");
	int command_idx = 0;
	for (int i = 0; i < args.len; i++) {
		string arg = (*(string*)builtin__array_get(args, i));

		if (_SLIT_EQ(arg.str, arg.len, "--")) {
			break;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-wasm-validate")) {
			res->wasm_validate = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-wasm-stack-top")) {
			res->wasm_stack_top = builtin__string_int(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, builtin__int_str(res->wasm_stack_top)));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-apk")) {
			res->is_apk = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-arch")) {
			string target_arch = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-arch"), _S(""));
			i++;
			_result_v__pref__Arch _t3 = v__pref__arch_from_string(target_arch);
			if (_t3.is_error) {
				v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown architecture target `"), 0xfe10, {.d_s = target_arch}}, {_S("`"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 			v__pref__Arch target_arch_kind = (*(v__pref__Arch*)_t3.data);
			res->arch = target_arch_kind;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = target_arch}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-assert")) {
			string assert_mode = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-assert"), _S(""));

			if (_SLIT_EQ(assert_mode.str, assert_mode.len, "aborts")) {
				res->assert_failure_mode = v__pref__AssertFailureMode__aborts;
			}
			else if (_SLIT_EQ(assert_mode.str, assert_mode.len, "backtraces")) {
				res->assert_failure_mode = v__pref__AssertFailureMode__backtraces;
			}
			else if (_SLIT_EQ(assert_mode.str, assert_mode.len, "continues")) {
				res->assert_failure_mode = v__pref__AssertFailureMode__continues;
			}
			else {
				builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown assert mode `-gc "), 0xfe10, {.d_s = assert_mode}}, {_S("`, supported modes are:`"), 0, { .d_c = 0 }}})));
				builtin__eprintln(_S("  `-assert aborts`     .... calls abort() after assertion failure"));
				builtin__eprintln(_S("  `-assert backtraces` .... calls print_backtrace() after assertion failure"));
				builtin__eprintln(_S("  `-assert continues`  .... does not call anything, just continue after an assertion failure"));
				builtin___v_exit(1);
				VUNREACHABLE();
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-show-timings")) {
			res->show_timings = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-show-asserts")) {
			res->show_asserts = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-check-syntax")) {
			res->only_check_syntax = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-check")) {
			res->check_only = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-vls-mode")) {
			res->is_vls = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-?") || _SLIT_EQ(arg.str, arg.len, "-h") || _SLIT_EQ(arg.str, arg.len, "-help") || _SLIT_EQ(arg.str, arg.len, "--help")) {
			res->is_help = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-q")) {
			res->is_quiet = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-v") || _SLIT_EQ(arg.str, arg.len, "-V") || _SLIT_EQ(arg.str, arg.len, "--version") || _SLIT_EQ(arg.str, arg.len, "-version")) {
			if ((command).len != 0) {
				continue;
			}
			if (builtin__array_slice(args, i, 2147483647).len > 1 && _SLIT_EQ(arg.str, arg.len, "-v")) {
				res->is_verbose = true;
			} else {
				command = _S("version");
			}
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-progress")) {
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-Wimpure-v")) {
			res->warn_impure_v = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-Wfatal-errors")) {
			res->fatal_errors = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-silent")) {
			res->output_mode = v__pref__OutputMode__silent;
			builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("silent") }));
			builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("silent") }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-skip-running")) {
			res->skip_running = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cstrict")) {
			res->is_cstrict = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-nofloat")) {
			res->nofloat = true;
			builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("nofloat") }));
			builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("nofloat") }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-fast-math")) {
			res->fast_math = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-e")) {
			res->is_eval_argument = true;
			res->eval_argument = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-e"), _S(""));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-subsystem")) {
			string subsystem = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-subsystem"), _S(""));
			_result_v__pref__Subsystem _t9 = v__pref__Subsystem__static__from_T_string(subsystem);
			if (_t9.is_error) {
				Array_string valid = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				/* $for x in v.pref.Subsystem.values */ {
						EnumData x = {0};
					/* enum vals 0 */ {
						x.name = _S("auto");
						x.value = v__pref__Subsystem__auto;
						x.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
						builtin__array_push((array*)&valid, _MOV((string[]){ builtin__string_clone(x.name) }));
					}
					/* enum vals 1 */ {
						x.name = _S("console");
						x.value = v__pref__Subsystem__console;
						x.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
						builtin__array_push((array*)&valid, _MOV((string[]){ builtin__string_clone(x.name) }));
					}
					/* enum vals 2 */ {
						x.name = _S("windows");
						x.value = v__pref__Subsystem__windows;
						x.attrs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
						builtin__array_push((array*)&valid, _MOV((string[]){ builtin__string_clone(x.name) }));
					}
				}// $for
				builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid subsystem: "), 0xfe10, {.d_s = subsystem}}, {_SLIT0, 0, { .d_c = 0 }}})));
				builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("valid values are: "), 0xfe10, {.d_s = Array_string_str(valid)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				builtin___v_exit(1);
				VUNREACHABLE();
			;
			}
			
 			res->subsystem = (*(v__pref__Subsystem*)_t9.data);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-gc")) {
			string gc_mode = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-gc"), _S(""));

			if (_SLIT_EQ(gc_mode.str, gc_mode.len, "none")) {
				res->gc_mode = v__pref__GarbageCollectionMode__no_gc;
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "") || _SLIT_EQ(gc_mode.str, gc_mode.len, "boehm")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full_opt;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_full"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_opt"));
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "boehm_full")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_full"));
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "boehm_incr")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_incr;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_incr"));
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "boehm_full_opt")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_full_opt;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_full"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_opt"));
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "boehm_incr_opt")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_incr_opt;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_incr"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_opt"));
			}
			else if (_SLIT_EQ(gc_mode.str, gc_mode.len, "boehm_leak")) {
				res->gc_mode = v__pref__GarbageCollectionMode__boehm_leak;
				v__pref__Preferences_parse_define(res, _S("gcboehm"));
				v__pref__Preferences_parse_define(res, _S("gcboehm_leak"));
			}
			else {
				builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown garbage collection mode `-gc "), 0xfe10, {.d_s = gc_mode}}, {_S("`, supported modes are:`"), 0, { .d_c = 0 }}})));
				builtin__eprintln(_S("  `-gc boehm` ............ default GC-mode (currently `boehm_full_opt`)"));
				builtin__eprintln(_S("  `-gc boehm_full` ....... classic full collection"));
				builtin__eprintln(_S("  `-gc boehm_incr` ....... incremental collection"));
				builtin__eprintln(_S("  `-gc boehm_full_opt` ... optimized classic full collection"));
				builtin__eprintln(_S("  `-gc boehm_incr_opt` ... optimized incremental collection"));
				builtin__eprintln(_S("  `-gc boehm_leak` ....... leak detection (for debugging)"));
				builtin__eprintln(_S("  `-gc none` ............. no garbage collection"));
				builtin___v_exit(1);
				VUNREACHABLE();
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-g") || _SLIT_EQ(arg.str, arg.len, "-debug")) {
			res->is_debug = true;
			res->is_vlines = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cg") || _SLIT_EQ(arg.str, arg.len, "-cdebug")) {
			res->is_debug = true;
			res->is_vlines = false;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-debug-tcc")) {
			res->ccompiler = _S("tcc");
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = res->ccompiler}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			res->retry_compilation = false;
			res->show_cc = true;
			res->show_c_output = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-sourcemap")) {
			res->sourcemap = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-warn-about-allocs")) {
			res->warn_about_allocs = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-div-by-zero-is-zero")) {
			res->div_by_zero_is_zero = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-sourcemap-src-included")) {
			res->sourcemap_src_included = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-sourcemap-inline")) {
			res->sourcemap_inline = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-repl")) {
			res->is_repl = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-json-errors")) {
			res->json_errors = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-live")) {
			res->is_livemain = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-sharedlive")) {
			res->is_liveshared = true;
			res->is_shared = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-shared")) {
			res->is_shared = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "--enable-globals")) {
			v__pref__eprintln_cond(show_output && !res->is_quiet, _S("`--enable-globals` flag is deprecated, please use `-enable-globals` instead"));
			res->enable_globals = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-enable-globals")) {
			res->enable_globals = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-autofree")) {
			res->autofree = true;
			res->gc_mode = v__pref__GarbageCollectionMode__no_gc;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-print_autofree_vars")) {
			res->print_autofree_vars = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-print_autofree_vars_in_fn")) {
			res->print_autofree_vars = true;
			string value = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(value) }));
			res->print_autofree_vars_in_fn = value;
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-trace-calls")) {
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
			res->trace_calls = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-trace-fns")) {
			string value = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(value) }));
			Array_string trace_fns = builtin__string_split(value, _S(","));
			if (trace_fns.len > 0) {
				_PUSH_MANY(&res->trace_fns, (trace_fns), _t23, Array_string);
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-manualfree")) {
			res->autofree = false;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-skip-unused")) {
			res->skip_unused = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-skip-unused")) {
			no_skip_unused = true;
			res->skip_unused = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-compress")) {
			res->compress = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-freestanding")) {
			res->is_bare = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-retry-compilation")) {
			res->retry_compilation = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-musl")) {
			res->is_musl = true;
			res->is_glibc = false;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-glibc")) {
			res->is_musl = false;
			res->is_glibc = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-bounds-checking")) {
			res->no_bounds_checking = true;
			builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("no_bounds_checking") }));
			builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("no_bounds_checking") }));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-force-bounds-checking")) {
			res->force_bounds_checking = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-builtin")) {
			res->no_builtin = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-preludes")) {
			res->no_preludes = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-relaxed-gcc14")) {
			res->relaxed_gcc14 = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-prof") || _SLIT_EQ(arg.str, arg.len, "-profile")) {
			res->profile_file = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			res->is_prof = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = res->profile_file}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cov") || _SLIT_EQ(arg.str, arg.len, "-coverage")) {
			res->coverage_dir = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-profile-fns")) {
			Array_string profile_fns = builtin__string_split(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("")), _S(","));
			if (profile_fns.len > 0) {
				_PUSH_MANY(&res->profile_fns, (profile_fns), _t34, Array_string);
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-profile-no-inline")) {
			res->profile_no_inline = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-prod")) {
			res->is_prod = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-prod-options")) {
			res->no_prod_options = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-sanitize")) {
			res->sanitize = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-simulator")) {
			res->is_ios_simulator = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-stats")) {
			res->is_stats = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-obf") || _SLIT_EQ(arg.str, arg.len, "-obfuscate")) {
			builtin__println(_S("obfuscation has been removed; use `strip` on the resulting binary instead"));
			res->obfuscate_removed = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-hide-auto-str")) {
			res->hide_auto_str = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-translated")) {
			res->translated = true;
			res->gc_mode = v__pref__GarbageCollectionMode__no_gc;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-translated-go")) {
			builtin__println(_S("got -translated-go"));
			res->translated_go = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-m32") || _SLIT_EQ(arg.str, arg.len, "-m64")) {
			res->m64 = builtin__string_at(arg, 2) == '6';
			res->cflags = builtin__string__plus(res->cflags, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-color")) {
			res->use_color = v__pref__ColorOutput__always;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-nocolor")) {
			res->use_color = v__pref__ColorOutput__never;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-showcc")) {
			res->show_cc = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-show-c-output")) {
			res->show_c_output = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-show-callgraph")) {
			res->show_callgraph = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-show-depgraph")) {
			res->show_depgraph = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-run-only")) {
			res->run_only = builtin__string_split_any(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, os__getenv(_S("VTEST_ONLY_FN"))), _S(","));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-exclude")) {
			Array_string patterns = builtin__string_split_any(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("")), _S(","));
			_PUSH_MANY(&res->exclude, (patterns), _t38, Array_string);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-file-list")) {
			res->file_list = builtin__string_split_any(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("")), _S(","));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-test-runner")) {
			res->test_runner = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, res->test_runner);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-dump-c-flags")) {
			res->dump_c_flags = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-dump-modules")) {
			res->dump_modules = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-dump-files")) {
			res->dump_files = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-dump-defines")) {
			res->dump_defines = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("-"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-experimental")) {
			res->experimental = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-new-transformer")) {
			res->new_transform = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-usecache")) {
			res->use_cache = true;
			res->parallel_cc = false;
			res->no_parallel = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-use-os-system-to-run")) {
			res->use_os_system_to_run = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-macosx-version-min")) {
			res->macosx_version_min = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, res->macosx_version_min);
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = res->macosx_version_min}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-nocache")) {
			res->use_cache = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-prealloc")) {
			res->prealloc = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-parallel")) {
			res->no_parallel = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-parallel-cc")) {
			res->parallel_cc = true;
			res->no_parallel = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-native")) {
			res->backend = v__pref__Backend__native;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__string_clone(arg) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-interpret")) {
			res->backend = v__pref__Backend__interpret;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-W")) {
			res->warns_are_errors = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-w")) {
			res->skip_warnings = true;
			res->warns_are_errors = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-N")) {
			res->notes_are_errors = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-n")) {
			res->skip_notes = true;
			res->notes_are_errors = false;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-closures")) {
			res->no_closures = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-rsp")) {
			res->no_rsp = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-no-std")) {
			res->no_std = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-keepc")) {
			res->reuse_tmpc = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-watch")) {
			v__pref__eprintln_exit(_S("The -watch option is deprecated. Please use the watch command `v watch file.v` instead."));
			VUNREACHABLE();
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-print-v-files")) {
			res->print_v_files = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-print-watched-files")) {
			res->print_watched_files = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-http")) {
			string run_http_argument = _S("import net.http.file; file.serve()");
			Array_string _t44 = {0};
			Array_string _t44_orig = args;
			int _t44_len = _t44_orig.len;
			_t44 = builtin____new_array(0, _t44_len, sizeof(string));

			for (int _t45 = 0; _t45 < _t44_len; ++_t45) {
				string it = ((string*) _t44_orig.data)[_t45];
				if (_SLIT_NE(it.str, it.len, "-http")) {
					builtin__array_push((array*)&_t44, &it);
				}
			}
			Array_string new_args =_t44;
			_PUSH_MANY(&new_args, (builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("-e"), builtin__string_clone(run_http_argument)}))), _t46, Array_string);
			v__pref__eprintln_cond(show_output && !res->is_quiet, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Note: use `v -e '"), 0xfe10, {.d_s = run_http_argument}}, {_S("'`, if you want to customise the http server options."), 0, { .d_c = 0 }}})));
			v__pref__run_code_in_tmp_vfile_and_exit(new_args, res, _S("-e"), _S("vsh"), run_http_argument);
			VUNREACHABLE();
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cross")) {
			res->output_cross_c = true;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-os")) {
			string target_os = builtin__string_to_lower_ascii(os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-os"), _S("")));
			i++;
			_result_v__pref__OS _t48 = v__pref__os_from_string(target_os);
			if (_t48.is_error) {
				if (_SLIT_EQ(target_os.str, target_os.len, "cross")) {
					res->output_cross_c = true;
					continue;
				}
				v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown operating system target `"), 0xfe10, {.d_s = target_os}}, {_S("`"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 			v__pref__OS target_os_kind = (*(v__pref__OS*)_t48.data);
			if (target_os_kind == v__pref__OS__wasm32) {
				res->is_bare = true;
			}
			if (target_os_kind == v__pref__OS__wasm32 || target_os_kind == v__pref__OS__wasm32_emscripten || target_os_kind == v__pref__OS__wasm32_wasi) {
				res->arch = v__pref__Arch__wasm32;
			}
			if (target_os_kind == v__pref__OS__wasm32_emscripten) {
				res->gc_mode = v__pref__GarbageCollectionMode__no_gc;
			}
			res->os = target_os_kind;
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = target_os}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-printfn")) {
			_PUSH_MANY(&res->printfn_list, (builtin__string_split(os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-printfn"), _S("")), _S(","))), _t50, Array_string);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cflags")) {
			res->cflags = builtin__string__plus(res->cflags, builtin__string__plus(_S(" "), os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-cflags"), _S(""))));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = builtin__string_trim_space(res->cflags)}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-ldflags")) {
			res->ldflags = builtin__string__plus(res->ldflags, builtin__string__plus(_S(" "), os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-ldflags"), _S(""))));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = builtin__string_trim_space(res->ldflags)}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-d") || _SLIT_EQ(arg.str, arg.len, "-define")) {
			string* _t54 = (string*)(builtin__array_get_with_check(builtin__array_slice(args, i, 2147483647), 1));
			_option_string _t53 = {0};
			if (_t54) {
				*((string*)&_t53.data) = *((string*)_t54);
			} else {
				_t53.state = 2; _t53.err = builtin___v_error(_S("array index out of range"));
			}
			
			if (_t53.state == 0) {
				string define = (*(string*)_t53.data);
				v__pref__Preferences_parse_define(res, define);
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-message-limit")) {
			res->message_limit = builtin__string_int(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("5")));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-thread-stack-size")) {
			res->thread_stack_size = builtin__string_int(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, builtin__int_str(res->thread_stack_size)));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cc")) {
			res->ccompiler = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-cc"), _S("cc"));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = res->ccompiler}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-c++")) {
			res->cppcompiler = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-c++"), _S("c++"));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-checker-match-exhaustive-cutoff-limit")) {
			res->checker_match_exhaustive_cutoff_limit = builtin__string_int(os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("10")));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-o") || _SLIT_EQ(arg.str, arg.len, "-output")) {
			res->out_name = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			if (!os__is_abs_path(res->out_name)) {
				res->out_name = os__join_path(os__getwd(), builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){res->out_name})));
			}
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-is_o")) {
			res->is_o = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-b") || _SLIT_EQ(arg.str, arg.len, "-backend")) {
			string sbackend = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S("c"));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = sbackend}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			_result_v__pref__Backend _t57 = v__pref__backend_from_string(sbackend);
			if (_t57.is_error) {
				v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Unknown V backend: "), 0xfe10, {.d_s = sbackend}}, {_S("\nValid -backend choices are: c, go, interpret, js, js_node, js_browser, js_freestanding, native, wasm"), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 			v__pref__Backend b = (*(v__pref__Backend*)_t57.data);
			if (b == v__pref__Backend__wasm) {
				builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("wasm") }));
				builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("wasm") }));
				res->arch = v__pref__Arch__wasm32;
			} else if (v__pref__Backend_is_js(b)) {
				res->output_cross_c = true;
			}
			res->backend = b;
			res->backend_set_by_flag = true;
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-es5")) {
			res->output_es5 = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-path")) {
			string path = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-path"), _S(""));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = path}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			res->lookup_path = builtin__string_split(builtin__string_replace(path, _S("|"), _const_os__path_delimiter), _const_os__path_delimiter);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-bare-builtin-dir")) {
			string bare_builtin_dir = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" \""), 0xfe10, {.d_s = bare_builtin_dir}}, {_S("\""), 0, { .d_c = 0 }}})) }));
			res->bare_builtin_dir = bare_builtin_dir;
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-custom-prelude")) {
			string path = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-custom-prelude"), _S(""));
			builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg}}, {_S(" "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
			_result_string _t63 = os__read_file(path);
			if (_t63.is_error) {
				IError err = _t63.err;
				v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot open custom prelude file: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 			string prelude = (*(string*)_t63.data);
			res->custom_prelude = prelude;
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-raw-vsh-tmp-prefix")) {
			res->raw_vsh_tmp_prefix = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-cmain")) {
			res->cmain = os__cmdline__option(builtin__array_slice(args, i, 2147483647), _S("-cmain"), _S(""));
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-line-info")) {
			res->line_info = os__cmdline__option(builtin__array_slice(args, i, 2147483647), arg, _S(""));
			v__pref__Preferences_parse_line_info(res, res->line_info);
			i++;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-check-unused-fn-args")) {
			res->show_unused_params = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-check-return")) {
			res->is_check_return = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-check-overflow")) {
			res->is_check_overflow = true;
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-use-coroutines")) {
			res->use_coroutines = true;
			#if defined(__APPLE__) || defined(__linux__)
			{
				string _t65;
				#if defined(__V_arm64)
					_t65 = _S("arm64");
					;
				#else
				#endif
								string arch = _t65;
				string vexe = v__pref__vexe_path();
				string vroot = os__dir(vexe);
				string so_path = os__join_path(vroot, builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("thirdparty"), _S("photon"), _S("photonwrapper.so")})));
				string so_url = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("https://raw.githubusercontent.com/vlang/photonbin/master/photonwrapper_"), 0xfe10, {.d_s = os__user_os()}}, {_S("_"), 0xfe10, {.d_s = arch}}, {_S(".so"), 0, { .d_c = 0 }}}));
				if (!os__exists(so_path)) {
					builtin__println(_S("coroutines .so not found, downloading..."));
					_result_os__Result _t66 = os__execute_opt(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" download -o \""), 0xfe10, {.d_s = so_path}}, {_S("\" \""), 0xfe10, {.d_s = so_url}}, {_S("\""), 0, { .d_c = 0 }}})));
					if (_t66.is_error) {
						builtin___v_panic(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("coroutines .so could not be downloaded with `v download`. Download "), 0xfe10, {.d_s = so_url}}, {_S(", place it in "), 0xfe10, {.d_s = so_path}}, {_S(" then try again."), 0, { .d_c = 0 }}})));
						VUNREACHABLE();
					;
					}
					
 ;
					builtin__println(_S("done!"));
				}
				builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("is_coroutine") }));
				builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("is_coroutine") }));
				{
					string dyld_fallback_paths = os__getenv(_S("DYLD_FALLBACK_LIBRARY_PATH"));
					string so_dir = os__dir(so_path);
					if (!builtin__string_contains(dyld_fallback_paths, so_dir)) {
						Array_string _t69 = {0};
						Array_string _t69_orig = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){builtin__string_clone(dyld_fallback_paths), builtin__string_clone(so_dir)}));
						int _t69_len = _t69_orig.len;
						_t69 = builtin____new_array(0, _t69_len, sizeof(string));

						for (int _t70 = 0; _t70 < _t69_len; ++_t70) {
							string it = ((string*) _t69_orig.data)[_t70];
							if (it.len != 0) {
								builtin__array_push((array*)&_t69, &it);
							}
						}
						string env = Array_string_join(_t69, _S(":"));
						os__setenv(_S("DYLD_FALLBACK_LIBRARY_PATH"), env, true);
					}
				}
			}
			#else
			{
			}
			#endif
		}
		else if (_SLIT_EQ(arg.str, arg.len, "-new-generic-solver")) {
			res->new_generic_solver = true;
		}
		else {
			if (_SLIT_EQ(command.str, command.len, "build") && v__pref__is_source_file(arg)) {
				v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Use `v "), 0xfe10, {.d_s = arg}}, {_S("` instead."), 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			}
			if (v__pref__is_source_file(arg) && builtin__string_ends_with(arg, _S(".vsh"))) {
				res->is_vsh = true;
			}
			if (!builtin__string_starts_with(arg, _S("-"))) {
				if ((command).len == 0) {
					command = arg;
					command_idx = i;
					if (res->is_eval_argument || (_SLIT_EQ(command.str, command.len, "run") || _SLIT_EQ(command.str, command.len, "crun") || _SLIT_EQ(command.str, command.len, "watch"))) {
						break;
					}
				} else if (v__pref__is_source_file(command) && v__pref__is_source_file(arg) && !(Array_string_contains(known_external_commands, command)) && (res->raw_vsh_tmp_prefix).len == 0) {
					v__pref__eprintln_exit(_S("Too many targets. Specify just one target: <target.v|target_directory>."));
					VUNREACHABLE();
				}
				continue;
			}
			if (!(_SLIT_EQ(command.str, command.len, "") || _SLIT_EQ(command.str, command.len, "build-module")) && !v__pref__is_source_file(command)) {
				continue;
			}
			if (command_idx < i && (res->is_vsh || (v__pref__is_source_file(command) && (Array_string_contains(known_external_commands, command))))) {
				continue;
			}
			string err_detail = ((command).len == 0 ? (_S("")) : (builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" for command `"), 0xfe10, {.d_s = command}}, {_S("`"), 0, { .d_c = 0 }}}))));
			v__pref__eprintln_exit(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Unknown argument `"), 0xfe10, {.d_s = arg}}, {_S("`"), 0xfe10, {.d_s = err_detail}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	if (res->force_bounds_checking) {
		res->no_bounds_checking = false;
		Array_string _t71 = {0};
		Array_string _t71_orig = res->compile_defines;
		int _t71_len = _t71_orig.len;
		_t71 = builtin____new_array(0, _t71_len, sizeof(string));

		for (int _t72 = 0; _t72 < _t71_len; ++_t72) {
			string it = ((string*) _t71_orig.data)[_t72];
			if (_SLIT_EQ(it.str, it.len, "no_bounds_checking")) {
				builtin__array_push((array*)&_t71, &it);
			}
		}
		res->compile_defines =_t71;
		Array_string _t73 = {0};
		Array_string _t73_orig = res->compile_defines_all;
		int _t73_len = _t73_orig.len;
		_t73 = builtin____new_array(0, _t73_len, sizeof(string));

		for (int _t74 = 0; _t74 < _t73_len; ++_t74) {
			string it = ((string*) _t73_orig.data)[_t74];
			if (_SLIT_EQ(it.str, it.len, "no_bounds_checking")) {
				builtin__array_push((array*)&_t73, &it);
			}
		}
		res->compile_defines_all =_t73;
	}
	if (res->trace_calls) {
		if (res->trace_fns.len == 0) {
			builtin__array_push((array*)&res->trace_fns, _MOV((string[]){ _S("*") }));
		}
		for (int _t76 = 0; _t76 < res->trace_fns.len; ++_t76) {
			string* fpattern = ((string*)res->trace_fns.data) + _t76;
			if (builtin__string_contains(*fpattern, _S("*"))) {
				continue;
			}
			*fpattern = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("*"), 0xfe10, {.d_s = builtin__string_str(*fpattern)}}, {_S("*"), 0, { .d_c = 0 }}}));
		}
	}
	if (_SLIT_EQ(command.str, command.len, "crun")) {
		res->is_crun = true;
	}
	if (_SLIT_EQ(command.str, command.len, "run")) {
		res->is_run = true;
	}
	res->show_asserts = res->show_asserts || res->is_stats || (os__getenv(_S("VTEST_SHOW_ASSERTS"))).len != 0;
	if (res->os != v__pref__OS__wasm32_emscripten) {
		if (builtin__string_ends_with(res->out_name, _S(".js")) && !res->backend_set_by_flag) {
			res->backend = v__pref__Backend__js_node;
			res->output_cross_c = true;
		}
	}
	if (builtin__string_ends_with(res->out_name, _S(".o"))) {
		res->is_o = true;
	}
	if (_SLIT_EQ(command.str, command.len, "run") && res->is_prod && os__is_atty(1) > 0) {
		v__pref__eprintln_cond(show_output && !res->is_quiet, _S("Note: building an optimized binary takes much longer. It shouldn't be used with `v run`."));
		v__pref__eprintln_cond(show_output && !res->is_quiet, _S("Use `v run` without optimization, or build an optimized binary with -prod first, then run it separately."));
	}
	if ((res->os == v__pref__OS__browser || res->os == v__pref__OS__wasi) && res->backend != v__pref__Backend__wasm) {
		v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("OS `"), 0xfe10, {.d_s = v__pref__OS_str(res->os)}}, {_S("` forbidden for backends other than wasm"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	if (res->backend == v__pref__Backend__wasm && !(res->os == v__pref__OS__browser || res->os == v__pref__OS__wasi || res->os == v__pref__OS___auto)) {
		v__pref__eprintln_exit(_S("Native WebAssembly backend OS must be `browser` or `wasi`"));
		VUNREACHABLE();
	}
	if (_SLIT_NE(command.str, command.len, "doc") && builtin__string_ends_with(res->out_name, _S(".v"))) {
		v__pref__eprintln_exit(_S("Cannot save output binary in a .v file."));
		VUNREACHABLE();
	}
	if (res->fast_math) {
		if (res->ccompiler_type == v__pref__CompilerType__msvc) {
			res->cflags = builtin__string__plus(res->cflags, _S(" /fp:fast"));
		} else {
			res->cflags = builtin__string__plus(res->cflags, _S(" -ffast-math"));
		}
	}
	if (res->is_eval_argument) {
		v__pref__run_code_in_tmp_vfile_and_exit(args, res, _S("-e"), _S("vsh"), res->eval_argument);
		VUNREACHABLE();
	}
	Array_string command_args = builtin__array_slice_ni(args, (int)(command_idx + 1), 2147483647);
	if (res->is_run || res->is_crun) {
		string* _t78 = (string*)(builtin__array_get_with_check(command_args, 0));
		_option_string _t77 = {0};
		if (_t78) {
			*((string*)&_t77.data) = *((string*)_t78);
		} else {
			_t77.state = 2; _t77.err = builtin___v_error(_S("array index out of range"));
		}
		;
		if (_t77.state != 0) {
			v__pref__eprintln_exit(_S("v run: no v files listed"));
			VUNREACHABLE();
		;
		}
		
		res->path = (*(string*)_t77.data);
		res->run_args = builtin__array_slice(command_args, 1, 2147483647);
		if (builtin__fast_string_eq(res->path, _S("-"))) {
			string contents = os__get_raw_lines_joined();
			v__pref__run_code_in_tmp_vfile_and_exit(args, res, _S("run"), _S("v"), contents);
			VUNREACHABLE();
		}
		v__pref__must_exist(res->path);
		if (!builtin__string_ends_with(res->path, _S(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(builtin__string__plus(res->path, _S(".v")))) {
			v__pref__eprintln_cond(show_output && !res->is_quiet, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("It looks like you wanted to run \""), 0xfe10, {.d_s = res->path}}, {_S(".v\", so we went ahead and did that since \""), 0xfe10, {.d_s = res->path}}, {_S("\" is an executable."), 0, { .d_c = 0 }}})));
			res->path = builtin__string__plus(res->path, _S(".v"));
		}
	} else if (v__pref__is_source_file(command)) {
		res->path = command;
	}
	if (!res->is_bare && (res->bare_builtin_dir).len != 0) {
		v__pref__eprintln_cond(show_output && !res->is_quiet, _S("`-bare-builtin-dir` must be used with `-freestanding`"));
	}
	if (builtin__string_ends_with(command, _S(".vsh")) || ((res->raw_vsh_tmp_prefix).len != 0 && !res->is_run)) {
		res->is_crun = true;
		res->path = command;
		res->run_args = command_args;
	} else if (_SLIT_EQ(command.str, command.len, "interpret")) {
		res->backend = v__pref__Backend__interpret;
		string* _t80 = (string*)(builtin__array_get_with_check(command_args, 0));
		_option_string _t79 = {0};
		if (_t80) {
			*((string*)&_t79.data) = *((string*)_t80);
		} else {
			_t79.state = 2; _t79.err = builtin___v_error(_S("array index out of range"));
		}
		;
		if (_t79.state != 0) {
			v__pref__eprintln_exit(_S("v interpret: no v files listed"));
			VUNREACHABLE();
		;
		}
		
		res->path = (*(string*)_t79.data);
		if ((res->path).len != 0) {
			v__pref__must_exist(res->path);
			if (!builtin__string_ends_with(res->path, _S(".v")) && os__is_executable(res->path) && os__is_file(res->path) && os__is_file(builtin__string__plus(res->path, _S(".v")))) {
				v__pref__eprintln_cond(show_output && !res->is_quiet, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("It looks like you wanted to run \""), 0xfe10, {.d_s = res->path}}, {_S(".v\", so we went ahead and did that since \""), 0xfe10, {.d_s = res->path}}, {_S("\" is an executable."), 0, { .d_c = 0 }}})));
				res->path = builtin__string__plus(res->path, _S(".v"));
			}
		}
		res->run_args = builtin__array_slice(command_args, 1, 2147483647);
	}
	if (_SLIT_EQ(command.str, command.len, "build-module")) {
		res->build_mode = v__pref__BuildMode__build_module;
		res->no_parallel = true;
		res->parallel_cc = false;
		string* _t82 = (string*)(builtin__array_get_with_check(command_args, 0));
		_option_string _t81 = {0};
		if (_t82) {
			*((string*)&_t81.data) = *((string*)_t82);
		} else {
			_t81.state = 2; _t81.err = builtin___v_error(_S("array index out of range"));
		}
		;
		if (_t81.state != 0) {
			v__pref__eprintln_exit(_S("v build-module: no module specified"));
			VUNREACHABLE();
		;
		}
		
		res->path = (*(string*)_t81.data);
	}
	if (builtin__fast_string_eq(res->ccompiler, _S("musl-gcc"))) {
		res->is_musl = true;
		res->is_glibc = false;
	}
	if (res->is_musl) {
		builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("musl") }));
		builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("musl") }));
	}
	if (res->is_bare) {
		builtin__array_push((array*)&res->compile_defines, _MOV((string[]){ _S("freestanding") }));
		builtin__array_push((array*)&res->compile_defines_all, _MOV((string[]){ _S("freestanding") }));
	}
	if ((Array_string_contains(res->compile_defines_all, _S("callstack")))) {
		res->is_callstack = true;
	}
	if ((Array_string_contains(res->compile_defines_all, _S("trace")))) {
		res->is_trace = true;
	}
	if ((res->coverage_dir).len != 0) {
		res->is_coverage = true;
		builtin__array_push((array*)&res->build_options, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-coverage "), 0xfe10, {.d_s = res->coverage_dir}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	Map_string_string m = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t88 = 0; _t88 < res->build_options.len; ++_t88) {
		string x = ((string*)res->build_options.data)[_t88];
		builtin__map_set(&m, &(string[]){x}, &(string[]) { _S("") });
	}
	res->build_options = builtin__map_keys(&m);
	v__pref__Preferences_fill_with_defaults(res);
	if (res->backend == v__pref__Backend__c) {
		res->skip_unused = res->build_mode != v__pref__BuildMode__build_module;
		if (no_skip_unused) {
			res->skip_unused = false;
		}
	}
	return (multi_return_ref_v__pref__Preferences_string){.arg0=res, .arg1=command};
}
VNORETURN void v__pref__eprintln_exit(string s) {
	builtin__eprintln(s);
	builtin___v_exit(1);
	VUNREACHABLE();
	while(1);
}
void v__pref__eprintln_cond(bool condition, string s) {
	if (!condition) {
		return;
	}
	builtin__eprintln(s);
}
void v__pref__Preferences_vrun_elog(v__pref__Preferences* pref, string s) {
	if (pref->is_verbose) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("> v run -, "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}
bool v__pref__Preferences_should_output_to_stdout(v__pref__Preferences* pref) {
	return builtin__string_ends_with(pref->out_name, _S("/-")) || builtin__string_ends_with(pref->out_name, _S("\\-"));
}
VV_LOC void v__pref__must_exist(string path) {
	if (!os__exists(path)) {
		v__pref__eprintln_exit(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("v expects that `"), 0xfe10, {.d_s = path}}, {_S("` exists, but it does not"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}
inline VV_LOC bool v__pref__is_source_file(string path) {
	return builtin__string_ends_with(path, _S(".v")) || os__exists(path);
}
_result_v__pref__Backend v__pref__backend_from_string(string s) {
	_result_v__pref__Backend _t2 = {0};
	
	if (_SLIT_EQ(s.str, s.len, "c")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__c }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "interpret")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__interpret }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "js") || _SLIT_EQ(s.str, s.len, "js_node")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__js_node }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "js_browser")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__js_browser }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "js_freestanding")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__js_freestanding }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "wasm")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__wasm }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "native")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__native }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else if (_SLIT_EQ(s.str, s.len, "go")) {
		builtin___result_ok(&(v__pref__Backend[]) { v__pref__Backend__golang }, (_result*)(&_t2), sizeof(v__pref__Backend));
	}
	else {
		_t2.is_error = true;
		_t2.err = builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Unknown backend type "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}return _t2;
}
v__pref__CompilerType v__pref__cc_from_string(string s) {
	if ((s).len == 0) {
		return v__pref__CompilerType__gcc;
	}
	string cc = builtin__string_to_lower_ascii(os__file_name(s));
	bool _t3 = true;
	return ((_t3 == (builtin__string_contains(cc, _S("tcc")) || builtin__string_contains(cc, _S("tinyc"))))? (v__pref__CompilerType__tinyc) : (_t3 == (builtin__string_contains(cc, _S("gcc"))))? (v__pref__CompilerType__gcc) : (_t3 == (builtin__string_contains(cc, _S("clang"))))? (v__pref__CompilerType__clang) : (_t3 == (builtin__string_contains(cc, _S("emcc"))))? (v__pref__CompilerType__emcc) : (_t3 == (builtin__string_contains(cc, _S("msvc"))))? (v__pref__CompilerType__msvc) : (_t3 == (builtin__string_contains(cc, _S("mingw"))))? (v__pref__CompilerType__mingw) : (_t3 == (builtin__string_contains(cc, _S("++"))))? (v__pref__CompilerType__cplusplus) : (v__pref__CompilerType__gcc));
}
VV_LOC void v__pref__Preferences_parse_define(v__pref__Preferences* prefs, string define) {
	if (!(prefs->is_debug && _SLIT_EQ(define.str, define.len, "debug"))) {
		builtin__array_push((array*)&prefs->build_options, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("-d "), 0xfe10, {.d_s = define}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	}
	if (!builtin__string_contains(define, _S("="))) {
		builtin__map_set(&prefs->compile_values, &(string[]){define}, &(string[]) { _S("true") });
		builtin__array_push((array*)&prefs->compile_defines, _MOV((string[]){ builtin__string_clone(define) }));
		builtin__array_push((array*)&prefs->compile_defines_all, _MOV((string[]){ builtin__string_clone(define) }));
		return;
	}
	string dname = builtin__string_all_before(define, _S("="));
	string dvalue = builtin__string_all_after_first(define, _S("="));
	builtin__map_set(&prefs->compile_values, &(string[]){dname}, &(string[]) { dvalue });
	builtin__array_push((array*)&prefs->compile_defines_all, _MOV((string[]){ builtin__string_clone(dname) }));

	if (_SLIT_EQ(dvalue.str, dvalue.len, "")) {
	}
	else {
		builtin__array_push((array*)&prefs->compile_defines, _MOV((string[]){ builtin__string_clone(dname) }));
	}
}
string v__pref__supported_test_runners_list(void) {
	Array_string _t2 = {0};
	Array_string _t2_orig = _const_v__pref__supported_test_runners;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
		string it = ((string*) _t2_orig.data)[_t4];
		string _t3 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = it}}, {_S("`"), 0, { .d_c = 0 }}}));
		builtin__array_push((array*)&_t2, &_t3);
	}
	return Array_string_join( _t2, _S(", "));
}
bool v__pref__Preferences_should_trace_fn_name(v__pref__Preferences* pref, string fname) {
	bool _t2 = false;
	Array_string _t2_orig = pref->trace_fns;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		string it = ((string*) _t2_orig.data)[_t3];
		if (builtin__string_match_glob(fname, it)) {
			_t2 = true;
			break;
		}
	}
	return _t2;
}
bool v__pref__Preferences_should_use_segfault_handler(v__pref__Preferences* pref) {
	return !((Array_string_contains(pref->compile_defines, _S("no_segfault_handler"))) || (pref->os == v__pref__OS__wasm32 || pref->os == v__pref__OS__wasm32_emscripten));
}
Array_string v__pref__Preferences_should_compile_filtered_files(v__pref__Preferences* prefs, string dir, Array_string files_) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_string files = builtin__array_clone_to_depth(&files_, 1);
	if (files.len > 0) { qsort(files.data, files.len, files.element_size, (voidptr)compare_9574989068970878465_string); }
	;
	Array_string all_v_files = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		files_loop: {}
	for (int _t1 = 0; _t1 < files.len; ++_t1) {
		string file = ((string*)files.data)[_t1];
		if (!builtin__string_ends_with(file, _S(".v")) && !builtin__string_ends_with(file, _S(".vh"))) {
			continue;
		}
		if (builtin__string_ends_with(file, _S("_test.v")) || builtin__string_ends_with(builtin__string_all_before_last(builtin__string_all_before_last(file, _S(".v")), _S(".")), _S("_test"))) {
			continue;
		}
		bool is_d_notd_file = false;
		if (builtin__string_contains(file, _S("_d_"))) {
			is_d_notd_file = true;
			if (prefs->compile_defines_all.len == 0) {
				continue;
			}
			bool allowed = false;
			for (int _t2 = 0; _t2 < prefs->compile_defines.len; ++_t2) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t2];
				Array_string file_postfixes = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_d_"), 0xfe10, {.d_s = cdefine}}, {_S(".v"), 0, { .d_c = 0 }}})), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_d_"), 0xfe10, {.d_s = cdefine}}, {_S(".c.v"), 0, { .d_c = 0 }}}))}));
				for (int _t3 = 0; _t3 < file_postfixes.len; ++_t3) {
					string file_postfix = ((string*)file_postfixes.data)[_t3];
					if (builtin__string_ends_with(file, file_postfix)) {
						allowed = true;
						break;
					}
				}
				if (allowed) {
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		if (builtin__string_contains(file, _S("_notd_"))) {
			is_d_notd_file = true;
			bool allowed = true;
			for (int _t4 = 0; _t4 < prefs->compile_defines.len; ++_t4) {
				string cdefine = ((string*)prefs->compile_defines.data)[_t4];
				Array_string file_postfixes = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_notd_"), 0xfe10, {.d_s = cdefine}}, {_S(".v"), 0, { .d_c = 0 }}})), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_notd_"), 0xfe10, {.d_s = cdefine}}, {_S(".c.v"), 0, { .d_c = 0 }}}))}));
				for (int _t5 = 0; _t5 < file_postfixes.len; ++_t5) {
					string file_postfix = ((string*)file_postfixes.data)[_t5];
					if (builtin__string_ends_with(file, file_postfix)) {
						allowed = false;
						break;
					}
				}
				if (!allowed) {
					break;
				}
			}
			if (!allowed) {
				continue;
			}
		}
		if ((prefs->backend == v__pref__Backend__c || prefs->backend == v__pref__Backend__interpret) && !is_d_notd_file && !v__pref__Preferences_should_compile_c(prefs, file)) {
			continue;
		}
		if (v__pref__Backend_is_js(prefs->backend) && !v__pref__Preferences_should_compile_js(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend__native && !v__pref__Preferences_should_compile_native(prefs, file)) {
			continue;
		}
		if (!v__pref__Backend_is_js(prefs->backend) && !v__pref__Preferences_should_compile_asm(prefs, file)) {
			continue;
		}
		if (prefs->backend == v__pref__Backend__wasm && !v__pref__Preferences_should_compile_wasm(prefs, file)) {
			continue;
		}
		if (builtin__string_starts_with(file, _S(".#"))) {
			continue;
		}
		if (!prefs->prealloc && !prefs->output_cross_c && builtin__string_ends_with(file, _S("prealloc.c.v"))) {
			continue;
		}
		if (prefs->nofloat && builtin__string_ends_with(file, _S("float.c.v"))) {
			continue;
		}
		if (prefs->exclude.len > 0) {
			string full_file_path = os__join_path(dir, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file})));
			for (int _t6 = 0; _t6 < prefs->exclude.len; ++_t6) {
				string epattern = ((string*)prefs->exclude.data)[_t6];
				if (builtin__string_match_glob(full_file_path, epattern)) {
					goto files_loop__continue;
				}
			}
		}
		builtin__array_push((array*)&all_v_files, _MOV((string[]){ os__join_path(dir, builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){file}))) }));
		files_loop__continue: {}
	}
		files_loop__break: {}
	Array_string defaults = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_Array_string fnames_no_postfixes = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t8 = 0; _t8 < all_v_files.len; ++_t8) {
		string file = ((string*)all_v_files.data)[_t8];
		if (builtin__string_contains(file, _S("default.c.v"))) {
			builtin__array_push((array*)&defaults, _MOV((string[]){ builtin__string_clone(file) }));
		} else {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(file) }));
			string no_postfix_key = v__pref__fname_without_platform_postfix(file);
			Array_string candidates = (*(Array_string*)builtin__map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) }));
			builtin__array_push((array*)&candidates, _MOV((string[]){ builtin__string_clone(file) }));
			(*(Array_string*)builtin__map_get_and_set((map*)&fnames_no_postfixes, &(string[]){no_postfix_key}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = candidates;
		}
	}
	for (int _t12 = 0; _t12 < defaults.len; ++_t12) {
		string file = ((string*)defaults.data)[_t12];
		string no_postfix_key = v__pref__fname_without_platform_postfix(file);
		if (_IN_MAP(ADDR(string, no_postfix_key), ADDR(map, fnames_no_postfixes))) {
			if (prefs->is_verbose) {
				builtin__println(builtin__str_intp(3, _MOV((StrIntpData[]){{_S(">>> should_compile_filtered_files: skipping _default.c.v file "), 0xfe10, {.d_s = file}}, {_S(" ; the specialized versions are: "), 0xfe10, {.d_s = Array_string_str((*(Array_string*)builtin__map_get(ADDR(map, fnames_no_postfixes), &(string[]){no_postfix_key}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			continue;
		}
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(file) }));
	}
	if (prefs->is_verbose) {
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(">>> should_compile_filtered_files: res: "), 0xfe10, {.d_s = Array_string_str(res)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	return res;
}
VV_LOC string v__pref__fname_without_platform_postfix(string file) {
	string res = builtin__string_replace_each(file, builtin__new_array_from_c_array(32, 32, sizeof(string), _MOV((string[32]){
			_S("default.c.v"), _S("_"), _S("nix.c.v"), _S("_"), _S("windows.c.v"), _S("_"), _S("linux.c.v"), _S("_"), _S("darwin.c.v"),
			_S("_"), _S("macos.c.v"), _S("_"), _S("android.c.v"), _S("_"), _S("termux.c.v"), _S("_"), _S("android_outside_termux.c.v"),
			_S("_"), _S("freebsd.c.v"), _S("_"), _S("openbsd.c.v"), _S("_"), _S("netbsd.c.v"), _S("_"), _S("dragonfly.c.v"),
			_S("_"), _S("solaris.c.v"), _S("_"), _S("native.v"), _S("_"), _S("wasm32_emscripten.c.v"), _S("_")})));
	return res;
}
bool v__pref__Preferences_should_compile_native(v__pref__Preferences* prefs, string file) {
	return v__pref__Preferences_should_compile_c(prefs, file);
}
bool v__pref__Preferences_should_compile_c(v__pref__Preferences* prefs, string file) {
	if (builtin__string_ends_with(file, _S(".js.v"))) {
		return false;
	}
	if (prefs->is_bare && builtin__string_ends_with(file, _S(".freestanding.v"))) {
		return true;
	}
	if (prefs->os == v__pref__OS__all) {
		return true;
	}
	if (prefs->backend != v__pref__Backend__native && builtin__string_ends_with(file, _S("_native.v"))) {
		return false;
	}
	if (prefs->building_v && prefs->output_cross_c && builtin__string_ends_with(file, _S("_windows.v"))) {
		return true;
	}
	if (prefs->os == v__pref__OS__windows && (builtin__string_ends_with(file, _S("_nix.c.v")) || builtin__string_ends_with(file, _S("_nix.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__windows && (builtin__string_ends_with(file, _S("_windows.c.v")) || builtin__string_ends_with(file, _S("_windows.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__linux && (builtin__string_ends_with(file, _S("_linux.c.v")) || builtin__string_ends_with(file, _S("_linux.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__macos && (builtin__string_ends_with(file, _S("_darwin.c.v")) || builtin__string_ends_with(file, _S("_darwin.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__macos && (builtin__string_ends_with(file, _S("_macos.c.v")) || builtin__string_ends_with(file, _S("_macos.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__ios && (builtin__string_ends_with(file, _S("_ios.c.v")) || builtin__string_ends_with(file, _S("_ios.v")))) {
		return false;
	}
	if (prefs->os != v__pref__OS__freebsd && builtin__string_ends_with(file, _S("_freebsd.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__openbsd && builtin__string_ends_with(file, _S("_openbsd.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__netbsd && builtin__string_ends_with(file, _S("_netbsd.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__dragonfly && builtin__string_ends_with(file, _S("_dragonfly.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__solaris && builtin__string_ends_with(file, _S("_solaris.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__qnx && builtin__string_ends_with(file, _S("_qnx.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__serenity && builtin__string_ends_with(file, _S("_serenity.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__plan9 && builtin__string_ends_with(file, _S("_plan9.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__vinix && builtin__string_ends_with(file, _S("_vinix.c.v"))) {
		return false;
	}
	if (prefs->os == v__pref__OS__android || prefs->os == v__pref__OS__termux) {
		if (builtin__string_ends_with(file, _S("_android.c.v"))) {
			return true;
		}
		if (builtin__string_ends_with(file, _S("_android_outside_termux.c.v"))) {
			return prefs->os == v__pref__OS__android;
		}
		if (builtin__string_ends_with(file, _S("_termux.c.v"))) {
			return prefs->os == v__pref__OS__termux;
		}
	} else if (builtin__string_ends_with(file, _S("_android.c.v")) || builtin__string_ends_with(file, _S("_termux.c.v")) || builtin__string_ends_with(file, _S("_android_outside_termux.c.v"))) {
		return false;
	}
	if (prefs->os != v__pref__OS__wasm32_emscripten && (builtin__string_ends_with(file, _S("_wasm32_emscripten.c.v")) || builtin__string_ends_with(file, _S("_wasm32_emscripten.v")))) {
		return false;
	}
	return true;
}
bool v__pref__Preferences_should_compile_asm(v__pref__Preferences* prefs, string path) {
	if (builtin__string_count(path, _S(".")) != 2 || builtin__string_ends_with(path, _S("c.v")) || builtin__string_ends_with(path, _S("js.v"))) {
		return true;
	}
	string file = builtin__string_all_before_last(path, _S(".v"));
	_result_v__pref__Arch _t2 = v__pref__arch_from_string(builtin__string_all_after_last(file, _S(".")));
	if (_t2.is_error) {
		*(v__pref__Arch*) _t2.data = v__pref__Arch___auto;
	}
	
 	v__pref__Arch arch = (*(v__pref__Arch*)_t2.data);
	if (arch != prefs->arch && prefs->arch != v__pref__Arch___auto && arch != v__pref__Arch___auto) {
		return false;
	}
	_result_v__pref__OS _t4 = v__pref__os_from_string(builtin__string_all_before(builtin__string_all_after_last(file, _S("_")), _S(".")));
	if (_t4.is_error) {
		*(v__pref__OS*) _t4.data = v__pref__OS___auto;
	}
	
 	v__pref__OS file_os = (*(v__pref__OS*)_t4.data);
	if (file_os != prefs->os && prefs->os != v__pref__OS___auto && file_os != v__pref__OS___auto) {
		return false;
	}
	return true;
}
bool v__pref__Preferences_should_compile_js(v__pref__Preferences* prefs, string file) {
	if (!builtin__string_ends_with(file, _S(".js.v")) && builtin__string_split(file, _S(".")).len > 2) {
		return false;
	}
	return true;
}
bool v__pref__Preferences_should_compile_wasm(v__pref__Preferences* prefs, string file) {
	if (!builtin__string_ends_with(file, _S(".wasm.v")) && builtin__string_count(file, _S(".")) >= 2) {
		return false;
	}
	return true;
}
bool v__pref__OS_is_target_of(v__pref__OS this_os, string target) {
	if (this_os == v__pref__OS__all) {
		return true;
	}
	if ((this_os == v__pref__OS__windows && _SLIT_EQ(target.str, target.len, "nix")) || (this_os != v__pref__OS__windows && _SLIT_EQ(target.str, target.len, "windows")) || (this_os != v__pref__OS__linux && _SLIT_EQ(target.str, target.len, "linux")) || (this_os != v__pref__OS__macos && (_SLIT_EQ(target.str, target.len, "darwin") || _SLIT_EQ(target.str, target.len, "macos"))) || (this_os != v__pref__OS__ios && _SLIT_EQ(target.str, target.len, "ios")) || (this_os != v__pref__OS__freebsd && _SLIT_EQ(target.str, target.len, "freebsd")) || (this_os != v__pref__OS__openbsd && _SLIT_EQ(target.str, target.len, "openbsd")) || (this_os != v__pref__OS__netbsd && _SLIT_EQ(target.str, target.len, "netbsd")) || (this_os != v__pref__OS__dragonfly && _SLIT_EQ(target.str, target.len, "dragonfly")) || (this_os != v__pref__OS__solaris && _SLIT_EQ(target.str, target.len, "solaris")) || (this_os != v__pref__OS__qnx && _SLIT_EQ(target.str, target.len, "qnx")) || (this_os != v__pref__OS__serenity && _SLIT_EQ(target.str, target.len, "serenity")) || (this_os != v__pref__OS__plan9 && _SLIT_EQ(target.str, target.len, "plan9")) || (this_os != v__pref__OS__vinix && _SLIT_EQ(target.str, target.len, "vinix")) || (this_os != v__pref__OS__android && (_SLIT_EQ(target.str, target.len, "android") || _SLIT_EQ(target.str, target.len, "android_outside_termux"))) || (this_os != v__pref__OS__termux && _SLIT_EQ(target.str, target.len, "termux"))) {
		return false;
	}
	return true;
}
_result_v__pref__Subsystem v__pref__Subsystem__static__from_T_string(string input) {
	#if false
	{
	}
	#endif
	#if true
	{
		string val = builtin__string_str(input);

		if (_SLIT_EQ(val.str, val.len, "auto")) {
			_result_v__pref__Subsystem _t3;
			builtin___result_ok(&(v__pref__Subsystem[]) { v__pref__Subsystem__auto }, (_result*)(&_t3), sizeof(v__pref__Subsystem));
			 
			return _t3;
		}
		else if (_SLIT_EQ(val.str, val.len, "console")) {
			_result_v__pref__Subsystem _t4;
			builtin___result_ok(&(v__pref__Subsystem[]) { v__pref__Subsystem__console }, (_result*)(&_t4), sizeof(v__pref__Subsystem));
			 
			return _t4;
		}
		else if (_SLIT_EQ(val.str, val.len, "windows")) {
			_result_v__pref__Subsystem _t5;
			builtin___result_ok(&(v__pref__Subsystem[]) { v__pref__Subsystem__windows }, (_result*)(&_t5), sizeof(v__pref__Subsystem));
			 
			return _t5;
		}
		else {
		}
	}
	#endif
	return (_result_v__pref__Subsystem){ .is_error=true, .err=builtin___v_error(_S("invalid value")), .data={E_STRUCT} };
}
VV_LOC sync__Channel* sync__new_channel_st(u32 n, u32 st) {
	u32 wsem = (n > 0 ? (n) : (1));
	u32 rsem = (n > 0 ? (((u32)(0))) : (1));
	u8* rbuf = (n > 0 ? (builtin___v_malloc(((int)((u32)(n * st))))) : (((u8*)(((void*)0)))));
	u8* sbuf = (n > 0 ? (builtin__vcalloc_noscan(((int)((u32)(n * 2))))) : (((u8*)(((void*)0)))));
	sync__Channel *ch = HEAP(sync__Channel, (((sync__Channel){
		.ringbuf = rbuf,
		.statusbuf = sbuf,
		.objsize = st,
		.writesem = ((sync__Semaphore){.count = 0,}),
		.readsem = ((sync__Semaphore){.count = 0,}),
		.writesem_im = ((sync__Semaphore){.count = 0,}),
		.readsem_im = ((sync__Semaphore){.count = 0,}),
		.write_free = n,
		.read_avail = 0,
		.buf_elem_write_idx = 0,
		.buf_elem_read_idx = 0,
		.write_subscriber = ((void*)0),
		.read_subscriber = ((void*)0),
		.write_sub_mtx = sync__new_spin_lock(),
		.read_sub_mtx = sync__new_spin_lock(),
		.closed = 0,
		.cap = n,
	})));
	sync__Semaphore_init(&(*(ch)).writesem, wsem);
	sync__Semaphore_init(&(*(ch)).readsem, rsem);
	sync__Semaphore_init(&(*(ch)).writesem_im, 0);
	sync__Semaphore_init(&(*(ch)).readsem_im, 0);
	return &(*(ch));
}
void sync__Channel_close(sync__Channel* ch) {
	u16 open_val = ((u16)(0));
	if (!atomic_compare_exchange_strong_u16(&ch->closed, &open_val, 1)) {
		return;
	}
	voidptr nulladr = ((void*)0);
	for (;;) {
		if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&nulladr)), ((isize)(-1))))) break;
		nulladr = ((void*)0);
	}
	sync__Semaphore_post(&ch->readsem_im);
	sync__Semaphore_post(&ch->readsem);
	sync__SpinLock_lock(ch->read_sub_mtx);
	if (ch->read_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->read_subscriber->sem);
	}
	sync__SpinLock_unlock(ch->read_sub_mtx);
	sync__SpinLock_lock(ch->write_sub_mtx);
	if (ch->write_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->write_subscriber->sem);
	}
	sync__SpinLock_unlock(ch->write_sub_mtx);
	sync__Semaphore_post(&ch->writesem);
	if (ch->cap == 0) {
		atomic_store_ptr(((voidptr*)(&ch->read_adr)), ((void*)0));
	}
	sync__Semaphore_post(&ch->writesem_im);
}
inline int sync__Channel_len(sync__Channel* ch) {
	return ((int)(atomic_load_u32(&ch->read_avail)));
}
inline bool sync__Channel_closed(sync__Channel* ch) {
	return atomic_load_u16(&ch->closed) != 0;
}
inline void sync__Channel_push(sync__Channel* ch, voidptr src) {
	if (sync__Channel_try_push_priv(ch, src, false) == ChanState__closed) {
		builtin___v_panic(_S("push on closed channel"));
		VUNREACHABLE();
	}
}
inline ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src) {
	return sync__Channel_try_push_priv(ch, src, true);
}
VV_LOC ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block) {
	if (atomic_load_u16(&ch->closed) != 0) {
		return ChanState__closed;
	}
	multi_return_u32_u32 mr_4744 = (no_block ? ((multi_return_u32_u32){.arg0=((u32)(1)),.arg1=((u32)(1))}) : ((multi_return_u32_u32){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	u32 spinloops_sem_ = mr_4744.arg0;
	u32 spinloops_ = mr_4744.arg1;
	bool have_swapped = false;
	for (;;) {
		bool got_sem = false;
		voidptr wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
		for (;;) {
			if (!(wradr != NULL)) break;
			if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->write_adr)), ((voidptr)(&wradr)), ((isize)(0)))) {
				memcpy(wradr, src, ch->objsize);
				voidptr nulladr = ((void*)0);
				for (;;) {
					if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&nulladr)), ((isize)(wradr))))) break;
					nulladr = ((void*)0);
				}
				sync__Semaphore_post(&ch->readsem_im);
				return ChanState__success;
			}
		}
		if (no_block && ch->cap == 0) {
			return ChanState__not_ready;
		}
		for (u32 _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->writesem);
		}
		if (!got_sem) {
			if (no_block) {
				return ChanState__not_ready;
			}
			sync__Semaphore_wait(&ch->writesem);
		}
		if (atomic_load_u16(&ch->closed) != 0) {
			sync__Semaphore_post(&ch->writesem);
			return ChanState__closed;
		}
		if (ch->cap == 0) {
			bool read_in_progress = false;
			atomic_store_ptr(((voidptr*)(&ch->read_adr)), src);
			wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
			if (wradr != NULL) {
				voidptr src2 = src;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->read_adr)), ((voidptr)(&src2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					continue;
				} else {
					read_in_progress = true;
				}
			}
			if (!read_in_progress) {
				sync__SpinLock_lock(ch->read_sub_mtx);
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				sync__SpinLock_unlock(ch->read_sub_mtx);
			}
			voidptr src2 = src;
			for (u32 sp = ((u32)(0)); sp < spinloops_ || read_in_progress; sp++) {
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
					have_swapped = true;
					read_in_progress = true;
					break;
				}
				src2 = src;
			}
			bool got_im_sem = false;
			for (u32 sp = ((u32)(0)); sp < spinloops_sem_ || read_in_progress; sp++) {
				got_im_sem = sync__Semaphore_try_wait(&ch->writesem_im);
				if (got_im_sem) {
					break;
				}
			}
			for (;;) {
				if (got_im_sem) {
					got_im_sem = false;
				} else {
					sync__Semaphore_wait(&ch->writesem_im);
				}
				if (atomic_load_u16(&ch->closed) != 0) {
					if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
						sync__Semaphore_post(&ch->writesem);
						return ChanState__success;
					} else {
						return ChanState__closed;
					}
				}
				if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&src2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->writesem);
					break;
				} else {
					sync__Semaphore_post(&ch->writesem_im);
					if (src2 == ((voidptr)(-1))) {
						sync__Semaphore_post(&ch->readsem);
						return ChanState__closed;
					}
					src2 = src;
				}
			}
			return ChanState__success;
		} else {
			bool space_in_queue = false;
			u32 wr_free = atomic_load_u32(&ch->write_free);
			for (;;) {
				if (!(wr_free > 0)) break;
				space_in_queue = atomic_compare_exchange_weak_u32(&ch->write_free, &wr_free, (u32)(wr_free - 1));
				if (space_in_queue) {
					break;
				}
			}
			if (space_in_queue) {
				u32 wr_idx = atomic_load_u32(&ch->buf_elem_write_idx);
				for (;;) {
					u32 new_wr_idx = (u32)(wr_idx + 1);
					for (;;) {
						if (!(new_wr_idx >= ch->cap)) break;
						new_wr_idx -= ch->cap;
					}
					if (atomic_compare_exchange_strong_u32(&ch->buf_elem_write_idx, &wr_idx, new_wr_idx)) {
						break;
					}
				}
				u8* wr_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					wr_ptr += ((u32)(wr_idx * ch->objsize));
					status_adr += (u32)(wr_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__unused));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__writing))))) break;
					expected_status = ((u16)(sync__BufferElemStat__unused));
				}
				memcpy(wr_ptr, src, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__written)));
				atomic_fetch_add_u32(((voidptr)(&ch->read_avail)), 1);
				sync__Semaphore_post(&ch->readsem);
				sync__SpinLock_lock(ch->read_sub_mtx);
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				sync__SpinLock_unlock(ch->read_sub_mtx);
				return ChanState__success;
			} else {
				if (no_block) {
					return ChanState__not_ready;
				}
				sync__Semaphore_post(&ch->writesem);
			}
		}
	}
	builtin___v_panic(_S("unknown `try_push_priv` state"));
	VUNREACHABLE();
	return 0;
}
inline bool sync__Channel_pop(sync__Channel* ch, voidptr dest) {
	return sync__Channel_try_pop_priv(ch, dest, false) == ChanState__success;
}
inline ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest) {
	return sync__Channel_try_pop_priv(ch, dest, true);
}
VV_LOC ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block) {
	multi_return_u32_u32 mr_9469 = (no_block ? ((multi_return_u32_u32){.arg0=((u32)(1)),.arg1=((u32)(1))}) : ((multi_return_u32_u32){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	u32 spinloops_sem_ = mr_9469.arg0;
	u32 spinloops_ = mr_9469.arg1;
	bool have_swapped = false;
	bool write_in_progress = false;
	for (;;) {
		bool got_sem = false;
		if (ch->cap == 0) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			for (;;) {
				if (!(rdadr != NULL)) break;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->read_adr)), ((voidptr)(&rdadr)), ((isize)(0)))) {
					memcpy(dest, rdadr, ch->objsize);
					voidptr nulladr = ((void*)0);
					for (;;) {
						if (!(!atomic_compare_exchange_weak_ptr(((voidptr)(&ch->adr_read)), ((voidptr)(&nulladr)), ((isize)(rdadr))))) break;
						nulladr = ((void*)0);
					}
					sync__Semaphore_post(&ch->writesem_im);
					return ChanState__success;
				}
			}
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0) {
					return ChanState__not_ready;
				} else {
					return ChanState__closed;
				}
			}
		}
		for (u32 _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->readsem);
		}
		if (!got_sem) {
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0) {
					return ChanState__not_ready;
				} else {
					return ChanState__closed;
				}
			}
			sync__Semaphore_wait(&ch->readsem);
		}
		if (ch->cap > 0) {
			bool obj_in_queue = false;
			u32 rd_avail = atomic_load_u32(&ch->read_avail);
			for (;;) {
				if (!(rd_avail > 0)) break;
				obj_in_queue = atomic_compare_exchange_weak_u32(&ch->read_avail, &rd_avail, (u32)(rd_avail - 1));
				if (obj_in_queue) {
					break;
				}
			}
			if (obj_in_queue) {
				u32 rd_idx = atomic_load_u32(&ch->buf_elem_read_idx);
				for (;;) {
					u32 new_rd_idx = (u32)(rd_idx + 1);
					for (;;) {
						if (!(new_rd_idx >= ch->cap)) break;
						new_rd_idx -= ch->cap;
					}
					if (atomic_compare_exchange_weak_u32(&ch->buf_elem_read_idx, &rd_idx, new_rd_idx)) {
						break;
					}
				}
				u8* rd_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					rd_ptr += (u32)(rd_idx * ch->objsize);
					status_adr += (u32)(rd_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__written));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__reading))))) break;
					expected_status = ((u16)(sync__BufferElemStat__written));
				}
				memcpy(dest, rd_ptr, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__unused)));
				atomic_fetch_add_u32(((voidptr)(&ch->write_free)), 1);
				sync__Semaphore_post(&ch->writesem);
				sync__SpinLock_lock(ch->write_sub_mtx);
				if (ch->write_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->write_subscriber->sem);
				}
				sync__SpinLock_unlock(ch->write_sub_mtx);
				return ChanState__success;
			}
		}
		atomic_store_ptr(((voidptr*)(&ch->write_adr)), dest);
		if (ch->cap == 0) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			if (rdadr != NULL) {
				voidptr dest2 = dest;
				if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->write_adr)), ((voidptr)(&dest2)), ((isize)(0)))) {
					sync__Semaphore_post(&ch->readsem);
					continue;
				} else {
					write_in_progress = true;
				}
			}
		}
		if (ch->cap == 0 && !write_in_progress) {
			sync__SpinLock_lock(ch->write_sub_mtx);
			if (ch->write_subscriber != ((void*)0)) {
				sync__Semaphore_post(ch->write_subscriber->sem);
			}
			sync__SpinLock_unlock(ch->write_sub_mtx);
		}
		voidptr dest2 = dest;
		for (u32 sp = ((u32)(0)); sp < spinloops_ || write_in_progress; sp++) {
			if (atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&dest2)), ((isize)(0)))) {
				have_swapped = true;
				break;
			} else if (dest2 == ((voidptr)(-1))) {
				sync__Semaphore_post(&ch->readsem);
				return ChanState__closed;
			}
			dest2 = dest;
		}
		bool got_im_sem = false;
		for (u32 sp = ((u32)(0)); sp < spinloops_sem_ || write_in_progress; sp++) {
			got_im_sem = sync__Semaphore_try_wait(&ch->readsem_im);
			if (got_im_sem) {
				break;
			}
		}
		for (;;) {
			if (got_im_sem) {
				got_im_sem = false;
			} else {
				sync__Semaphore_wait(&ch->readsem_im);
			}
			if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr)(&ch->adr_written)), ((voidptr)(&dest2)), ((isize)(0)))) {
				sync__Semaphore_post(&ch->readsem);
				break;
			} else {
				sync__Semaphore_post(&ch->readsem_im);
				if (dest2 == ((voidptr)(-1))) {
					sync__Semaphore_post(&ch->readsem);
					return ChanState__closed;
				}
				dest2 = dest;
			}
		}
		break;
	}
	return ChanState__success;
}
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout) {
	Array_sync__Subscription subscr = builtin____new_array_with_default(channels->len, 0, sizeof(sync__Subscription), (voidptr)&(sync__Subscription[]){(sync__Subscription){.sem = ((void*)0),.prev = ((void*)0),.nxt = ((void*)0),}}[0]);
	sync__Semaphore *sem = HEAP(sync__Semaphore, (((sync__Semaphore){.count = 0,})));
	sync__Semaphore_init(&(*(sem)), 0);
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		(*(sync__Subscription*)builtin__array_get(subscr, i)).sem = &(*(sem));
		multi_return_ref_sync__SpinLock_ref_sync__Subscription mr_14535 = ((*(sync__Direction*)builtin__array_get(dir, i)) == sync__Direction__push ? ((multi_return_ref_sync__SpinLock_ref_sync__Subscription){.arg0=ch->write_sub_mtx,.arg1=&ch->write_subscriber}) : ((multi_return_ref_sync__SpinLock_ref_sync__Subscription){.arg0=ch->read_sub_mtx,.arg1=&ch->read_subscriber}));
		sync__SpinLock* sub_mtx = mr_14535.arg0;
		sync__Subscription** subscriber = mr_14535.arg1;
		sync__SpinLock_lock(sub_mtx);
		(*(sync__Subscription*)builtin__array_get(subscr, i)).prev = subscriber;
		{ // Unsafe block
			(*(sync__Subscription*)builtin__array_get(subscr, i)).nxt = ((sync__Subscription*)(atomic_exchange_ptr(((voidptr*)(subscriber)), &(*(sync__Subscription*)builtin__array_get(subscr, i)))));
		}
		if (((voidptr)((*(sync__Subscription*)builtin__array_get(subscr, i)).nxt)) != ((void*)0)) {
			(*(sync__Subscription*)builtin__array_get(subscr, i)).nxt->prev = &(*(sync__Subscription*)builtin__array_get(subscr, i)).nxt;
		}
		sync__SpinLock_unlock(sub_mtx);
	}
	time__StopWatch stopwatch = (timeout == _const_time__infinite || timeout <= 0 ? (((time__StopWatch){.elapsed = 0,.start = 0,.end = 0,})) : (time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}))));
	int event_idx = -1;
	outer:
	for (;;) {
		_result_int _t1 = rand__intn(channels->len);
		if (_t1.is_error) {
			*(int*) _t1.data = 0;
		}
		
 		int rnd = (*(int*)_t1.data);
		int num_closed = 0;
		for (int j = 0; j < channels->len; ++j) {
			int i = (int)(j + rnd);
			if (i >= channels->len) {
				i -= channels->len;
			}
			ChanState stat = ((*(sync__Direction*)builtin__array_get(dir, i)) == sync__Direction__push ? (sync__Channel_try_push_priv((*(sync__Channel**)builtin__array_get(*channels, i)), (*(voidptr*)builtin__array_get(*objrefs, i)), true)) : (sync__Channel_try_pop_priv((*(sync__Channel**)builtin__array_get(*channels, i)), (*(voidptr*)builtin__array_get(*objrefs, i)), true)));
			if (stat == ChanState__success) {
				event_idx = i;
				goto outer__break;
			} else if (stat == ChanState__closed) {
				num_closed++;
			}
		}
		if (num_closed == channels->len) {
			event_idx = -2;
			goto outer__break;
		}
		if (timeout <= 0) {
			goto outer__break;
		}
		if (timeout != _const_time__infinite) {
			time__Duration remaining = timeout - time__StopWatch_elapsed(stopwatch);
			if (!sync__Semaphore_timed_wait(&(*(sem)), remaining)) {
				goto outer__break;
			}
		} else {
			sync__Semaphore_wait(&(*(sem)));
		}
		outer__continue: {}
	}
	outer__break: {}
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		sync__SpinLock* sub_mtx = ((*(sync__Direction*)builtin__array_get(dir, i)) == sync__Direction__push ? (ch->write_sub_mtx) : (ch->read_sub_mtx));
		sync__SpinLock_lock(sub_mtx);
		{ // Unsafe block
			*(*(sync__Subscription*)builtin__array_get(subscr, i)).prev = (*(sync__Subscription*)builtin__array_get(subscr, i)).nxt;
		}
		if ((*(sync__Subscription*)builtin__array_get(subscr, i)).nxt != 0) {
			(*(sync__Subscription*)builtin__array_get(subscr, i)).nxt->prev = (*(sync__Subscription*)builtin__array_get(subscr, i)).prev;
			sync__Semaphore_post((*(sync__Subscription*)builtin__array_get(subscr, i)).nxt->sem);
		}
		sync__SpinLock_unlock(sub_mtx);
	}
	sync__Semaphore_destroy(&(*(sem)));
	return event_idx;
}
string sync__Mutex_str(sync__Mutex* m) {
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Mutex("), 0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_S(")"), 0, { .d_c = 0 }}}));
}
string sync__RwMutex_str(sync__RwMutex* m) {
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("RwMutex("), 0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_S(")"), 0, { .d_c = 0 }}}));
}
sync__Cond* sync__new_cond(sync__Mutex* m) {
	return ((sync__Cond*)builtin__memdup(&(sync__Cond){.mutex = m,.inner_mutex = *sync__new_mutex(),.waiters = builtin____new_array_with_default(0, 0, sizeof(chan_bool), 0),}, sizeof(sync__Cond)));
}
void sync__Cond_wait(sync__Cond* c) {
	chan_bool ch = sync__new_channel_st(1, sizeof(bool)>0 ? sizeof(bool) : 1);
	sync__Mutex_lock(&c->inner_mutex);
	builtin__array_push((array*)&c->waiters, _MOV((chan_bool[]){ ch }));
	sync__Mutex_unlock(&c->inner_mutex);
	sync__Mutex_unlock(c->mutex);
	{bool _ = __chan_bool_popval(ch);}
	;
	sync__Mutex_lock(&c->inner_mutex);
	for (int i = (int)(c->waiters.len - 1); i >= 0; i--) {
		if (((chan_bool*)c->waiters.data)[i] == ch) {
			builtin__array_delete(&c->waiters, i);
			break;
		}
	}
	sync__Mutex_unlock(&c->inner_mutex);
	sync__Mutex_lock(c->mutex);
	{ // defer begin
		sync__Channel_close(ch);
	} // defer end
}
void sync__Cond_signal(sync__Cond* c) {
	sync__Mutex_lock(&c->inner_mutex);
	if (c->waiters.len > 0) {
		chan_bool waiter = ((chan_bool*)c->waiters.data)[0];
		builtin__array_delete(&c->waiters, 0);
		if (!sync__Channel_closed(waiter)) {
			__chan_bool_pushval(waiter, true);
		}
	}
	{ // defer begin
		sync__Mutex_unlock(&c->inner_mutex);
	} // defer end
}
void sync__Cond_broadcast(sync__Cond* c) {
	sync__Mutex_lock(&c->inner_mutex);
	for (int i = 0; i < c->waiters.len; ++i) {
		chan_bool waiter = ((chan_bool*)c->waiters.data)[i];
		if (!sync__Channel_closed(waiter)) {
			__chan_bool_pushval(waiter, true);
		}
	}
	builtin__array_clear(&c->waiters);
	{ // defer begin
		sync__Mutex_unlock(&c->inner_mutex);
	} // defer end
}
sync__ManyTimes* sync__new_many_times(u64 times) {
	sync__ManyTimes* many_times = ((sync__ManyTimes*)builtin__memdup(&(sync__ManyTimes){.m = ((sync__RwMutex){E_STRUCT}),.times = times,.count = 0,}, sizeof(sync__ManyTimes)));
	sync__RwMutex_init(&many_times->m);
	return many_times;
}
void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&m->count) < m->times) {
		sync__ManyTimes_do_slow(m, (voidptr)f);
	}
}
VV_LOC void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)(void)) {
	sync__RwMutex_lock(&m->m);
	if (m->count < m->times) {
		sync__stdatomic__store_u64(&m->count, (u64)(m->count + 1));
		f();
	}
	sync__RwMutex_unlock(&m->m);
}
sync__Once* sync__new_once(void) {
	sync__Once* once = ((sync__Once*)builtin__memdup(&(sync__Once){.m = ((sync__RwMutex){E_STRUCT}),.count = 0,}, sizeof(sync__Once)));
	sync__RwMutex_init(&once->m);
	return once;
}
void sync__Once_do(sync__Once* o, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&o->count) < 1) {
		sync__Once_do_slow(o, (voidptr)f);
	}
}
VV_LOC void sync__Once_do_slow(sync__Once* o, void (*f)(void)) {
	sync__RwMutex_lock(&o->m);
	if (o->count < 1) {
		sync__stdatomic__store_u64(&o->count, 1);
		f();
	}
	sync__RwMutex_unlock(&o->m);
}
void sync__Once_do_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param) {
	if (sync__stdatomic__load_u64(&o->count) < 1) {
		sync__Once_do_slow_with_param(o, (voidptr)f, param);
	}
}
VV_LOC void sync__Once_do_slow_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param) {
	sync__RwMutex_lock(&o->m);
	if (o->count < 1) {
		sync__stdatomic__store_u64(&o->count, 1);
		f(param);
	}
	sync__RwMutex_unlock(&o->m);
}
VNORETURN VV_LOC void sync__cpanic(int res) {
	builtin___v_panic(builtin__tos_clone(((u8*)(strerror(res)))));
	VUNREACHABLE();
	while(1);
}
VV_LOC void sync__should_be_zero(int res) {
	if (res != 0) {
		sync__cpanic(res);
		VUNREACHABLE();
	}
}
sync__SpinLock* sync__new_spin_lock(void) {
	sync__SpinLock* the_lock = ((sync__SpinLock*)builtin__memdup(&(sync__SpinLock){.locked = 0,.padding = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},}, sizeof(sync__SpinLock)));
	atomic_thread_fence(memory_order_release);
	return the_lock;
}
inline void sync__SpinLock_lock(sync__SpinLock* s) {
	u8 expected = ((u8)(0));
	int spin_count = 0;
	int max_spins = 100;
	int base_delay = 100;
	int max_delay = 10000;
	for (;;) {
		if (atomic_compare_exchange_weak_byte(&s->locked, &expected, 1)) {
			atomic_thread_fence(memory_order_acquire);
			return;
		}
		spin_count++;
		if (spin_count > max_spins) {
			int exponent = builtin__int_min((int)(spin_count / max_spins), 10);
			int delay = builtin__int_min((int)(base_delay * ((1 << exponent))), max_delay);
			time__sleep(delay * _const_time__nanosecond);
		} else {
			cpu_relax();
		}
		expected = 0;
	}
}
inline bool sync__SpinLock_try_lock(sync__SpinLock* s) {
	if (atomic_load_byte(&s->locked) == 0) {
		u8 expected = ((u8)(0));
		if (atomic_compare_exchange_weak_byte(&s->locked, &expected, 1)) {
			atomic_thread_fence(memory_order_acquire);
			return true;
		}
	}
	return false;
}
inline void sync__SpinLock_unlock(sync__SpinLock* s) {
	atomic_thread_fence(memory_order_release);
	atomic_store_byte(&s->locked, 0);
}
void sync__SpinLock_destroy(sync__SpinLock* s) {
}
sync__Mutex* sync__new_mutex(void) {
	sync__Mutex* m = ((sync__Mutex*)builtin__memdup(&(sync__Mutex){E_STRUCT}, sizeof(sync__Mutex)));
	sync__Mutex_init(m);
	return m;
}
void sync__Mutex_init(sync__Mutex* m) {
	sync__should_be_zero(pthread_mutex_init(&m->mutex, NULL));
}
sync__RwMutex* sync__new_rwmutex(void) {
	sync__RwMutex* m = ((sync__RwMutex*)builtin__memdup(&(sync__RwMutex){E_STRUCT}, sizeof(sync__RwMutex)));
	sync__RwMutex_init(m);
	return m;
}
void sync__RwMutex_init(sync__RwMutex* m) {
	sync__RwMutexAttr a = ((sync__RwMutexAttr){E_STRUCT});
	sync__should_be_zero(pthread_rwlockattr_init(&a.attr));
	pthread_rwlockattr_setkind_np(&a.attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);
	sync__should_be_zero(pthread_rwlock_init(&m->mutex, &a.attr));
}
inline void sync__Mutex_lock(sync__Mutex* m) {
	pthread_mutex_lock(&m->mutex);
}
inline bool sync__Mutex_try_lock(sync__Mutex* m) {
	return pthread_mutex_trylock(&m->mutex) == 0;
}
inline void sync__Mutex_unlock(sync__Mutex* m) {
	pthread_mutex_unlock(&m->mutex);
}
void sync__Mutex_destroy(sync__Mutex* m) {
	sync__should_be_zero(pthread_mutex_destroy(&m->mutex));
}
inline void sync__RwMutex_rlock(sync__RwMutex* m) {
	pthread_rwlock_rdlock(&m->mutex);
}
inline void sync__RwMutex_lock(sync__RwMutex* m) {
	pthread_rwlock_wrlock(&m->mutex);
}
inline bool sync__RwMutex_try_rlock(sync__RwMutex* m) {
	return pthread_rwlock_tryrdlock(&m->mutex) == 0;
}
inline bool sync__RwMutex_try_wlock(sync__RwMutex* m) {
	return pthread_rwlock_trywrlock(&m->mutex) == 0;
}
void sync__RwMutex_destroy(sync__RwMutex* m) {
	sync__should_be_zero(pthread_rwlock_destroy(&m->mutex));
}
inline void sync__RwMutex_runlock(sync__RwMutex* m) {
	pthread_rwlock_unlock(&m->mutex);
}
inline void sync__RwMutex_unlock(sync__RwMutex* m) {
	pthread_rwlock_unlock(&m->mutex);
}
sync__Semaphore* sync__new_semaphore(void) {
	return sync__new_semaphore_init(0);
}
sync__Semaphore* sync__new_semaphore_init(u32 n) {
	sync__Semaphore* sem = ((sync__Semaphore*)builtin__memdup(&(sync__Semaphore){.count = 0,}, sizeof(sync__Semaphore)));
	sync__Semaphore_init(sem, n);
	return sem;
}
void sync__Semaphore_init(sync__Semaphore* sem, u32 n) {
	atomic_store_u32(&sem->count, n);
	sync__should_be_zero(pthread_mutex_init(&sem->mtx, NULL));
	sync__CondAttr attr = ((sync__CondAttr){E_STRUCT});
	sync__should_be_zero(pthread_condattr_init(&attr.attr));
	pthread_condattr_setpshared(&attr.attr, PTHREAD_PROCESS_PRIVATE);
	pthread_cond_init(&sem->cond, &attr.attr);
	pthread_condattr_destroy(&attr.attr);
}
void sync__Semaphore_post(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 1)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c + 1))) {
			return;
		}
	}
	pthread_mutex_lock(&sem->mtx);
	c = atomic_fetch_add_u32(&sem->count, 1);
	if (c == 0) {
		pthread_cond_signal(&sem->cond);
	}
	pthread_mutex_unlock(&sem->mtx);
}
void sync__Semaphore_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1))) {
			return;
		}
	}
	pthread_mutex_lock(&sem->mtx);
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0) {
			pthread_cond_wait(&sem->cond, &sem->mtx);
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1))) {
				if (c > 1) {
					pthread_cond_signal(&sem->cond);
				}
				goto outer__break;
			}
		}
		outer__continue: {}
	}
	outer__break: {}
	pthread_mutex_unlock(&sem->mtx);
}
bool sync__Semaphore_try_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1))) {
			return true;
		}
	}
	return false;
}
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1))) {
			return true;
		}
	}
	pthread_mutex_lock(&sem->mtx);
	struct timespec t_spec = time__Duration_timespec(timeout);
	int res = 0;
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0) {
			res = pthread_cond_timedwait(&sem->cond, &sem->mtx, &t_spec);
			if (res == ETIMEDOUT) {
				goto outer__break;
			}
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1))) {
				if (c > 1) {
					pthread_cond_signal(&sem->cond);
				}
				goto outer__break;
			}
		}
		outer__continue: {}
	}
	outer__break: {}
	pthread_mutex_unlock(&sem->mtx);
	return res == 0;
}
void sync__Semaphore_destroy(sync__Semaphore* sem) {
	sync__should_be_zero(pthread_cond_destroy(&sem->cond));
	sync__should_be_zero(pthread_mutex_destroy(&sem->mtx));
}
sync__WaitGroup* sync__new_waitgroup(void) {
	sync__WaitGroup *wg = HEAP(sync__WaitGroup, (((sync__WaitGroup){.task_count = 0,.wait_count = 0,.sem = ((sync__Semaphore){.count = 0,}),})));
	sync__WaitGroup_init(&(*(wg)));
	return &(*(wg));
}
void sync__WaitGroup_init(sync__WaitGroup* wg) {
	sync__Semaphore_init(&wg->sem, 0);
}
void sync__WaitGroup_add(sync__WaitGroup* wg, int delta) {
	int old_nrjobs = ((int)(atomic_fetch_add_u32(((voidptr)(&wg->task_count)), ((u32)(delta)))));
	int new_nrjobs = (int)(old_nrjobs + delta);
	u32 num_waiters = atomic_load_u32(&wg->wait_count);
	if (new_nrjobs < 0) {
		builtin___v_panic(_S("Negative number of jobs in waitgroup"));
		VUNREACHABLE();
	}
	if (new_nrjobs == 0 && num_waiters > 0) {
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u32(&wg->wait_count, &num_waiters, 0))) break;
			if (num_waiters == 0) {
				return;
			}
		}
		for (;;) {
			if (!((num_waiters > 0))) break;
			sync__Semaphore_post(&wg->sem);
			num_waiters--;
		}
	}
}
void sync__WaitGroup_done(sync__WaitGroup* wg) {
	sync__WaitGroup_add(wg, -1);
}
void sync__WaitGroup_wait(sync__WaitGroup* wg) {
	int nrjobs = ((int)(atomic_load_u32(&wg->task_count)));
	if (nrjobs == 0) {
		return;
	}
	atomic_fetch_add_u32(((voidptr)(&wg->wait_count)), 1);
	sync__Semaphore_wait(&wg->sem);
}
void sync__WaitGroup_go(sync__WaitGroup* wg, void (*f)(void)) {
	sync__WaitGroup_add(wg, 1);
	// start go
	thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731 *arg__t1 = (thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731 *) builtin___v_malloc(sizeof(thread_arg_anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731));
	arg__t1->fn = anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731;
	arg__t1->arg1 = wg;
	arg__t1->arg2 = f;
	pthread_t thread__t1;
	pthread_attr_t thread__t1_attributes;
	pthread_attr_init(&thread__t1_attributes);
	pthread_attr_setstacksize(&thread__t1_attributes, 8388608); // fn: 
	int _t1_thr_res = pthread_create(&thread__t1, &thread__t1_attributes, (void*)anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731_thread_wrapper, arg__t1);
	if (_t1_thr_res) builtin__panic_error_number(builtin__tos3("`go anon_fn_aa8c1b3ce4c55ec6_189_mut_sync__waitgroup_anon_fn__2731()`: "), _t1_thr_res);
	pthread_detach(thread__t1);
	// end go
	;
}
u64 sync__thread_id(void) {
	return ((u64)(pthread_self()));
}
_result_string v__util__resolve_d_value(Map_string_string compile_values, string str) {
	_option_int _t1 = builtin__string_index(str, _const_v__util__d_sig);
	if (_t1.state != 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("no \""), 0xfe10, {.d_s = _const_v__util__d_sig}}, {_S("...\')\" could be found in \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	int start = (*(int*)_t1.data);
	int i = 0;
	u8 ch = ((u8)('.'));
	Array_u8 bd_ident = builtin____new_array_with_default(0, 20, sizeof(u8), 0);
	int blevel = 1;
	for (i = (int)(start + _const_v__util__d_sig.len); i < str.len && ch != '\''; i++) {
		ch = builtin__string_at(str, i);
		if (ch == ')') {
			blevel--;
		} else if (ch == '(') {
			blevel++;
		}
		if (builtin__u8_is_letter(ch) || builtin__u8_is_digit(ch) || ch == '_') {
			builtin__array_push((array*)&bd_ident, _MOV((u8[]){ ch }));
		} else {
			if (!(ch == '\'')) {
				if (ch == '$') {
					return (_result_string){ .is_error=true, .err=builtin___v_error(_S("cannot use string interpolation in compile time $d() expression")), .data={E_STRUCT} };
				}
				return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("invalid `$d` identifier in \""), 0xfe10, {.d_s = str}}, {_S("\", invalid character `"), 0xfe10, {.d_s = builtin__rune_str(((rune)(ch)))}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
		}
	}
	string d_ident = builtin__string_trim_space(Array_u8_bytestr(bd_ident));
	if ((d_ident).len == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("first argument of `$d` must be a string identifier")), .data={E_STRUCT} };
	}
	for (; i < str.len; i++) {
		ch = builtin__string_at(str, i);

		if (ch == (' ') || ch == (',')) {
			continue;
		}
		else if (ch == ('\'')) {
			i++;
		}
		else {
		}
		break;
	}
	ch = '.';
	int dv_start = i;
	int dv_end = i;
	for (;;) {
		if (!(i < str.len)) break;
		ch = builtin__string_at(str, i);
		dv_end++;
		i++;

		if (ch == ('\'')) {
			break;
		}
		else if (ch == ('(')) {
			blevel++;
		}
		else if (ch == (')')) {
			blevel--;
			if (blevel <= 0) {
				break;
			}
		}
		else if (ch == ('$')) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(_S("cannot use string interpolation in compile time $d() expression")), .data={E_STRUCT} };
		}
		else {
		}
	}
	if ((int)(dv_end - dv_start) == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("second argument of `$d` must be a pure literal")), .data={E_STRUCT} };
	}
	for (; blevel > 0 && i < str.len; i++) {
		if (builtin__string_at(str, i) == ')') {
			i++;
			break;
		}
	}
	string d_default_value = builtin__string_trim_space(builtin__string_substr_ni(str, dv_start, (int)(dv_end - 1)));
	string* _t10 = (string*)(builtin__map_get_check(ADDR(map, compile_values), &(string[]){d_ident}));
	_option_string _t9 = {0};
	if (_t10) {
		*((string*)&_t9.data) = *((string*)_t10);
	} else {
		_t9.state = 2; _t9.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t9.state != 0) {
		*(string*) _t9.data = d_default_value;
	}
	
	string d_value = (*(string*)_t9.data);
	string original_expr_to_be_replaced = builtin__string_substr_ni(str, start, i);
	if (builtin__string_at(original_expr_to_be_replaced, (int)(original_expr_to_be_replaced.len - 1)) != ')') {
		builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the last character of `"), 0xfe10, {.d_s = original_expr_to_be_replaced}}, {_S("` should be `)`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	string rep = builtin__string_replace_once(str, original_expr_to_be_replaced, d_value);
	if (original_expr_to_be_replaced.len > 0 && builtin__string_contains(rep, _const_v__util__d_sig)) {
		return v__util__resolve_d_value(compile_values, rep);
	}
	_result_string _t12;
	builtin___result_ok(&(string[]) { rep }, (_result*)(&_t12), sizeof(string));
	 
	return _t12;
}
_result_string v__util__resolve_env_value(string str, bool check_for_presence) {
	string env_ident = _S("$env('");
	_option_int _t1 = builtin__string_index(str, env_ident);
	if (_t1.state != 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("no \""), 0xfe10, {.d_s = env_ident}}, {_SLIT0, 0, { .d_c = 0 }}})), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("...\')\" could be found in \""), 0xfe10, {.d_s = str}}, {_S("\"."), 0, { .d_c = 0 }}})))), .data={E_STRUCT} };
	}
	
 	int at = (*(int*)_t1.data);
	u8 ch = ((u8)('.'));
	Array_u8 benv_lit = builtin____new_array_with_default(0, 20, sizeof(u8), 0);
	for (int i = (int)(at + env_ident.len); i < str.len && ch != ')'; i++) {
		ch = ((u8)(builtin__string_at(str, i)));
		if (builtin__u8_is_letter(ch) || builtin__u8_is_digit(ch) || ch == '_') {
			builtin__array_push((array*)&benv_lit, _MOV((u8[]){ ch }));
		} else {
			if (!(ch == '\'' || ch == ')')) {
				if (ch == '$') {
					return (_result_string){ .is_error=true, .err=builtin___v_error(_S("cannot use string interpolation in compile time $env() expression")), .data={E_STRUCT} };
				}
				return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("invalid environment variable name in \""), 0xfe10, {.d_s = str}}, {_S("\", invalid character \""), 0xfe10, {.d_s = builtin__rune_str(((rune)(ch)))}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
		}
	}
	string env_lit = Array_u8_bytestr(benv_lit);
	if ((env_lit).len == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("supply an env variable name like HOME, PATH or USER")), .data={E_STRUCT} };
	}
	string env_value = _S("");
	if (check_for_presence) {
		string* _t8 = (string*)(builtin__map_get_check(ADDR(map, os__environ()), &(string[]){env_lit}));
		_option_string _t7 = {0};
		if (_t8) {
			*((string*)&_t7.data) = *((string*)_t8);
		} else {
			_t7.state = 2; _t7.err = builtin___v_error(_S("map key does not exist"));
		}
		;
		if (_t7.state != 0) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the environment variable \""), 0xfe10, {.d_s = env_lit}}, {_S("\" does not exist."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		
		env_value = (*(string*)_t7.data);
		if ((env_value).len == 0) {
			return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the environment variable \""), 0xfe10, {.d_s = env_lit}}, {_S("\" is empty."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else {
		env_value = os__getenv(env_lit);
	}
	string rep = builtin__string_replace_once(str, builtin__string__plus(builtin__string__plus(builtin__string__plus(env_ident, env_lit), _S("'")), _S(")")), env_value);
	if (builtin__string_contains(rep, env_ident)) {
		return v__util__resolve_env_value(rep, check_for_presence);
	}
	_result_string _t12;
	builtin___result_ok(&(string[]) { rep }, (_result*)(&_t12), sizeof(string));
	 
	return _t12;
}
v__util__EManager* v__util__new_error_manager(void) {
	return ((v__util__EManager*)builtin__memdup(&(v__util__EManager){.support_color = term__can_show_color_on_stderr() && term__can_show_color_on_stdout(),}, sizeof(v__util__EManager)));
}
void v__util__EManager_set_support_color(v__util__EManager* e, bool b) {
	{ // Unsafe block
		v__util__EManager* me = e;
		me->support_color = b;
	}
}
string v__util__bold(string msg) {
	if (!_const_v__util__emanager->support_color) {
		return msg;
	}
	return term__bold(msg);
}
string v__util__color(string kind, string msg) {
	if (!_const_v__util__emanager->support_color) {
		return msg;
	}
	if (builtin__string_contains(kind, _S("error"))) {
		return term__red(msg);
	}
	if (builtin__string_contains(kind, _S("notice"))) {
		return term__yellow(msg);
	}
	if (builtin__string_contains(kind, _S("details"))) {
		return term__bright_blue(msg);
	}
	return term__magenta(msg);
}
string v__util__path_styled_for_error_messages(string path) {
	string rpath = os__real_path(path);
	rpath = builtin__string_replace(rpath, _S("\\"), _S("/"));
	if (_const_v__util__verror_paths_absolute) {
		return rpath;
	}
	if (builtin__string_starts_with(rpath, _const_v__util__normalised_workdir)) {
		rpath = builtin__string_replace_once(rpath, _const_v__util__normalised_workdir, _S(""));
	}
	return rpath;
}
string v__util__formatted_error(string kind, string omsg, string filepath, v__token__Pos pos) {
	string emsg = builtin__string_replace(omsg, _S("main."), _S(""));
	string path = v__util__path_styled_for_error_messages(filepath);
	string position = ((filepath).len != 0 ? (builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = path}}, {_S(":"), 0xfe07, {.d_i32 = (int)(pos.line_nr + 1)}}, {_S(":"), 0xfe07, {.d_i32 = builtin__int_max(1, (u16)(pos.col + 1))}}, {_S(":"), 0, { .d_c = 0 }}}))) : (_S("")));
	string scontext = Array_string_join(v__util__source_file_context(kind, filepath, pos), _S("\n"));
	string final_position = v__util__bold(position);
	string final_kind = v__util__bold(v__util__color(kind, kind));
	string final_msg = emsg;
	string final_context = (scontext.len > 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\n"), 0xfe10, {.d_s = scontext}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_S("")));
	return builtin__string_trim_space(builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = final_position}}, {_S(" "), 0xfe10, {.d_s = final_kind}}, {_S(" "), 0xfe10, {.d_s = final_msg}}, {_SLIT0, 0xfe10, {.d_s = final_context}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
Array_string v__util__cached_file2sourcelines(string path) {
	Array_string* _t2 = (Array_string*)(builtin__map_get_check(ADDR(map, lines_cache->lines), &(string[]){path}));
	_option_Array_string _t1 = {0};
	if (_t2) {
		*((Array_string*)&_t1.data) = *((Array_string*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		Array_string res = (*(Array_string*)_t1.data);
		return res;
	}
	_result_string _t4 = v__util__read_file(path);
	if (_t4.is_error) {
		*(string*) _t4.data = _S("");
	}
	
 	string source = (*(string*)_t4.data);
	Array_string res = v__util__set_source_for_path(path, source);
	return res;
}
Array_string v__util__set_source_for_path(string path, string source) {
	Array_string lines = builtin__string_split_into_lines(source);
	(*(Array_string*)builtin__map_get_and_set((map*)&lines_cache->lines, &(string[]){path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = lines;
	return lines;
}
Array_string v__util__source_file_context(string kind, string filepath, v__token__Pos pos) {
	Array_string clines = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_string source_lines = v__util__cached_file2sourcelines(filepath);
	if (source_lines.len == 0) {
		return clines;
	}
	int bline = builtin__int_max(0, (int)(pos.line_nr - 2));
	int aline = builtin__int_max(0, builtin__int_min((int)(source_lines.len - 1), (int)(pos.line_nr + 2)));
	string tab_spaces = _S("    ");
	for (int iline = bline; iline <= aline; iline++) {
		string* _t3 = (string*)(builtin__array_get_with_check(source_lines, iline));
		_option_string _t2 = {0};
		if (_t3) {
			*((string*)&_t2.data) = *((string*)_t3);
		} else {
			_t2.state = 2; _t2.err = builtin___v_error(_S("array index out of range"));
		}
		;
		if (_t2.state != 0) {
			*(string*) _t2.data = _S("");
		}
		
		string sline = (*(string*)_t2.data);
		int start_column = builtin__int_max(0, builtin__int_min(pos.col, sline.len));
		int end_column = builtin__int_max(0, builtin__int_min((int)(pos.col + builtin__int_max(0, pos.len)), sline.len));
		string cline = (iline == pos.line_nr ? (builtin__string__plus(builtin__string__plus(builtin__string_substr(sline, 0, start_column), v__util__color(kind, builtin__string_substr(sline, start_column, end_column))), builtin__string_substr(sline, end_column, 2147483647))) : (sline));
		builtin__array_push((array*)&clines, _MOV((string[]){ builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xafe27, {.d_i32 = (int)(iline + 1)}}, {_S(" | "), 0, { .d_c = 0 }}})), builtin__string_replace(cline, _S("\t"), tab_spaces)) }));
		if (iline == pos.line_nr) {
			strings__Builder pointerline_builder = strings__new_builder(sline.len);
			for (int i = 0; i < start_column; ) {
				if (builtin__u8_is_space(builtin__string_at(sline, i))) {
					strings__Builder_write_u8(&pointerline_builder, builtin__string_at(sline, i));
					i++;
				} else {
					int char_len = builtin__utf8_char_len(builtin__string_at(sline, i));
					string spaces = builtin__string_repeat(_S(" "), builtin__utf8_str_visible_length(builtin__string_substr_ni(sline, i, (int)(i + char_len))));
					strings__Builder_write_string(&pointerline_builder, spaces);
					i += char_len;
				}
			}
			int underline_len = builtin__utf8_str_visible_length(builtin__string_substr(sline, start_column, end_column));
			string underline = (underline_len > 1 ? (builtin__string_repeat(_S("~"), underline_len)) : (_S("^")));
			strings__Builder_write_string(&pointerline_builder, v__util__bold(v__util__color(kind, underline)));
			builtin__array_push((array*)&clines, _MOV((string[]){ builtin__string__plus(_S("      | "), builtin__string_replace(strings__Builder_str(&pointerline_builder), _S("\t"), tab_spaces)) }));
		}
	}
	return clines;
}
VNORETURN void v__util__verror(string kind, string s) {
	string final_kind = v__util__bold(v__util__color(kind, kind));
	builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = final_kind}}, {_S(": "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	builtin___v_exit(1);
	VUNREACHABLE();
	while(1);
}
string v__util__vlines_escape_path(string path, string ccompiler) {
	return v__util__cescaped_path(os__real_path(path));
}
void v__util__show_compiler_message(string kind, v__errors__CompilerMessage err) {
	string ferror = v__util__formatted_error(kind, err.message, err.file_path, err.pos);
	builtin__eprintln(ferror);
	if (err.details.len > 0) {
		builtin__eprintln(builtin__string__plus(v__util__bold(_S("Details: ")), v__util__color(_S("details"), err.details)));
	}
	if (err.call_stack.len > 0) {
		for (int _t1 = 0; _t1 < err.call_stack.len; ++_t1) {
			v__errors__CallStackItem item = ((v__errors__CallStackItem*)err.call_stack.data)[_t1];
			string caller_path = v__util__path_styled_for_error_messages(item.file_path);
			builtin__eprintln(builtin__string__plus(v__util__bold(_S("called from")), builtin__str_intp(4, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = caller_path}}, {_S(":"), 0xfe07, {.d_i32 = (int)(item.pos.line_nr + 1)}}, {_S(":"), 0xfe07, {.d_i32 = builtin__int_max(1, (u16)(item.pos.col + 1))}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			string scontext = Array_string_join(v__util__source_file_context(kind, item.file_path, item.pos), _S("\n"));
			if (scontext.len > 0) {
				builtin__eprintln(scontext);
			}
		}
	}
}
void v__util__print_json_errors(Array_v__util__JsonError errs) {
	builtin__eprintln(_S("["));
	for (int i = 0; i < errs.len; ++i) {
		v__util__JsonError e = ((v__util__JsonError*)errs.data)[i];
		string msg = builtin__string_replace(builtin__string_replace(e.message, _S("\""), _S("\\\"")), _S("\n"), _S("\\n"));
		builtin__eprintln(builtin__str_intp(6, _MOV((StrIntpData[]){{_S("{\n\"path\":\""), 0xfe10, {.d_s = e.path}}, {_S("\",\n\"message\":\""), 0xfe10, {.d_s = msg}}, {_S("\",\n\"line_nr\":"), 0xfe07, {.d_i32 = e.line_nr}}, {_S(",\n\"col\":"), 0xfe07, {.d_i32 = e.col}}, {_S(",\n\"len\":"), 0xfe07, {.d_i32 = e.len}}, {_S("\n}"), 0, { .d_c = 0 }}})));
		if (i < (int)(errs.len - 1)) {
			builtin__eprintln(_S(","));
		}
	}
	builtin__eprintln(_S("]"));
}
string v__util__qualify_import(v__pref__Preferences* pref_, string mod, string file_path) {
	Array_string mod_paths = builtin__array_clone_to_depth(&pref_->lookup_path, 1);
	_PUSH_MANY(&mod_paths, (os__vmodules_paths()), _t1, Array_string);
	string mod_path = builtin__string_replace(mod, _S("."), _const_os__path_separator);
	for (int _t2 = 0; _t2 < mod_paths.len; ++_t2) {
		string search_path = ((string*)mod_paths.data)[_t2];
		string try_path = os__join_path_single(search_path, mod_path);
		if (os__is_dir(try_path)) {
			_result_string _t3;
			if (_t3 = v__util__mod_path_to_full_name(pref_, mod, try_path), !_t3.is_error) {
				string m1 = *(string*)_t3.data;
				;
				return m1;
			}
		}
	}
	_result_string _t5;
	if (_t5 = v__util__mod_path_to_full_name(pref_, mod, file_path), !_t5.is_error) {
		string m1 = *(string*)_t5.data;
		;
		return m1;
	}
	;
	return mod;
}
string v__util__qualify_module(v__pref__Preferences* pref_, string mod, string file_path) {
	if (_SLIT_EQ(mod.str, mod.len, "main")) {
		;
		return mod;
	}
	string clean_file_path = builtin__string_all_before_last(file_path, _const_os__path_separator);
	if (builtin__string__eq(builtin__string_replace(clean_file_path, builtin__string__plus(os__getwd(), _S("/")), _S("")), mod)) {
		;
		return mod;
	}
	_result_string _t3;
	if (_t3 = v__util__mod_path_to_full_name(pref_, mod, clean_file_path), !_t3.is_error) {
		string m1 = *(string*)_t3.data;
		;
		return m1;
	}
	;
	return mod;
}
VV_LOC _result_string v__util__mod_path_to_full_name(v__pref__Preferences* pref_, string mod, string path) {
	Array_string vmod_folders = builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("vlib"), _S(".vmodules"), _S("modules")}));
	Array_string _t1 = {0};
	Array_string _t1_orig = pref_->lookup_path;
	int _t1_len = _t1_orig.len;
	_t1 = builtin____new_array(0, _t1_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
		string it = ((string*) _t1_orig.data)[_t3];
		string _t2 = os__base(it);
		builtin__array_push((array*)&_t1, &_t2);
	}
	Array_string bases =_t1;
	for (int _t4 = 0; _t4 < bases.len; ++_t4) {
		string base = ((string*)bases.data)[_t4];
		if (!(Array_string_contains(vmod_folders, base))) {
			builtin__array_push((array*)&vmod_folders, _MOV((string[]){ builtin__string_clone(base) }));
		}
	}
	bool in_vmod_path = false;
	Array_string parts = builtin__string_split(path, _const_os__path_separator);
	for (int _t6 = 0; _t6 < vmod_folders.len; ++_t6) {
		string vmod_folder = ((string*)vmod_folders.data)[_t6];
		if ((Array_string_contains(parts, vmod_folder))) {
			in_vmod_path = true;
			break;
		}
	}
	Array_string path_parts = builtin__string_split(path, _const_os__path_separator);
	string mod_path = builtin__string_replace(mod, _S("."), _const_os__path_separator);
	for (int i = (int)(path_parts.len - 1); i > 0; i--) {
		string try_path = os__join_path_single(Array_string_join(builtin__array_slice(path_parts, 0, i), _const_os__path_separator), mod_path);
		if (os__is_dir(try_path)) {
			if (in_vmod_path) {
				for (int j = i; j >= 0; j--) {
					string path_part = (*(string*)builtin__array_get(path_parts, j));
					if ((Array_string_contains(vmod_folders, path_part))) {
						string mod_full_name = Array_string_join(builtin__array_slice(builtin__string_split(try_path, _const_os__path_separator), (int)(j + 1), 2147483647), _S("."));
						_result_string _t7;
						builtin___result_ok(&(string[]) { mod_full_name }, (_result*)(&_t7), sizeof(string));
						 
						return _t7;
					}
				}
			} else {
				Array_string try_path_parts = builtin__string_split(try_path, _const_os__path_separator);
				int last_v_mod = -1;
				for (int j = try_path_parts.len; j > 0; j--) {
					string parent = Array_string_join(builtin__array_slice(try_path_parts, 0, j), _const_os__path_separator);
					_result_Array_string _t8;
					if (_t8 = os__ls(parent), !_t8.is_error) {
						Array_string ls = *(Array_string*)_t8.data;
						if ((Array_string_contains(ls, _S("v.mod"))) && (try_path_parts.len > i && !builtin__string__eq((*(string*)builtin__array_get(try_path_parts, i)), _S("v")) && !(Array_string_contains(ls, _S("vlib"))))) {
							last_v_mod = j;
						}
						continue;
					}
					break;
				}
				if (last_v_mod > -1) {
					string mod_full_name = Array_string_join(builtin__array_slice(try_path_parts, last_v_mod, 2147483647), _S("."));
					_result_string _t10; /* if prepend */
					if (mod_full_name.len < mod.len) {
						builtin___result_ok(&(string[]) { mod }, (_result*)(&_t10), sizeof(string));
						goto _t11;
					};
					{
						builtin___result_ok(&(string[]) { mod_full_name }, (_result*)(&_t10), sizeof(string));
					}
	_t11: {};
										return _t10;
				}
			}
		}
	}
	if (os__is_abs_path(pref_->path) && os__is_abs_path(path) && os__is_dir(path)) {
		string rel_mod_path = builtin__string_replace(path, builtin__string__plus(builtin__string_all_before_last(pref_->path, _const_os__path_separator), _S("/")), _S(""));
		if (!builtin__string__eq(rel_mod_path, path)) {
			string full_mod_name = builtin__string_replace(rel_mod_path, _const_os__path_separator, _S("."));
			_result_string _t12;
			builtin___result_ok(&(string[]) { full_mod_name }, (_result*)(&_t12), sizeof(string));
			 
			return _t12;
		}
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(_S("module not found")), .data={E_STRUCT} };
}
string v__util__smart_quote(string str, bool raw) {
	int len = str.len;
	if (len == 0) {
		return _S("");
	}
	if (len < 256) {
		bool is_pure = true;
		for (int i = 0; i < len; i++) {
			u8 ch = ((u8)(str.str[ i]));
			if ((ch >= 37 && ch <= 90) || (ch >= 95 && ch <= 126) || (ch == ' ' || ch == '!' || ch == '#' || ch == '[' || ch == ']')) {
				continue;
			}
			is_pure = false;
			break;
		}
		if (is_pure) {
			return str;
		}
	}
	strings__Builder result = strings__new_builder((int)(len + 10));
	int pos = -1;
	u8 last = ((u8)(0));
	u8 current = ((u8)(0));
	u8 next = ((u8)(0));
	bool skip_next = false;
	for (;;) {
		pos++;
		if (skip_next) {
			skip_next = false;
			pos++;
		}
		if (pos >= len) {
			break;
		}
		last = current;
		current = str.str[ pos];
		if ((int)(pos + 1) < len) {
			next = str.str[ (int)(pos + 1)];
		} else {
			next = 0;
		}
		if (current == 34) {
			current = 0;
			strings__Builder_write_u8(&result, _const_v__util__backslash);
			strings__Builder_write_u8(&result, _const_v__util__double_quote);
			continue;
		}
		if (current == 92) {
			if (raw) {
				strings__Builder_write_string(&result, _const_v__util__double_escape);
				continue;
			}
			if (next == 92) {
				current = 0;
				skip_next = true;
				strings__Builder_write_string(&result, _const_v__util__double_escape);
				continue;
			}
			if (next != 0) {
				if (raw) {
					skip_next = true;
					strings__Builder_write_string(&result, _const_v__util__double_escape);
					continue;
				}
				if ((Array_u8_contains(_const_v__util__invalid_escapes, next))) {
					current = 0;
					skip_next = true;
					strings__Builder_write_u8(&result, next);
					continue;
				}
				skip_next = true;
				strings__Builder_write_u8(&result, current);
				strings__Builder_write_u8(&result, next);
				current = 0;
				continue;
			}
		}
		if (current == 10) {
			current = 0;
			strings__Builder_write_u8(&result, _const_v__util__backslash);
			strings__Builder_write_u8(&result, 'n');
			continue;
		}
		if (current == 13 && next == 10) {
			strings__Builder_write_u8(&result, current);
			strings__Builder_write_u8(&result, next);
			current = 0;
			skip_next = true;
			continue;
		}
		if (next == 0 && current == 92) {
			continue;
		}
		if (!raw) {
			if (current == '$') {
				if (last == 92) {
					strings__Builder_write_u8(&result, last);
					strings__Builder_write_u8(&result, current);
					continue;
				}
			}
		}
		strings__Builder_write_u8(&result, current);
	}
	return strings__Builder_str(&result);
}
VV_LOC _v_Array_fixed_bool_256 v__util__get_non_white_space_table(void) {
	Array_fixed_bool_256 bytes = {0};
	for (int c = 0; c < 256; ++c) {
		bytes[c] = !builtin__u8_is_space(((u8)(c)));
	}
	_v_Array_fixed_bool_256 _t1 = {0};
	memcpy(_t1.ret_arr, bytes, sizeof(Array_fixed_bool_256));
	return _t1;
}
VV_LOC _v_Array_fixed_bool_256 v__util__get_name_char_table(void) {
	Array_fixed_bool_256 res = {0};
	for (int c = 0; c < 256; ++c) {
		res[c] = builtin__u8_is_letter(((u8)(c))) || c == '_';
	}
	_v_Array_fixed_bool_256 _t1 = {0};
	memcpy(_t1.ret_arr, res, sizeof(Array_fixed_bool_256));
	return _t1;
}
VV_LOC _v_Array_fixed_bool_256 v__util__get_func_char_table(void) {
	Array_fixed_bool_256 res = {0};
	for (int c = 0; c < 256; ++c) {
		res[c] = builtin__u8_is_letter(((u8)(c))) || builtin__u8_is_digit(((u8)(c))) || c == '_';
	}
	_v_Array_fixed_bool_256 _t1 = {0};
	memcpy(_t1.ret_arr, res, sizeof(Array_fixed_bool_256));
	return _t1;
}
inline bool v__util__is_name_char(u8 c) {
	return _const_v__util__name_char_table[c];
}
inline bool v__util__is_func_char(u8 c) {
	return _const_v__util__func_char_table[c];
}
bool v__util__contains_capital(string s) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 c = s.str[_t1];
		if (builtin__u8_is_capital(c)) {
			return true;
		}
	}
	return false;
}
bool v__util__good_type_name(string s) {
	if (s.len < 4) {
		return true;
	}
	for (int i = 2; i < s.len; ++i) {
		if (builtin__u8_is_capital(s.str[ i]) && builtin__u8_is_capital(s.str[ (int_literal)(i - 1)]) && builtin__u8_is_capital(s.str[ (int_literal)(i - 2)])) {
			return false;
		}
	}
	return true;
}
inline bool v__util__is_generic_type_name(string name) {
	return name.len == 1 && name.str[ 0] != 'C' && (name.str[ 0] >= 'A' && name.str[ 0] <= 'Z');
}
string v__util__cescaped_path(string s) {
	return builtin__string_replace(s, _S("\\"), _S("\\\\"));
}
v__util__Suggestion v__util__new_suggestion(string wanted, Array_string possibilities, v__util__SuggestionParams params) {
	v__util__Suggestion s = ((v__util__Suggestion){.known = builtin____new_array(0, 0, sizeof(v__util__Possibility)),.wanted = wanted,.swanted = v__util__short_module_name(wanted),.similarity_threshold = params.similarity_threshold,.similarity_fn = (voidptr)params.similarity_fn,});
	v__util__Suggestion_add_many(&s, possibilities);
	v__util__Suggestion_sort(&s);
	return s;
}
void v__util__Suggestion_add(v__util__Suggestion* s, string val) {
	if (s->known.len >= _const_v__util__max_suggestions_limit) {
		return;
	}
	if (builtin__string__eq(val, s->wanted) || builtin__string__eq(val, s->swanted)) {
		return;
	}
	string sval = v__util__short_module_name(val);
	if (builtin__string__eq(sval, s->wanted) || builtin__string__eq(sval, s->swanted)) {
		return;
	}
	f32 similarity = (f32)(((f32)(((int)((f32)(s->similarity_fn(s->swanted, sval) * 1000))))) / 1000);
	builtin__array_push((array*)&s->known, _MOV((v__util__Possibility[]){ ((v__util__Possibility){.value = val,.svalue = sval,.similarity = similarity,}) }));
}
void v__util__Suggestion_add_many(v__util__Suggestion* s, Array_string many) {
	for (int _t1 = 0; _t1 < many.len; ++_t1) {
		string x = ((string*)many.data)[_t1];
		v__util__Suggestion_add(s, x);
	}
}
void v__util__Suggestion_sort(v__util__Suggestion* s) {
	if (s->known.len > 0) { qsort(s->known.data, s->known.len, s->known.element_size, (voidptr)compare_5516636134126562804_v__util__Possibility_by_similarity); }
	;
}
string v__util__Suggestion_say(v__util__Suggestion s, string msg) {
	string res = msg;
	bool found = false;
	if (s.known.len > 0) {
		v__util__Possibility top_possibility = (*(v__util__Possibility*)builtin__array_last(s.known));
		if (top_possibility.similarity > s.similarity_threshold) {
			string val = top_possibility.value;
			if (!builtin__string_starts_with(val, _S("[]"))) {
				res = builtin__string__plus(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(".\nDid you mean `"), 0xfe10, {.d_s = v__util__highlight_suggestion(val)}}, {_S("`?"), 0, { .d_c = 0 }}})));
				found = true;
			}
		}
	}
	if (!found) {
		if (s.known.len > 0) {
			Array_string _t1 = {0};
			Array_v__util__Possibility _t1_orig = s.known;
			int _t1_len = _t1_orig.len;
			_t1 = builtin____new_array(0, _t1_len, sizeof(string));

			for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
				v__util__Possibility it = ((v__util__Possibility*) _t1_orig.data)[_t3];
				string _t2 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = v__util__highlight_suggestion(it.svalue)}}, {_S("`"), 0, { .d_c = 0 }}}));
				builtin__array_push((array*)&_t1, &_t2);
			}
			Array_string values =_t1;
			if (values.len > 0) { qsort(values.data, values.len, values.element_size, (voidptr)compare_5516636134126562804_string); }
			;
			if (values.len == 1) {
				res = builtin__string__plus(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(".\n1 possibility: "), 0xfe10, {.d_s = (*(string*)builtin__array_get(values, 0))}}, {_S("."), 0, { .d_c = 0 }}})));
			} else if (values.len < 25) {
				res = builtin__string__plus(res, builtin__string__plus(builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(".\n"), 0xfe07, {.d_i32 = values.len}}, {_S(" possibilities: "), 0, { .d_c = 0 }}})), Array_string_join(values, _S(", "))), _S(".")));
			}
		}
	}
	return res;
}
string v__util__short_module_name(string name) {
	if (!builtin__string_contains(name, _S("."))) {
		return name;
	}
	Array_string vals = builtin__string_split(name, _S("."));
	if (vals.len < 2) {
		return name;
	}
	string mname = (*(string*)builtin__array_get(vals, (int)(vals.len - 2)));
	string symname = (*(string*)builtin__array_last(vals));
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mname}}, {_S("."), 0xfe10, {.d_s = symname}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string v__util__highlight_suggestion(string message) {
	return term__ecolorize((voidptr)term__bright_blue, message);
}
v__util__Surrounder v__util__new_surrounder(int expected_length) {
	return ((v__util__Surrounder){.befores = builtin____new_array_with_default(0, expected_length, sizeof(string), 0),.afters = builtin____new_array_with_default(0, expected_length, sizeof(string), 0),});
}
void v__util__Surrounder_add(v__util__Surrounder* s, string before, string after) {
	builtin__array_push((array*)&s->befores, _MOV((string[]){ builtin__string_clone(before) }));
	builtin__array_push((array*)&s->afters, _MOV((string[]){ builtin__string_clone(after) }));
}
string v__util__Surrounder_before(v__util__Surrounder* s) {
	int len = s->befores.len;
	if (len > 0) {
		strings__Builder res = strings__new_builder((int)(len * 100));
		for (int i = 0; i < len; i++) {
			string x = (*(string*)builtin__array_get(s->befores, i));
			if (x.len > 0) {
				strings__Builder_writeln(&res, x);
			}
		}
		string ret = strings__Builder_str(&res);
		string _t1 = ret;
			{ // defer begin
				strings__Builder_free(&res);
			} // defer end
		return _t1;
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	}
	string _t2 = _S("");
	return _t2;
}
string v__util__Surrounder_after(v__util__Surrounder* s) {
	int len = s->afters.len;
	if (len > 0) {
		strings__Builder res = strings__new_builder((int)(len * 100));
		for (int i = (int)(len - 1); i >= 0; i--) {
			string x = (*(string*)builtin__array_get(s->afters, i));
			if (x.len > 0) {
				strings__Builder_writeln(&res, x);
			}
		}
		string ret = strings__Builder_str(&res);
		string _t1 = ret;
			{ // defer begin
				strings__Builder_free(&res);
			} // defer end
		return _t1;
		{ // defer begin
			strings__Builder_free(&res);
		} // defer end
	}
	string _t2 = _S("");
	return _t2;
}
void v__util__Surrounder_builder_write_befores(v__util__Surrounder* s, strings__Builder* sb) {
	int len = s->befores.len;
	if (len > 0) {
		for (int i = 0; i < len; i++) {
			string x = (*(string*)builtin__array_get(s->befores, i));
			if (x.len > 0) {
				strings__Builder_writeln(sb, x);
			}
		}
	}
}
void v__util__Surrounder_builder_write_afters(v__util__Surrounder* s, strings__Builder* sb) {
	int len = s->afters.len;
	if (len > 0) {
		for (int i = (int)(len - 1); i >= 0; i--) {
			string x = (*(string*)builtin__array_get(s->afters, i));
			if (x.len > 0) {
				strings__Builder_writeln(sb, x);
			}
		}
	}
}
void v__util__Surrounder_free(v__util__Surrounder* s) {
	{ // Unsafe block
		Array_string_free(&s->befores);
		Array_string_free(&s->afters);
	}
}
v__util__Timers* v__util__new_timers(v__util__TimerParams params) {
	return ((v__util__Timers*)builtin__memdup(&(v__util__Timers){.label = params.label,.swatches = (__shared__Map_string_time__StopWatch*)__dup_shared_map(&(__shared__Map_string_time__StopWatch){.mtx = {0}, .val =
	builtin__new_map(sizeof(string), sizeof(time__StopWatch), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	}, sizeof(__shared__Map_string_time__StopWatch))
	,.should_print = params.should_print,.already_shown = builtin____new_array_with_default(0, 100, sizeof(string), 0),}, sizeof(v__util__Timers)));
}
v__util__Timers* v__util__get_timers(void) {
	return g_timers;
}
void v__util__timing_start(string label) {
	v__util__Timers* t = v__util__get_timers();
	v__util__Timers_start(t, label);
}
void v__util__timing_measure(string label) {
	v__util__Timers_show(g_timers, label);
}
void v__util__timing_measure_cumulative(string label) {
	v__util__Timers_measure_cumulative(g_timers, label);
}
void v__util__timing_set_should_print(bool should_print) {
	g_timers->should_print = should_print;
}
void v__util__Timers_start(v__util__Timers* t, string name) {
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, name);
	if (_t1.state != 0) {
		*(time__StopWatch*) _t1.data = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}));
	}
	
 	time__StopWatch sw = (*(time__StopWatch*)_t1.data);
	time__StopWatch_start(&sw);
	v__util__Timers_tsafe_set_sw(t, name, sw);
}
i64 v__util__Timers_measure(v__util__Timers* t, string name) {
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, name);
	if (_t1.state != 0) {
		Array_string timer_keys = v__util__Timers_tsafe_get_keys(t);
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("> Timer `"), 0xfe10, {.d_s = name}}, {_S("` was NOT started."), 0, { .d_c = 0 }}})));
		builtin__eprintln(_S(">   Available timers:"));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(">   "), 0xfe10, {.d_s = Array_string_str(timer_keys)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		*(time__StopWatch*) _t1.data = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}));
	}
	
 	time__StopWatch sw = (*(time__StopWatch*)_t1.data);
	i64 ms = time__Duration_microseconds(time__StopWatch_elapsed(sw));
	time__StopWatch_pause(&sw);
	v__util__Timers_tsafe_set_sw(t, name, sw);
	return ms;
}
i64 v__util__Timers_measure_cumulative(v__util__Timers* t, string name) {
	i64 ms = v__util__Timers_measure(t, name);
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, name);
	if (_t1.state != 0) {
		return ms;
	}
	
 	time__StopWatch sw = (*(time__StopWatch*)_t1.data);
	time__StopWatch_pause(&sw);
	v__util__Timers_tsafe_set_sw(t, name, sw);
	return ms;
}
void v__util__Timers_measure_pause(v__util__Timers* t, string name) {
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, name);
	if (_t1.state != 0) {
		return;
	}
	
 	time__StopWatch sw = (*(time__StopWatch*)_t1.data);
	time__StopWatch_pause(&sw);
	v__util__Timers_tsafe_set_sw(t, name, sw);
}
void v__util__Timers_measure_resume(v__util__Timers* t, string name) {
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, name);
	if (_t1.state != 0) {
		return;
	}
	
 	time__StopWatch sw = (*(time__StopWatch*)_t1.data);
	time__StopWatch_start(&sw);
	v__util__Timers_tsafe_set_sw(t, name, sw);
}
string v__util__Timers_message(v__util__Timers* t, string name) {
	f64 ms = (f64)(((f64)(v__util__Timers_measure(t, name))) / ((f64)(1000.0)));
	string value = v__util__bold(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x10060d, {.d_f64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}})));
	string formatted_message = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = value}}, {_S(" ms "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return formatted_message;
}
void v__util__Timers_show(v__util__Timers* t, string label) {
	if (v_memory_panic) {
		return;
	}
	if (t->should_print) {
		string formatted_message = v__util__Timers_message(t, label);
		builtin__println(formatted_message);
	}
	builtin__array_push((array*)&t->already_shown, _MOV((string[]){ builtin__string_clone(label) }));
}
void v__util__Timers_show_if_exists(v__util__Timers* t, string label) {
	_option_time__StopWatch _t1 = v__util__Timers_tsafe_get_sw(t, label);
	if (_t1.state != 0) {
		return;
	}
	
 ;
	v__util__Timers_show(t, label);
	builtin__array_push((array*)&t->already_shown, _MOV((string[]){ builtin__string_clone(label) }));
}
void v__util__Timers_show_remaining(v__util__Timers* t) {
	Array_string keys = v__util__Timers_tsafe_get_keys(t);
	for (int _t1 = 0; _t1 < keys.len; ++_t1) {
		string k = ((string*)keys.data)[_t1];
		if ((Array_string_contains(t->already_shown, k))) {
			continue;
		}
		v__util__Timers_show(t, k);
	}
}
void v__util__Timers_dump_all(v__util__Timers* t) {
	Array_string keys = v__util__Timers_tsafe_get_keys(t);
	for (int _t1 = 0; _t1 < keys.len; ++_t1) {
		string k = ((string*)keys.data)[_t1];
		string elapsed = v__util__Timers_message(t, k);
		builtin__println(elapsed);
	}
}
VV_LOC Array_string v__util__Timers_tsafe_get_keys(v__util__Timers* t) {
Array_string _t1;
	sync__RwMutex_rlock(&t->swatches->mtx);
	/*lock*/ {
		_t1 = builtin__map_keys(&t->swatches->val);
	;
	}
	sync__RwMutex_runlock(&t->swatches->mtx);
		Array_string keys = _t1;
	return keys;
}
VV_LOC void v__util__Timers_tsafe_set_sw(v__util__Timers* t, string name, time__StopWatch sw) {
	sync__RwMutex_lock(&t->swatches->mtx);
	/*lock*/ {
		(*(time__StopWatch*)builtin__map_get_and_set((map*)&t->swatches->val, &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) = sw;
	}
	sync__RwMutex_unlock(&t->swatches->mtx);;
}
VV_LOC _option_time__StopWatch v__util__Timers_tsafe_get_sw(v__util__Timers* t, string name) {
	sync__RwMutex_rlock(&t->swatches->mtx);
	/*lock*/ {
		if (!_IN_MAP(ADDR(string, name), ADDR(map, t->swatches->val))) {
			_option_time__StopWatch _t1 = (_option_time__StopWatch){ .state=2, .err=_const_none__, .data={E_STRUCT} };
			sync__RwMutex_runlock(&t->swatches->mtx);return _t1;
		}
		_option_time__StopWatch _t2;
		builtin___option_ok(&(time__StopWatch[]) { (*(time__StopWatch*)builtin__map_get(ADDR(map, t->swatches->val), &(string[]){name}, &(time__StopWatch[]){ (time__StopWatch){.elapsed = 0,.start = 0,.end = 0,} })) }, (_option*)(&_t2), sizeof(time__StopWatch));
		 
		sync__RwMutex_runlock(&t->swatches->mtx);return _t2;
	}
	sync__RwMutex_runlock(&t->swatches->mtx);;
	return (_option_time__StopWatch){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
string v__util__skip_bom(string file_content) {
	string raw_text = file_content;
	if (raw_text.len >= 3) {
		{ // Unsafe block
			u8* c_text = raw_text.str;
			if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
				int offset_from_begin = 3;
				raw_text = builtin__tos((voidptr)&c_text[offset_from_begin], (int)(builtin__vstrlen(c_text) - offset_from_begin));
			}
		}
	}
	return raw_text;
}
bool v__util__module_is_builtin(string mod) {
	return (Array_string_contains(_const_v__util__builtin_module_parts, mod));
}
string v__util__tabs(int n) {
	return (n >= 0 && n < 11 ? (_const_v__util__const_tabs[n]) : (builtin__string_repeat(_S("\t"), n)));
}
time__Time v__util__get_build_time(void) {
	string sde = os__getenv(_S("SOURCE_DATE_EPOCH"));
	if ((sde).len == 0) {
		return time__utc();
	}
	return time__unix_nanosecond(builtin__string_i64(sde), 0);
}
void v__util__set_vroot_folder(string vroot_path) {
	string vexe = os__getenv(_S("VEXE"));
	if ((vexe).len == 0) {
		string vname = (builtin__string__eq(os__user_os(), _S("windows")) ? (_S("v.exe")) : (_S("v")));
		os__setenv(_S("VEXE"), os__real_path(os__join_path_single(vroot_path, vname)), true);
	}
	os__setenv(_S("VCHILD"), _S("true"), true);
}
inline bool v__util__is_escape_sequence(u8 c) {
	return (c == 'x' || c == 'u' || c == 'e' || c == 'n' || c == 'r' || c == 't' || c == 'v' || c == 'a' || c == 'f' || c == 'b' || c == '\\' || c == '`' || c == '$' || c == '@' || c == '?' || c == '{' || c == '}' || c == '\'' || c == '"' || c == 'U');
}
VNORETURN void v__util__launch_tool(bool is_verbose, string tool_name, Array_string args) {
	string vexe = v__pref__vexe_path();
	string vroot = os__dir(vexe);
	v__util__set_vroot_folder(vroot);
	string tool_args = v__util__args_quote_paths(args);
	string tools_folder = os__join_path(vroot, builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("cmd"), _S("tools")})));
	string tool_basename = os__real_path(os__join_path_single(tools_folder, tool_name));
	string tool_exe = _S("");
	string tool_source = _S("");
	if (os__is_dir(tool_basename)) {
		tool_exe = v__util__path_of_executable(os__join_path_single(tool_basename, os__file_name(tool_name)));
		tool_source = tool_basename;
	} else {
		tool_exe = v__util__path_of_executable(tool_basename);
		tool_source = builtin__string__plus(tool_basename, _S(".v"));
	}
	if (is_verbose) {
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool vexe        : "), 0xfe10, {.d_s = vexe}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool vroot       : "), 0xfe10, {.d_s = vroot}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool tool_source : "), 0xfe10, {.d_s = tool_source}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool tool_exe    : "), 0xfe10, {.d_s = tool_exe}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool tool_args   : "), 0xfe10, {.d_s = tool_args}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	string disabling_file = v__util__recompilation__disabling_file(vroot);
	bool is_recompilation_disabled = os__exists(disabling_file);
	bool should_compile = !is_recompilation_disabled && v__util__should_recompile_tool(vexe, tool_source, tool_name, tool_exe);
	if (is_verbose) {
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("launch_tool should_compile: "), 0xfe10, {.d_s = should_compile ? _S("true") : _S("false")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if (should_compile) {
		Array_string emodules = (*(Array_string*)builtin__map_get(ADDR(map, _const_v__util__external_module_dependencies_for_tool), &(string[]){tool_name}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) }));
		for (int _t1 = 0; _t1 < emodules.len; ++_t1) {
			string emodule = ((string*)emodules.data)[_t1];
			_result_bool _t2 = v__util__check_module_is_installed(emodule, is_verbose, false);
			if (_t2.is_error) {
				IError err = _t2.err;
				builtin___v_panic(builtin__IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
		}
		string compilation_command = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" "), 0, { .d_c = 0 }}}));
		if (_SLIT_EQ(tool_name.str, tool_name.len, "vself") || _SLIT_EQ(tool_name.str, tool_name.len, "vup") || _SLIT_EQ(tool_name.str, tool_name.len, "vdoctor") || _SLIT_EQ(tool_name.str, tool_name.len, "vsymlink")) {
			compilation_command = builtin__string__plus(compilation_command, _S(" -g "));
		}
		if (_SLIT_EQ(tool_name.str, tool_name.len, "vfmt")) {
			compilation_command = builtin__string__plus(compilation_command, _S(" -d vfmt "));
		}
		compilation_command = builtin__string__plus(compilation_command, os__quoted_path(tool_source));
		if (is_verbose) {
			builtin__println(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Compiling "), 0xfe10, {.d_s = tool_name}}, {_S(" with: \""), 0xfe10, {.d_s = compilation_command}}, {_S("\""), 0, { .d_c = 0 }}})));
		}
		string current_work_dir = os__getwd();
		;
		string lockfile = builtin__string__plus(tool_exe, _S(".lock"));
		;
		os__filelock__FileLock l = os__filelock__new(lockfile);
		if (os__filelock__FileLock_try_acquire(&l)) {
			;
			_option_string _t3 = os__getenv_opt(_S("VUTIL_RETRY_MAX_COUNT"));
			if (_t3.state != 0) {
				*(string*) _t3.data = _S("7");
			}
			
 			int tool_recompile_retry_max_count = builtin__int_max(1, builtin__string_int((*(string*)_t3.data)));
			for (int i = 0; i < tool_recompile_retry_max_count; ++i) {
				;
				_result_void _t4 = os__chdir(vroot);
				(void)_t4;
 ;
				time__StopWatch compile_sw = time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}));
				os__Result tool_compilation = os__execute(compilation_command);
				_result_void _t5 = os__chdir(current_work_dir);
				(void)_t5;
 ;
				;
				if (tool_compilation.exit_code == 0) {
					break;
				} else {
					if (_SLIT_EQ(tool_name.str, tool_name.len, "vup")) {
						builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Cannot recompile the new version of `vup`: "), 0xfe07, {.d_i32 = tool_compilation.exit_code}}, {_S("\n"), 0xfe10, {.d_s = tool_compilation.output}}, {_SLIT0, 0, { .d_c = 0 }}})));
						if (os__exists(tool_exe)) {
							builtin__eprintln(_S("Trying an already existing old version of the `vup` tool instead..."));
							break;
						} else {
							builtin__eprintln(_S("Failed compilation of the `vup` tool, using the new V source code."));
							builtin__eprintln(_S("The new source code, is likely to be unsupported, by your existing older V executable."));
							builtin__eprintln(_S("Try running `make` or `make.bat` manually."));
							builtin__eprintln(_S("If that fails, clone V from source in a new folder, and run `make` or `make.bat` manually again there."));
							os__filelock__FileLock_release(&l);
							builtin___v_exit(1);
							VUNREACHABLE();
						}
					}
					if (i == (int)(tool_recompile_retry_max_count - 1)) {
						builtin__eprintln(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("cannot compile `"), 0xfe10, {.d_s = tool_source}}, {_S("`: "), 0xfe07, {.d_i32 = tool_compilation.exit_code}}, {_S("\n"), 0xfe10, {.d_s = tool_compilation.output}}, {_SLIT0, 0, { .d_c = 0 }}})));
						os__filelock__FileLock_release(&l);
						builtin___v_exit(1);
						VUNREACHABLE();
					}
				}
				_result_int _t6 = rand__intn(40);
				if (_t6.is_error) {
					*(int*) _t6.data = 0;
				}
				
 				time__sleep(((int)(20 + (*(int*)_t6.data))) * _const_time__millisecond);
			}
			;
			os__filelock__FileLock_release(&l);
			;
		} else {
			;
			if (os__filelock__FileLock_wait_acquire(&l, 10 * _const_time__second)) {
				;
				os__filelock__FileLock_release(&l);
			} else {
				;
			}
			_result_int _t7 = rand__intn(40);
			if (_t7.is_error) {
				*(int*) _t7.data = 0;
			}
			
 			time__sleep(((int)(50 + (*(int*)_t7.data))) * _const_time__millisecond);
			;
		}
	}
	;
	#if defined(_WIN32)
	{
	}
	#elif defined(_VJS)
	{
	}
	#else
	{
		_result_void _t9 = os__execvp(tool_exe, args);
		if (_t9.is_error) {
			IError err = _t9.err;
			builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("> error while executing: "), 0xfe10, {.d_s = tool_exe}}, {_S(" "), 0xfe10, {.d_s = Array_string_str(args)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			builtin___v_panic(builtin__IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	#endif
	builtin___v_exit(2);
	VUNREACHABLE();
	while(1);
}
bool v__util__should_recompile_tool(string vexe, string tool_source, string tool_name, string tool_exe) {
	if (os__is_dir(tool_source)) {
		Array_string source_files = os__walk_ext(tool_source, _S(".v"), ((os__WalkParams){.hidden = 0,}));
		string newest_sfile = _S("");
		i64 newest_sfile_mtime = ((i64)(0));
		for (int _t1 = 0; _t1 < source_files.len; ++_t1) {
			string sfile = ((string*)source_files.data)[_t1];
			i64 mtime = os__file_last_mod_unix(sfile);
			if (mtime > newest_sfile_mtime) {
				newest_sfile_mtime = mtime;
				newest_sfile = sfile;
			}
		}
		bool single_file_recompile = v__util__should_recompile_tool(vexe, newest_sfile, tool_name, tool_exe);
		return single_file_recompile;
	}
	bool should_compile = false;
	if (!os__exists(tool_exe)) {
		should_compile = true;
	} else {
		i64 mtime_vexe = os__file_last_mod_unix(vexe);
		i64 mtime_tool_exe = os__file_last_mod_unix(tool_exe);
		i64 mtime_tool_source = os__file_last_mod_unix(tool_source);
		if (mtime_tool_exe <= mtime_vexe) {
			should_compile = true;
			if (_SLIT_EQ(tool_name.str, tool_name.len, "vself") || _SLIT_EQ(tool_name.str, tool_name.len, "vup")) {
				should_compile = false;
			}
		}
		if (mtime_tool_exe <= mtime_tool_source) {
			should_compile = true;
		}
		if (mtime_vexe < 1024 && mtime_tool_exe < 1024) {
			should_compile = false;
		}
	}
	return should_compile;
}
VV_LOC multi_return_string_string v__util__tool_source2name_and_exe(string tool_source) {
	string sfolder = os__dir(tool_source);
	string tool_name = builtin__string_replace(os__base(tool_source), _S(".v"), _S(""));
	string tool_exe = os__join_path_single(sfolder, v__util__path_of_executable(tool_name));
	return (multi_return_string_string){.arg0=tool_name, .arg1=tool_exe};
}
string v__util__quote_path(string s) {
	return os__quoted_path(s);
}
string v__util__args_quote_paths(Array_string args) {
	Array_string _t2 = {0};
	Array_string _t2_orig = args;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
		string it = ((string*) _t2_orig.data)[_t4];
		string _t3 = v__util__quote_path(it);
		builtin__array_push((array*)&_t2, &_t3);
	}
	return Array_string_join( _t2, _S(" "));
}
string v__util__path_of_executable(string path) {
	return path;
}
_result_string v__util__cached_read_source_file(string path) {
	static v__util__SourceCache* cache = ((v__util__SourceCache*)(((void*)0)));
	if (cache == ((void*)0)) {
		cache = ((v__util__SourceCache*)builtin__memdup(&(v__util__SourceCache){.sources = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}, sizeof(v__util__SourceCache)));
	}
	if ((path).len == 0) {
		builtin__map_free(&cache->sources);
		builtin___v_free(cache);
		cache = ((v__util__SourceCache*)(((void*)0)));
		return (_result_string){ .is_error=true, .err=builtin___v_error(_S("memory source file cache cleared")), .data={E_STRUCT} };
	}
	string* _t3 = (string*)(builtin__map_get_check(ADDR(map, cache->sources), &(string[]){path}));
	_option_string _t2 = {0};
	if (_t3) {
		*((string*)&_t2.data) = *((string*)_t3);
	} else {
		_t2.state = 2; _t2.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t2.state == 0) {
		string res = (*(string*)_t2.data);
		_result_string _t4;
		builtin___result_ok(&(string[]) { res }, (_result*)(&_t4), sizeof(string));
		 
		return _t4;
	}
	_result_string _t5 = os__read_file(path);
	if (_t5.is_error) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("failed to open "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 	string raw_text = (*(string*)_t5.data);
	string res = v__util__skip_bom(raw_text);
	builtin__map_set(&cache->sources, &(string[]){path}, &(string[]) { res });
	_result_string _t7;
	builtin___result_ok(&(string[]) { res }, (_result*)(&_t7), sizeof(string));
	 
	return _t7;
}
string v__util__replace_op(string s) {
	return ((_SLIT_EQ(s.str, s.len, "+"))? (_S("_plus")) : (_SLIT_EQ(s.str, s.len, "-"))? (_S("_minus")) : (_SLIT_EQ(s.str, s.len, "*"))? (_S("_mult")) : (_SLIT_EQ(s.str, s.len, "/"))? (_S("_div")) : (_SLIT_EQ(s.str, s.len, "%"))? (_S("_mod")) : (_SLIT_EQ(s.str, s.len, "<"))? (_S("_lt")) : (_SLIT_EQ(s.str, s.len, ">"))? (_S("_gt")) : (_SLIT_EQ(s.str, s.len, "=="))? (_S("_eq")) : (_S("")));
}
Array_string v__util__join_env_vflags_and_os_args(void) {
	return v__util__vflags__join_env_vflags_and_os_args();
}
_result_bool v__util__check_module_is_installed(string modulename, bool is_verbose, bool need_update) {
	string mpath = os__join_path_single(os__vmodules_dir(), modulename);
	string mod_v_file = os__join_path_single(mpath, _S("v.mod"));
	string murl = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("https://github.com/vlang/"), 0xfe10, {.d_s = modulename}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (is_verbose) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("check_module_is_installed: mpath: "), 0xfe10, {.d_s = mpath}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("check_module_is_installed: mod_v_file: "), 0xfe10, {.d_s = mod_v_file}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("check_module_is_installed: murl: "), 0xfe10, {.d_s = murl}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	string vexe = v__pref__vexe_path();
	if (os__exists(mod_v_file)) {
		if (need_update) {
			string update_cmd = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" update '"), 0xfe10, {.d_s = modulename}}, {_S("'"), 0, { .d_c = 0 }}}));
			if (is_verbose) {
				builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("check_module_is_installed: updating with "), 0xfe10, {.d_s = update_cmd}}, {_S(" ..."), 0, { .d_c = 0 }}})));
			}
			os__Result update_res = os__execute(update_cmd);
			if (update_res.exit_code < 0) {
				return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("can not start "), 0xfe10, {.d_s = update_cmd}}, {_S(", error: "), 0xfe10, {.d_s = update_res.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			if (update_res.exit_code != 0) {
				builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Warning: `"), 0xfe10, {.d_s = modulename}}, {_S("` exists, but is not updated.\nV will continue, since updates can fail due to temporary network problems,\nand the existing module `"), 0xfe10, {.d_s = modulename}}, {_S("` may still work."), 0, { .d_c = 0 }}})));
				if (is_verbose) {
					builtin__eprintln(_S("Details:"));
					builtin__eprintln(update_res.output);
				}
				builtin__eprintln(builtin__string_repeat(_S("-"), 50));
			}
		}
		_result_bool _t2;
		builtin___result_ok(&(bool[]) { true }, (_result*)(&_t2), sizeof(bool));
		 
		return _t2;
	}
	if (is_verbose) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("check_module_is_installed: cloning from "), 0xfe10, {.d_s = murl}}, {_S(" ..."), 0, { .d_c = 0 }}})));
	}
	os__Result cloning_res = os__execute(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" retry -- git clone "), 0xfe10, {.d_s = os__quoted_path(murl)}}, {_S(" "), 0xfe10, {.d_s = os__quoted_path(mpath)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (cloning_res.exit_code != 0) {
		return (_result_bool){ .is_error=true, .err=builtin__error_with_code(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cloning failed, details: "), 0xfe10, {.d_s = cloning_res.output}}, {_SLIT0, 0, { .d_c = 0 }}})), cloning_res.exit_code), .data={E_STRUCT} };
	}
	if (!os__exists(mod_v_file)) {
		return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("even after cloning, "), 0xfe10, {.d_s = mod_v_file}}, {_S(" is still missing"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	if (is_verbose) {
		builtin__eprintln(_S("check_module_is_installed: done"));
	}
	_result_bool _t5;
	builtin___result_ok(&(bool[]) { true }, (_result*)(&_t5), sizeof(bool));
	 
	return _t5;
}
void v__util__ensure_modules_for_all_tools_are_installed(bool is_verbose) {
	int _t2 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = _const_v__util__external_module_dependencies_for_tool.key_values.len - _t2;
		_t2 = _const_v__util__external_module_dependencies_for_tool.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1)) {continue;}
		string tool_name = *(string*)builtin__DenseArray_key(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1);
		tool_name = builtin__string_clone(tool_name);
		Array_string tool_modules = (*(Array_string*)builtin__DenseArray_value(&_const_v__util__external_module_dependencies_for_tool.key_values, _t1));
		if (is_verbose) {
			builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Installing modules for tool: "), 0xfe10, {.d_s = tool_name}}, {_S(" ..."), 0, { .d_c = 0 }}})));
		}
		for (int _t4 = 0; _t4 < tool_modules.len; ++_t4) {
			string emodule = ((string*)tool_modules.data)[_t4];
			_result_bool _t5 = v__util__check_module_is_installed(emodule, is_verbose, false);
			if (_t5.is_error) {
				IError err = _t5.err;
				builtin___v_panic(builtin__IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
		}
	}
}
inline string v__util__strip_mod_name(string name) {
	_option_int _t1;
	if (_t1 = builtin__string_index(name, _S("[")), _t1.state == 0) {
		int bracket_pos = *(int*)_t1.data;
		string prefix = builtin__string_substr(name, 0, bracket_pos);
		string suffix = builtin__string_substr(name, bracket_pos, 2147483647);
		string result = builtin__string__plus(builtin__string_all_after_last(prefix, _S(".")), _S("["));
		string params = builtin__string_substr(suffix, 1, (int)(suffix.len - 1));
		Array_string param_parts = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		Array_string _t2 = builtin__string_split(params, _S(", "));
		for (int _t3 = 0; _t3 < _t2.len; ++_t3) {
			string param = ((string*)_t2.data)[_t3];
			builtin__array_push((array*)&param_parts, _MOV((string[]){ builtin__string_all_after_last(param, _S(".")) }));
		}
		result = builtin__string__plus(result, Array_string_join(param_parts, _S(", ")));
		result = builtin__string__plus(result, _S("]"));
		return result;
	}
	return builtin__string_all_after_last(name, _S("."));
}
inline string v__util__strip_main_name(string name) {
	return builtin__string_replace(name, _S("main."), _S(""));
}
inline string v__util__no_dots(string s) {
	return builtin__string_replace(s, _S("."), _S("__"));
}
string v__util__no_cur_mod(string __v_typename, string cur_mod) {
	string res = __v_typename;
	string mod_prefix = builtin__string__plus(cur_mod, _S("."));
	bool has_map_prefix = builtin__string_starts_with(res, _const_v__util__map_prefix);
	if (has_map_prefix) {
		res = builtin__string_replace_once(res, _const_v__util__map_prefix, _S(""));
	}
	string no_symbols = builtin__string_trim_left(res, _S("&[]"));
	bool should_shorten = builtin__string_starts_with(no_symbols, mod_prefix);
	if (should_shorten) {
		res = builtin__string_replace_once(res, mod_prefix, _S(""));
	}
	if (has_map_prefix) {
		res = builtin__string__plus(_S("map[string]"), res);
	}
	return res;
}
void v__util__prepare_tool_when_needed(string source_name) {
	string vexe = os__getenv(_S("VEXE"));
	string vroot = os__dir(vexe);
	string stool = os__join_path(vroot, builtin__new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_S("cmd"), _S("tools"), source_name})));
	multi_return_string_string mr_18046 = v__util__tool_source2name_and_exe(stool);
	string tool_name = mr_18046.arg0;
	string tool_exe = mr_18046.arg1;
	if (v__util__should_recompile_tool(vexe, stool, tool_name, tool_exe)) {
		_result_int _t1 = rand__intn(20);
		if (_t1.is_error) {
			*(int*) _t1.data = 0;
		}
		
 		time__sleep(((int)(1001 + (*(int*)_t1.data))) * _const_time__millisecond);
		v__util__recompile_file(vexe, stool);
	}
}
void v__util__recompile_file(string vexe, string file) {
	string cmd = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = os__quoted_path(vexe)}}, {_S(" "), 0xfe10, {.d_s = os__quoted_path(file)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	int recompile_result = os__system(cmd);
	if (recompile_result != 0) {
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("could not recompile "), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})));
		builtin___v_exit(2);
		VUNREACHABLE();
	}
}
string v__util__get_vtmp_folder(void) {
	return os__vtmp_dir();
}
bool v__util__should_bundle_module(string mod) {
	return (Array_fixed_string_9_contains(_const_v__util__bundle_modules, mod)) || (builtin__string_contains(mod, _S(".")) && (Array_fixed_string_9_contains(_const_v__util__bundle_modules, builtin__string_all_before(mod, _S(".")))));
}
_result_Array_string v__util__find_all_v_files(Array_string roots) {
	Array_string files = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < roots.len; ++_t1) {
		string file = ((string*)roots.data)[_t1];
		if (os__is_dir(file)) {
			_PUSH_MANY(&files, (os__walk_ext(file, _S(".v"), ((os__WalkParams){.hidden = 0,}))), _t2, Array_string);
			_PUSH_MANY(&files, (os__walk_ext(file, _S(".vsh"), ((os__WalkParams){.hidden = 0,}))), _t3, Array_string);
			continue;
		}
		if (!builtin__string_ends_with(file, _S(".v")) && !builtin__string_ends_with(file, _S(".vv")) && !builtin__string_ends_with(file, _S(".vsh"))) {
			return (_result_Array_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("v fmt can only be used on .v files.\nOffending file: \""), 0xfe10, {.d_s = file}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		if (!os__exists(file)) {
			return (_result_Array_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\""), 0xfe10, {.d_s = file}}, {_S("\" does not exist"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		builtin__array_push((array*)&files, _MOV((string[]){ builtin__string_clone(file) }));
	}
	_result_Array_string _t7;
	builtin___result_ok(&(Array_string[]) { files }, (_result*)(&_t7), sizeof(Array_string));
	 
	return _t7;
}
void v__util__free_caches(void) {
	{ // Unsafe block
		v__util__cached_file2sourcelines(_S(""));
		_result_string _t1 = v__util__cached_read_source_file(_S(""));
		if (_t1.is_error) {
			*(string*) _t1.data = _S("");
		}
		
 ;
	}
}
_result_string v__util__read_file(string file_path) {
	return v__util__cached_read_source_file(file_path);
}
_result_string v__util__resolve_vmodroot(string str, string dir) {
	v__vmod__ModFileCacher* mcache = v__vmod__get_cache();
	v__vmod__ModFileAndFolder vmod_file_location = v__vmod__ModFileCacher_get_by_folder(mcache, dir);
	if (vmod_file_location.vmod_file.len == 0) {
		return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("To use @VMODROOT, you need to have a \"v.mod\" file in "), 0xfe10, {.d_s = dir}}, {_S(", or in one of its parent folders."), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	string vmod_path = vmod_file_location.vmod_folder;
	_result_string _t2;
	builtin___result_ok(&(string[]) { builtin__string_replace(str, _S("@VMODROOT"), os__real_path(vmod_path)) }, (_result*)(&_t2), sizeof(string));
	 
	return _t2;
}
string v__ast__ComptimeType_str(v__ast__ComptimeType cty) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (cty.kind) {
		case v__ast__ComptimeTypeKind__unknown: {
			_t2 = _S("$unknown");
			break;
		}
		case v__ast__ComptimeTypeKind__map: {
			_t2 = _S("$map");
			break;
		}
		case v__ast__ComptimeTypeKind__int: {
			_t2 = _S("$int");
			break;
		}
		case v__ast__ComptimeTypeKind__float: {
			_t2 = _S("$float");
			break;
		}
		case v__ast__ComptimeTypeKind__struct: {
			_t2 = _S("$struct");
			break;
		}
		case v__ast__ComptimeTypeKind__iface: {
			_t2 = _S("$interface");
			break;
		}
		case v__ast__ComptimeTypeKind__array: {
			_t2 = _S("$array");
			break;
		}
		case v__ast__ComptimeTypeKind__array_dynamic: {
			_t2 = _S("$array_dynamic");
			break;
		}
		case v__ast__ComptimeTypeKind__array_fixed: {
			_t2 = _S("$array_fixed");
			break;
		}
		case v__ast__ComptimeTypeKind__sum_type: {
			_t2 = _S("$sumtype");
			break;
		}
		case v__ast__ComptimeTypeKind__enum: {
			_t2 = _S("$enum");
			break;
		}
		case v__ast__ComptimeTypeKind__alias: {
			_t2 = _S("$alias");
			break;
		}
		case v__ast__ComptimeTypeKind__function: {
			_t2 = _S("$function");
			break;
		}
		case v__ast__ComptimeTypeKind__option: {
			_t2 = _S("$option");
			break;
		}
		case v__ast__ComptimeTypeKind__shared: {
			_t2 = _S("$shared");
			break;
		}
		case v__ast__ComptimeTypeKind__string: {
			_t2 = _S("$string");
			break;
		}
		case v__ast__ComptimeTypeKind__pointer: {
			_t2 = _S("$pointer");
			break;
		}
		case v__ast__ComptimeTypeKind__voidptr: {
			_t2 = _S("$voidptr");
			break;
		}
	}
	return _t2;
}
_option_v__ast__Ident v__ast__SelectorExpr_root_ident(v__ast__SelectorExpr* e) {
	v__ast__Expr root = e->expr;
	for (;;) {
		if (!((root)._typ == 302 /* v.ast.SelectorExpr */)) break;
		root = (*root._v__ast__SelectorExpr).expr;
	}
	if ((root)._typ == 281 /* v.ast.Ident */) {
		_option_v__ast__Ident _t1;
		builtin___option_ok(&(v__ast__Ident[]) { (*root._v__ast__Ident) }, (_option*)(&_t1), sizeof(v__ast__Ident));
		 
		return _t1;
	}
	return (_option_v__ast__Ident){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__StructField_equals(v__ast__StructField* f, v__ast__StructField* o) {
	return builtin__string__eq(f->name, o->name) && f->typ == o->typ && f->is_pub == o->is_pub && f->is_global == o->is_global;
}
v__ast__FnDecl v__ast__FnDecl_new_method_with_receiver_type(v__ast__FnDecl* f, v__ast__Type new_type_) {
	v__ast__Type new_type = (v__ast__Type_is_ptr((*(v__ast__Param*)builtin__array_get(f->params, 0)).typ) && !v__ast__Type_is_ptr(new_type_) ? (v__ast__Type_ref(new_type_)) : (new_type_));
	{ // Unsafe block
		v__ast__FnDecl* new_method = f;
		new_method->params = builtin__array_clone_to_depth(&f->params, 0);
		for (int i = 1; i < new_method->params.len; ++i) {
			if ((*(v__ast__Param*)builtin__array_get(new_method->params, i)).typ == (*(v__ast__Param*)builtin__array_get(new_method->params, 0)).typ) {
				(*(v__ast__Param*)builtin__array_get(new_method->params, i)).typ = new_type;
			}
		}
		(*(v__ast__Param*)builtin__array_get(new_method->params, 0)).typ = new_type;
		return *new_method;
	}
	return (v__ast__FnDecl){.receiver = (v__ast__StructField){.anon_struct_decl = (v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.option_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,},.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.static_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.method_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.body_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.return_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.end_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,};
}
VV_LOC bool v__ast__Fn_method_equals(v__ast__Fn* f, v__ast__Fn* o) {
	return Array_v__ast__Param_equals(builtin__array_slice(f->params, 1, 2147483647), builtin__array_slice(o->params, 1, 2147483647)) && f->return_type == o->return_type && f->is_variadic == o->is_variadic && f->language == o->language && Array_string_arr_eq(f->generic_names, o->generic_names) && f->is_pub == o->is_pub && builtin__string__eq(f->mod, o->mod) && builtin__string__eq(f->name, o->name);
}
string v__ast__Param_specifier(v__ast__Param* p) {
	bool _t2 = true;
	return ((_t2 == (p->is_shared))? (_S("shared")) : (_t2 == (p->is_atomic))? (_S("atomic")) : (_t2 == (p->is_mut))? (_S("mut")) : (_S("")));
}
v__ast__Fn v__ast__Fn_new_method_with_receiver_type(v__ast__Fn* f, v__ast__Type new_type_) {
	v__ast__Type new_type = (v__ast__Type_is_ptr((*(v__ast__Param*)builtin__array_get(f->params, 0)).typ) && !v__ast__Type_is_ptr(new_type_) ? (v__ast__Type_ref(new_type_)) : (new_type_));
	{ // Unsafe block
		v__ast__Fn* new_method = f;
		new_method->params = builtin__array_clone_to_depth(&f->params, 0);
		for (int i = 1; i < new_method->params.len; ++i) {
			if ((*(v__ast__Param*)builtin__array_get(new_method->params, i)).typ == (*(v__ast__Param*)builtin__array_get(new_method->params, 0)).typ) {
				(*(v__ast__Param*)builtin__array_get(new_method->params, i)).typ = new_type;
			}
		}
		new_method->from_embedded_type = (f->from_embedded_type != 0 ? (f->from_embedded_type) : ((*(v__ast__Param*)builtin__array_get(f->params, 0)).typ));
		(*(v__ast__Param*)builtin__array_get(new_method->params, 0)).typ = new_type;
		return *new_method;
	}
	return (v__ast__Fn){.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.dep_names = builtin____new_array(0, 0, sizeof(string)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.file = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.return_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.receiver_type = 0,.usages = 0,.return_type = 0,.from_embedded_type = 0,.ctdefine_idx = 0,.file_mode = 0,.language = 0,.is_expand_simple_interpolation = 0,.is_c_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_must_use = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.is_static_type_method = 0,.no_body = 0,.is_file_translated = 0,.is_conditional = 0,.is_variadic = 0,};
}
VV_LOC bool v__ast__Param_equals(v__ast__Param* p, v__ast__Param* o) {
	return builtin__string__eq(p->name, o->name) && p->is_mut == o->is_mut && p->typ == o->typ && p->is_hidden == o->is_hidden;
}
VV_LOC bool Array_v__ast__Param_equals(Array_v__ast__Param p, Array_v__ast__Param o) {
	if (p.len != o.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (!v__ast__Param_equals(&(*(v__ast__Param*)builtin__array_get(p, i)), (voidptr)&(*(v__ast__Param*)builtin__array_get(o, i)))) {
			return false;
		}
	}
	return true;
}
void v__ast__File_free(v__ast__File* f) {
	{ // Unsafe block
		builtin__string_free(&f->path);
		builtin__string_free(&f->path_base);
		v__ast__Scope_free(f->scope);
		builtin__array_free(&f->stmts);
		builtin__array_free(&f->imports);
		Array_string_free(&f->auto_imports);
		builtin__array_free(&f->embedded_files);
		builtin__map_free(&f->imported_symbols);
		builtin__array_free(&f->errors);
		builtin__array_free(&f->warnings);
		builtin__array_free(&f->notices);
		Array_string_free(&f->global_labels);
	}
}
string v__ast__Ident_full_name(v__ast__Ident* i) {
	if ((i->full_name).len != 0) {
		return i->full_name;
	}
	if (builtin__string_contains(i->name, _S("."))) {
		i->full_name = i->name;
	} else {
		i->full_name = builtin__string__plus(builtin__string__plus(i->mod, _S(".")), i->name);
	}
	return i->full_name;
}
inline bool v__ast__Ident_is_auto_heap(v__ast__Ident* i) {
	return ((i->obj._typ == 341 /* v.ast.Var */)? ((*i->obj._v__ast__Var).is_auto_heap) : (false));
}
inline bool v__ast__Ident_is_mut(v__ast__Ident* i) {
	if (i->obj._typ == 341 /* v.ast.Var */) {
		return (*i->obj._v__ast__Var).is_mut;
	}
	else if (i->obj._typ == 339 /* v.ast.ConstField */) {
		return false;
	}
	else if (i->obj._typ == 337 /* v.ast.EmptyScopeObject */) {
		return false;
	}
	else if (i->obj._typ == 338 /* v.ast.AsmRegister */) {
		return true;
	}
	else if (i->obj._typ == 340 /* v.ast.GlobalField */) {
		return true;
	}
	
	return 0;
}
v__ast__IdentVar v__ast__Ident_var_info(v__ast__Ident* i) {
	if (i->info._typ == 408 /* v.ast.IdentVar */) {
		return (*i->info._v__ast__IdentVar);
	}
	
	else {
		builtin___v_panic(_S("Ident.var_info(): info is not IdentVar variant"));
		VUNREACHABLE();
	}
	
	return (v__ast__IdentVar){.typ = 0,.share = 0,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_option = 0,};
}
_result_void v__ast__ComptimeCall_resolve_compile_value(v__ast__ComptimeCall* cc, Map_string_string compile_values) {
	if (cc->is_d_resolved) {
		return (_result_void){0};
	}
	if (cc->kind != v__ast__ComptimeCallKind__d) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("ComptimeCall is not $d()")), .data={E_STRUCT} };
	}
	v__ast__CallArg* _t3 = (v__ast__CallArg*)(builtin__array_get_with_check(cc->args, 0));
	_option_v__ast__CallArg _t2 = {0};
	if (_t3) {
		*((v__ast__CallArg*)&_t2.data) = *((v__ast__CallArg*)_t3);
	} else {
		_t2.state = 2; _t2.err = builtin___v_error(_S("array index out of range"));
	}
	;
	if (_t2.state != 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("$d() takes two arguments, a string and a primitive literal")), .data={E_STRUCT} };
	}
	
	v__ast__CallArg arg = (*(v__ast__CallArg*)_t2.data);
	if (!v__ast__Expr_is_pure_literal(arg.expr)) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("$d() values can only be pure literals")), .data={E_STRUCT} };
	}
	v__ast__Type typ = v__ast__Expr_get_pure_type(arg.expr);
	string arg_as_string = builtin__string_trim(v__ast__CallArg_str(arg), _S("`\"\'"));
	string* _t7 = (string*)(builtin__map_get_check(ADDR(map, compile_values), &(string[]){cc->args_var}));
	_option_string _t6 = {0};
	if (_t7) {
		*((string*)&_t6.data) = *((string*)_t7);
	} else {
		_t6.state = 2; _t6.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t6.state != 0) {
		*(string*) _t6.data = arg_as_string;
	}
	
	string value = (*(string*)_t6.data);
	_result_void _t8 = v__ast__validate_type_string_is_pure_literal(typ, value);
	if (_t8.is_error) {
		IError err = _t8.err;
		return (_result_void){ .is_error=true, .err=builtin___v_error(IError_name_table[err._typ]._method_msg(err._object)), .data={E_STRUCT} };
	}
	
 ;
	cc->compile_value = value;
	cc->result_type = typ;
	cc->is_d_resolved = true;
	return (_result_void){0};
}
string v__ast__ComptimeCall_expr_str(v__ast__ComptimeCall _v_toheap_cc) {
v__ast__ComptimeCall* cc = HEAP(v__ast__ComptimeCall, _v_toheap_cc);
	string str = _S("ast.ComptimeCall");
	if ((*(cc)).kind == v__ast__ComptimeCallKind__d) {
		v__ast__CallArg* _t2 = (v__ast__CallArg*)(builtin__array_get_with_check((*(cc)).args, 0));
		_option_v__ast__CallArg _t1 = {0};
		if (_t2) {
			*((v__ast__CallArg*)&_t1.data) = *((v__ast__CallArg*)_t2);
		} else {
			_t1.state = 2; _t1.err = builtin___v_error(_S("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			return str;
		}
		
		v__ast__CallArg arg = (*(v__ast__CallArg*)_t1.data);
		if (v__ast__Expr_is_pure_literal(arg.expr)) {
			str = builtin__str_intp(4, _MOV((StrIntpData[]){{_S("$"), 0xfe10, {.d_s = (*(cc)).method_name}}, {_S("('"), 0xfe10, {.d_s = (*(cc)).args_var}}, {_S("', "), 0xfe10, {.d_s = v__ast__CallArg_str(arg)}}, {_S(")"), 0, { .d_c = 0 }}}));
		}
	} else if ((*(cc)).kind == v__ast__ComptimeCallKind__pkgconfig) {
		str = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("$"), 0xfe10, {.d_s = (*(cc)).method_name}}, {_S("('"), 0xfe10, {.d_s = (*(cc)).args_var}}, {_S("')"), 0, { .d_c = 0 }}}));
	}
	return str;
}
v__ast__Type v__ast__Expr_type(v__ast__Expr e) {
	return ((e._typ == 259 /* v.ast.AnonFn */)? ((*e._v__ast__AnonFn).typ) : (e._typ == 260 /* v.ast.ArrayDecompose */)? ((*e._v__ast__ArrayDecompose).expr_type) : (e._typ == 261 /* v.ast.ArrayInit */)? ((*e._v__ast__ArrayInit).typ) : (e._typ == 262 /* v.ast.AsCast */)? ((*e._v__ast__AsCast).typ) : (e._typ == 264 /* v.ast.AtExpr */)? (_const_v__ast__string_type) : (e._typ == 265 /* v.ast.BoolLiteral */)? (_const_v__ast__bool_type) : (e._typ == 266 /* v.ast.CTempVar */)? ((*e._v__ast__CTempVar).typ) : (e._typ == 267 /* v.ast.CallExpr */)? ((*e._v__ast__CallExpr).return_type) : (e._typ == 268 /* v.ast.CastExpr */)? ((*e._v__ast__CastExpr).typ) : (e._typ == 269 /* v.ast.ChanInit */)? ((*e._v__ast__ChanInit).typ) : (e._typ == 270 /* v.ast.CharLiteral */)? (_const_v__ast__char_type) : (e._typ == 272 /* v.ast.ComptimeCall */)? ((*e._v__ast__ComptimeCall).result_type) : (e._typ == 273 /* v.ast.ComptimeSelector */)? ((*e._v__ast__ComptimeSelector).typ) : (e._typ == 275 /* v.ast.ConcatExpr */)? ((*e._v__ast__ConcatExpr).return_type) : (e._typ == 276 /* v.ast.DumpExpr */)? ((*e._v__ast__DumpExpr).expr_type) : (e._typ == 278 /* v.ast.EnumVal */)? ((*e._v__ast__EnumVal).typ) : (e._typ == 279 /* v.ast.FloatLiteral */)? (_const_v__ast__float_literal_type) : (e._typ == 281 /* v.ast.Ident */)? ((*((*e._v__ast__Ident).info.typ))) : (e._typ == 282 /* v.ast.IfExpr */)? ((*e._v__ast__IfExpr).typ) : (e._typ == 283 /* v.ast.IfGuardExpr */)? ((*e._v__ast__IfGuardExpr).expr_type) : (e._typ == 284 /* v.ast.IndexExpr */)? ((*e._v__ast__IndexExpr).typ) : (e._typ == 285 /* v.ast.InfixExpr */)? ((*e._v__ast__InfixExpr).promoted_type) : (e._typ == 286 /* v.ast.IntegerLiteral */)? (_const_v__ast__int_literal_type) : (e._typ == 287 /* v.ast.IsRefType */)? ((*e._v__ast__IsRefType).typ) : (e._typ == 288 /* v.ast.LambdaExpr */)? ((*e._v__ast__LambdaExpr).typ) : (e._typ == 289 /* v.ast.Likely */)? (v__ast__Expr_type((*e._v__ast__Likely).expr)) : (e._typ == 290 /* v.ast.LockExpr */)? ((*e._v__ast__LockExpr).typ) : (e._typ == 291 /* v.ast.MapInit */)? ((*e._v__ast__MapInit).typ) : (e._typ == 292 /* v.ast.MatchExpr */)? ((*e._v__ast__MatchExpr).return_type) : (e._typ == 293 /* v.ast.Nil */)? (_const_v__ast__voidptr_type) : (e._typ == 297 /* v.ast.ParExpr */)? (v__ast__Expr_type((*e._v__ast__ParExpr).expr)) : (e._typ == 298 /* v.ast.PostfixExpr */)? ((*e._v__ast__PostfixExpr).typ) : (e._typ == 299 /* v.ast.PrefixExpr */)? ((*e._v__ast__PrefixExpr).right_type) : (e._typ == 300 /* v.ast.RangeExpr */)? ((*e._v__ast__RangeExpr).typ) : (e._typ == 302 /* v.ast.SelectorExpr */)? ((*e._v__ast__SelectorExpr).typ) : (e._typ == 303 /* v.ast.SizeOf */)? ((*e._v__ast__SizeOf).typ) : (e._typ == 305 /* v.ast.SqlExpr */)? ((*e._v__ast__SqlExpr).typ) : (e._typ == 306 /* v.ast.StringInterLiteral */)? (_const_v__ast__string_type) : (e._typ == 237 /* v.ast.StringLiteral */)? (_const_v__ast__string_type) : (e._typ == 236 /* v.ast.StructInit */)? ((*e._v__ast__StructInit).typ) : (e._typ == 307 /* v.ast.TypeNode */)? ((*e._v__ast__TypeNode).typ) : (e._typ == 308 /* v.ast.TypeOf */)? ((*e._v__ast__TypeOf).typ) : (e._typ == 309 /* v.ast.UnsafeExpr */)? (v__ast__Expr_type((*e._v__ast__UnsafeExpr).expr)) : (_const_v__ast__void_type));
}
inline bool v__ast__Expr_is_blank_ident(v__ast__Expr expr) {
	if ((expr)._typ == 281 /* v.ast.Ident */) {
		return (*expr._v__ast__Ident).kind == v__ast__IdentKind__blank_ident;
	}
	return false;
}
inline bool v__ast__Expr_is_as_cast(v__ast__Expr expr) {
	if ((expr)._typ == 297 /* v.ast.ParExpr */) {
		return v__ast__Expr_is_as_cast((*expr._v__ast__ParExpr).expr);
	} else if ((expr)._typ == 302 /* v.ast.SelectorExpr */) {
		return v__ast__Expr_is_as_cast((*expr._v__ast__SelectorExpr).expr);
	} else {
		return (expr)._typ == 262 /* v.ast.AsCast */;
	}
	return 0;
}
v__token__Pos v__ast__Expr_pos(v__ast__Expr expr) {
	i64 pos_calls = sync__stdatomic__add_i64(&nested_expr_pos_calls, 1);
	if (pos_calls > 5000) {
		return ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	}
v__token__Pos _t3 = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,};
	if (expr._typ == 259 /* v.ast.AnonFn */) {
		_t3 = (*expr._v__ast__AnonFn).decl.pos;
	}
	else if (expr._typ == 266 /* v.ast.CTempVar */) {
		_t3 = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	}
	else if (expr._typ == 277 /* v.ast.EmptyExpr */) {
		_t3 = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	}
	else if (expr._typ == 258 /* v.ast.NodeError */) {
		_t3 = (*expr._v__ast__NodeError).pos;
	}
	else if (expr._typ == 260 /* v.ast.ArrayDecompose */) {
		_t3 = (*expr._v__ast__ArrayDecompose).pos;
	}
	else if (expr._typ == 261 /* v.ast.ArrayInit */) {
		_t3 = (*expr._v__ast__ArrayInit).pos;
	}
	else if (expr._typ == 262 /* v.ast.AsCast */) {
		_t3 = (*expr._v__ast__AsCast).pos;
	}
	else if (expr._typ == 263 /* v.ast.Assoc */) {
		_t3 = (*expr._v__ast__Assoc).pos;
	}
	else if (expr._typ == 264 /* v.ast.AtExpr */) {
		_t3 = (*expr._v__ast__AtExpr).pos;
	}
	else if (expr._typ == 265 /* v.ast.BoolLiteral */) {
		_t3 = (*expr._v__ast__BoolLiteral).pos;
	}
	else if (expr._typ == 267 /* v.ast.CallExpr */) {
		_t3 = (*expr._v__ast__CallExpr).pos;
	}
	else if (expr._typ == 268 /* v.ast.CastExpr */) {
		_t3 = (*expr._v__ast__CastExpr).pos;
	}
	else if (expr._typ == 269 /* v.ast.ChanInit */) {
		_t3 = (*expr._v__ast__ChanInit).pos;
	}
	else if (expr._typ == 270 /* v.ast.CharLiteral */) {
		_t3 = (*expr._v__ast__CharLiteral).pos;
	}
	else if (expr._typ == 275 /* v.ast.ConcatExpr */) {
		_t3 = (*expr._v__ast__ConcatExpr).pos;
	}
	else if (expr._typ == 271 /* v.ast.Comment */) {
		_t3 = (*expr._v__ast__Comment).pos;
	}
	else if (expr._typ == 272 /* v.ast.ComptimeCall */) {
		_t3 = (*expr._v__ast__ComptimeCall).pos;
	}
	else if (expr._typ == 273 /* v.ast.ComptimeSelector */) {
		_t3 = (*expr._v__ast__ComptimeSelector).pos;
	}
	else if (expr._typ == 278 /* v.ast.EnumVal */) {
		_t3 = (*expr._v__ast__EnumVal).pos;
	}
	else if (expr._typ == 276 /* v.ast.DumpExpr */) {
		_t3 = (*expr._v__ast__DumpExpr).pos;
	}
	else if (expr._typ == 279 /* v.ast.FloatLiteral */) {
		_t3 = (*expr._v__ast__FloatLiteral).pos;
	}
	else if (expr._typ == 280 /* v.ast.GoExpr */) {
		_t3 = (*expr._v__ast__GoExpr).pos;
	}
	else if (expr._typ == 304 /* v.ast.SpawnExpr */) {
		_t3 = (*expr._v__ast__SpawnExpr).pos;
	}
	else if (expr._typ == 281 /* v.ast.Ident */) {
		_t3 = (*expr._v__ast__Ident).pos;
	}
	else if (expr._typ == 282 /* v.ast.IfExpr */) {
		_t3 = (*expr._v__ast__IfExpr).pos;
	}
	else if (expr._typ == 286 /* v.ast.IntegerLiteral */) {
		_t3 = (*expr._v__ast__IntegerLiteral).pos;
	}
	else if (expr._typ == 287 /* v.ast.IsRefType */) {
		_t3 = (*expr._v__ast__IsRefType).pos;
	}
	else if (expr._typ == 289 /* v.ast.Likely */) {
		_t3 = (*expr._v__ast__Likely).pos;
	}
	else if (expr._typ == 290 /* v.ast.LockExpr */) {
		_t3 = (*expr._v__ast__LockExpr).pos;
	}
	else if (expr._typ == 291 /* v.ast.MapInit */) {
		_t3 = (*expr._v__ast__MapInit).pos;
	}
	else if (expr._typ == 292 /* v.ast.MatchExpr */) {
		_t3 = (*expr._v__ast__MatchExpr).pos;
	}
	else if (expr._typ == 294 /* v.ast.None */) {
		_t3 = (*expr._v__ast__None).pos;
	}
	else if (expr._typ == 295 /* v.ast.OffsetOf */) {
		_t3 = (*expr._v__ast__OffsetOf).pos;
	}
	else if (expr._typ == 296 /* v.ast.OrExpr */) {
		_t3 = (*expr._v__ast__OrExpr).pos;
	}
	else if (expr._typ == 297 /* v.ast.ParExpr */) {
		_t3 = (*expr._v__ast__ParExpr).pos;
	}
	else if (expr._typ == 298 /* v.ast.PostfixExpr */) {
		_t3 = (*expr._v__ast__PostfixExpr).pos;
	}
	else if (expr._typ == 299 /* v.ast.PrefixExpr */) {
		_t3 = (*expr._v__ast__PrefixExpr).pos;
	}
	else if (expr._typ == 300 /* v.ast.RangeExpr */) {
		_t3 = (*expr._v__ast__RangeExpr).pos;
	}
	else if (expr._typ == 301 /* v.ast.SelectExpr */) {
		_t3 = (*expr._v__ast__SelectExpr).pos;
	}
	else if (expr._typ == 302 /* v.ast.SelectorExpr */) {
		_t3 = (*expr._v__ast__SelectorExpr).pos;
	}
	else if (expr._typ == 303 /* v.ast.SizeOf */) {
		_t3 = (*expr._v__ast__SizeOf).pos;
	}
	else if (expr._typ == 305 /* v.ast.SqlExpr */) {
		_t3 = (*expr._v__ast__SqlExpr).pos;
	}
	else if (expr._typ == 306 /* v.ast.StringInterLiteral */) {
		_t3 = (*expr._v__ast__StringInterLiteral).pos;
	}
	else if (expr._typ == 237 /* v.ast.StringLiteral */) {
		_t3 = (*expr._v__ast__StringLiteral).pos;
	}
	else if (expr._typ == 236 /* v.ast.StructInit */) {
		_t3 = (*expr._v__ast__StructInit).pos;
	}
	else if (expr._typ == 307 /* v.ast.TypeNode */) {
		_t3 = (*expr._v__ast__TypeNode).pos;
	}
	else if (expr._typ == 308 /* v.ast.TypeOf */) {
		_t3 = (*expr._v__ast__TypeOf).pos;
	}
	else if (expr._typ == 309 /* v.ast.UnsafeExpr */) {
		_t3 = (*expr._v__ast__UnsafeExpr).pos;
	}
	else if (expr._typ == 274 /* v.ast.ComptimeType */) {
		_t3 = (*expr._v__ast__ComptimeType).pos;
	}
	else if (expr._typ == 288 /* v.ast.LambdaExpr */) {
		_t3 = (*expr._v__ast__LambdaExpr).pos;
	}
	else if (expr._typ == 293 /* v.ast.Nil */) {
		_t3 = (*expr._v__ast__Nil).pos;
	}
	else if (expr._typ == 284 /* v.ast.IndexExpr */) {
		_t3 = ((*expr._v__ast__IndexExpr).or_expr.kind != v__ast__OrKind__absent ? ((*expr._v__ast__IndexExpr).or_expr.pos) : ((*expr._v__ast__IndexExpr).pos));
	}
	else if (expr._typ == 283 /* v.ast.IfGuardExpr */) {
		_t3 = v__ast__Expr_pos((*expr._v__ast__IfGuardExpr).expr);
	}
	else if (expr._typ == 285 /* v.ast.InfixExpr */) {
		v__token__Pos left_pos = v__ast__Expr_pos((*expr._v__ast__InfixExpr).left);
		v__token__Pos right_pos = v__ast__Expr_pos((*expr._v__ast__InfixExpr).right);
		_t3 = ((v__token__Pos){.len = (int)((int)(right_pos.pos - left_pos.pos) + right_pos.len),.line_nr = (*expr._v__ast__InfixExpr).pos.line_nr,.pos = left_pos.pos,.col = left_pos.col,.file_idx = -1,.last_line = right_pos.last_line,});
	}
	v__token__Pos _t2 = _t3;
		{ // defer begin
			sync__stdatomic__sub_i64(&nested_expr_pos_calls, 1);
		} // defer end
	return _t2;
}
bool v__ast__Expr_is_constant(v__ast__Expr expr) {
	bool _t2 = 0;
	if (expr._typ == 286 /* v.ast.IntegerLiteral */) {
		_t2 = true;
	}
	else if (expr._typ == 279 /* v.ast.FloatLiteral */) {
		_t2 = true;
	}
	else if (expr._typ == 265 /* v.ast.BoolLiteral */) {
		_t2 = true;
	}
	else if (expr._typ == 237 /* v.ast.StringLiteral */) {
		_t2 = true;
	}
	else if (expr._typ == 285 /* v.ast.InfixExpr */) {
		_t2 = true;
	}
	else if (expr._typ == 268 /* v.ast.CastExpr */) {
		_t2 = true;
	}
	else if (expr._typ == 261 /* v.ast.ArrayInit */) {
		_t2 = true;
	}
	else if (expr._typ == 309 /* v.ast.UnsafeExpr */) {
		_t2 = v__ast__Expr_is_constant((*expr._v__ast__UnsafeExpr).expr);
	}
	
	else {
		return false;
	}
	return _t2;
}
bool v__ast__Expr_is_lvalue(v__ast__Expr expr) {
	return ((expr._typ == 281 /* v.ast.Ident */)? (true) : (expr._typ == 266 /* v.ast.CTempVar */)? (true) : (expr._typ == 284 /* v.ast.IndexExpr */)? (v__ast__Expr_is_lvalue((*expr._v__ast__IndexExpr).left)) : (expr._typ == 302 /* v.ast.SelectorExpr */)? (v__ast__Expr_is_lvalue((*expr._v__ast__SelectorExpr).expr)) : (expr._typ == 297 /* v.ast.ParExpr */)? (v__ast__Expr_is_lvalue((*expr._v__ast__ParExpr).expr)) : (expr._typ == 299 /* v.ast.PrefixExpr */)? (v__ast__Expr_is_lvalue((*expr._v__ast__PrefixExpr).right)) : (expr._typ == 273 /* v.ast.ComptimeSelector */)? (v__ast__Expr_is_lvalue((*expr._v__ast__ComptimeSelector).field_expr)) : (false));
}
bool v__ast__Expr_is_expr(v__ast__Expr expr) {
	return ((expr._typ == 282 /* v.ast.IfExpr */)? ((*expr._v__ast__IfExpr).is_expr) : (expr._typ == 290 /* v.ast.LockExpr */)? ((*expr._v__ast__LockExpr).is_expr) : (expr._typ == 292 /* v.ast.MatchExpr */)? ((*expr._v__ast__MatchExpr).is_expr) : (expr._typ == 301 /* v.ast.SelectExpr */)? ((*expr._v__ast__SelectExpr).is_expr) : (true));
}
v__ast__Type v__ast__Expr_get_pure_type(v__ast__Expr expr) {
	return ((expr._typ == 265 /* v.ast.BoolLiteral */)? (_const_v__ast__bool_type) : (expr._typ == 270 /* v.ast.CharLiteral */)? (_const_v__ast__char_type) : (expr._typ == 279 /* v.ast.FloatLiteral */)? (_const_v__ast__f64_type) : (expr._typ == 237 /* v.ast.StringLiteral */)? (_const_v__ast__string_type) : (expr._typ == 286 /* v.ast.IntegerLiteral */)? (_const_v__ast__i64_type) : (_const_v__ast__void_type));
}
bool v__ast__Expr_is_pure_literal(v__ast__Expr expr) {
	return ((expr._typ == 265 /* v.ast.BoolLiteral */)? (true) : (expr._typ == 270 /* v.ast.CharLiteral */)? (true) : (expr._typ == 279 /* v.ast.FloatLiteral */)? (true) : (expr._typ == 237 /* v.ast.StringLiteral */)? (true) : (expr._typ == 286 /* v.ast.IntegerLiteral */)? (true) : (false));
}
bool v__ast__Expr_is_auto_deref_var(v__ast__Expr expr) {
	return ((expr._typ == 281 /* v.ast.Ident */)? ((((*expr._v__ast__Ident).obj)._typ == 341 /* v.ast.Var */ ? ((*(*expr._v__ast__Ident).obj._v__ast__Var).is_auto_deref) : (false))) : (expr._typ == 299 /* v.ast.PrefixExpr */)? ((*expr._v__ast__PrefixExpr).op == v__token__Kind__amp && v__ast__Expr_is_auto_deref_var((*expr._v__ast__PrefixExpr).right)) : (false));
}
bool v__ast__Expr_is_lockable(v__ast__Expr* e) {
	return ((e->_typ == 281 /* v.ast.Ident */)? (true) : (e->_typ == 302 /* v.ast.SelectorExpr */)? (v__ast__Expr_is_lockable(&(*e->_v__ast__SelectorExpr).expr)) : (e->_typ == 273 /* v.ast.ComptimeSelector */)? (true) : (false));
}
bool v__ast__Expr_has_fn_call(v__ast__Expr* e) {
	return ((e->_typ == 267 /* v.ast.CallExpr */)? (true) : (e->_typ == 302 /* v.ast.SelectorExpr */)? (v__ast__Expr_has_fn_call(&(*e->_v__ast__SelectorExpr).expr)) : (false));
}
v__token__Pos v__ast__Node_pos(v__ast__Node node) {
	if (node._typ == 258 /* v.ast.NodeError */) {
		return ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	}
	else if (node._typ == 344 /* v.ast.EmptyNode */) {
		return ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	}
	else if (node._typ == 226 /* v.ast.Stmt */) {
		v__token__Pos pos = (*((*node._v__ast__Stmt).pos));
		if (((*node._v__ast__Stmt))._typ == 329 /* v.ast.Import */) {
			for (int _t3 = 0; _t3 < (*(*node._v__ast__Stmt)._v__ast__Import).syms.len; ++_t3) {
				v__ast__ImportSymbol sym = ((v__ast__ImportSymbol*)(*(*node._v__ast__Stmt)._v__ast__Import).syms.data)[_t3];
				pos = v__token__Pos_extend(pos, sym.pos);
			}
		} else if (((*node._v__ast__Stmt))._typ == 257 /* v.ast.TypeDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 255 /* v.ast.FnTypeDecl */) {
				pos = v__token__Pos_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__FnTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 254 /* v.ast.AliasTypeDecl */) {
				pos = v__token__Pos_extend(pos, (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__AliasTypeDecl).type_pos);
			}
			else if ((*(*node._v__ast__Stmt)._v__ast__TypeDecl)._typ == 256 /* v.ast.SumTypeDecl */) {
				for (int _t4 = 0; _t4 < (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.len; ++_t4) {
					v__ast__TypeNode variant = ((v__ast__TypeNode*)(*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants.data)[_t4];
					pos = v__token__Pos_extend(pos, variant.pos);
				}
			}
			
		}
		if (((*node._v__ast__Stmt))._typ == 313 /* v.ast.AssignStmt */) {
			return v__token__Pos_extend(pos, v__ast__Expr_pos((*(v__ast__Expr*)builtin__array_last((*(*node._v__ast__Stmt)._v__ast__AssignStmt).right))));
		}
		if (((*node._v__ast__Stmt))._typ == 312 /* v.ast.AssertStmt */) {
			return v__token__Pos_extend(pos, v__ast__Expr_pos((*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr));
		}
		return pos;
	}
	else if (node._typ == 310 /* v.ast.Expr */) {
		return v__ast__Expr_pos((*node._v__ast__Expr));
	}
	else if (node._typ == 350 /* v.ast.StructField */) {
		return v__token__Pos_extend((*node._v__ast__StructField).pos, (*node._v__ast__StructField).type_pos);
	}
	else if (node._typ == 347 /* v.ast.MatchBranch */) {
		return (*node._v__ast__MatchBranch).pos;
	}
	else if (node._typ == 349 /* v.ast.SelectBranch */) {
		return (*node._v__ast__SelectBranch).pos;
	}
	else if (node._typ == 345 /* v.ast.EnumField */) {
		return (*node._v__ast__EnumField).pos;
	}
	else if (node._typ == 339 /* v.ast.ConstField */) {
		return (*node._v__ast__ConstField).pos;
	}
	else if (node._typ == 351 /* v.ast.StructInitField */) {
		return (*node._v__ast__StructInitField).pos;
	}
	else if (node._typ == 340 /* v.ast.GlobalField */) {
		return (*node._v__ast__GlobalField).pos;
	}
	else if (node._typ == 343 /* v.ast.CallArg */) {
		return (*node._v__ast__CallArg).pos;
	}
	else if (node._typ == 348 /* v.ast.Param */) {
		return v__token__Pos_extend((*node._v__ast__Param).pos, (*node._v__ast__Param).type_pos);
	}
	else if (node._typ == 346 /* v.ast.IfBranch */) {
		return v__token__Pos_extend((*node._v__ast__IfBranch).pos, (*node._v__ast__IfBranch).body_pos);
	}
	else if (node._typ == 342 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 339 /* v.ast.ConstField */) {
			return (*(*node._v__ast__ScopeObject)._v__ast__ConstField).pos;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 340 /* v.ast.GlobalField */) {
			return (*(*node._v__ast__ScopeObject)._v__ast__GlobalField).pos;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 341 /* v.ast.Var */) {
			return (*(*node._v__ast__ScopeObject)._v__ast__Var).pos;
		}
		else if ((*node._v__ast__ScopeObject)._typ == 337 /* v.ast.EmptyScopeObject */) {
			return ((v__token__Pos){.len = -1,.line_nr = -1,.pos = -1,.col = 0,.file_idx = -1,.last_line = -1,});
		}
		else if ((*node._v__ast__ScopeObject)._typ == 338 /* v.ast.AsmRegister */) {
			return ((v__token__Pos){.len = -1,.line_nr = -1,.pos = -1,.col = 0,.file_idx = -1,.last_line = -1,});
		}
		
	}
	else if (node._typ == 235 /* v.ast.File */) {
		v__token__Pos pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		if ((*node._v__ast__File).stmts.len > 0) {
			v__token__Pos first_pos = (*((*(v__ast__Stmt*)builtin__array_first((*node._v__ast__File).stmts)).pos));
			v__token__Pos last_pos = (*((*(v__ast__Stmt*)builtin__array_last((*node._v__ast__File).stmts)).pos));
			pos = v__token__Pos_extend_with_last_line(first_pos, last_pos, last_pos.line_nr);
		}
		return pos;
	}
	
	return (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,};
}
Array_v__ast__Node v__ast__Node_children(v__ast__Node node) {
	Array_v__ast__Node children = builtin____new_array_with_default(0, 0, sizeof(v__ast__Node), 0);
	if ((node)._typ == 310 /* v.ast.Expr */) {
		if ((*node._v__ast__Expr)._typ == 306 /* v.ast.StringInterLiteral */) {
			Array_v__ast__Node _t2 = {0};
			Array_v__ast__Expr _t2_orig = (*(*node._v__ast__Expr)._v__ast__StringInterLiteral).exprs;
			int _t2_len = _t2_orig.len;
			_t2 = builtin____new_array(0, _t2_len, sizeof(v__ast__Node));

			for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
				v__ast__Expr it = ((v__ast__Expr*) _t2_orig.data)[_t4];
				v__ast__Node _t3 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t2, &_t3);
			}
			return _t2;
		}
		else if ((*node._v__ast__Expr)._typ == 263 /* v.ast.Assoc */) {
			Array_v__ast__Node _t6 = {0};
			Array_v__ast__Expr _t6_orig = (*(*node._v__ast__Expr)._v__ast__Assoc).exprs;
			int _t6_len = _t6_orig.len;
			_t6 = builtin____new_array(0, _t6_len, sizeof(v__ast__Node));

			for (int _t8 = 0; _t8 < _t6_len; ++_t8) {
				v__ast__Expr it = ((v__ast__Expr*) _t6_orig.data)[_t8];
				v__ast__Node _t7 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t6, &_t7);
			}
			return _t6;
		}
		else if ((*node._v__ast__Expr)._typ == 261 /* v.ast.ArrayInit */) {
			Array_v__ast__Node _t10 = {0};
			Array_v__ast__Expr _t10_orig = (*(*node._v__ast__Expr)._v__ast__ArrayInit).exprs;
			int _t10_len = _t10_orig.len;
			_t10 = builtin____new_array(0, _t10_len, sizeof(v__ast__Node));

			for (int _t12 = 0; _t12 < _t10_len; ++_t12) {
				v__ast__Expr it = ((v__ast__Expr*) _t10_orig.data)[_t12];
				v__ast__Node _t11 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t10, &_t11);
			}
			return _t10;
		}
		else if ((*node._v__ast__Expr)._typ == 302 /* v.ast.SelectorExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__SelectorExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 298 /* v.ast.PostfixExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__PostfixExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 309 /* v.ast.UnsafeExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__UnsafeExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 262 /* v.ast.AsCast */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__AsCast).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 297 /* v.ast.ParExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ParExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 283 /* v.ast.IfGuardExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IfGuardExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 303 /* v.ast.SizeOf */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__SizeOf).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 289 /* v.ast.Likely */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__Likely).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 308 /* v.ast.TypeOf */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__TypeOf).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 260 /* v.ast.ArrayDecompose */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ArrayDecompose).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 288 /* v.ast.LambdaExpr */) {
			for (int _t23 = 0; _t23 < (*(*node._v__ast__Expr)._v__ast__LambdaExpr).params.len; ++_t23) {
				v__ast__Ident p = ((v__ast__Ident*)(*(*node._v__ast__Expr)._v__ast__LambdaExpr).params.data)[_t23];
				builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__Ident_to_sumtype_v__ast__Expr(&p, false))), false) }));
			}
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__LambdaExpr).expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 290 /* v.ast.LockExpr */) {
			Array_v__ast__Node _t27 = {0};
			Array_v__ast__Stmt _t27_orig = (*(*node._v__ast__Expr)._v__ast__LockExpr).stmts;
			int _t27_len = _t27_orig.len;
			_t27 = builtin____new_array(0, _t27_len, sizeof(v__ast__Node));

			for (int _t29 = 0; _t29 < _t27_len; ++_t29) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t27_orig.data)[_t29];
				v__ast__Node _t28 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t27, &_t28);
			}
			return _t27;
		}
		else if ((*node._v__ast__Expr)._typ == 296 /* v.ast.OrExpr */) {
			Array_v__ast__Node _t31 = {0};
			Array_v__ast__Stmt _t31_orig = (*(*node._v__ast__Expr)._v__ast__OrExpr).stmts;
			int _t31_len = _t31_orig.len;
			_t31 = builtin____new_array(0, _t31_len, sizeof(v__ast__Node));

			for (int _t33 = 0; _t33 < _t31_len; ++_t33) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t31_orig.data)[_t33];
				v__ast__Node _t32 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t31, &_t32);
			}
			return _t31;
		}
		else if ((*node._v__ast__Expr)._typ == 236 /* v.ast.StructInit */) {
			Array_v__ast__Node _t35 = {0};
			Array_v__ast__StructInitField _t35_orig = (*(*node._v__ast__Expr)._v__ast__StructInit).init_fields;
			int _t35_len = _t35_orig.len;
			_t35 = builtin____new_array(0, _t35_len, sizeof(v__ast__Node));

			for (int _t37 = 0; _t37 < _t35_len; ++_t37) {
				v__ast__StructInitField it = ((v__ast__StructInitField*) _t35_orig.data)[_t37];
				v__ast__Node _t36 = v__ast__StructInitField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t35, &_t36);
			}
			return _t35;
		}
		else if ((*node._v__ast__Expr)._typ == 259 /* v.ast.AnonFn */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(&(*(*node._v__ast__Expr)._v__ast__AnonFn).decl, false))), false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 267 /* v.ast.CallExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CallExpr).left, false) }));
			Array_v__ast__Node _t41 = {0};
			Array_v__ast__CallArg _t41_orig = (*(*node._v__ast__Expr)._v__ast__CallExpr).args;
			int _t41_len = _t41_orig.len;
			_t41 = builtin____new_array(0, _t41_len, sizeof(v__ast__Node));

			for (int _t43 = 0; _t43 < _t41_len; ++_t43) {
				v__ast__CallArg it = ((v__ast__CallArg*) _t41_orig.data)[_t43];
				v__ast__Node _t42 = v__ast__CallArg_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t41, &_t42);
			}
			_PUSH_MANY(&children, (_t41), _t40, Array_v__ast__Node);
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__OrExpr_to_sumtype_v__ast__Expr(&(*(*node._v__ast__Expr)._v__ast__CallExpr).or_block, false))), false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 285 /* v.ast.InfixExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__InfixExpr).left, false) }));
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__InfixExpr).right, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 299 /* v.ast.PrefixExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__PrefixExpr).right, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 284 /* v.ast.IndexExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IndexExpr).left, false) }));
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IndexExpr).index, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 282 /* v.ast.IfExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__IfExpr).left, false) }));
			Array_v__ast__Node _t52 = {0};
			Array_v__ast__IfBranch _t52_orig = (*(*node._v__ast__Expr)._v__ast__IfExpr).branches;
			int _t52_len = _t52_orig.len;
			_t52 = builtin____new_array(0, _t52_len, sizeof(v__ast__Node));

			for (int _t54 = 0; _t54 < _t52_len; ++_t54) {
				v__ast__IfBranch it = ((v__ast__IfBranch*) _t52_orig.data)[_t54];
				v__ast__Node _t53 = v__ast__IfBranch_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t52, &_t53);
			}
			_PUSH_MANY(&children, (_t52), _t51, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 292 /* v.ast.MatchExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__MatchExpr).cond, false) }));
			Array_v__ast__Node _t57 = {0};
			Array_v__ast__MatchBranch _t57_orig = (*(*node._v__ast__Expr)._v__ast__MatchExpr).branches;
			int _t57_len = _t57_orig.len;
			_t57 = builtin____new_array(0, _t57_len, sizeof(v__ast__Node));

			for (int _t59 = 0; _t59 < _t57_len; ++_t59) {
				v__ast__MatchBranch it = ((v__ast__MatchBranch*) _t57_orig.data)[_t59];
				v__ast__Node _t58 = v__ast__MatchBranch_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t57, &_t58);
			}
			_PUSH_MANY(&children, (_t57), _t56, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 301 /* v.ast.SelectExpr */) {
			Array_v__ast__Node _t61 = {0};
			Array_v__ast__SelectBranch _t61_orig = (*(*node._v__ast__Expr)._v__ast__SelectExpr).branches;
			int _t61_len = _t61_orig.len;
			_t61 = builtin____new_array(0, _t61_len, sizeof(v__ast__Node));

			for (int _t63 = 0; _t63 < _t61_len; ++_t63) {
				v__ast__SelectBranch it = ((v__ast__SelectBranch*) _t61_orig.data)[_t63];
				v__ast__Node _t62 = v__ast__SelectBranch_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t61, &_t62);
			}
			return _t61;
		}
		else if ((*node._v__ast__Expr)._typ == 269 /* v.ast.ChanInit */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ChanInit).cap_expr, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 291 /* v.ast.MapInit */) {
			Array_v__ast__Node _t66 = {0};
			Array_v__ast__Expr _t66_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).keys;
			int _t66_len = _t66_orig.len;
			_t66 = builtin____new_array(0, _t66_len, sizeof(v__ast__Node));

			for (int _t68 = 0; _t68 < _t66_len; ++_t68) {
				v__ast__Expr it = ((v__ast__Expr*) _t66_orig.data)[_t68];
				v__ast__Node _t67 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t66, &_t67);
			}
			_PUSH_MANY(&children, (_t66), _t65, Array_v__ast__Node);
			Array_v__ast__Node _t70 = {0};
			Array_v__ast__Expr _t70_orig = (*(*node._v__ast__Expr)._v__ast__MapInit).vals;
			int _t70_len = _t70_orig.len;
			_t70 = builtin____new_array(0, _t70_len, sizeof(v__ast__Node));

			for (int _t72 = 0; _t72 < _t70_len; ++_t72) {
				v__ast__Expr it = ((v__ast__Expr*) _t70_orig.data)[_t72];
				v__ast__Node _t71 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t70, &_t71);
			}
			_PUSH_MANY(&children, (_t70), _t69, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Expr)._typ == 300 /* v.ast.RangeExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__RangeExpr).low, false) }));
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__RangeExpr).high, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 268 /* v.ast.CastExpr */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CastExpr).expr, false) }));
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__CastExpr).arg, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 275 /* v.ast.ConcatExpr */) {
			Array_v__ast__Node _t78 = {0};
			Array_v__ast__Expr _t78_orig = (*(*node._v__ast__Expr)._v__ast__ConcatExpr).vals;
			int _t78_len = _t78_orig.len;
			_t78 = builtin____new_array(0, _t78_len, sizeof(v__ast__Node));

			for (int _t80 = 0; _t80 < _t78_len; ++_t80) {
				v__ast__Expr it = ((v__ast__Expr*) _t78_orig.data)[_t80];
				v__ast__Node _t79 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t78, &_t79);
			}
			return _t78;
		}
		else if ((*node._v__ast__Expr)._typ == 272 /* v.ast.ComptimeCall */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ComptimeCall).left, false) }));
		}
		else if ((*node._v__ast__Expr)._typ == 273 /* v.ast.ComptimeSelector */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Expr)._v__ast__ComptimeSelector).left, false) }));
		}
		
		else {
		}
		
	} else if ((node)._typ == 226 /* v.ast.Stmt */) {
		if ((*node._v__ast__Stmt)._typ == 314 /* v.ast.Block */) {
			Array_v__ast__Node _t84 = {0};
			Array_v__ast__Stmt _t84_orig = (*(*node._v__ast__Stmt)._v__ast__Block).stmts;
			int _t84_len = _t84_orig.len;
			_t84 = builtin____new_array(0, _t84_len, sizeof(v__ast__Node));

			for (int _t86 = 0; _t86 < _t84_len; ++_t86) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t84_orig.data)[_t86];
				v__ast__Node _t85 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t84, &_t85);
			}
			return _t84;
		}
		else if ((*node._v__ast__Stmt)._typ == 318 /* v.ast.DeferStmt */) {
			Array_v__ast__Node _t88 = {0};
			Array_v__ast__Stmt _t88_orig = (*(*node._v__ast__Stmt)._v__ast__DeferStmt).stmts;
			int _t88_len = _t88_orig.len;
			_t88 = builtin____new_array(0, _t88_len, sizeof(v__ast__Node));

			for (int _t90 = 0; _t90 < _t88_len; ++_t90) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t88_orig.data)[_t90];
				v__ast__Node _t89 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t88, &_t89);
			}
			return _t88;
		}
		else if ((*node._v__ast__Stmt)._typ == 322 /* v.ast.ForCStmt */) {
			Array_v__ast__Node _t92 = {0};
			Array_v__ast__Stmt _t92_orig = (*(*node._v__ast__Stmt)._v__ast__ForCStmt).stmts;
			int _t92_len = _t92_orig.len;
			_t92 = builtin____new_array(0, _t92_len, sizeof(v__ast__Node));

			for (int _t94 = 0; _t94 < _t92_len; ++_t94) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t92_orig.data)[_t94];
				v__ast__Node _t93 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t92, &_t93);
			}
			return _t92;
		}
		else if ((*node._v__ast__Stmt)._typ == 323 /* v.ast.ForInStmt */) {
			Array_v__ast__Node _t96 = {0};
			Array_v__ast__Stmt _t96_orig = (*(*node._v__ast__Stmt)._v__ast__ForInStmt).stmts;
			int _t96_len = _t96_orig.len;
			_t96 = builtin____new_array(0, _t96_len, sizeof(v__ast__Node));

			for (int _t98 = 0; _t98 < _t96_len; ++_t98) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t96_orig.data)[_t98];
				v__ast__Node _t97 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t96, &_t97);
			}
			return _t96;
		}
		else if ((*node._v__ast__Stmt)._typ == 324 /* v.ast.ForStmt */) {
			Array_v__ast__Node _t100 = {0};
			Array_v__ast__Stmt _t100_orig = (*(*node._v__ast__Stmt)._v__ast__ForStmt).stmts;
			int _t100_len = _t100_orig.len;
			_t100 = builtin____new_array(0, _t100_len, sizeof(v__ast__Node));

			for (int _t102 = 0; _t102 < _t100_len; ++_t102) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t100_orig.data)[_t102];
				v__ast__Node _t101 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t100, &_t101);
			}
			return _t100;
		}
		else if ((*node._v__ast__Stmt)._typ == 316 /* v.ast.ComptimeFor */) {
			Array_v__ast__Node _t104 = {0};
			Array_v__ast__Stmt _t104_orig = (*(*node._v__ast__Stmt)._v__ast__ComptimeFor).stmts;
			int _t104_len = _t104_orig.len;
			_t104 = builtin____new_array(0, _t104_len, sizeof(v__ast__Node));

			for (int _t106 = 0; _t106 < _t104_len; ++_t106) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t104_orig.data)[_t106];
				v__ast__Node _t105 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t104, &_t105);
			}
			return _t104;
		}
		else if ((*node._v__ast__Stmt)._typ == 321 /* v.ast.ExprStmt */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__ExprStmt).expr, false) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 312 /* v.ast.AssertStmt */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__AssertStmt).expr, false) }));
		}
		else if ((*node._v__ast__Stmt)._typ == 330 /* v.ast.InterfaceDecl */) {
			Array_v__ast__Node _t110 = {0};
			Array_v__ast__FnDecl _t110_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).methods;
			int _t110_len = _t110_orig.len;
			_t110 = builtin____new_array(0, _t110_len, sizeof(v__ast__Node));

			for (int _t112 = 0; _t112 < _t110_len; ++_t112) {
				v__ast__FnDecl it = ((v__ast__FnDecl*) _t110_orig.data)[_t112];
				v__ast__Node _t111 = v__ast__Stmt_to_sumtype_v__ast__Node(ADDR(v__ast__Stmt, (v__ast__FnDecl_to_sumtype_v__ast__Stmt(&it, false))), false);
				builtin__array_push((array*)&_t110, &_t111);
			}
			_PUSH_MANY(&children, (_t110), _t109, Array_v__ast__Node);
			Array_v__ast__Node _t114 = {0};
			Array_v__ast__StructField _t114_orig = (*(*node._v__ast__Stmt)._v__ast__InterfaceDecl).fields;
			int _t114_len = _t114_orig.len;
			_t114 = builtin____new_array(0, _t114_len, sizeof(v__ast__Node));

			for (int _t116 = 0; _t116 < _t114_len; ++_t116) {
				v__ast__StructField it = ((v__ast__StructField*) _t114_orig.data)[_t116];
				v__ast__Node _t115 = v__ast__StructField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t114, &_t115);
			}
			_PUSH_MANY(&children, (_t114), _t113, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 313 /* v.ast.AssignStmt */) {
			Array_v__ast__Node _t118 = {0};
			Array_v__ast__Expr _t118_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).left;
			int _t118_len = _t118_orig.len;
			_t118 = builtin____new_array(0, _t118_len, sizeof(v__ast__Node));

			for (int _t120 = 0; _t120 < _t118_len; ++_t120) {
				v__ast__Expr it = ((v__ast__Expr*) _t118_orig.data)[_t120];
				v__ast__Node _t119 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t118, &_t119);
			}
			_PUSH_MANY(&children, (_t118), _t117, Array_v__ast__Node);
			Array_v__ast__Node _t122 = {0};
			Array_v__ast__Expr _t122_orig = (*(*node._v__ast__Stmt)._v__ast__AssignStmt).right;
			int _t122_len = _t122_orig.len;
			_t122 = builtin____new_array(0, _t122_len, sizeof(v__ast__Node));

			for (int _t124 = 0; _t124 < _t122_len; ++_t124) {
				v__ast__Expr it = ((v__ast__Expr*) _t122_orig.data)[_t124];
				v__ast__Node _t123 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t122, &_t123);
			}
			_PUSH_MANY(&children, (_t122), _t121, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 332 /* v.ast.Return */) {
			Array_v__ast__Node _t126 = {0};
			Array_v__ast__Expr _t126_orig = (*(*node._v__ast__Stmt)._v__ast__Return).exprs;
			int _t126_len = _t126_orig.len;
			_t126 = builtin____new_array(0, _t126_len, sizeof(v__ast__Node));

			for (int _t128 = 0; _t128 < _t126_len; ++_t128) {
				v__ast__Expr it = ((v__ast__Expr*) _t126_orig.data)[_t128];
				v__ast__Node _t127 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t126, &_t127);
			}
			return _t126;
		}
		else if ((*node._v__ast__Stmt)._typ == 228 /* v.ast.StructDecl */) {
			Array_v__ast__Node _t130 = {0};
			Array_v__ast__StructField _t130_orig = (*(*node._v__ast__Stmt)._v__ast__StructDecl).fields;
			int _t130_len = _t130_orig.len;
			_t130 = builtin____new_array(0, _t130_len, sizeof(v__ast__Node));

			for (int _t132 = 0; _t132 < _t130_len; ++_t132) {
				v__ast__StructField it = ((v__ast__StructField*) _t130_orig.data)[_t132];
				v__ast__Node _t131 = v__ast__StructField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t130, &_t131);
			}
			return _t130;
		}
		else if ((*node._v__ast__Stmt)._typ == 325 /* v.ast.GlobalDecl */) {
			Array_v__ast__Node _t134 = {0};
			Array_v__ast__GlobalField _t134_orig = (*(*node._v__ast__Stmt)._v__ast__GlobalDecl).fields;
			int _t134_len = _t134_orig.len;
			_t134 = builtin____new_array(0, _t134_len, sizeof(v__ast__Node));

			for (int _t136 = 0; _t136 < _t134_len; ++_t136) {
				v__ast__GlobalField it = ((v__ast__GlobalField*) _t134_orig.data)[_t136];
				v__ast__Node _t135 = v__ast__GlobalField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t134, &_t135);
			}
			return _t134;
		}
		else if ((*node._v__ast__Stmt)._typ == 231 /* v.ast.ConstDecl */) {
			Array_v__ast__Node _t138 = {0};
			Array_v__ast__ConstField _t138_orig = (*(*node._v__ast__Stmt)._v__ast__ConstDecl).fields;
			int _t138_len = _t138_orig.len;
			_t138 = builtin____new_array(0, _t138_len, sizeof(v__ast__Node));

			for (int _t140 = 0; _t140 < _t138_len; ++_t140) {
				v__ast__ConstField it = ((v__ast__ConstField*) _t138_orig.data)[_t140];
				v__ast__Node _t139 = v__ast__ConstField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t138, &_t139);
			}
			return _t138;
		}
		else if ((*node._v__ast__Stmt)._typ == 320 /* v.ast.EnumDecl */) {
			Array_v__ast__Node _t142 = {0};
			Array_v__ast__EnumField _t142_orig = (*(*node._v__ast__Stmt)._v__ast__EnumDecl).fields;
			int _t142_len = _t142_orig.len;
			_t142 = builtin____new_array(0, _t142_len, sizeof(v__ast__Node));

			for (int _t144 = 0; _t144 < _t142_len; ++_t144) {
				v__ast__EnumField it = ((v__ast__EnumField*) _t142_orig.data)[_t144];
				v__ast__Node _t143 = v__ast__EnumField_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t142, &_t143);
			}
			return _t142;
		}
		else if ((*node._v__ast__Stmt)._typ == 229 /* v.ast.FnDecl */) {
			if ((*(*node._v__ast__Stmt)._v__ast__FnDecl).is_method) {
				builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__StructField_to_sumtype_v__ast__Node(&(*(*node._v__ast__Stmt)._v__ast__FnDecl).receiver, false) }));
			}
			Array_v__ast__Node _t147 = {0};
			Array_v__ast__Param _t147_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).params;
			int _t147_len = _t147_orig.len;
			_t147 = builtin____new_array(0, _t147_len, sizeof(v__ast__Node));

			for (int _t149 = 0; _t149 < _t147_len; ++_t149) {
				v__ast__Param it = ((v__ast__Param*) _t147_orig.data)[_t149];
				v__ast__Node _t148 = v__ast__Param_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t147, &_t148);
			}
			_PUSH_MANY(&children, (_t147), _t146, Array_v__ast__Node);
			Array_v__ast__Node _t151 = {0};
			Array_v__ast__Stmt _t151_orig = (*(*node._v__ast__Stmt)._v__ast__FnDecl).stmts;
			int _t151_len = _t151_orig.len;
			_t151 = builtin____new_array(0, _t151_len, sizeof(v__ast__Node));

			for (int _t153 = 0; _t153 < _t151_len; ++_t153) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t151_orig.data)[_t153];
				v__ast__Node _t152 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t151, &_t152);
			}
			_PUSH_MANY(&children, (_t151), _t150, Array_v__ast__Node);
		}
		else if ((*node._v__ast__Stmt)._typ == 257 /* v.ast.TypeDecl */) {
			if (((*(*node._v__ast__Stmt)._v__ast__TypeDecl))._typ == 256 /* v.ast.SumTypeDecl */) {
				Array_v__ast__Node _t155 = {0};
				Array_v__ast__TypeNode _t155_orig = (*(*(*node._v__ast__Stmt)._v__ast__TypeDecl)._v__ast__SumTypeDecl).variants;
				int _t155_len = _t155_orig.len;
				_t155 = builtin____new_array(0, _t155_len, sizeof(v__ast__Node));

				for (int _t157 = 0; _t157 < _t155_len; ++_t157) {
					v__ast__TypeNode it = ((v__ast__TypeNode*) _t155_orig.data)[_t157];
					v__ast__Node _t156 = v__ast__Expr_to_sumtype_v__ast__Node(ADDR(v__ast__Expr, (v__ast__TypeNode_to_sumtype_v__ast__Expr(&it, false))), false);
					builtin__array_push((array*)&_t155, &_t156);
				}
				_PUSH_MANY(&children, (_t155), _t154, Array_v__ast__Node);
			}
		}
		
		else {
		}
		
	} else if ((node)._typ == 342 /* v.ast.ScopeObject */) {
		if ((*node._v__ast__ScopeObject)._typ == 340 /* v.ast.GlobalField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__GlobalField).expr, false) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 339 /* v.ast.ConstField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__ConstField).expr, false) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 341 /* v.ast.Var */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*(*node._v__ast__ScopeObject)._v__ast__Var).expr, false) }));
		}
		else if ((*node._v__ast__ScopeObject)._typ == 338 /* v.ast.AsmRegister */) {
		}
		else if ((*node._v__ast__ScopeObject)._typ == 337 /* v.ast.EmptyScopeObject */) {
		}
		
	} else {
		if (node._typ == 340 /* v.ast.GlobalField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__GlobalField).expr, false) }));
		}
		else if (node._typ == 339 /* v.ast.ConstField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__ConstField).expr, false) }));
		}
		else if (node._typ == 345 /* v.ast.EnumField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__EnumField).expr, false) }));
		}
		else if (node._typ == 351 /* v.ast.StructInitField */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__StructInitField).expr, false) }));
		}
		else if (node._typ == 343 /* v.ast.CallArg */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Expr_to_sumtype_v__ast__Node(&(*node._v__ast__CallArg).expr, false) }));
		}
		else if (node._typ == 349 /* v.ast.SelectBranch */) {
			builtin__array_push((array*)&children, _MOV((v__ast__Node[]){ v__ast__Stmt_to_sumtype_v__ast__Node(&(*node._v__ast__SelectBranch).stmt, false) }));
			Array_v__ast__Node _t168 = {0};
			Array_v__ast__Stmt _t168_orig = (*node._v__ast__SelectBranch).stmts;
			int _t168_len = _t168_orig.len;
			_t168 = builtin____new_array(0, _t168_len, sizeof(v__ast__Node));

			for (int _t170 = 0; _t170 < _t168_len; ++_t170) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t168_orig.data)[_t170];
				v__ast__Node _t169 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t168, &_t169);
			}
			_PUSH_MANY(&children, (_t168), _t167, Array_v__ast__Node);
		}
		else if (node._typ == 346 /* v.ast.IfBranch */) {
			Array_v__ast__Node _t172 = {0};
			Array_v__ast__Stmt _t172_orig = (*node._v__ast__IfBranch).stmts;
			int _t172_len = _t172_orig.len;
			_t172 = builtin____new_array(0, _t172_len, sizeof(v__ast__Node));

			for (int _t174 = 0; _t174 < _t172_len; ++_t174) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t172_orig.data)[_t174];
				v__ast__Node _t173 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t172, &_t173);
			}
			return _t172;
		}
		else if (node._typ == 235 /* v.ast.File */) {
			Array_v__ast__Node _t176 = {0};
			Array_v__ast__Stmt _t176_orig = (*node._v__ast__File).stmts;
			int _t176_len = _t176_orig.len;
			_t176 = builtin____new_array(0, _t176_len, sizeof(v__ast__Node));

			for (int _t178 = 0; _t178 < _t176_len; ++_t178) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t176_orig.data)[_t178];
				v__ast__Node _t177 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t176, &_t177);
			}
			return _t176;
		}
		else if (node._typ == 347 /* v.ast.MatchBranch */) {
			Array_v__ast__Node _t180 = {0};
			Array_v__ast__Stmt _t180_orig = (*node._v__ast__MatchBranch).stmts;
			int _t180_len = _t180_orig.len;
			_t180 = builtin____new_array(0, _t180_len, sizeof(v__ast__Node));

			for (int _t182 = 0; _t182 < _t180_len; ++_t182) {
				v__ast__Stmt it = ((v__ast__Stmt*) _t180_orig.data)[_t182];
				v__ast__Node _t181 = v__ast__Stmt_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t180, &_t181);
			}
			_PUSH_MANY(&children, (_t180), _t179, Array_v__ast__Node);
			Array_v__ast__Node _t184 = {0};
			Array_v__ast__Expr _t184_orig = (*node._v__ast__MatchBranch).exprs;
			int _t184_len = _t184_orig.len;
			_t184 = builtin____new_array(0, _t184_len, sizeof(v__ast__Node));

			for (int _t186 = 0; _t186 < _t184_len; ++_t186) {
				v__ast__Expr it = ((v__ast__Expr*) _t184_orig.data)[_t186];
				v__ast__Node _t185 = v__ast__Expr_to_sumtype_v__ast__Node(&it, false);
				builtin__array_push((array*)&_t184, &_t185);
			}
			_PUSH_MANY(&children, (_t184), _t183, Array_v__ast__Node);
		}
		
		else {
		}
		
	}
	return children;
}
void v__ast__IndexExpr_recursive_mapset_is_setter(v__ast__IndexExpr* lx, bool val) {
	lx->is_setter = val;
	if ((lx->left)._typ == 284 /* v.ast.IndexExpr */ && (*(v__ast__IndexExpr*)builtin____as_cast((lx->left)._v__ast__IndexExpr,(lx->left)._typ, 284)).is_map) {
		v__ast__IndexExpr_recursive_mapset_is_setter(&(*lx->left._v__ast__IndexExpr), val);
	}
}
void v__ast__IndexExpr_recursive_arraymap_set_is_setter(v__ast__IndexExpr* lx) {
	lx->is_setter = true;
	if ((lx->left)._typ == 284 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr_recursive_arraymap_set_is_setter(&(*lx->left._v__ast__IndexExpr));
	} else if ((lx->left)._typ == 302 /* v.ast.SelectorExpr */ && ((*(v__ast__SelectorExpr*)builtin____as_cast((lx->left)._v__ast__SelectorExpr,(lx->left)._typ, 302)).expr)._typ == 284 /* v.ast.IndexExpr */) {
		v__ast__IndexExpr_recursive_arraymap_set_is_setter(&(*(*lx->left._v__ast__SelectorExpr).expr._v__ast__IndexExpr));
	}
}
Map_string_v__ast__ScopeObject v__ast__all_registers(v__ast__Table* t, v__pref__Arch arch) {
	Map_string_v__ast__ScopeObject res = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	switch (arch) {
		case v__pref__Arch___auto: {
			return v__ast__all_registers(t, v__pref__Arch__amd64);
		}
		case v__pref__Arch__amd64: case v__pref__Arch__i386: {
			int _t3 = _const_v__ast__x86_no_number_register_list.key_values.len;
			for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
				int _t4 = _const_v__ast__x86_no_number_register_list.key_values.len - _t3;
				_t3 = _const_v__ast__x86_no_number_register_list.key_values.len;
				if (_t4 < 0) {
					_t2 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&_const_v__ast__x86_no_number_register_list.key_values, _t2)) {continue;}
				int bit_size = *(int*)builtin__DenseArray_key(&_const_v__ast__x86_no_number_register_list.key_values, _t2);
				Array_string __v_array = (*(Array_string*)builtin__DenseArray_value(&_const_v__ast__x86_no_number_register_list.key_values, _t2));
				for (int _t5 = 0; _t5 < __v_array.len; ++_t5) {
					string name = ((string*)__v_array.data)[_t5];
					builtin__map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, (((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))), false) });
				}
			}
			int _t7 = _const_v__ast__x86_with_number_register_list.key_values.len;
			for (int _t6 = 0; _t6 < _t7; ++_t6 ) {
				int _t8 = _const_v__ast__x86_with_number_register_list.key_values.len - _t7;
				_t7 = _const_v__ast__x86_with_number_register_list.key_values.len;
				if (_t8 < 0) {
					_t6 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&_const_v__ast__x86_with_number_register_list.key_values, _t6)) {continue;}
				int bit_size = *(int*)builtin__DenseArray_key(&_const_v__ast__x86_with_number_register_list.key_values, _t6);
				Map_string_int __v_array = (*(Map_string_int*)builtin__DenseArray_value(&_const_v__ast__x86_with_number_register_list.key_values, _t6));
				int _t10 = __v_array.key_values.len;
				for (int _t9 = 0; _t9 < _t10; ++_t9 ) {
					int _t11 = __v_array.key_values.len - _t10;
					_t10 = __v_array.key_values.len;
					if (_t11 < 0) {
						_t9 = -1;
						continue;
					}
					if (!builtin__DenseArray_has_index(&__v_array.key_values, _t9)) {continue;}
					string name = *(string*)builtin__DenseArray_key(&__v_array.key_values, _t9);
					name = builtin__string_clone(name);
					int max_num = (*(int*)builtin__DenseArray_value(&__v_array.key_values, _t9));
					for (int i = 0; i < max_num; ++i) {
						_option_int _t12 = builtin__string_index(name, _S("#"));
						if (_t12.state != 0) {
							builtin___v_panic(_S("all_registers: no hashtag found"));
							VUNREACHABLE();
						;
						}
						
 						int hash_index = (*(int*)_t12.data);
						string assembled_name = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = builtin__string_substr(name, 0, hash_index)}}, {_SLIT0, 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = builtin__string_substr(name, (int)(hash_index + 1), 2147483647)}}, {_SLIT0, 0, { .d_c = 0 }}}));
						builtin__map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, (((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))), false) });
					}
				}
			}
			break;
		}
		case v__pref__Arch__arm32: {
			Map_string_v__ast__ScopeObject arm32 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 32);
			int _t14 = arm32.key_values.len;
			for (int _t13 = 0; _t13 < _t14; ++_t13 ) {
				int _t15 = arm32.key_values.len - _t14;
				_t14 = arm32.key_values.len;
				if (_t15 < 0) {
					_t13 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&arm32.key_values, _t13)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&arm32.key_values, _t13);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&arm32.key_values, _t13));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__arm64: {
			Map_string_v__ast__ScopeObject arm64 = v__ast__gen_all_registers(t, _const_v__ast__arm_no_number_register_list, _const_v__ast__arm_with_number_register_list, 64);
			int _t17 = arm64.key_values.len;
			for (int _t16 = 0; _t16 < _t17; ++_t16 ) {
				int _t18 = arm64.key_values.len - _t17;
				_t17 = arm64.key_values.len;
				if (_t18 < 0) {
					_t16 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&arm64.key_values, _t16)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&arm64.key_values, _t16);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&arm64.key_values, _t16));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__rv32: {
			Map_string_v__ast__ScopeObject rv32 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 32);
			int _t20 = rv32.key_values.len;
			for (int _t19 = 0; _t19 < _t20; ++_t19 ) {
				int _t21 = rv32.key_values.len - _t20;
				_t20 = rv32.key_values.len;
				if (_t21 < 0) {
					_t19 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&rv32.key_values, _t19)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&rv32.key_values, _t19);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&rv32.key_values, _t19));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__rv64: {
			Map_string_v__ast__ScopeObject rv64 = v__ast__gen_all_registers(t, _const_v__ast__riscv_no_number_register_list, _const_v__ast__riscv_with_number_register_list, 64);
			int _t23 = rv64.key_values.len;
			for (int _t22 = 0; _t22 < _t23; ++_t22 ) {
				int _t24 = rv64.key_values.len - _t23;
				_t23 = rv64.key_values.len;
				if (_t24 < 0) {
					_t22 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&rv64.key_values, _t22)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&rv64.key_values, _t22);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&rv64.key_values, _t22));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__s390x: {
			Map_string_v__ast__ScopeObject s390x = v__ast__gen_all_registers(t, _const_v__ast__s390x_no_number_register_list, _const_v__ast__s390x_with_number_register_list, 64);
			int _t26 = s390x.key_values.len;
			for (int _t25 = 0; _t25 < _t26; ++_t25 ) {
				int _t27 = s390x.key_values.len - _t26;
				_t26 = s390x.key_values.len;
				if (_t27 < 0) {
					_t25 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&s390x.key_values, _t25)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&s390x.key_values, _t25);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&s390x.key_values, _t25));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__ppc64le: {
			Map_string_v__ast__ScopeObject ppc64le = v__ast__gen_all_registers(t, _const_v__ast__ppc64le_no_number_register_list, _const_v__ast__ppc64le_with_number_register_list, 64);
			int _t29 = ppc64le.key_values.len;
			for (int _t28 = 0; _t28 < _t29; ++_t28 ) {
				int _t30 = ppc64le.key_values.len - _t29;
				_t29 = ppc64le.key_values.len;
				if (_t30 < 0) {
					_t28 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&ppc64le.key_values, _t28)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&ppc64le.key_values, _t28);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&ppc64le.key_values, _t28));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__loongarch64: {
			Map_string_v__ast__ScopeObject loongarch64 = v__ast__gen_all_registers(t, _const_v__ast__loongarch64_no_number_register_list, _const_v__ast__loongarch64_with_number_register_list, 64);
			int _t32 = loongarch64.key_values.len;
			for (int _t31 = 0; _t31 < _t32; ++_t31 ) {
				int _t33 = loongarch64.key_values.len - _t32;
				_t32 = loongarch64.key_values.len;
				if (_t33 < 0) {
					_t31 = -1;
					continue;
				}
				if (!builtin__DenseArray_has_index(&loongarch64.key_values, _t31)) {continue;}
				string k = *(string*)builtin__DenseArray_key(&loongarch64.key_values, _t31);
				k = builtin__string_clone(k);
				v__ast__ScopeObject v = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&loongarch64.key_values, _t31));
				builtin__map_set(&res, &(string[]){k}, &(v__ast__ScopeObject[]) { v });
			}
			break;
		}
		case v__pref__Arch__wasm32: {
			break;
		}
		case v__pref__Arch__js_node:
		case v__pref__Arch__js_browser:
		case v__pref__Arch__js_freestanding:
		case v__pref__Arch___max:
		default: {
			{
				builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("all_registers: unhandled arch: "), 0xfe10, {.d_s = v__pref__Arch_str(arch)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				VUNREACHABLE();
				break;
			}
		}
	}
	
	return res;
}
VV_LOC Map_string_v__ast__ScopeObject v__ast__gen_all_registers(v__ast__Table* t, Array_string without_numbers, Map_string_int with_numbers, int bit_size) {
	Map_string_v__ast__ScopeObject res = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t1 = 0; _t1 < without_numbers.len; ++_t1) {
		string name = ((string*)without_numbers.data)[_t1];
		builtin__map_set(&res, &(string[]){name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, (((v__ast__AsmRegister){.name = name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))), false) });
	}
	int _t3 = with_numbers.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = with_numbers.key_values.len - _t3;
		_t3 = with_numbers.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&with_numbers.key_values, _t2)) {continue;}
		string name = *(string*)builtin__DenseArray_key(&with_numbers.key_values, _t2);
		name = builtin__string_clone(name);
		int max_num = (*(int*)builtin__DenseArray_value(&with_numbers.key_values, _t2));
		for (int i = 0; i < max_num; ++i) {
			_option_int _t5 = builtin__string_index(name, _S("#"));
			if (_t5.state != 0) {
				builtin___v_panic(_S("all_registers: no hashtag found"));
				VUNREACHABLE();
			;
			}
			
 			int hash_index = (*(int*)_t5.data);
			string assembled_name = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = builtin__string_substr(name, 0, hash_index)}}, {_SLIT0, 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = builtin__string_substr(name, (int)(hash_index + 1), 2147483647)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			builtin__map_set(&res, &(string[]){assembled_name}, &(v__ast__ScopeObject[]) { v__ast__AsmRegister_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__AsmRegister, (((v__ast__AsmRegister){.name = assembled_name,.typ = v__ast__Table_bitsize_to_type(t, bit_size),.size = bit_size,}))), false) });
		}
	}
	return res;
}
bool v__ast__Expr_is_reference(v__ast__Expr expr) {
	return ((expr._typ == 299 /* v.ast.PrefixExpr */)? ((*expr._v__ast__PrefixExpr).op == v__token__Kind__amp) : (expr._typ == 309 /* v.ast.UnsafeExpr */)? (v__ast__Expr_is_reference((*expr._v__ast__UnsafeExpr).expr)) : (expr._typ == 297 /* v.ast.ParExpr */)? (v__ast__Expr_is_reference((*expr._v__ast__ParExpr).expr)) : (false));
}
v__ast__Expr v__ast__Expr_remove_par(v__ast__Expr* expr) {
	v__ast__Expr e = *expr;
	for (;;) {
		if (!((e)._typ == 297 /* v.ast.ParExpr */)) break;
		e = (*e._v__ast__ParExpr).expr;
	}
	return e;
}
bool v__ast__Expr_is_literal(v__ast__Expr expr) {
	return ((expr._typ == 265 /* v.ast.BoolLiteral */)? (true) : (expr._typ == 270 /* v.ast.CharLiteral */)? (true) : (expr._typ == 279 /* v.ast.FloatLiteral */)? (true) : (expr._typ == 286 /* v.ast.IntegerLiteral */)? (true) : (expr._typ == 237 /* v.ast.StringLiteral */)? (true) : (expr._typ == 306 /* v.ast.StringInterLiteral */)? (true) : (expr._typ == 299 /* v.ast.PrefixExpr */)? (v__ast__Expr_is_literal((*expr._v__ast__PrefixExpr).right)) : (expr._typ == 285 /* v.ast.InfixExpr */)? (v__ast__Expr_is_literal((*expr._v__ast__InfixExpr).left) && v__ast__Expr_is_literal((*expr._v__ast__InfixExpr).right)) : (expr._typ == 297 /* v.ast.ParExpr */)? (v__ast__Expr_is_literal((*expr._v__ast__ParExpr).expr)) : (expr._typ == 268 /* v.ast.CastExpr */)? (!(*expr._v__ast__CastExpr).has_arg && v__ast__Expr_is_literal((*expr._v__ast__CastExpr).expr) && (v__ast__Type_is_any_kind_of_pointer((*expr._v__ast__CastExpr).typ) || ((*expr._v__ast__CastExpr).typ == _const_v__ast__i8_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__i16_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__i32_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__int_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__i64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u8_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u16_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u32_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__u64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__f32_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__f64_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__char_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__bool_type || (*expr._v__ast__CastExpr).typ == _const_v__ast__rune_type))) : (expr._typ == 303 /* v.ast.SizeOf */)? ((*expr._v__ast__SizeOf).is_type || v__ast__Expr_is_literal((*expr._v__ast__SizeOf).expr)) : (expr._typ == 287 /* v.ast.IsRefType */)? ((*expr._v__ast__IsRefType).is_type || v__ast__Expr_is_literal((*expr._v__ast__IsRefType).expr)) : (false));
}
inline bool v__ast__Expr_is_nil(v__ast__Expr e) {
	return (e)._typ == 293 /* v.ast.Nil */ || ((e)._typ == 309 /* v.ast.UnsafeExpr */ && ((*(v__ast__UnsafeExpr*)builtin____as_cast((e)._v__ast__UnsafeExpr,(e)._typ, 309)).expr)._typ == 293 /* v.ast.Nil */);
}
bool v__ast__type_can_start_with_token(v__token__Token* tok) {
	return ((tok->kind == (v__token__Kind__name))? ((tok->lit.len > 0 && builtin__u8_is_capital(tok->lit.str[ 0])) || v__token__KeywordsMatcherTrie_matches(&_const_v__ast__builtin_type_names_matcher, tok->lit)) : (tok->kind == (v__token__Kind__amp) || tok->kind == (v__token__Kind__key_fn) || tok->kind == (v__token__Kind__lsbr) || tok->kind == (v__token__Kind__question))? (true) : (false));
}
_result_void v__ast__validate_type_string_is_pure_literal(v__ast__Type typ, string str) {
	if (typ == _const_v__ast__bool_type) {
		if (!(_SLIT_EQ(str.str, str.len, "true") || _SLIT_EQ(str.str, str.len, "false"))) {
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("bool literal `true` or `false` expected, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if (typ == _const_v__ast__char_type) {
		if (builtin__string_starts_with(str, _S("\\"))) {
			if (str.len <= 1) {
				return (_result_void){ .is_error=true, .err=builtin___v_error(_S("empty escape sequence found")), .data={E_STRUCT} };
			}
			if (!v__util__is_escape_sequence(builtin__string_at(str, 1))) {
				return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("char literal escape sequence expected, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
		} else if (str.len != 1) {
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("char literal expected, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if (typ == _const_v__ast__f64_type) {
		if (builtin__string_count(str, _S(".")) != 1) {
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("f64 literal expected, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if (typ == _const_v__ast__string_type) {
	} else if (typ == _const_v__ast__i64_type) {
		if (!builtin__string_is_int(str)) {
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("i64 literal expected, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected pure literal, found \""), 0xfe10, {.d_s = str}}, {_S("\""), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
string v__ast__Attr_debug(v__ast__Attr* a) {
	return builtin__str_intp(8, _MOV((StrIntpData[]){{_S("Attr{ name: \""), 0xfe10, {.d_s = a->name}}, {_S("\", has_arg: "), 0xfe10, {.d_s = a->has_arg ? _S("true") : _S("false")}}, {_S(", arg: \""), 0xfe10, {.d_s = a->arg}}, {_S("\", kind: "), 0xfe10, {.d_s = v__ast__AttrKind_str(a->kind)}}, {_S(", ct_expr: "), 0xfe10, {.d_s = v__ast__Expr_str(a->ct_expr)}}, {_S(", ct_opt: "), 0xfe10, {.d_s = a->ct_opt ? _S("true") : _S("false")}}, {_S(", ct_skip: "), 0xfe10, {.d_s = a->ct_skip ? _S("true") : _S("false")}}, {_S("}"), 0, { .d_c = 0 }}}));
}
string v__ast__Attr_str(v__ast__Attr* a) {
	string s = _S("");
	string _t1; /* if prepend */
	if (a->has_arg) {
		s = builtin__string__plus(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = a->name}}, {_S(": "), 0, { .d_c = 0 }}})));
		_t1 = a->arg;
		goto _t2;
	};
	{
		_t1 = a->name;
	}
	_t2: {};
		string arg = _t1;
	s = builtin__string__plus(s, ((a->kind == (v__ast__AttrKind__plain) || a->kind == (v__ast__AttrKind__number) || a->kind == (v__ast__AttrKind__bool))? (arg) : (a->kind == (v__ast__AttrKind__string))? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("'"), 0xfe10, {.d_s = arg}}, {_S("'"), 0, { .d_c = 0 }}}))) : (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("if "), 0xfe10, {.d_s = arg}}, {_SLIT0, 0, { .d_c = 0 }}})))));
	return s;
}
bool Array_v__ast__Attr_contains(Array_v__ast__Attr attrs, string str) {
	bool _t2 = false;
	Array_v__ast__Attr _t2_orig = attrs;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		v__ast__Attr it = ((v__ast__Attr*) _t2_orig.data)[_t3];
		if (builtin__string__eq(it.name, str)) {
			_t2 = true;
			break;
		}
	}
	return _t2;
}
bool Array_v__ast__Attr_contains_arg(Array_v__ast__Attr attrs, string str, string arg) {
	bool _t2 = false;
	Array_v__ast__Attr _t2_orig = attrs;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		v__ast__Attr it = ((v__ast__Attr*) _t2_orig.data)[_t3];
		if (it.has_arg && builtin__string__eq(it.name, str) && builtin__string__eq(it.arg, arg)) {
			_t2 = true;
			break;
		}
	}
	return _t2;
}
_option_v__ast__Attr Array_v__ast__Attr_find_first(Array_v__ast__Attr attrs, string aname) {
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr a = ((v__ast__Attr*)attrs.data)[_t1];
		if (builtin__string__eq(a.name, aname)) {
			_option_v__ast__Attr _t2;
			builtin___option_ok(&(v__ast__Attr[]) { a }, (_option*)(&_t2), sizeof(v__ast__Attr));
			 
			return _t2;
		}
	}
	return (_option_v__ast__Attr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__Attr Array_v__ast__Attr_find_last(Array_v__ast__Attr attrs, string aname) {
	for (int idx = (int)(attrs.len - 1); idx > -1; idx--) {
		v__ast__Attr a = ((v__ast__Attr*)attrs.data)[idx];
		if (builtin__string__eq(a.name, aname)) {
			_option_v__ast__Attr _t1;
			builtin___option_ok(&(v__ast__Attr[]) { a }, (_option*)(&_t1), sizeof(v__ast__Attr));
			 
			return _t1;
		}
	}
	return (_option_v__ast__Attr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_int Array_v__ast__Attr_find_comptime_define(Array_v__ast__Attr attrs) {
	for (int idx = 0; idx < attrs.len; ++idx) {
		if (((v__ast__Attr*)attrs.data)[idx].kind == v__ast__AttrKind__comptime_define) {
			_option_int _t1;
			builtin___option_ok(&(int[]) { idx }, (_option*)(&_t1), sizeof(int));
			 
			return _t1;
		}
	}
	return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__Table_has_cflag(v__ast__Table* t, v__cflag__CFlag flag) {
	for (int _t1 = 0; _t1 < t->cflags.len; ++_t1) {
		v__cflag__CFlag cf = ((v__cflag__CFlag*)t->cflags.data)[_t1];
		if (builtin__string__eq(cf.os, flag.os) && builtin__string__eq(cf.name, flag.name) && builtin__string__eq(cf.value, flag.value)) {
			return true;
		}
	}
	return false;
}
_result_void v__ast__Table_parse_cflag(v__ast__Table* t, string cflg, string mod, Array_string ctimedefines) {
	Array_string allowed_flags = builtin__new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
			_S("framework"), _S("library"), _S("Wa"), _S("Wl"), _S("Wp"), _S("I"), _S("l"), _S("L"), _S("D")}));
	string flag_orig = builtin__string_trim_space(cflg);
	string flag = flag_orig;
	if ((flag).len == 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(_S("flag is empty")), .data={E_STRUCT} };
	}
	string fos = _S("");
	Array_string allowed_os_overrides = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&allowed_os_overrides, (_const_v__ast__valid_comptime_not_user_defined), _t2, Array_string);
	_PUSH_MANY(&allowed_os_overrides, (ctimedefines), _t3, Array_string);
	for (int _t4 = 0; _t4 < allowed_os_overrides.len; ++_t4) {
		string os_override = ((string*)allowed_os_overrides.data)[_t4];
		if (!builtin__string_starts_with(flag, os_override)) {
			continue;
		}
		_option_int _t5 = builtin__string_index(flag, _S(" "));
		if (_t5.state != 0) {
			return (_result_void){ .is_error=true, .err=builtin___v_error(_S("none")), .data={E_STRUCT} };
		}
		
 		int pos = (*(int*)_t5.data);
		fos = builtin__string_trim_space(builtin__string_substr(flag, 0, pos));
		flag = builtin__string_trim_space(builtin__string_substr(flag, pos, 2147483647));
	}
	for (;;) {
		string name = _S("");
		string value = _S("");
		if (builtin__string_at(flag, 0) == '-') {
			for (int _t7 = 0; _t7 < allowed_flags.len; ++_t7) {
				string f = ((string*)allowed_flags.data)[_t7];
				int i = (int)(1 + f.len);
				if (i <= flag.len && builtin__string__eq(f, builtin__string_substr(flag, 1, i))) {
					name = builtin__string_trim_space(builtin__string_substr(flag, 0, i));
					flag = builtin__string_trim_space(builtin__string_substr(flag, i, 2147483647));
					break;
				}
			}
		}
		int index = builtin__string_index_(flag, _S(" -"));
		if (index > -1) {
			value = builtin__string_trim_space(builtin__string_substr(flag, 0, index));
			flag = builtin__string_trim_space(builtin__string_substr(flag, index, 2147483647));
		} else {
			value = flag;
		}
		if ((_SLIT_EQ(name.str, name.len, "-I") || _SLIT_EQ(name.str, name.len, "-l") || _SLIT_EQ(name.str, name.len, "-L")) && (value).len == 0) {
			string hint = (_SLIT_EQ(name.str, name.len, "-l") ? (_S("library name")) : (_S("path")));
			return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("bad #flag `"), 0xfe10, {.d_s = flag_orig}}, {_S("`: missing "), 0xfe10, {.d_s = hint}}, {_S(" after `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		v__cflag__CFlag cf = ((v__cflag__CFlag){.mod = mod,.os = fos,.name = name,.value = value,.cached = (string){.str=(byteptr)"", .is_lit=1},});
		if (!v__ast__Table_has_cflag(t, cf)) {
			builtin__array_push((array*)&t->cflags, _MOV((v__cflag__CFlag[]){ cf }));
		}
		if (index == -1) {
			break;
		}
	}
	return (_result_void){0};
}
_option_i8 v__ast__ComptTimeConstValue_i8(v__ast__ComptTimeConstValue val) {
	_option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) {
		return (_option_i8){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	i64 x = (*(i64*)_t1.data);
	if (x > -129 && x < 128) {
		_option_i8 _t2;
		builtin___option_ok(&(i8[]) { ((i8)(x)) }, (_option*)(&_t2), sizeof(i8));
		 
		return _t2;
	}
	return (_option_i8){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_i16 v__ast__ComptTimeConstValue_i16(v__ast__ComptTimeConstValue val) {
	_option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) {
		return (_option_i16){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	i64 x = (*(i64*)_t1.data);
	if (x > -32769 && x < 32768) {
		_option_i16 _t2;
		builtin___option_ok(&(i16[]) { ((i16)(x)) }, (_option*)(&_t2), sizeof(i16));
		 
		return _t2;
	}
	return (_option_i16){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_int v__ast__ComptTimeConstValue_int(v__ast__ComptTimeConstValue val) {
	_option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) {
		return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	i64 x = (*(i64*)_t1.data);
	if (x > -2147483649LL && x < 2147483648U) {
		_option_int _t2;
		builtin___option_ok(&(int[]) { ((int)(x)) }, (_option*)(&_t2), sizeof(int));
		 
		return _t2;
	}
	return (_option_int){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_i32 v__ast__ComptTimeConstValue_i32(v__ast__ComptTimeConstValue val) {
	_option_i64 _t1 = v__ast__ComptTimeConstValue_i64(val);
	if (_t1.state != 0) {
		return (_option_i32){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	i64 x = (*(i64*)_t1.data);
	if (x > -2147483649LL && x < 2147483648U) {
		_option_i32 _t2;
		builtin___option_ok(&(i32[]) { ((i32)(x)) }, (_option*)(&_t2), sizeof(i32));
		 
		return _t2;
	}
	return (_option_i32){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_voidptr v__ast__ComptTimeConstValue_voidptr(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		_option_voidptr _t1;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((i64)((*val._i8))))) }, (_option*)(&_t1), sizeof(voidptr));
		 
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		_option_voidptr _t2;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((i64)((*val._i16))))) }, (_option*)(&_t2), sizeof(voidptr));
		 
		return _t2;
	}
	else if (val._typ == 7 /* i32 */) {
		_option_voidptr _t3;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((i64)((*val._i32))))) }, (_option*)(&_t3), sizeof(voidptr));
		 
		return _t3;
	}
	else if (val._typ == 9 /* i64 */) {
		_option_voidptr _t4;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((i64)((*val._i64))))) }, (_option*)(&_t4), sizeof(voidptr));
		 
		return _t4;
	}
	else if (val._typ == 11 /* u8 */) {
		_option_voidptr _t5;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((u64)((*val._u8))))) }, (_option*)(&_t5), sizeof(voidptr));
		 
		return _t5;
	}
	else if (val._typ == 12 /* u16 */) {
		_option_voidptr _t6;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((u64)((*val._u16))))) }, (_option*)(&_t6), sizeof(voidptr));
		 
		return _t6;
	}
	else if (val._typ == 13 /* u32 */) {
		_option_voidptr _t7;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((u64)((*val._u32))))) }, (_option*)(&_t7), sizeof(voidptr));
		 
		return _t7;
	}
	else if (val._typ == 14 /* u64 */) {
		_option_voidptr _t8;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((u64)((*val._u64))))) }, (_option*)(&_t8), sizeof(voidptr));
		 
		return _t8;
	}
	else if (val._typ == 22 /* rune */) {
		_option_voidptr _t9;
		builtin___option_ok(&(voidptr[]) { ((voidptr)(((u64)((*val._rune))))) }, (_option*)(&_t9), sizeof(voidptr));
		 
		return _t9;
	}
	else if (val._typ == 2 /* voidptr */) {
		_option_voidptr _t10;
		builtin___option_ok(&(voidptr[]) { (*val._voidptr) }, (_option*)(&_t10), sizeof(voidptr));
		 
		return _t10;
	}
	else if (val._typ == 21 /* string */) {
	}
	else if (val._typ == 277 /* v.ast.EmptyExpr */) {
	}
	else if (val._typ == 16 /* f32 */) {
	}
	else if (val._typ == 17 /* f64 */) {
	}
	
	return (_option_voidptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_i64 v__ast__ComptTimeConstValue_i64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		_option_i64 _t1;
		builtin___option_ok(&(i64[]) { ((i64)((*val._i8))) }, (_option*)(&_t1), sizeof(i64));
		 
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		_option_i64 _t2;
		builtin___option_ok(&(i64[]) { ((i64)((*val._i16))) }, (_option*)(&_t2), sizeof(i64));
		 
		return _t2;
	}
	else if (val._typ == 7 /* i32 */) {
		_option_i64 _t3;
		builtin___option_ok(&(i64[]) { ((i64)((*val._i32))) }, (_option*)(&_t3), sizeof(i64));
		 
		return _t3;
	}
	else if (val._typ == 9 /* i64 */) {
		_option_i64 _t4;
		builtin___option_ok(&(i64[]) { ((i64)((*val._i64))) }, (_option*)(&_t4), sizeof(i64));
		 
		return _t4;
	}
	else if (val._typ == 11 /* u8 */) {
		_option_i64 _t5;
		builtin___option_ok(&(i64[]) { ((i64)((*val._u8))) }, (_option*)(&_t5), sizeof(i64));
		 
		return _t5;
	}
	else if (val._typ == 12 /* u16 */) {
		_option_i64 _t6;
		builtin___option_ok(&(i64[]) { ((i64)((*val._u16))) }, (_option*)(&_t6), sizeof(i64));
		 
		return _t6;
	}
	else if (val._typ == 13 /* u32 */) {
		_option_i64 _t7;
		builtin___option_ok(&(i64[]) { ((i64)((*val._u32))) }, (_option*)(&_t7), sizeof(i64));
		 
		return _t7;
	}
	else if (val._typ == 14 /* u64 */) {
		if ((*val._u64) <= 9223372036854775807LL) {
			_option_i64 _t8;
			builtin___option_ok(&(i64[]) { ((i64)((*val._u64))) }, (_option*)(&_t8), sizeof(i64));
			 
			return _t8;
		}
	}
	else if (val._typ == 16 /* f32 */) {
		if (((f32)(-9223372036854775808.0)) <= (*val._f32) && (*val._f32) <= ((f32)(9223372036854775807.0))) {
			_option_i64 _t9;
			builtin___option_ok(&(i64[]) { ((i64)((*val._f32))) }, (_option*)(&_t9), sizeof(i64));
			 
			return _t9;
		}
	}
	else if (val._typ == 17 /* f64 */) {
		if (((f64)(-9223372036854775808.0)) <= (*val._f64) && (*val._f64) <= ((f64)(9223372036854775807.0))) {
			_option_i64 _t10;
			builtin___option_ok(&(i64[]) { ((i64)((*val._f64))) }, (_option*)(&_t10), sizeof(i64));
			 
			return _t10;
		}
	}
	else if (val._typ == 21 /* string */) {
		_option_i64 _t11;
		builtin___option_ok(&(i64[]) { builtin__string_i64((*val._string)) }, (_option*)(&_t11), sizeof(i64));
		 
		return _t11;
	}
	else if (val._typ == 22 /* rune */) {
		_option_i64 _t12;
		builtin___option_ok(&(i64[]) { ((int)((*val._rune))) }, (_option*)(&_t12), sizeof(i64));
		 
		return _t12;
	}
	else if (val._typ == 2 /* voidptr */) {
		_option_i64 _t13;
		builtin___option_ok(&(i64[]) { ((i64)((*val._voidptr))) }, (_option*)(&_t13), sizeof(i64));
		 
		return _t13;
	}
	else if (val._typ == 277 /* v.ast.EmptyExpr */) {
	}
	
	return (_option_i64){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_u8 v__ast__ComptTimeConstValue_u8(v__ast__ComptTimeConstValue val) {
	_option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) {
		return (_option_u8){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	u64 x = (*(u64*)_t1.data);
	if (x < 256) {
		_option_u8 _t2;
		builtin___option_ok(&(u8[]) { ((u8)(x)) }, (_option*)(&_t2), sizeof(u8));
		 
		return _t2;
	}
	return (_option_u8){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_u16 v__ast__ComptTimeConstValue_u16(v__ast__ComptTimeConstValue val) {
	_option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) {
		return (_option_u16){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	u64 x = (*(u64*)_t1.data);
	if (x < 65536) {
		_option_u16 _t2;
		builtin___option_ok(&(u16[]) { ((u16)(x)) }, (_option*)(&_t2), sizeof(u16));
		 
		return _t2;
	}
	return (_option_u16){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_u32 v__ast__ComptTimeConstValue_u32(v__ast__ComptTimeConstValue val) {
	_option_u64 _t1 = v__ast__ComptTimeConstValue_u64(val);
	if (_t1.state != 0) {
		return (_option_u32){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	u64 x = (*(u64*)_t1.data);
	if (x < 4294967296LL) {
		_option_u32 _t2;
		builtin___option_ok(&(u32[]) { ((u32)(x)) }, (_option*)(&_t2), sizeof(u32));
		 
		return _t2;
	}
	return (_option_u32){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_u64 v__ast__ComptTimeConstValue_u64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		if ((*val._i8) >= 0) {
			_option_u64 _t1;
			builtin___option_ok(&(u64[]) { ((u64)((*val._i8))) }, (_option*)(&_t1), sizeof(u64));
			 
			return _t1;
		}
	}
	else if (val._typ == 6 /* i16 */) {
		if ((*val._i16) >= 0) {
			_option_u64 _t2;
			builtin___option_ok(&(u64[]) { ((u64)((*val._i16))) }, (_option*)(&_t2), sizeof(u64));
			 
			return _t2;
		}
	}
	else if (val._typ == 7 /* i32 */) {
		if ((*val._i32) >= 0) {
			_option_u64 _t3;
			builtin___option_ok(&(u64[]) { ((u64)((*val._i32))) }, (_option*)(&_t3), sizeof(u64));
			 
			return _t3;
		}
	}
	else if (val._typ == 9 /* i64 */) {
		if ((*val._i64) >= 0) {
			_option_u64 _t4;
			builtin___option_ok(&(u64[]) { ((u64)((*val._i64))) }, (_option*)(&_t4), sizeof(u64));
			 
			return _t4;
		}
	}
	else if (val._typ == 11 /* u8 */) {
		_option_u64 _t5;
		builtin___option_ok(&(u64[]) { ((u64)((*val._u8))) }, (_option*)(&_t5), sizeof(u64));
		 
		return _t5;
	}
	else if (val._typ == 12 /* u16 */) {
		_option_u64 _t6;
		builtin___option_ok(&(u64[]) { ((u64)((*val._u16))) }, (_option*)(&_t6), sizeof(u64));
		 
		return _t6;
	}
	else if (val._typ == 13 /* u32 */) {
		_option_u64 _t7;
		builtin___option_ok(&(u64[]) { ((u64)((*val._u32))) }, (_option*)(&_t7), sizeof(u64));
		 
		return _t7;
	}
	else if (val._typ == 14 /* u64 */) {
		_option_u64 _t8;
		builtin___option_ok(&(u64[]) { (*val._u64) }, (_option*)(&_t8), sizeof(u64));
		 
		return _t8;
	}
	else if (val._typ == 16 /* f32 */) {
		if ((*val._f32) <= ((f32)(18446744073709551615.0))) {
			_option_u64 _t9;
			builtin___option_ok(&(u64[]) { ((u64)((*val._f32))) }, (_option*)(&_t9), sizeof(u64));
			 
			return _t9;
		}
	}
	else if (val._typ == 17 /* f64 */) {
		if ((*val._f64) <= ((f64)(18446744073709551615.0))) {
			_option_u64 _t10;
			builtin___option_ok(&(u64[]) { ((u64)((*val._f64))) }, (_option*)(&_t10), sizeof(u64));
			 
			return _t10;
		}
	}
	else if (val._typ == 21 /* string */) {
		_option_u64 _t11;
		builtin___option_ok(&(u64[]) { builtin__string_u64((*val._string)) }, (_option*)(&_t11), sizeof(u64));
		 
		return _t11;
	}
	else if (val._typ == 2 /* voidptr */) {
		_option_u64 _t12;
		builtin___option_ok(&(u64[]) { ((u64)((*val._voidptr))) }, (_option*)(&_t12), sizeof(u64));
		 
		return _t12;
	}
	else if (val._typ == 22 /* rune */) {
	}
	else if (val._typ == 277 /* v.ast.EmptyExpr */) {
	}
	
	return (_option_u64){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_f32 v__ast__ComptTimeConstValue_f32(v__ast__ComptTimeConstValue val) {
	_option_f64 _t1 = v__ast__ComptTimeConstValue_f64(val);
	if (_t1.state != 0) {
		return (_option_f32){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
 	f64 x = (*(f64*)_t1.data);
	_option_f32 _t2;
	builtin___option_ok(&(f32[]) { ((f32)(x)) }, (_option*)(&_t2), sizeof(f32));
	 
	return _t2;
}
_option_f64 v__ast__ComptTimeConstValue_f64(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		_option_f64 _t1;
		builtin___option_ok(&(f64[]) { ((f64)((*val._i8))) }, (_option*)(&_t1), sizeof(f64));
		 
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		_option_f64 _t2;
		builtin___option_ok(&(f64[]) { ((f64)((*val._i16))) }, (_option*)(&_t2), sizeof(f64));
		 
		return _t2;
	}
	else if (val._typ == 7 /* i32 */) {
		_option_f64 _t3;
		builtin___option_ok(&(f64[]) { ((f64)((*val._i32))) }, (_option*)(&_t3), sizeof(f64));
		 
		return _t3;
	}
	else if (val._typ == 9 /* i64 */) {
		_option_f64 _t4;
		builtin___option_ok(&(f64[]) { ((f64)((*val._i64))) }, (_option*)(&_t4), sizeof(f64));
		 
		return _t4;
	}
	else if (val._typ == 11 /* u8 */) {
		_option_f64 _t5;
		builtin___option_ok(&(f64[]) { ((f64)((*val._u8))) }, (_option*)(&_t5), sizeof(f64));
		 
		return _t5;
	}
	else if (val._typ == 12 /* u16 */) {
		_option_f64 _t6;
		builtin___option_ok(&(f64[]) { ((f64)((*val._u16))) }, (_option*)(&_t6), sizeof(f64));
		 
		return _t6;
	}
	else if (val._typ == 13 /* u32 */) {
		_option_f64 _t7;
		builtin___option_ok(&(f64[]) { ((f64)((*val._u32))) }, (_option*)(&_t7), sizeof(f64));
		 
		return _t7;
	}
	else if (val._typ == 14 /* u64 */) {
		_option_f64 _t8;
		builtin___option_ok(&(f64[]) { ((f64)((*val._u64))) }, (_option*)(&_t8), sizeof(f64));
		 
		return _t8;
	}
	else if (val._typ == 16 /* f32 */) {
		_option_f64 _t9;
		builtin___option_ok(&(f64[]) { ((f64)((*val._f32))) }, (_option*)(&_t9), sizeof(f64));
		 
		return _t9;
	}
	else if (val._typ == 17 /* f64 */) {
		_option_f64 _t10;
		builtin___option_ok(&(f64[]) { (*val._f64) }, (_option*)(&_t10), sizeof(f64));
		 
		return _t10;
	}
	else if (val._typ == 21 /* string */) {
		_option_f64 _t11;
		builtin___option_ok(&(f64[]) { builtin__string_f64((*val._string)) }, (_option*)(&_t11), sizeof(f64));
		 
		return _t11;
	}
	else if (val._typ == 2 /* voidptr */) {
	}
	else if (val._typ == 22 /* rune */) {
	}
	else if (val._typ == 277 /* v.ast.EmptyExpr */) {
	}
	
	return (_option_f64){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_string v__ast__ComptTimeConstValue_string(v__ast__ComptTimeConstValue val) {
	if (val._typ == 5 /* i8 */) {
		_option_string _t1;
		builtin___option_ok(&(string[]) { builtin__i8_str((*val._i8)) }, (_option*)(&_t1), sizeof(string));
		 
		return _t1;
	}
	else if (val._typ == 6 /* i16 */) {
		_option_string _t2;
		builtin___option_ok(&(string[]) { builtin__i16_str((*val._i16)) }, (_option*)(&_t2), sizeof(string));
		 
		return _t2;
	}
	else if (val._typ == 7 /* i32 */) {
		_option_string _t3;
		builtin___option_ok(&(string[]) { builtin__i32_str((*val._i32)) }, (_option*)(&_t3), sizeof(string));
		 
		return _t3;
	}
	else if (val._typ == 9 /* i64 */) {
		_option_string _t4;
		builtin___option_ok(&(string[]) { builtin__i64_str((*val._i64)) }, (_option*)(&_t4), sizeof(string));
		 
		return _t4;
	}
	else if (val._typ == 11 /* u8 */) {
		_option_string _t5;
		builtin___option_ok(&(string[]) { builtin__u8_str((*val._u8)) }, (_option*)(&_t5), sizeof(string));
		 
		return _t5;
	}
	else if (val._typ == 12 /* u16 */) {
		_option_string _t6;
		builtin___option_ok(&(string[]) { builtin__u16_str((*val._u16)) }, (_option*)(&_t6), sizeof(string));
		 
		return _t6;
	}
	else if (val._typ == 13 /* u32 */) {
		_option_string _t7;
		builtin___option_ok(&(string[]) { builtin__u32_str((*val._u32)) }, (_option*)(&_t7), sizeof(string));
		 
		return _t7;
	}
	else if (val._typ == 14 /* u64 */) {
		_option_string _t8;
		builtin___option_ok(&(string[]) { builtin__u64_str((*val._u64)) }, (_option*)(&_t8), sizeof(string));
		 
		return _t8;
	}
	else if (val._typ == 16 /* f32 */) {
		_option_string _t9;
		builtin___option_ok(&(string[]) { builtin__f32_str((*val._f32)) }, (_option*)(&_t9), sizeof(string));
		 
		return _t9;
	}
	else if (val._typ == 17 /* f64 */) {
		_option_string _t10;
		builtin___option_ok(&(string[]) { builtin__f64_str((*val._f64)) }, (_option*)(&_t10), sizeof(string));
		 
		return _t10;
	}
	else if (val._typ == 22 /* rune */) {
		_option_string _t11;
		builtin___option_ok(&(string[]) { builtin__rune_str((*val._rune)) }, (_option*)(&_t11), sizeof(string));
		 
		return _t11;
	}
	else if (val._typ == 21 /* string */) {
		_option_string _t12;
		builtin___option_ok(&(string[]) { (*val._string) }, (_option*)(&_t12), sizeof(string));
		 
		return _t12;
	}
	else if (val._typ == 2 /* voidptr */) {
		_option_string _t13;
		builtin___option_ok(&(string[]) { builtin__ptr_str((*val._voidptr)) }, (_option*)(&_t13), sizeof(string));
		 
		return _t13;
	}
	else if (val._typ == 277 /* v.ast.EmptyExpr */) {
	}
	
	return (_option_string){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__ComptTimeConstValue v__ast__ConstField_comptime_expr_value(v__ast__ConstField obj) {
	if ((obj.comptime_expr_value)._typ != 277 /* v.ast.EmptyExpr */) {
		_option_v__ast__ComptTimeConstValue _t1;
		builtin___option_ok(&(v__ast__ComptTimeConstValue[]) { obj.comptime_expr_value }, (_option*)(&_t1), sizeof(v__ast__ComptTimeConstValue));
		 
		return _t1;
	}
	return (_option_v__ast__ComptTimeConstValue){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__ConstField_is_simple_define_const(v__ast__ConstField obj) {
	return ((obj.expr._typ == 270 /* v.ast.CharLiteral */)? (true) : (obj.expr._typ == 279 /* v.ast.FloatLiteral */)? (true) : (obj.expr._typ == 286 /* v.ast.IntegerLiteral */)? (true) : (false));
}
bool v__ast__ScopeObject_is_simple_define_const(v__ast__ScopeObject obj) {
	if ((obj)._typ == 339 /* v.ast.ConstField */) {
		return v__ast__ConstField_is_simple_define_const((*obj._v__ast__ConstField));
	}
	return false;
}
VV_LOC Array_string v__ast__all_valid_comptime_idents(void) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	_PUSH_MANY(&res, (_const_v__ast__valid_comptime_if_os), _t1, Array_string);
	_PUSH_MANY(&res, (_const_v__ast__valid_comptime_if_compilers), _t2, Array_string);
	_PUSH_MANY(&res, (_const_v__ast__valid_comptime_if_platforms), _t3, Array_string);
	_PUSH_MANY(&res, (_const_v__ast__valid_comptime_if_cpu_features), _t4, Array_string);
	_PUSH_MANY(&res, (_const_v__ast__valid_comptime_if_other), _t5, Array_string);
	return res;
}
_result_bool v__ast__eval_comptime_not_user_defined_ident(string ident, v__pref__Preferences* the_pref) {
	bool is_true = false;
	if ((Array_string_contains(_const_v__ast__valid_comptime_if_os, ident))) {
		_result_v__pref__OS _t1;
		if (_t1 = v__pref__os_from_string(ident), !_t1.is_error) {
			v__pref__OS ident_enum_val = *(v__pref__OS*)_t1.data;
			if (ident_enum_val == the_pref->os) {
				is_true = true;
			}
		}
	} else if ((Array_string_contains(_const_v__ast__valid_comptime_if_compilers, ident))) {
		is_true = v__pref__cc_from_string(ident) == the_pref->ccompiler_type;
	} else if ((Array_string_contains(_const_v__ast__valid_comptime_if_platforms, ident))) {

		if (_SLIT_EQ(ident.str, ident.len, "amd64")) {
			is_true = the_pref->arch == v__pref__Arch__amd64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "i386")) {
			is_true = the_pref->arch == v__pref__Arch__i386;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "aarch64")) {
			is_true = the_pref->arch == v__pref__Arch__arm64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "arm64")) {
			is_true = the_pref->arch == v__pref__Arch__arm64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "arm32")) {
			is_true = the_pref->arch == v__pref__Arch__arm32;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "rv64")) {
			is_true = the_pref->arch == v__pref__Arch__rv64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "rv32")) {
			is_true = the_pref->arch == v__pref__Arch__rv32;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "s390x")) {
			is_true = the_pref->arch == v__pref__Arch__s390x;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "ppc64le")) {
			is_true = the_pref->arch == v__pref__Arch__ppc64le;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "loongarch64")) {
			is_true = the_pref->arch == v__pref__Arch__loongarch64;
		}
		else {
			return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition: unknown platforms `"), 0xfe10, {.d_s = ident}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((Array_string_contains(_const_v__ast__valid_comptime_if_cpu_features, ident))) {

		if (_SLIT_EQ(ident.str, ident.len, "x64")) {
			is_true = the_pref->m64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "x32")) {
			is_true = !the_pref->m64;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "little_endian")) {
			bool _t3;
			#if defined(TARGET_ORDER_IS_LITTLE)
				_t3 = true;
				;
			#else
			#endif
						is_true = _t3;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "big_endian")) {
			bool _t4;
			#if defined(TARGET_ORDER_IS_BIG)
			#else
				_t4 = false;
				;
			#endif
						is_true = _t4;
		}
		else {
			return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition: unknown cpu_features `"), 0xfe10, {.d_s = ident}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((Array_string_contains(_const_v__ast__valid_comptime_if_other, ident))) {

		if (_SLIT_EQ(ident.str, ident.len, "apk")) {
			is_true = the_pref->is_apk;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "js")) {
			is_true = v__pref__Backend_is_js(the_pref->backend);
		}
		else if (_SLIT_EQ(ident.str, ident.len, "debug")) {
			is_true = the_pref->is_debug;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "prod")) {
			is_true = the_pref->is_prod;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "test")) {
			is_true = the_pref->is_test;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "glibc")) {
			is_true = the_pref->is_glibc;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "prealloc")) {
			is_true = the_pref->prealloc;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "no_bounds_checking")) {
			is_true = the_pref->no_bounds_checking;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "freestanding")) {
			is_true = the_pref->is_bare && !the_pref->output_cross_c;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "threads")) {
			return (_result_bool){ .is_error=true, .err=builtin___v_error(_S("threads should handle outside of `check_valid_ident()`")), .data={E_STRUCT} };
		}
		else if (_SLIT_EQ(ident.str, ident.len, "js_node")) {
			is_true = the_pref->backend == v__pref__Backend__js_node;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "js_browser")) {
			is_true = the_pref->backend == v__pref__Backend__js_browser;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "js_freestanding")) {
			is_true = the_pref->backend == v__pref__Backend__js_freestanding;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "interpreter")) {
			is_true = the_pref->backend == v__pref__Backend__interpret;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "es5")) {
			is_true = the_pref->output_es5;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "profile")) {
			is_true = the_pref->is_prof;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "wasm32")) {
			is_true = the_pref->arch == v__pref__Arch__wasm32;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "wasm32_wasi")) {
			is_true = the_pref->os == v__pref__OS__wasm32_wasi;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "fast_math")) {
			is_true = the_pref->fast_math;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "native")) {
			is_true = the_pref->backend == v__pref__Backend__native;
		}
		else if (_SLIT_EQ(ident.str, ident.len, "autofree")) {
			is_true = the_pref->autofree;
		}
		else {
			return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition: unknown other indent `"), 0xfe10, {.d_s = ident}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((Array_string_contains(the_pref->compile_defines, ident))) {
		is_true = true;
	} else {
		return (_result_bool){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition: unknown indent `"), 0xfe10, {.d_s = ident}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_bool _t9;
	builtin___result_ok(&(bool[]) { is_true }, (_result*)(&_t9), sizeof(bool));
	 
	return _t9;
}
_result_string v__ast__comptime_if_to_ifdef(string name, v__pref__Preferences* the_pref) {
	if (_SLIT_EQ(name.str, name.len, "fast_math")) {
		_result_string _t2; /* if prepend */
		if (the_pref->ccompiler_type == v__pref__CompilerType__msvc) {
			builtin___result_ok(&(string[]) { _S("_M_FP_FAST") }, (_result*)(&_t2), sizeof(string));
			goto _t3;
		};
		{
			builtin___result_ok(&(string[]) { _S("__FAST_MATH__") }, (_result*)(&_t2), sizeof(string));
		}
	_t3: {};
				return _t2;
	}
	string* _t5 = (string*)(builtin__map_get_check(ADDR(map, _const_v__ast__system_ident_map), &(string[]){name}));
	_option_string _t4 = {0};
	if (_t5) {
		*((string*)&_t4.data) = *((string*)_t5);
	} else {
		_t4.state = 2; _t4.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t4.state == 0) {
		string ifdef = (*(string*)_t4.data);
		_result_string _t6;
		builtin___result_ok(&(string[]) { ifdef }, (_result*)(&_t6), sizeof(string));
		 
		return _t6;
	}
	return (_result_string){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("bad os ifdef name `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
}
u64 v__ast__EmbeddedFile_hash(v__ast__EmbeddedFile e) {
	return hash__fnv1a__sum64_string(builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = e.apath}}, {_S(", "), 0xfe10, {.d_s = e.compression_type}}, {_S(", "), 0xfe10, {.d_s = e.is_compressed ? _S("true") : _S("false")}}, {_S(", "), 0xfe07, {.d_i32 = e.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
v__ast__Expr v__ast__Table_resolve_init(v__ast__Table* t, v__ast__StructInit node, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->info._typ == 452 /* v.ast.Array */) {
		bool has_len = false;
		bool has_cap = false;
		bool has_init = false;
		v__ast__Expr len_expr = _const_v__ast__empty_expr;
		v__ast__Expr cap_expr = _const_v__ast__empty_expr;
		v__ast__Expr init_expr = _const_v__ast__empty_expr;
		Array_v__ast__Expr exprs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		for (int _t1 = 0; _t1 < node.init_fields.len; ++_t1) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.init_fields.data)[_t1];

			if (_SLIT_EQ(field.name.str, field.name.len, "len")) {
				has_len = true;
				len_expr = field.expr;
			}
			else if (_SLIT_EQ(field.name.str, field.name.len, "cap")) {
				has_cap = true;
				cap_expr = field.expr;
			}
			else if (_SLIT_EQ(field.name.str, field.name.len, "init")) {
				has_init = true;
				init_expr = field.expr;
			}
			else {
				builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ field.expr }));
			}
		}
		return v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (((v__ast__ArrayInit){
			.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.ecmnts = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),
			.expr_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.exprs = exprs,
			.cap_expr = cap_expr,
			.init_expr = init_expr,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.len_expr = len_expr,
			.elem_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.pos = node.pos,
			.typ = typ,
			.init_type = 0,
			.elem_type = (*sym->info._v__ast__Array).elem_type,
			.alias_type = 0,
			.has_callexpr = 0,
			.is_fixed = 0,
			.is_option = 0,
			.has_val = 0,
			.has_len = has_len,
			.has_cap = has_cap,
			.has_init = has_init,
			.has_index = 0,
		}))), false);
	}
	else if (sym->info._typ == 453 /* v.ast.Map */) {
		Array_v__ast__Expr keys = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_v__ast__Expr vals = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		for (int _t4 = 0; _t4 < node.init_fields.len; ++_t4) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)node.init_fields.data)[_t4];
			builtin__array_push((array*)&keys, _MOV((v__ast__Expr[]){ v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, (((v__ast__StringLiteral){.val = field.name,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.language = 0,.is_raw = 0,}))), false) }));
			builtin__array_push((array*)&vals, _MOV((v__ast__Expr[]){ field.expr }));
		}
		return v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (((v__ast__MapInit){.comments = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.keys = keys,.vals = vals,.val_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.update_expr_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.update_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.update_expr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.key_type = (*sym->info._v__ast__Map).key_type,.typ = typ,.value_type = (*sym->info._v__ast__Map).value_type,.has_update_expr = 0,}))), false);
	}
	
	else {
		return v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (((v__ast__StructInit){.pre_comments = (node).pre_comments,.generic_types = (node).generic_types,.init_fields = (node).init_fields,.update_expr_comments = (node).update_expr_comments,.typ_str = (node).typ_str,.update_expr = (node).update_expr,.pos = (node).pos,.name_pos = (node).name_pos,.update_expr_pos = (node).update_expr_pos,.update_expr_type = (node).update_expr_type,.typ = (node).typ,.language = (node).language,.has_update_expr = (node).has_update_expr,.is_short_syntax = (node).is_short_syntax,.no_keys = (node).no_keys,.is_update_embed = (node).is_update_embed,.is_anon = (node).is_anon,.unresolved = false,}))), false);
	}
	
	return (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258};
}
void v__ast__Scope_free(v__ast__Scope* s) {
	if (s == ((void*)0)) {
		return;
	}
	{ // Unsafe block
		builtin__map_free(&s->objects);
		builtin__map_free(&s->struct_fields);
		for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
			v__ast__Scope* child = ((v__ast__Scope**)s->children.data)[_t1];
			v__ast__Scope_free(child);
		}
		builtin__array_free(&s->children);
	}
}
inline VV_LOC bool v__ast__Scope_dont_lookup_parent(v__ast__Scope* s) {
	return s->parent == ((void*)0) || s->detached_from_parent;
}
_option_v__ast__ScopeObject v__ast__Scope_find(v__ast__Scope* s, string name) {
	if (_unlikely_(s == ((void*)0))) {
		return (_option_v__ast__ScopeObject){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (_IN_MAP(ADDR(string, name), ADDR(map, sc->objects))) {
			_option_v__ast__ScopeObject _t2;
			builtin___option_ok(&(v__ast__ScopeObject[]) { (*(v__ast__ScopeObject*)builtin__map_get(ADDR(map, sc->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ (v__ast__ScopeObject){._v__ast__EmptyScopeObject=HEAP(v__ast__EmptyScopeObject, ((v__ast__EmptyScopeObject){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,})),._typ=337} })) }, (_option*)(&_t2), sizeof(v__ast__ScopeObject));
			 
			return _t2;
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return (_option_v__ast__ScopeObject){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
v__ast__ScopeObject* v__ast__Scope_find_ptr(v__ast__Scope* s, string name) {
	if (_unlikely_(s == ((void*)0))) {
		return 0;
	}
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		v__ast__ScopeObject* _t3 = (v__ast__ScopeObject*)(builtin__map_get_check(ADDR(map, sc->objects), &(string[]){name}));
		if (!_t3) { _t3 = ((void*)0); }
		v__ast__ScopeObject* pobj = &(*_t3);
		if (pobj != ((void*)0)) {
			return pobj;
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return 0;
}
v__ast__ScopeStructField* v__ast__Scope_find_struct_field(v__ast__Scope* s, string name, v__ast__Type struct_type, string field_name) {
	if (_unlikely_(s == ((void*)0))) {
		return ((void*)0);
	}
	string k = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_S("."), 0xfe10, {.d_s = field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		v__ast__ScopeStructField* _t3 = (v__ast__ScopeStructField*)(builtin__map_get_check(ADDR(map, sc->struct_fields), &(string[]){k}));
		_option_v__ast__ScopeStructField _t2 = {0};
		if (_t3) {
			*((v__ast__ScopeStructField*)&_t2.data) = *((v__ast__ScopeStructField*)_t3);
		} else {
			_t2.state = 2; _t2.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t2.state == 0) {
			v__ast__ScopeStructField field = (*(v__ast__ScopeStructField*)_t2.data);
			if (field.struct_type == struct_type) {
				return ((v__ast__ScopeStructField*)builtin__memdup(&(v__ast__ScopeStructField){.smartcasts = (field).smartcasts,.name = (field).name,.pos = (field).pos,.struct_type = (field).struct_type,.typ = (field).typ,.orig_type = (field).orig_type,}, sizeof(v__ast__ScopeStructField)));
			}
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return ((void*)0);
}
_option_v__ast__Var_ptr v__ast__Scope_find_var(v__ast__Scope* s, string name) {
	v__ast__ScopeObject* obj = v__ast__Scope_find_ptr(s, name);
	if (_likely_(obj != ((void*)0))) {
		if (obj->_typ == 341 /* v.ast.Var */) {
			_option_v__ast__Var_ptr _t1;
			builtin___option_ok(&(v__ast__Var*[]) { &(*obj->_v__ast__Var) }, (_option*)(&_t1), sizeof(v__ast__Var*));
			 
			return _t1;
		}
		
		else {
		}
		
	}
	return (_option_v__ast__Var_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__GlobalField_ptr v__ast__Scope_find_global(v__ast__Scope* s, string name) {
	v__ast__ScopeObject* obj = v__ast__Scope_find_ptr(s, name);
	if (_likely_(obj != ((void*)0))) {
		if (obj->_typ == 340 /* v.ast.GlobalField */) {
			_option_v__ast__GlobalField_ptr _t1;
			builtin___option_ok(&(v__ast__GlobalField*[]) { &(*obj->_v__ast__GlobalField) }, (_option*)(&_t1), sizeof(v__ast__GlobalField*));
			 
			return _t1;
		}
		
		else {
		}
		
	}
	return (_option_v__ast__GlobalField_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__ConstField_ptr v__ast__Scope_find_const(v__ast__Scope* s, string name) {
	v__ast__ScopeObject* obj = v__ast__Scope_find_ptr(s, name);
	if (_likely_(obj != ((void*)0))) {
		if (obj->_typ == 339 /* v.ast.ConstField */) {
			_option_v__ast__ConstField_ptr _t1;
			builtin___option_ok(&(v__ast__ConstField*[]) { &(*obj->_v__ast__ConstField) }, (_option*)(&_t1), sizeof(v__ast__ConstField*));
			 
			return _t1;
		}
		
		else {
		}
		
	}
	return (_option_v__ast__ConstField_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__Scope_known_var(v__ast__Scope* s, string name) {
	if (_unlikely_(s == ((void*)0))) {
		return false;
	}
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (_IN_MAP(ADDR(string, name), ADDR(map, sc->objects))) {
			v__ast__ScopeObject* _t3 = (v__ast__ScopeObject*)(builtin__map_get_check(ADDR(map, sc->objects), &(string[]){name}));
			_option_v__ast__ScopeObject _t2 = {0};
			if (_t3) {
				*((v__ast__ScopeObject*)&_t2.data) = *((v__ast__ScopeObject*)_t3);
			} else {
				_t2.state = 2; _t2.err = builtin___v_error(_S("map key does not exist"));
			}
			;
			if (_t2.state != 0) {
				*(v__ast__ScopeObject*) _t2.data = _const_v__ast__empty_scope_object;
			}
			
			v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)_t2.data);
			if ((obj)._typ == 341 /* v.ast.Var */) {
				return true;
			}
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return false;
}
bool v__ast__Scope_known_global(v__ast__Scope* s, string name) {
	_option_v__ast__GlobalField_ptr _t1 = v__ast__Scope_find_global(s, name);
	if (_t1.state != 0) {
		return false;
	}
	
 ;
	return true;
}
bool v__ast__Scope_known_const(v__ast__Scope* s, string name) {
	_option_v__ast__ConstField_ptr _t1 = v__ast__Scope_find_const(s, name);
	if (_t1.state != 0) {
		return false;
	}
	
 ;
	return true;
}
void v__ast__Scope_update_var_type(v__ast__Scope* s, string name, v__ast__Type typ) {
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__map_get(ADDR(map, s->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ (v__ast__ScopeObject){._v__ast__EmptyScopeObject=HEAP(v__ast__EmptyScopeObject, ((v__ast__EmptyScopeObject){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,})),._typ=337} }));
	if ((obj)._typ == 341 /* v.ast.Var */) {
		if ((*obj._v__ast__Var).typ != typ) {
			(*obj._v__ast__Var).typ = typ;
		}
	}
}
void v__ast__Scope_update_ct_var_kind(v__ast__Scope* s, string name, v__ast__ComptimeVarKind kind) {
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__map_get(ADDR(map, s->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ (v__ast__ScopeObject){._v__ast__EmptyScopeObject=HEAP(v__ast__EmptyScopeObject, ((v__ast__EmptyScopeObject){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,})),._typ=337} }));
	if ((obj)._typ == 341 /* v.ast.Var */) {
		(*obj._v__ast__Var).ct_type_var = kind;
	}
}
void v__ast__Scope_update_smartcasts(v__ast__Scope* s, string name, v__ast__Type typ, bool is_unwrapped) {
	v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__map_get(ADDR(map, s->objects), &(string[]){name}, &(v__ast__ScopeObject[]){ (v__ast__ScopeObject){._v__ast__EmptyScopeObject=HEAP(v__ast__EmptyScopeObject, ((v__ast__EmptyScopeObject){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,})),._typ=337} }));
	if ((obj)._typ == 341 /* v.ast.Var */) {
		(*obj._v__ast__Var).smartcasts = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Type), _MOV((v__ast__Type[1]){typ}));
		(*obj._v__ast__Var).is_unwrapped = is_unwrapped;
	}
}
void v__ast__Scope_register_struct_field(v__ast__Scope* s, string name, v__ast__ScopeStructField field) {
	string k = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_S("."), 0xfe10, {.d_s = field.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	v__ast__ScopeStructField* _t2 = (v__ast__ScopeStructField*)(builtin__map_get_check(ADDR(map, s->struct_fields), &(string[]){k}));
	_option_v__ast__ScopeStructField _t1 = {0};
	if (_t2) {
		*((v__ast__ScopeStructField*)&_t1.data) = *((v__ast__ScopeStructField*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		v__ast__ScopeStructField f = (*(v__ast__ScopeStructField*)_t1.data);
		if (f.struct_type == field.struct_type) {
			return;
		}
	}
(*(v__ast__ScopeStructField*)builtin__map_get_and_set((map*)&s->struct_fields, &(string[]){k}, &(v__ast__ScopeStructField[]){ (v__ast__ScopeStructField){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.struct_type = 0,.typ = 0,.orig_type = 0,} })) = field;
}
void v__ast__Scope_register(v__ast__Scope* s, v__ast__ScopeObject obj) {
	if (!(builtin__fast_string_eq((*(obj.name)), _S("_")) || _IN_MAP(ADDR(string, (*(obj.name))), ADDR(map, s->objects)))) {
		builtin__map_set(&s->objects, &(string[]){(*(obj.name))}, &(v__ast__ScopeObject[]) { obj });
	}
}
v__ast__Scope* v__ast__Scope_innermost(v__ast__Scope* s, int pos) {
	if (v__ast__Scope_contains(s, pos)) {
		int first = 0;
		int last = (int)(s->children.len - 1);
		int middle = (int)(last / 2);
		for (;;) {
			if (!(first <= last)) break;
			v__ast__Scope* s1 = ((v__ast__Scope**)s->children.data)[middle];
			if (s1->end_pos < pos) {
				first = (int)(middle + 1);
			} else if (v__ast__Scope_contains(s1, pos)) {
				return v__ast__Scope_innermost(s1, pos);
			} else {
				last = (int)(middle - 1);
			}
			middle = (int)(((int)(first + last)) / 2);
			if (first > last) {
				break;
			}
		}
		return s;
	}
	return s;
}
Array_v__ast__ScopeObject v__ast__Scope_get_all_vars(v__ast__Scope* s) {
	if (s == ((void*)0)) {
		return builtin____new_array_with_default(0, 0, sizeof(v__ast__ScopeObject), 0);
	}
	Array_v__ast__ScopeObject scope_vars = builtin____new_array_with_default(0, 0, sizeof(v__ast__ScopeObject), 0);
	for (v__ast__Scope* sc = s; true; sc = sc->parent) {
		if (sc->objects.len > 0) {
			Array_v__ast__ScopeObject _t3 = {0};
			Array_v__ast__ScopeObject _t3_orig = builtin__map_values(&sc->objects);
			int _t3_len = _t3_orig.len;
			_t3 = builtin____new_array(0, _t3_len, sizeof(v__ast__ScopeObject));

			for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
				v__ast__ScopeObject it = ((v__ast__ScopeObject*) _t3_orig.data)[_t4];
				if ((it)._typ == 341 /* v.ast.Var */) {
					builtin__array_push((array*)&_t3, &it);
				}
			}
			_PUSH_MANY(&scope_vars, (_t3), _t2, Array_v__ast__ScopeObject);
		}
		if (v__ast__Scope_dont_lookup_parent(sc)) {
			break;
		}
	}
	return scope_vars;
}
inline bool v__ast__Scope_contains(v__ast__Scope* s, int pos) {
	return pos >= s->start_pos && pos <= s->end_pos;
}
inline bool v__ast__Scope__eq(v__ast__Scope* s, v__ast__Scope* o) {
	return s->start_pos == o->start_pos && s->end_pos == o->end_pos;
}
bool v__ast__Scope_has_inherited_vars(v__ast__Scope* s) {
	Map_string_v__ast__ScopeObject _t1 = s->objects;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&_t1.key_values, _t2));
		if ((obj)._typ == 341 /* v.ast.Var */) {
			if ((*obj._v__ast__Var).is_inherited) {
				return true;
			}
		}
	}
	return false;
}
bool v__ast__Scope_is_inherited_var(v__ast__Scope* s, string var_name) {
	Map_string_v__ast__ScopeObject _t1 = s->objects;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&_t1.key_values, _t2));
		if ((obj)._typ == 341 /* v.ast.Var */) {
			if ((*obj._v__ast__Var).is_inherited && builtin__string__eq((*obj._v__ast__Var).name, var_name)) {
				return true;
			}
		}
	}
	return false;
}
string v__ast__Scope_show(v__ast__Scope* sc, int depth, int max_depth) {
	string out = _S("");
	string indent = _S("");
	for (int _t1 = 0; _t1 < (int)(depth * 4); ++_t1) {
		indent = builtin__string__plus(indent, _S(" "));
	}
	out = builtin__string__plus(out, builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_S("# "), 0xfe07, {.d_i32 = sc->start_pos}}, {_S(" - "), 0xfe07, {.d_i32 = sc->end_pos}}, {_S("\n"), 0, { .d_c = 0 }}})));
	Map_string_v__ast__ScopeObject _t2 = sc->objects;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		v__ast__ScopeObject obj = (*(v__ast__ScopeObject*)builtin__DenseArray_value(&_t2.key_values, _t3));
		if (obj._typ == 339 /* v.ast.ConstField */) {
			out = builtin__string__plus(out, builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_S("  * const: "), 0xfe10, {.d_s = (*obj._v__ast__ConstField).name}}, {_S(" - "), 0xfe10, {.d_s = v__ast__Type_str((*obj._v__ast__ConstField).typ)}}, {_S("\n"), 0, { .d_c = 0 }}})));
		}
		else if (obj._typ == 341 /* v.ast.Var */) {
			out = builtin__string__plus(out, builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_S("  * var: "), 0xfe10, {.d_s = (*obj._v__ast__Var).name}}, {_S(" - "), 0xfe10, {.d_s = v__ast__Type_str((*obj._v__ast__Var).typ)}}, {_S("\n"), 0, { .d_c = 0 }}})));
		}
		
		else {
		}
		
	}
	Map_string_v__ast__ScopeStructField _t6 = sc->struct_fields;
	int _t8 = _t6.key_values.len;
	for (int _t7 = 0; _t7 < _t8; ++_t7 ) {
		int _t9 = _t6.key_values.len - _t8;
		_t8 = _t6.key_values.len;
		if (_t9 < 0) {
			_t7 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t6.key_values, _t7)) {continue;}
		v__ast__ScopeStructField field = (*(v__ast__ScopeStructField*)builtin__DenseArray_value(&_t6.key_values, _t7));
		out = builtin__string__plus(out, builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = indent}}, {_S("  * struct_field: "), 0xfe10, {.d_s = v__ast__Type_str(field.struct_type)}}, {_S(" "), 0xfe10, {.d_s = field.name}}, {_S(" - "), 0xfe10, {.d_s = v__ast__Type_str(field.typ)}}, {_S("\n"), 0, { .d_c = 0 }}})));
	}
	if (max_depth == 0 || depth < (int)(max_depth - 1)) {
		for (int i = 0; i < sc->children.len; ++i) {
			out = builtin__string__plus(out, v__ast__Scope_show((*(v__ast__Scope**)builtin__array_get(sc->children, i)), (int)(depth + 1), max_depth));
		}
	}
	return out;
}
bool v__ast__Scope_mark_var_as_used(v__ast__Scope* sc, string varname) {
	v__ast__ScopeObject* obj = v__ast__Scope_find_ptr(sc, varname);
	if (obj == ((void*)0)) {
		return false;
	}
	if ((obj)->_typ == 341 /* v.ast.Var */) {
		(*obj->_v__ast__Var).is_used = true;
		return true;
	} else if ((obj)->_typ == 340 /* v.ast.GlobalField */) {
		return true;
	}
	return false;
}
string v__ast__Scope_str(v__ast__Scope* sc) {
	return v__ast__Scope_show(sc, 0, 0);
}
string v__ast__FnDecl_get_name(v__ast__FnDecl* f) {
	if (f->is_static_type_method) {
		return builtin__string_all_after_last(f->name, _S("__static__"));
	} else {
		return f->name;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string v__ast__Table_get_anon_fn_name(v__ast__Table* table, string prefix, v__ast__Fn* func, v__token__Pos pos) {
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("anon_fn_"), 0xfe10, {.d_s = prefix}}, {_S("_"), 0xfe05, {.d_i16 = pos.file_idx}}, {_S("_"), 0xfe10, {.d_s = v__ast__Table_fn_type_signature(table, func)}}, {_S("_"), 0xfe07, {.d_i32 = pos.pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string v__ast__CallExpr_get_name(v__ast__CallExpr* f) {
	if (f->is_static_method) {
		return builtin__string_replace(f->name, _S("__static__"), _S("."));
	} else {
		return f->name;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string v__ast__FnDecl_modname(v__ast__FnDecl* node) {
	if ((node->mod).len != 0) {
		return node->mod;
	}
	string pamod = builtin__string_all_before_last(node->name, _S("."));
	if (builtin__string__eq(pamod, builtin__string_after(node->name, _S(".")))) {
		pamod = (node->is_builtin ? (_S("builtin")) : (_S("main")));
	}
	return pamod;
}
string v__ast__FnDecl_fkey(v__ast__FnDecl* node) {
	if (node->is_method) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver.typ))}}, {_S("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return node->name;
}
string v__ast__StructField_sfkey(v__ast__StructField* node) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->container_typ))}}, {_S("."), 0xfe10, {.d_s = node->name}}, {_S("}"), 0, { .d_c = 0 }}}));
}
string v__ast__Fn_fkey(v__ast__Fn* node) {
	if (node->is_method) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver_type))}}, {_S("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return node->name;
}
string v__ast__CallExpr_fkey(v__ast__CallExpr* node) {
	if (node->is_method) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = ((int)(node->receiver_type))}}, {_S("."), 0xfe10, {.d_s = node->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return node->name;
}
string v__ast__Table_stringify_anon_decl(v__ast__Table* t, v__ast__AnonFn* node, string cur_mod, Map_string_string m2a) {
	strings__Builder f = strings__new_builder(30);
	strings__Builder_write_string(&f, _S("fn "));
	if (node->inherited_vars.len > 0) {
		strings__Builder_write_string(&f, _S("["));
		for (int i = 0; i < node->inherited_vars.len; ++i) {
			v__ast__Param var = ((v__ast__Param*)node->inherited_vars.data)[i];
			if (i > 0) {
				strings__Builder_write_string(&f, _S(", "));
			}
			if (var.is_shared) {
				strings__Builder_write_string(&f, _S("shared "));
			} else if (var.is_atomic) {
				strings__Builder_write_string(&f, _S("atomic "));
			} else if (var.is_mut) {
				strings__Builder_write_string(&f, _S("mut "));
			}
			strings__Builder_write_string(&f, var.name);
		}
		strings__Builder_write_string(&f, _S("] "));
	}
	v__ast__Table_stringify_fn_after_name(t, (voidptr)&node->decl, (voidptr)&f, cur_mod, m2a);
	return strings__Builder_str(&f);
}
string v__ast__Table_stringify_fn_decl(v__ast__Table* t, v__ast__FnDecl* node, string cur_mod, Map_string_string m2a, bool needs_wrap) {
	strings__Builder f = strings__new_builder(30);
	if (node->is_pub) {
		strings__Builder_write_string(&f, _S("pub "));
	}
	strings__Builder_write_string(&f, _S("fn "));
	Array_v__ast__Comment _t1 = {0};
	Array_v__ast__Comment _t1_orig = node->comments;
	int _t1_len = _t1_orig.len;
	_t1 = builtin____new_array(0, _t1_len, sizeof(v__ast__Comment));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__Comment it = ((v__ast__Comment*) _t1_orig.data)[_t2];
		if (it.pos.pos < node->name_pos.pos) {
			builtin__array_push((array*)&_t1, &it);
		}
	}
	Array_v__ast__Comment pre_comments =_t1;
	if (pre_comments.len > 0) {
		v__ast__write_comments(pre_comments, (voidptr)&f);
		if (!builtin__u8_is_space(builtin__string_at(strings__Builder_last_n(&f, 1), 0))) {
			strings__Builder_write_string(&f, _S(" "));
		}
	}
	if (node->is_method) {
		strings__Builder_write_string(&f, _S("("));
		string styp = v__util__no_cur_mod(v__ast__Table_type_to_code(t, v__ast__Type_clear_flag(node->receiver.typ, v__ast__TypeFlag__shared_f)), cur_mod);
		if (node->rec_mut) {
			strings__Builder_write_string(&f, builtin__string__plus(v__ast__ShareType_str(v__ast__Type_share(node->receiver.typ)), _S(" ")));
			styp = builtin__string_substr(styp, 1, 2147483647);
		}
		strings__Builder_write_string(&f, builtin__string__plus(node->receiver.name, _S(" ")));
		styp = v__util__no_cur_mod(styp, cur_mod);
		if (t->new_int_fmt_fix && _SLIT_EQ(styp.str, styp.len, "int")) {
			styp = _S("i32");
		}
		strings__Builder_write_string(&f, builtin__string__plus(styp, _S(") ")));
	} else if (node->is_static_type_method) {
		string styp = v__util__no_cur_mod(v__ast__Table_type_to_code(t, v__ast__Type_clear_flag(node->receiver.typ, v__ast__TypeFlag__shared_f)), cur_mod);
		strings__Builder_write_string(&f, builtin__string__plus(styp, _S(".")));
	}
	string name = (!node->is_method && node->language == v__ast__Language__v ? (builtin__string_all_after_last(node->name, _S("."))) : (node->name));
	if (node->is_static_type_method) {
		name = builtin__string_after(name, _S("__static__"));
	}
	strings__Builder_write_string(&f, name);
	if (_SLIT_EQ(name.str, name.len, "+") || _SLIT_EQ(name.str, name.len, "-") || _SLIT_EQ(name.str, name.len, "*") || _SLIT_EQ(name.str, name.len, "/") || _SLIT_EQ(name.str, name.len, "%") || _SLIT_EQ(name.str, name.len, "<") || _SLIT_EQ(name.str, name.len, ">") || _SLIT_EQ(name.str, name.len, "==") || _SLIT_EQ(name.str, name.len, "!=") || _SLIT_EQ(name.str, name.len, ">=") || _SLIT_EQ(name.str, name.len, "<=")) {
		strings__Builder_write_string(&f, _S(" "));
	}
	v__ast__Table_stringify_fn_after_name(t, node, (voidptr)&f, cur_mod, m2a);
	return strings__Builder_str(&f);
}
VV_LOC void v__ast__Table_stringify_fn_after_name(v__ast__Table* t, v__ast__FnDecl* node, strings__Builder* f, string cur_mod, Map_string_string m2a) {
	bool add_para_types = true;
	if (node->generic_names.len > 0) {
		if (node->is_method) {
			v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__Param*)builtin__array_get(node->params, 0)).typ);
			if ((sym->info)._typ == 457 /* v.ast.Struct */) {
				Array_string _t1 = {0};
				Array_v__ast__Type _t1_orig = (*sym->info._v__ast__Struct).generic_types;
				int _t1_len = _t1_orig.len;
				_t1 = builtin____new_array(0, _t1_len, sizeof(string));

				for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
					v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t3];
					string _t2 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t1, &_t2);
				}
				Array_string generic_names =_t1;
				if (Array_string_arr_eq(generic_names, node->generic_names)) {
					add_para_types = false;
				}
			}
		}
		if (add_para_types) {
			strings__Builder_write_string(f, _S("["));
			for (int i = 0; i < node->generic_names.len; ++i) {
				string gname = ((string*)node->generic_names.data)[i];
				strings__Builder_write_string(f, gname);
				if (i != (int)(node->generic_names.len - 1)) {
					strings__Builder_write_string(f, _S(", "));
				}
			}
			strings__Builder_write_string(f, _S("]"));
		}
	}
	strings__Builder_write_string(f, _S("("));
	int old_pline = node->pos.line_nr;
	int pline = node->pos.line_nr;
	int nparams_on_pline = 0;
	for (int i = 0; i < node->params.len; ++i) {
		v__ast__Param param = ((v__ast__Param*)node->params.data)[i];
		if (node->is_method && i == 0) {
			continue;
		}
		if (param.is_hidden) {
			continue;
		}
		v__ast__Type param_typ = (t->new_int_fmt_fix && param.typ == _const_v__ast__int_type ? (_const_v__ast__i32_type) : (param.typ));
		bool is_last_param = i == (int)(node->params.len - 1);
		bool is_type_only = (param.name).len == 0;
		if (param.on_newline) {
			strings__Builder_write_string(f, _S("\n\t"));
			pline++;
			nparams_on_pline = 0;
		}
		if (pline == old_pline && nparams_on_pline > 0) {
			strings__Builder_write_string(f, _S(" "));
		}
		if (param.is_mut) {
			strings__Builder_write_string(f, builtin__string__plus(v__ast__ShareType_str(v__ast__Type_share(param_typ)), _S(" ")));
		}
		strings__Builder_write_string(f, param.name);
		v__ast__TypeSymbol* param_sym = v__ast__Table_sym(t, param_typ);
		if ((param_sym->info)._typ == 457 /* v.ast.Struct */ && (*(v__ast__Struct*)builtin____as_cast((param_sym->info)._v__ast__Struct,(param_sym->info)._typ, 457)).is_anon) {
			if (v__ast__Type_has_flag(param_typ, v__ast__TypeFlag__option)) {
				strings__Builder_write_string(f, _S(" ?"));
			} else {
				strings__Builder_write_string(f, _S(" "));
			}
			strings__Builder_write_string(f, _S("struct {"));
			for (int _t4 = 0; _t4 < (*param_sym->info._v__ast__Struct).fields.len; ++_t4) {
				v__ast__StructField field = ((v__ast__StructField*)(*param_sym->info._v__ast__Struct).fields.data)[_t4];
				v__ast__Type field_typ = (t->new_int_fmt_fix && field.typ == _const_v__ast__int_type ? (_const_v__ast__i32_type) : (field.typ));
				{
					strings__Builder_write_string(f, _S(" "));
					strings__Builder_write_string(f, field.name);
					strings__Builder_write_string(f, _S(" "));
					strings__Builder_write_string(f, v__ast__Table_type_to_str(t, field_typ));
				}
				if (field.has_default_expr) {
					strings__Builder_write_string(f, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" = "), 0xfe10, {.d_s = v__ast__Expr_str(field.default_expr)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
			}
			if ((*param_sym->info._v__ast__Struct).fields.len > 0) {
				strings__Builder_write_string(f, _S(" "));
			}
			strings__Builder_write_string(f, _S("}"));
		} else {
			string s = v__ast__Table_type_to_str(t, v__ast__Type_clear_flag(param_typ, v__ast__TypeFlag__shared_f));
			if (param.is_mut) {
				if (builtin__string_starts_with(s, _S("&")) && ((!v__ast__TypeSymbol_is_number(param_sym) && param_sym->kind != v__ast__Kind__bool) || node->language != v__ast__Language__v || (v__ast__Type_is_ptr(param_typ) && param_sym->kind == v__ast__Kind__struct))) {
					s = builtin__string_substr(s, 1, 2147483647);
				} else if (v__ast__Type_is_ptr(param_typ) && param_sym->kind == v__ast__Kind__struct && !builtin__string_contains(s, _S("["))) {
					s = v__ast__Table_type_to_str(t, v__ast__Type_deref(v__ast__Type_clear_flag(param_typ, v__ast__TypeFlag__shared_f)));
				}
			}
			s = v__util__no_cur_mod(s, cur_mod);
			s = v__ast__shorten_full_name_based_on_aliases(s, m2a);
			if (!is_type_only) {
				strings__Builder_write_string(f, _S(" "));
			}
			if (node->is_variadic && is_last_param && !node->is_c_variadic) {
				strings__Builder_write_string(f, _S("..."));
			}
			strings__Builder_write_string(f, s);
		}
		if (!is_last_param) {
			strings__Builder_write_string(f, _S(","));
		} else if (node->is_c_variadic) {
			strings__Builder_write_string(f, _S(", ..."));
		}
		nparams_on_pline++;
		old_pline = pline;
	}
	strings__Builder_write_string(f, _S(")"));
	if (node->return_type != _const_v__ast__void_type) {
		v__ast__Type return_type = (t->new_int_fmt_fix && node->return_type == _const_v__ast__int_type ? (_const_v__ast__i32_type) : (node->return_type));
		string sreturn_type = v__util__no_cur_mod(v__ast__Table_type_to_str(t, return_type), cur_mod);
		string short_sreturn_type = v__ast__shorten_full_name_based_on_aliases(sreturn_type, m2a);
		{
			strings__Builder_write_string(f, _S(" "));
			strings__Builder_write_string(f, short_sreturn_type);
		}
	}
}
VV_LOC void v__ast__write_comments(Array_v__ast__Comment comments, strings__Builder* f) {
	for (int i = 0; i < comments.len; ++i) {
		v__ast__Comment c = ((v__ast__Comment*)comments.data)[i];
		v__ast__write_comment(c, f);
		if (i < (int)(comments.len - 1)) {
			strings__Builder_writeln(f, _S(""));
		}
	}
}
VV_LOC void v__ast__write_comment(v__ast__Comment node, strings__Builder* f) {
	if (node.is_multi) {
		string x = builtin__string_trim_space(builtin__string_trim_left(node.text, _S("\001")));
		strings__Builder_writeln(f, _S("/*"));
		strings__Builder_writeln(f, x);
		strings__Builder_write_string(f, _S("*/"));
	} else {
		string s = builtin__string_trim_right(builtin__string_trim_left(node.text, _S("\001")), _S(" "));
		string out_s = _S("//");
		if ((s).len != 0) {
			if (builtin__u8_is_letter(builtin__string_at(s, 0)) || builtin__u8_is_digit(builtin__string_at(s, 0))) {
				out_s = builtin__string__plus(out_s, _S(" "));
			}
			out_s = builtin__string__plus(out_s, s);
		}
		strings__Builder_writeln(f, out_s);
	}
}
VV_LOC string v__ast__shorten_full_name_based_on_aliases(string input, Map_string_string m2a) {
	if (m2a.len == 0 || -1 == builtin__string_index_u8(input, '.')) {
		return input;
	}
	Array_v__ast__StringifyModReplacement replacements = builtin____new_array_with_default(0, m2a.len, sizeof(v__ast__StringifyModReplacement), 0);
	int _t3 = m2a.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = m2a.key_values.len - _t3;
		_t3 = m2a.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&m2a.key_values, _t2)) {continue;}
		string mod = *(string*)builtin__DenseArray_key(&m2a.key_values, _t2);
		mod = builtin__string_clone(mod);
		string alias = (*(string*)builtin__DenseArray_value(&m2a.key_values, _t2));
		if (builtin__string__eq(mod, alias)) {
			continue;
		}
		if (!builtin__string_contains(input, mod)) {
			continue;
		}
		builtin__array_push((array*)&replacements, _MOV((v__ast__StringifyModReplacement[]){ ((v__ast__StringifyModReplacement){.mod = mod,.alias = alias,.weight = (int)((int)(builtin__string_count(mod, _S(".")) * 100) + mod.len),}) }));
	}
	if (replacements.len == 0) {
		return input;
	}
	string res = input;
	if (replacements.len > 1) {
		if (replacements.len > 0) { qsort(replacements.data, replacements.len, replacements.element_size, (voidptr)compare_15770755226076705614_v__ast__StringifyModReplacement_by_weight_reverse); }
		;
	}
	for (int _t7 = 0; _t7 < replacements.len; ++_t7) {
		v__ast__StringifyModReplacement r = ((v__ast__StringifyModReplacement*)replacements.data)[_t7];
		if (-1 == builtin__string_index_u8(res, '.')) {
			break;
		}
		if (!builtin__string_contains(res, r.mod)) {
			continue;
		}
		res = builtin__string_replace(res, r.mod, r.alias);
	}
	return res;
}
string v__ast__StringInterLiteral_get_fspec(v__ast__StringInterLiteral* lit, int i) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	bool needs_fspec = (*(bool*)builtin__array_get(lit->need_fmts, i)) || (*(bool*)builtin__array_get(lit->pluss, i)) || ((*(bool*)builtin__array_get(lit->fills, i)) && (*(int*)builtin__array_get(lit->fwidths, i)) >= 0) || (*(int*)builtin__array_get(lit->fwidths, i)) != 0 || (*(int*)builtin__array_get(lit->precisions, i)) != 987698;
	if (needs_fspec) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S(":") }));
		if ((*(bool*)builtin__array_get(lit->pluss, i))) {
			builtin__array_push((array*)&res, _MOV((string[]){ _S("+") }));
		}
		if ((*(bool*)builtin__array_get(lit->fills, i)) && (*(int*)builtin__array_get(lit->fwidths, i)) >= 0) {
			builtin__array_push((array*)&res, _MOV((string[]){ _S("0") }));
		}
		if ((*(int*)builtin__array_get(lit->fwidths, i)) != 0) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = (*(int*)builtin__array_get(lit->fwidths, i))}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		if ((*(int*)builtin__array_get(lit->precisions, i)) != 987698) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("."), 0xfe07, {.d_i32 = (*(int*)builtin__array_get(lit->precisions, i))}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		if ((*(bool*)builtin__array_get(lit->need_fmts, i))) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe01, {.d_c = (*(u8*)builtin__array_get(lit->fmts, i))}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
	}
	return Array_string_join(res, _S(""));
}
string v__ast__Expr_str(v__ast__Expr x) {
	i64 str_calls = sync__stdatomic__add_i64(&nested_expr_str_calls, 1);
	if (str_calls > 300) {
		return _S("{expression too deep}");
	}
	if (x._typ == 259 /* v.ast.AnonFn */) {
		string _t2 = _S("anon_fn");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t2;
	}
	else if (x._typ == 274 /* v.ast.ComptimeType */) {
		string _t3 = v__ast__ComptimeType_str((*x._v__ast__ComptimeType));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t3;
	}
	else if (x._typ == 276 /* v.ast.DumpExpr */) {
		string _t4 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("dump("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__DumpExpr).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t4;
	}
	else if (x._typ == 261 /* v.ast.ArrayInit */) {
		Array_string fields = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		if ((*x._v__ast__ArrayInit).has_len) {
			builtin__array_push((array*)&fields, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("len: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).len_expr)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		if ((*x._v__ast__ArrayInit).has_cap) {
			builtin__array_push((array*)&fields, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cap: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).cap_expr)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		if ((*x._v__ast__ArrayInit).has_init) {
			builtin__array_push((array*)&fields, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("init: "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ArrayInit).init_expr)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		string typ_str = v__ast__Table_type_to_str(global_table, (*x._v__ast__ArrayInit).elem_type);
		if (fields.len > 0) {
			if ((*x._v__ast__ArrayInit).is_fixed) {
				string _t8 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_v__ast__Expr_str((*x._v__ast__ArrayInit).exprs)}}, {_SLIT0, 0xfe10, {.d_s = typ_str}}, {_S("{"), 0xfe10, {.d_s = Array_string_join(fields, _S(", "))}}, {_S("}"), 0, { .d_c = 0 }}}));
					{ // defer begin
						sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
					} // defer end
				return _t8;
			} else {
				string _t9 = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("[]"), 0xfe10, {.d_s = typ_str}}, {_S("{"), 0xfe10, {.d_s = Array_string_join(fields, _S(", "))}}, {_S("}"), 0, { .d_c = 0 }}}));
					{ // defer begin
						sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
					} // defer end
				return _t9;
			}
		} else {
			if ((*x._v__ast__ArrayInit).is_fixed) {
				string _t10 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_v__ast__Expr_str((*x._v__ast__ArrayInit).exprs)}}, {_SLIT0, 0xfe10, {.d_s = typ_str}}, {_S("{}"), 0, { .d_c = 0 }}}));
					{ // defer begin
						sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
					} // defer end
				return _t10;
			} else {
				string _t11 = Array_v__ast__Expr_str((*x._v__ast__ArrayInit).exprs);
					{ // defer begin
						sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
					} // defer end
				return _t11;
			}
		}
	}
	else if (x._typ == 262 /* v.ast.AsCast */) {
		string _t12 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__AsCast).expr)}}, {_S(" as "), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__AsCast).typ)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t12;
	}
	else if (x._typ == 264 /* v.ast.AtExpr */) {
		string _t13 = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__AtExpr).name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t13;
	}
	else if (x._typ == 266 /* v.ast.CTempVar */) {
		string _t14 = v__ast__Expr_str((*x._v__ast__CTempVar).orig);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t14;
	}
	else if (x._typ == 265 /* v.ast.BoolLiteral */) {
		string _t15 = builtin__bool_str((*x._v__ast__BoolLiteral).val);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t15;
	}
	else if (x._typ == 268 /* v.ast.CastExpr */) {
		string type_name = v__util__strip_main_name(v__ast__Table_type_to_str(global_table, (*x._v__ast__CastExpr).typ));
		string _t16 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = type_name}}, {_S("("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__CastExpr).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t16;
	}
	else if (x._typ == 267 /* v.ast.CallExpr */) {
		string sargs = v__ast__args2str((*x._v__ast__CallExpr).args);
		string propagate_suffix = ((*x._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate_option ? (_S("?")) : (*x._v__ast__CallExpr).or_block.kind == v__ast__OrKind__propagate_result ? (_S("!")) : (_S("")));
		if ((*x._v__ast__CallExpr).is_method) {
			string _t17 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__CallExpr).left)}}, {_S("."), 0xfe10, {.d_s = (*x._v__ast__CallExpr).name}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t17;
		}
		if (builtin__string_starts_with((*x._v__ast__CallExpr).name, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).mod}}, {_S("."), 0, { .d_c = 0 }}})))) {
			string _t18 = v__util__strip_main_name(builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__CallExpr_get_name(&(*x._v__ast__CallExpr))}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}})));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t18;
		}
		if (((*x._v__ast__CallExpr).mod).len == 0 && ((*x._v__ast__CallExpr).name).len == 0) {
			string _t19 = builtin__string__plus(v__ast__Expr_str((*x._v__ast__CallExpr).left), builtin__str_intp(3, _MOV((StrIntpData[]){{_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}})));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t19;
		}
		if (builtin__string_contains((*x._v__ast__CallExpr).name, _S("."))) {
			string _t20 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__CallExpr_get_name(&(*x._v__ast__CallExpr))}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t20;
		}
		if ((*x._v__ast__CallExpr).is_static_method) {
			string _t21 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).mod}}, {_S("."), 0xfe10, {.d_s = v__ast__CallExpr_get_name(&(*x._v__ast__CallExpr))}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t21;
		}
		if (builtin__fast_string_eq((*x._v__ast__CallExpr).mod, _S("main"))) {
			string _t22 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__CallExpr_get_name(&(*x._v__ast__CallExpr))}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t22;
		} else {
			string _t23 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*x._v__ast__CallExpr).mod}}, {_S("."), 0xfe10, {.d_s = v__ast__CallExpr_get_name(&(*x._v__ast__CallExpr))}}, {_S("("), 0xfe10, {.d_s = sargs}}, {_S(")"), 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t23;
		}
	}
	else if (x._typ == 270 /* v.ast.CharLiteral */) {
		string _t24 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = (*x._v__ast__CharLiteral).val}}, {_S("`"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t24;
	}
	else if (x._typ == 271 /* v.ast.Comment */) {
		if ((*x._v__ast__Comment).is_multi) {
			Array_string lines = builtin__string_split_into_lines((*x._v__ast__Comment).text);
			string _t25 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("/* "), 0xfe07, {.d_i32 = lines.len}}, {_S(" lines comment */"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t25;
		} else {
			string text = builtin__string_trim_space(builtin__string_trim((*x._v__ast__Comment).text, _S("\001")));
			string _t26 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\302\264// "), 0xfe10, {.d_s = text}}, {_S("\302\264"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t26;
		}
	}
	else if (x._typ == 273 /* v.ast.ComptimeSelector */) {
		string _t27 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ComptimeSelector).left)}}, {_S(".$("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ComptimeSelector).field_expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t27;
	}
	else if (x._typ == 275 /* v.ast.ConcatExpr */) {
		Array_string _t29 = {0};
		Array_v__ast__Expr _t29_orig = (*x._v__ast__ConcatExpr).vals;
		int _t29_len = _t29_orig.len;
		_t29 = builtin____new_array(0, _t29_len, sizeof(string));

		for (int _t31 = 0; _t31 < _t29_len; ++_t31) {
			v__ast__Expr it = ((v__ast__Expr*) _t29_orig.data)[_t31];
			string _t30 = v__ast__Expr_str(it);
			builtin__array_push((array*)&_t29, &_t30);
		}
		string _t28 = Array_string_join( _t29, _S(","));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t28;
	}
	else if (x._typ == 278 /* v.ast.EnumVal */) {
		string _t32 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("."), 0xfe10, {.d_s = (*x._v__ast__EnumVal).val}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t32;
	}
	else if (x._typ == 279 /* v.ast.FloatLiteral */) {
		string _t33 = builtin__string_clone((*x._v__ast__FloatLiteral).val);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t33;
	}
	else if (x._typ == 286 /* v.ast.IntegerLiteral */) {
		string _t34 = builtin__string_clone((*x._v__ast__IntegerLiteral).val);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t34;
	}
	else if (x._typ == 280 /* v.ast.GoExpr */) {
		string _t35 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("go "), 0xfe10, {.d_s = v__ast__CallExpr_str((*x._v__ast__GoExpr).call_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t35;
	}
	else if (x._typ == 304 /* v.ast.SpawnExpr */) {
		string _t36 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("spawn "), 0xfe10, {.d_s = v__ast__CallExpr_str((*x._v__ast__SpawnExpr).call_expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t36;
	}
	else if (x._typ == 281 /* v.ast.Ident */) {
		if (((*x._v__ast__Ident).cached_name).len == 0) {
			{ // Unsafe block
				(*x._v__ast__Ident).cached_name = v__util__strip_main_name((*x._v__ast__Ident).name);
			}
		}
		string _t37 = builtin__string_clone((*x._v__ast__Ident).cached_name);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t37;
	}
	else if (x._typ == 282 /* v.ast.IfExpr */) {
		Array_string parts = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		string dollar = ((*x._v__ast__IfExpr).is_comptime ? (_S("$")) : (_S("")));
		for (int i = 0; i < (*x._v__ast__IfExpr).branches.len; ++i) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)(*x._v__ast__IfExpr).branches.data)[i];
			if (i != 0) {
				builtin__array_push((array*)&parts, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" } "), 0xfe10, {.d_s = dollar}}, {_S("else "), 0, { .d_c = 0 }}})) }));
			}
			if (i < (int)((*x._v__ast__IfExpr).branches.len - 1) || !(*x._v__ast__IfExpr).has_else) {
				builtin__array_push((array*)&parts, _MOV((string[]){ builtin__string__plus(builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = dollar}}, {_S("if "), 0, { .d_c = 0 }}})), v__ast__Expr_str(branch.cond)), _S(" { ")) }));
			} else if ((*x._v__ast__IfExpr).has_else && i == (int)((*x._v__ast__IfExpr).branches.len - 1)) {
				builtin__array_push((array*)&parts, _MOV((string[]){ _S("{ ") }));
			}
			for (int _t41 = 0; _t41 < branch.stmts.len; ++_t41) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t41];
				builtin__array_push((array*)&parts, _MOV((string[]){ v__ast__Stmt_str(stmt) }));
			}
		}
		builtin__array_push((array*)&parts, _MOV((string[]){ _S(" }") }));
		string _t44 = Array_string_join(parts, _S(""));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t44;
	}
	else if (x._typ == 284 /* v.ast.IndexExpr */) {
		string _t45 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__IndexExpr).left)}}, {_S("["), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__IndexExpr).index)}}, {_S("]"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t45;
	}
	else if (x._typ == 285 /* v.ast.InfixExpr */) {
		string _t46 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__InfixExpr).left)}}, {_S(" "), 0xfe10, {.d_s = v__token__Kind_str((*x._v__ast__InfixExpr).op)}}, {_S(" "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__InfixExpr).right)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t46;
	}
	else if (x._typ == 291 /* v.ast.MapInit */) {
		Array_string pairs = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		for (int ik = 0; ik < (*x._v__ast__MapInit).keys.len; ++ik) {
			v__ast__Expr kv = ((v__ast__Expr*)(*x._v__ast__MapInit).keys.data)[ik];
			string mv = v__ast__Expr_str((*(v__ast__Expr*)builtin__array_get((*x._v__ast__MapInit).vals, ik)));
			builtin__array_push((array*)&pairs, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(kv)}}, {_S(": "), 0xfe10, {.d_s = mv}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		if ((*x._v__ast__MapInit).has_update_expr) {
			string _t48 = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("map{ ..."), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__MapInit).update_expr)}}, {_S(" "), 0xfe10, {.d_s = Array_string_join(pairs, _S(" "))}}, {_S(" }"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t48;
		}
		string _t49 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("map{ "), 0xfe10, {.d_s = Array_string_join(pairs, _S(" "))}}, {_S(" }"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t49;
	}
	else if (x._typ == 293 /* v.ast.Nil */) {
		string _t50 = _S("nil");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t50;
	}
	else if (x._typ == 297 /* v.ast.ParExpr */) {
		string _t51 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__ParExpr).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t51;
	}
	else if (x._typ == 298 /* v.ast.PostfixExpr */) {
		if ((*x._v__ast__PostfixExpr).op == v__token__Kind__question) {
			string _t52 = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__PostfixExpr).expr)}}, {_S(" ?"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t52;
		}
		string _t53 = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__PostfixExpr).expr)}}, {_SLIT0, 0xfe10, {.d_s = v__token__Kind_str((*x._v__ast__PostfixExpr).op)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t53;
	}
	else if (x._typ == 299 /* v.ast.PrefixExpr */) {
		string _t54 = builtin__string__plus(v__token__Kind_str((*x._v__ast__PrefixExpr).op), v__ast__Expr_str((*x._v__ast__PrefixExpr).right));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t54;
	}
	else if (x._typ == 300 /* v.ast.RangeExpr */) {
		string s = _S("..");
		if ((*x._v__ast__RangeExpr).has_low) {
			s = builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__RangeExpr).low)}}, {_S(" "), 0, { .d_c = 0 }}})), s);
		}
		if ((*x._v__ast__RangeExpr).has_high) {
			s = builtin__string__plus(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__RangeExpr).high)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		string _t55 = s;
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t55;
	}
	else if (x._typ == 301 /* v.ast.SelectExpr */) {
		string _t56 = _S("ast.SelectExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t56;
	}
	else if (x._typ == 302 /* v.ast.SelectorExpr */) {
		string propagate_suffix = ((*x._v__ast__SelectorExpr).or_block.kind == v__ast__OrKind__propagate_option ? (_S("?")) : (*x._v__ast__SelectorExpr).or_block.kind == v__ast__OrKind__propagate_result ? (_S("!")) : (_S("")));
		string _t57 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__SelectorExpr).expr)}}, {_S("."), 0xfe10, {.d_s = (*x._v__ast__SelectorExpr).field_name}}, {_SLIT0, 0xfe10, {.d_s = propagate_suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t57;
	}
	else if (x._typ == 303 /* v.ast.SizeOf */) {
		if ((*x._v__ast__SizeOf).is_type) {
			string _t58 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sizeof("), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__SizeOf).typ)}}, {_S(")"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t58;
		}
		string _t59 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sizeof("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__SizeOf).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t59;
	}
	else if (x._typ == 295 /* v.ast.OffsetOf */) {
		string _t60 = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("__offsetof("), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__OffsetOf).struct_type)}}, {_S(", "), 0xfe10, {.d_s = (*x._v__ast__OffsetOf).field}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t60;
	}
	else if (x._typ == 306 /* v.ast.StringInterLiteral */) {
		strings__Builder res = strings__new_builder(50);
		strings__Builder_write_string(&res, _S("'"));
		for (int i = 0; i < (*x._v__ast__StringInterLiteral).vals.len; ++i) {
			string val = ((string*)(*x._v__ast__StringInterLiteral).vals.data)[i];
			strings__Builder_write_string(&res, val);
			if (i >= (*x._v__ast__StringInterLiteral).exprs.len) {
				break;
			}
			strings__Builder_write_string(&res, _S("$"));
			string fspec_str = v__ast__StringInterLiteral_get_fspec(&(*x._v__ast__StringInterLiteral), i);
			strings__Builder_write_string(&res, _S("{"));
			strings__Builder_write_string(&res, v__ast__Expr_str((*(v__ast__Expr*)builtin__array_get((*x._v__ast__StringInterLiteral).exprs, i))));
			strings__Builder_write_string(&res, fspec_str);
			strings__Builder_write_string(&res, _S("}"));
		}
		strings__Builder_write_string(&res, _S("'"));
		string _t61 = strings__Builder_str(&res);
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t61;
	}
	else if (x._typ == 237 /* v.ast.StringLiteral */) {
		string _t62 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("'"), 0xfe10, {.d_s = (*x._v__ast__StringLiteral).val}}, {_S("'"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t62;
	}
	else if (x._typ == 307 /* v.ast.TypeNode */) {
		string opt_prefix = (v__ast__Type_has_flag((*x._v__ast__TypeNode).typ, v__ast__TypeFlag__option) ? (_S("?")) : (_S("")));
		string _t63 = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("TypeNode("), 0xfe10, {.d_s = opt_prefix}}, {_SLIT0, 0xfe10, {.d_s = v__ast__Table_type_str(global_table, (*x._v__ast__TypeNode).typ)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t63;
	}
	else if (x._typ == 308 /* v.ast.TypeOf */) {
		if ((*x._v__ast__TypeOf).is_type) {
			string _t64 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("typeof["), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__TypeOf).typ)}}, {_S("]()"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t64;
		}
		string _t65 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("typeof("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__TypeOf).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t65;
	}
	else if (x._typ == 288 /* v.ast.LambdaExpr */) {
		Array_string _t66 = {0};
		Array_v__ast__Ident _t66_orig = (*x._v__ast__LambdaExpr).params;
		int _t66_len = _t66_orig.len;
		_t66 = builtin____new_array(0, _t66_len, sizeof(string));

		for (int _t68 = 0; _t68 < _t66_len; ++_t68) {
			v__ast__Ident it = ((v__ast__Ident*) _t66_orig.data)[_t68];
			string _t67 = it.name;
			builtin__array_push((array*)&_t66, &_t67);
		}
		string ilist = Array_string_join(_t66, _S(", "));
		string _t69 = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("|"), 0xfe10, {.d_s = ilist}}, {_S("| "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__LambdaExpr).expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t69;
	}
	else if (x._typ == 289 /* v.ast.Likely */) {
		string _t70 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_likely_("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__Likely).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t70;
	}
	else if (x._typ == 309 /* v.ast.UnsafeExpr */) {
		string _t71 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unsafe { "), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__UnsafeExpr).expr)}}, {_S(" }"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t71;
	}
	else if (x._typ == 294 /* v.ast.None */) {
		string _t72 = _S("none");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t72;
	}
	else if (x._typ == 287 /* v.ast.IsRefType */) {
		if ((*x._v__ast__IsRefType).is_type) {
			string _t73 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("isreftype("), 0xfe10, {.d_s = v__ast__Table_type_to_str(global_table, (*x._v__ast__IsRefType).typ)}}, {_S(")"), 0, { .d_c = 0 }}}));
				{ // defer begin
					sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
				} // defer end
			return _t73;
		}
		string _t74 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("isreftype("), 0xfe10, {.d_s = v__ast__Expr_str((*x._v__ast__IsRefType).expr)}}, {_S(")"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t74;
	}
	else if (x._typ == 283 /* v.ast.IfGuardExpr */) {
		string s = _S("");
		for (int i = 0; i < (*x._v__ast__IfGuardExpr).vars.len; ++i) {
			v__ast__IfGuardVar var = ((v__ast__IfGuardVar*)(*x._v__ast__IfGuardExpr).vars.data)[i];
			s = builtin__string__plus(s, var.name);
			if (i != (int)((*x._v__ast__IfGuardExpr).vars.len - 1)) {
				s = builtin__string__plus(s, _S(", "));
			}
		}
		string _t75 = builtin__string__plus(builtin__string__plus(s, _S(" := ")), v__ast__Expr_str((*x._v__ast__IfGuardExpr).expr));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t75;
	}
	else if (x._typ == 236 /* v.ast.StructInit */) {
		string sname = v__ast__Table_sym(global_table, (*x._v__ast__StructInit).typ)->name;
		string _t76 = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sname}}, {_S("{....}"), 0, { .d_c = 0 }}}));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t76;
	}
	else if (x._typ == 260 /* v.ast.ArrayDecompose */) {
		string _t77 = _S("ast.ArrayDecompose");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t77;
	}
	else if (x._typ == 263 /* v.ast.Assoc */) {
		string _t78 = _S("ast.Assoc");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t78;
	}
	else if (x._typ == 269 /* v.ast.ChanInit */) {
		string _t79 = _S("ast.ChanInit");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t79;
	}
	else if (x._typ == 272 /* v.ast.ComptimeCall */) {
		string _t80 = v__ast__ComptimeCall_expr_str((*x._v__ast__ComptimeCall));
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t80;
	}
	else if (x._typ == 277 /* v.ast.EmptyExpr */) {
		string _t81 = _S("ast.EmptyExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t81;
	}
	else if (x._typ == 290 /* v.ast.LockExpr */) {
		string _t82 = _S("ast.LockExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t82;
	}
	else if (x._typ == 292 /* v.ast.MatchExpr */) {
		string _t83 = _S("ast.MatchExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t83;
	}
	else if (x._typ == 258 /* v.ast.NodeError */) {
		string _t84 = _S("ast.NodeError");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t84;
	}
	else if (x._typ == 296 /* v.ast.OrExpr */) {
		string _t85 = _S("ast.OrExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t85;
	}
	else if (x._typ == 305 /* v.ast.SqlExpr */) {
		string _t86 = _S("ast.SqlExpr");
			{ // defer begin
				sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
			} // defer end
		return _t86;
	}
	
	string _t87 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("[unhandled expr type "), 0xfe10, {.d_s = builtin__charptr_vstring_literal(v_typeof_sumtype_v__ast__Expr( (x)._typ ))}}, {_S("]"), 0, { .d_c = 0 }}}));
		{ // defer begin
			sync__stdatomic__sub_i64(&nested_expr_str_calls, 1);
		} // defer end
	return _t87;
}
string v__ast__CallArg_str(v__ast__CallArg a) {
	if (a.is_mut) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("mut "), 0xfe10, {.d_s = v__ast__Expr_str(a.expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(a.expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string v__ast__args2str(Array_v__ast__CallArg args) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < args.len; ++_t1) {
		v__ast__CallArg a = ((v__ast__CallArg*)args.data)[_t1];
		builtin__array_push((array*)&res, _MOV((string[]){ v__ast__CallArg_str(a) }));
	}
	return Array_string_join(res, _S(", "));
}
string v__ast__BranchStmt_str(v__ast__BranchStmt* node) {
	string s = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(node->kind)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if (node->label.len > 0) {
		s = builtin__string__plus(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = node->label}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	return s;
}
string v__ast__Stmt_str(v__ast__Stmt node) {
	if (node._typ == 312 /* v.ast.AssertStmt */) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("assert "), 0xfe10, {.d_s = v__ast__Expr_str((*node._v__ast__AssertStmt).expr)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	else if (node._typ == 313 /* v.ast.AssignStmt */) {
		string out = _S("");
		for (int i = 0; i < (*node._v__ast__AssignStmt).left.len; ++i) {
			v__ast__Expr left = ((v__ast__Expr*)(*node._v__ast__AssignStmt).left.data)[i];
			if ((left)._typ == 281 /* v.ast.Ident */) {
				v__ast__IdentVar var_info = v__ast__Ident_var_info(&(*left._v__ast__Ident));
				if (var_info.is_mut) {
					out = builtin__string__plus(out, _S("mut "));
				}
			}
			out = builtin__string__plus(out, v__ast__Expr_str(left));
			if (i < (int)((*node._v__ast__AssignStmt).left.len - 1)) {
				out = builtin__string__plus(out, _S(","));
			}
		}
		out = builtin__string__plus(out, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = v__token__Kind_str((*node._v__ast__AssignStmt).op)}}, {_S(" "), 0, { .d_c = 0 }}})));
		for (int i = 0; i < (*node._v__ast__AssignStmt).right.len; ++i) {
			v__ast__Expr val = ((v__ast__Expr*)(*node._v__ast__AssignStmt).right.data)[i];
			out = builtin__string__plus(out, v__ast__Expr_str(val));
			if (i < (int)((*node._v__ast__AssignStmt).right.len - 1)) {
				out = builtin__string__plus(out, _S(","));
			}
		}
		return out;
	}
	else if (node._typ == 314 /* v.ast.Block */) {
		string res = _S("");
		res = builtin__string__plus(res, _S("{"));
		for (int _t3 = 0; _t3 < (*node._v__ast__Block).stmts.len; ++_t3) {
			v__ast__Stmt s = ((v__ast__Stmt*)(*node._v__ast__Block).stmts.data)[_t3];
			res = builtin__string__plus(res, v__ast__Stmt_str(s));
			res = builtin__string__plus(res, _S(";"));
		}
		res = builtin__string__plus(res, _S("}"));
		return res;
	}
	else if (node._typ == 315 /* v.ast.BranchStmt */) {
		return v__ast__BranchStmt_str(&(*node._v__ast__BranchStmt));
	}
	else if (node._typ == 231 /* v.ast.ConstDecl */) {
		Array_string _t7 = {0};
		Array_v__ast__ConstField _t7_orig = (*node._v__ast__ConstDecl).fields;
		int _t7_len = _t7_orig.len;
		_t7 = builtin____new_array(0, _t7_len, sizeof(string));

		for (int _t9 = 0; _t9 < _t7_len; ++_t9) {
			v__ast__ConstField it = ((v__ast__ConstField*) _t7_orig.data)[_t9];
			string _t8 = v__ast__field_to_string(it);
			builtin__array_push((array*)&_t7, &_t8);
		}
		return Array_string_join( _t7, _S(""));
	}
	else if (node._typ == 318 /* v.ast.DeferStmt */) {
		string res = _S("");
		res = builtin__string__plus(res, _S("defer {"));
		for (int _t10 = 0; _t10 < (*node._v__ast__DeferStmt).stmts.len; ++_t10) {
			v__ast__Stmt s = ((v__ast__Stmt*)(*node._v__ast__DeferStmt).stmts.data)[_t10];
			res = builtin__string__plus(res, v__ast__Stmt_str(s));
			res = builtin__string__plus(res, _S(";"));
		}
		res = builtin__string__plus(res, _S("}"));
		return res;
	}
	else if (node._typ == 320 /* v.ast.EnumDecl */) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("enum "), 0xfe10, {.d_s = (*node._v__ast__EnumDecl).name}}, {_S(" { "), 0xfe07, {.d_i32 = (*node._v__ast__EnumDecl).fields.len}}, {_S(" fields }"), 0, { .d_c = 0 }}}));
	}
	else if (node._typ == 321 /* v.ast.ExprStmt */) {
		return v__ast__Expr_str((*node._v__ast__ExprStmt).expr);
	}
	else if (node._typ == 229 /* v.ast.FnDecl */) {
		return builtin__str_intp(4, _MOV((StrIntpData[]){{_S("fn "), 0xfe10, {.d_s = (*node._v__ast__FnDecl).name}}, {_S("( "), 0xfe07, {.d_i32 = (*node._v__ast__FnDecl).params.len}}, {_S(" params ) { "), 0xfe07, {.d_i32 = (*node._v__ast__FnDecl).stmts.len}}, {_S(" stmts }"), 0, { .d_c = 0 }}}));
	}
	else if (node._typ == 323 /* v.ast.ForInStmt */) {
		string res = _S("");
		if ((*node._v__ast__ForInStmt).label.len > 0) {
			res = builtin__string__plus(res, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*node._v__ast__ForInStmt).label}}, {_S(": "), 0, { .d_c = 0 }}})));
		}
		res = builtin__string__plus(res, _S("for "));
		if (((*node._v__ast__ForInStmt).key_var).len != 0) {
			res = builtin__string__plus(res, (*node._v__ast__ForInStmt).key_var);
		}
		if (((*node._v__ast__ForInStmt).key_var).len != 0 && ((*node._v__ast__ForInStmt).val_var).len != 0) {
			res = builtin__string__plus(res, _S(", "));
		}
		if (((*node._v__ast__ForInStmt).val_var).len != 0) {
			if ((*node._v__ast__ForInStmt).val_is_mut) {
				res = builtin__string__plus(res, _S("mut "));
			}
			res = builtin__string__plus(res, (*node._v__ast__ForInStmt).val_var);
		}
		res = builtin__string__plus(res, _S(" in "));
		res = builtin__string__plus(res, v__ast__Expr_str((*node._v__ast__ForInStmt).cond));
		if ((*node._v__ast__ForInStmt).is_range) {
			res = builtin__string__plus(res, _S(" .. "));
			res = builtin__string__plus(res, v__ast__Expr_str((*node._v__ast__ForInStmt).high));
		}
		res = builtin__string__plus(res, _S(" {"));
		return res;
	}
	else if (node._typ == 324 /* v.ast.ForStmt */) {
		if ((*node._v__ast__ForStmt).is_inf) {
			return _S("for {");
		}
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("for "), 0xfe10, {.d_s = v__ast__Expr_str((*node._v__ast__ForStmt).cond)}}, {_S(" {"), 0, { .d_c = 0 }}}));
	}
	else if (node._typ == 325 /* v.ast.GlobalDecl */) {
		string res = _S("");
		if ((*node._v__ast__GlobalDecl).fields.len == 0 && (*node._v__ast__GlobalDecl).pos.line_nr == (*node._v__ast__GlobalDecl).pos.last_line) {
			return _S("__global ()");
		}
		res = builtin__string__plus(res, _S("__global "));
		if ((*node._v__ast__GlobalDecl).is_block) {
			res = builtin__string__plus(res, _S("( "));
		}
		for (int _t19 = 0; _t19 < (*node._v__ast__GlobalDecl).fields.len; ++_t19) {
			v__ast__GlobalField field = ((v__ast__GlobalField*)(*node._v__ast__GlobalDecl).fields.data)[_t19];
			if (field.is_volatile) {
				res = builtin__string__plus(res, _S("volatile "));
			}
			res = builtin__string__plus(res, field.name);
			res = builtin__string__plus(res, _S(" "));
			if (field.has_expr) {
				res = builtin__string__plus(res, _S("= "));
				res = builtin__string__plus(res, v__ast__Expr_str(field.expr));
			} else {
				res = builtin__string__plus(res, v__ast__Table_type_to_str(global_table, field.typ));
			}
			res = builtin__string__plus(res, _S(";"));
		}
		if ((*node._v__ast__GlobalDecl).is_block) {
			res = builtin__string__plus(res, _S(" )"));
		}
		return res;
	}
	else if (node._typ == 329 /* v.ast.Import */) {
		string out = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("import "), 0xfe10, {.d_s = (*node._v__ast__Import).mod}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if ((*node._v__ast__Import).alias.len > 0) {
			out = builtin__string__plus(out, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" as "), 0xfe10, {.d_s = (*node._v__ast__Import).alias}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		return out;
	}
	else if (node._typ == 331 /* v.ast.Module */) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("module "), 0xfe10, {.d_s = (*node._v__ast__Module).name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	else if (node._typ == 332 /* v.ast.Return */) {
		string out = _S("return");
		for (int i = 0; i < (*node._v__ast__Return).exprs.len; ++i) {
			v__ast__Expr val = ((v__ast__Expr*)(*node._v__ast__Return).exprs.data)[i];
			out = builtin__string__plus(out, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = v__ast__Expr_str(val)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (i < (int)((*node._v__ast__Return).exprs.len - 1)) {
				out = builtin__string__plus(out, _S(","));
			}
		}
		return out;
	}
	else if (node._typ == 228 /* v.ast.StructDecl */) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("struct "), 0xfe10, {.d_s = (*node._v__ast__StructDecl).name}}, {_S(" { "), 0xfe07, {.d_i32 = (*node._v__ast__StructDecl).fields.len}}, {_S(" fields }"), 0, { .d_c = 0 }}}));
	}
	
	else {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("[unhandled stmt str type: "), 0xfe10, {.d_s = builtin__charptr_vstring_literal(v_typeof_sumtype_v__ast__Stmt( (node)._typ ))}}, {_S(" ]"), 0, { .d_c = 0 }}}));
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string v__ast__field_to_string(v__ast__ConstField f) {
	string x = builtin__string_trim_string_left(f.name, builtin__string__plus(f.mod, _S(".")));
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("const "), 0xfe10, {.d_s = x}}, {_S(" = "), 0xfe10, {.d_s = v__ast__Expr_str(f.expr)}}, {_S(";"), 0, { .d_c = 0 }}}));
}
string v__ast__ComptimeForKind_str(v__ast__ComptimeForKind e) {
	switch (e) {
		case v__ast__ComptimeForKind__methods: {
			return _S("methods");
		}
		case v__ast__ComptimeForKind__fields: {
			return _S("fields");
		}
		case v__ast__ComptimeForKind__attributes: {
			return _S("attributes");
		}
		case v__ast__ComptimeForKind__values: {
			return _S("values");
		}
		case v__ast__ComptimeForKind__variants: {
			return _S("variants");
		}
		case v__ast__ComptimeForKind__params: {
			return _S("params");
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}
void v__ast__UsedFeatures_free(v__ast__UsedFeatures* uf) {
	{ // Unsafe block
		builtin__map_free(&uf->print_types);
		builtin__map_free(&uf->used_fns);
		builtin__map_free(&uf->used_consts);
		builtin__map_free(&uf->used_globals);
		builtin__array_free(&uf->used_veb_types);
	}
}
void v__ast__Table_free(v__ast__Table* t) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < t->type_symbols.len; ++_t1) {
			v__ast__TypeSymbol* s = ((v__ast__TypeSymbol**)t->type_symbols.data)[_t1];
			v__ast__TypeSymbol_free(s);
		}
		builtin__array_free(&t->type_symbols);
		builtin__map_free(&t->type_idxs);
		builtin__map_free(&t->fns);
		builtin__map_free(&t->dumps);
		Array_string_free(&t->imports);
		Array_string_free(&t->modules);
		builtin__array_free(&t->cflags);
		Array_string_free(&t->redefined_fns);
		builtin__map_free(&t->fn_generic_types);
		builtin__string_free(&t->cmod_prefix);
		v__ast__UsedFeatures_free(t->used_features);
		builtin__map_free(&t->unwrap_generic_type_in_depth);
	}
}
VV_LOC void v__ast__default_table_panic_handler(v__ast__Table* _t, string message) {
	builtin___v_panic(message);
	VUNREACHABLE();
}
void v__ast__Table_panic(v__ast__Table* t, string message) {
	v__ast__Table* mt = ((v__ast__Table*)(t));
	mt->panic_npanics++;
	t->panic_handler(t, message);
}
v__ast__Table* v__ast__new_table(void) {
	v__ast__Table* t = ((v__ast__Table*)builtin__memdup(&(v__ast__Table){.module_deprecated = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.unwrap_generic_type_in_depth = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comptime_is_true = builtin__new_map(sizeof(string), sizeof(v__ast__ComptTimeCondResult), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.enum_decls = builtin__new_map(sizeof(string), sizeof(v__ast__EnumDecl), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.fns = builtin__new_map(sizeof(string), sizeof(v__ast__Fn), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.type_idxs = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.export_names = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.anon_struct_names = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.dumps = builtin__new_map(sizeof(int), sizeof(string), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.builtin_pub_fns = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.anon_union_names = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.iface_types = builtin__new_map(sizeof(string), sizeof(Array_v__ast__Type), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.fn_generic_types = builtin__new_map(sizeof(string), sizeof(Array_Array_v__ast__Type), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.interfaces = builtin__new_map(sizeof(int), sizeof(v__ast__InterfaceDecl), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.sumtypes = builtin__new_map(sizeof(int), sizeof(v__ast__SumTypeDecl), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.module_attrs = builtin__new_map(sizeof(string), sizeof(Array_v__ast__Attr), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.vls_info = builtin__new_map(sizeof(string), sizeof(v__ast__VlsInfo), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.filelist = builtin____new_array(0, 0, sizeof(string)),.imports = builtin____new_array(0, 0, sizeof(string)),.modules = builtin____new_array(0, 0, sizeof(string)),.cflags = builtin____new_array(0, 0, sizeof(v__cflag__CFlag)),.redefined_fns = builtin____new_array(0, 0, sizeof(string)),.type_symbols = builtin____new_array(0, 0, sizeof(v__ast__TypeSymbol*)),.cur_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.parsing_type = (string){.str=(byteptr)"", .is_lit=1},.cmod_prefix = (string){.str=(byteptr)"", .is_lit=1},.panic_handler = v__ast__default_table_panic_handler,.used_features = ((v__ast__UsedFeatures*)builtin__memdup(&(v__ast__UsedFeatures){.used_globals = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.used_syms = builtin__new_map(sizeof(int), sizeof(bool), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.comptime_syms = builtin__new_map(sizeof(v__ast__Type), sizeof(bool), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.print_types = builtin__new_map(sizeof(int), sizeof(bool), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.used_fns = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.used_consts = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comptime_calls = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.used_veb_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.used_maps = 0,.used_none = 0,.used_closures = 0,.arr_delete = 0,.arr_reverse = 0,.arr_map = 0,.print_options = 0,.safe_int = 0,.used_attr_noreturn = 0,.used_attr_hidden = 0,.dump = 0,.used_attr_weak = 0,.anon_fn = 0,.auto_str = 0,.auto_str_ptr = 0,.auto_str_arr = 0,.arr_prepend = 0,.arr_insert = 0,.arr_first = 0,.arr_last = 0,.arr_pop_left = 0,.arr_pop = 0,}, sizeof(v__ast__UsedFeatures))),.cached_type_to_str = (__shared__Map_u64_string*)__dup__shared__Map_u64_string(&(__shared__Map_u64_string){.mtx= {0}, .val=builtin__new_map(sizeof(u64), sizeof(string), &builtin__map_hash_int_8, &builtin__map_eq_int_8, &builtin__map_clone_int_8, &builtin__map_free_nop)}, sizeof(__shared__Map_u64_string)),.global_scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = ((void*)0),.detached_from_parent = 0,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope))),.cur_lambda = ((void*)0),.cur_fn = ((void*)0),.panic_userdata = ((void*)0),.anon_union_counter = 0,.veb_res_idx_cache = 0,.veb_ctx_idx_cache = 0,.panic_npanics = 0,.gostmts = 0,.pointer_size = 0,.anon_struct_counter = 0,.new_int_fmt_fix = 0,.new_int = 0,.is_fmt = 0,}, sizeof(v__ast__Table)));
	v__ast__Table_register_builtin_type_symbols(t);
	t->is_fmt = true;
	global_table = t;
	return t;
}
string v__ast__Table_fn_type_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _S("");
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		v__ast__Type typ = v__ast__Type_set_nr_muls(arg.typ, 0);
		if (arg.is_mut) {
			sig = builtin__string__plus(sig, _S("mut_"));
		}
		sig = builtin__string__plus(sig, builtin__string_to_lower_ascii(v__ast__Table_sym(t, typ)->cname));
		if (i < (int)(f->params.len - 1)) {
			sig = builtin__string__plus(sig, _S("_"));
		}
	}
	if (f->return_type != 0 && f->return_type != _const_v__ast__void_type) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(t, f->return_type);
		string opt = (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__option) ? (_S("option_")) : (_S("")));
		string res = (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__result) ? (_S("result_")) : (_S("")));
		sig = builtin__string__plus(sig, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("__"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	return sig;
}
string v__ast__Table_fn_type_source_signature(v__ast__Table* t, v__ast__Fn* f) {
	string sig = _S("(");
	for (int i = 0; i < f->params.len; ++i) {
		v__ast__Param arg = ((v__ast__Param*)f->params.data)[i];
		if (arg.is_mut) {
			sig = builtin__string__plus(sig, _S("mut "));
		}
		if (t->is_fmt && (arg.name).len != 0) {
			sig = builtin__string__plus(sig, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = arg.name}}, {_S(" "), 0, { .d_c = 0 }}})));
		}
		v__ast__TypeSymbol* arg_type_sym = v__ast__Table_sym(t, arg.typ);
		sig = builtin__string__plus(sig, arg_type_sym->name);
		if (i < (int)(f->params.len - 1)) {
			sig = builtin__string__plus(sig, _S(", "));
		}
	}
	sig = builtin__string__plus(sig, _S(")"));
	if (f->return_type == _const_v__ast__ovoid_type) {
		sig = builtin__string__plus(sig, _S(" ?"));
	} else if (f->return_type == _const_v__ast__rvoid_type) {
		sig = builtin__string__plus(sig, _S(" !"));
	} else if (f->return_type != _const_v__ast__void_type && f->return_type != 0) {
		v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, f->return_type);
		if (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__option)) {
			sig = builtin__string__plus(sig, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" ?"), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else if (v__ast__Type_has_flag(f->return_type, v__ast__TypeFlag__result)) {
			sig = builtin__string__plus(sig, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" !"), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			sig = builtin__string__plus(sig, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(" "), 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	return sig;
}
string v__ast__Table_is_same_method(v__ast__Table* t, v__ast__Fn* f, v__ast__Fn* func) {
	if (f->return_type != func->return_type) {
		string s = v__ast__Table_type_to_str(t, f->return_type);
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected return type `"), 0xfe10, {.d_s = s}}, {_S("`"), 0, { .d_c = 0 }}}));
	}
	if (f->params.len != func->params.len) {
		return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("expected "), 0xfe07, {.d_i32 = f->params.len}}, {_S(" parameter(s), not "), 0xfe07, {.d_i32 = func->params.len}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	for (int i = 0; i < f->params.len; ++i) {
		bool has_unexpected_type = i > 0 && v__ast__Table_unaliased_type(t, (*(v__ast__Param*)builtin__array_get(f->params, i)).typ) != v__ast__Table_unaliased_type(t, (*(v__ast__Param*)builtin__array_get(func->params, i)).typ);
		v__ast__TypeSymbol* lsym = v__ast__Table_sym(t, (*(v__ast__Param*)builtin__array_get(f->params, i)).typ);
		v__ast__TypeSymbol* rsym = v__ast__Table_sym(t, (*(v__ast__Param*)builtin__array_get(func->params, i)).typ);
		if (lsym->language == v__ast__Language__js && rsym->language == v__ast__Language__js) {
			return _S("");
		}
		bool has_unexpected_mutability = !(*(v__ast__Param*)builtin__array_get(f->params, i)).is_mut && (*(v__ast__Param*)builtin__array_get(func->params, i)).is_mut;
		if (has_unexpected_type || has_unexpected_mutability) {
			string exps = v__ast__Table_type_to_str(t, (*(v__ast__Param*)builtin__array_get(f->params, i)).typ);
			string gots = v__ast__Table_type_to_str(t, (*(v__ast__Param*)builtin__array_get(func->params, i)).typ);
			if (has_unexpected_type) {
				return builtin__str_intp(4, _MOV((StrIntpData[]){{_S("expected `"), 0xfe10, {.d_s = exps}}, {_S("`, not `"), 0xfe10, {.d_s = gots}}, {_S("` for parameter "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("expected `"), 0xfe10, {.d_s = exps}}, {_S("` which is immutable, not `mut "), 0xfe10, {.d_s = gots}}, {_S("`"), 0, { .d_c = 0 }}}));
			}
		}
	}
	return _S("");
}
_option_v__ast__Fn v__ast__Table_find_fn(v__ast__Table* t, string name) {
	v__ast__Fn* _t2 = (v__ast__Fn*)(builtin__map_get_check(ADDR(map, t->fns), &(string[]){name}));
	_option_v__ast__Fn _t1 = {0};
	if (_t2) {
		*((v__ast__Fn*)&_t1.data) = *((v__ast__Fn*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		v__ast__Fn f = (*(v__ast__Fn*)_t1.data);
		_option_v__ast__Fn _t3;
		builtin___option_ok(&(v__ast__Fn[]) { f }, (_option*)(&_t3), sizeof(v__ast__Fn));
		 
		return _t3;
	}
	return (_option_v__ast__Fn){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__Table_known_fn(v__ast__Table* t, string name) {
	_option_v__ast__Fn _t1 = v__ast__Table_find_fn(t, name);
	if (_t1.state != 0) {
		return false;
	}
	
 ;
	return true;
}
void v__ast__Table_register_fn(v__ast__Table* t, v__ast__Fn new_fn) {
(*(v__ast__Fn*)builtin__map_get_and_set((map*)&t->fns, &(string[]){new_fn.name}, &(v__ast__Fn[]){ (v__ast__Fn){.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.dep_names = builtin____new_array(0, 0, sizeof(string)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.file = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.return_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.receiver_type = 0,.usages = 0,.return_type = 0,.from_embedded_type = 0,.ctdefine_idx = 0,.file_mode = 0,.language = 0,.is_expand_simple_interpolation = 0,.is_c_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_must_use = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.is_static_type_method = 0,.no_body = 0,.is_file_translated = 0,.is_conditional = 0,.is_variadic = 0,} })) = new_fn;
	if (new_fn.is_pub && builtin__fast_string_eq(new_fn.mod, _S("builtin"))) {
		builtin__map_set(&t->builtin_pub_fns, &(string[]){new_fn.name}, &(bool[]) { true });
	}
}
void v__ast__Table_register_interface(v__ast__Table* t, v__ast__InterfaceDecl idecl) {
(*(v__ast__InterfaceDecl*)builtin__map_get_and_set((map*)&t->interfaces, &(int[]){idecl.typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,} })) = idecl;
}
void v__ast__Table_register_sumtype(v__ast__Table* t, v__ast__SumTypeDecl sumtyp) {
(*(v__ast__SumTypeDecl*)builtin__map_get_and_set((map*)&t->sumtypes, &(int[]){sumtyp.typ}, &(v__ast__SumTypeDecl[]){ (v__ast__SumTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.variants = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.is_markused = 0,} })) = sumtyp;
}
int v__ast__TypeSymbol_register_method(v__ast__TypeSymbol* t, v__ast__Fn new_fn) {
	builtin__array_push((array*)&t->methods, _MOV((v__ast__Fn[]){ new_fn }));
	return (int)(t->methods.len - 1);
}
int v__ast__TypeSymbol_update_method(v__ast__TypeSymbol* t, v__ast__Fn f) {
	for (int i = 0; i < t->methods.len; ++i) {
		v__ast__Fn m = ((v__ast__Fn*)t->methods.data)[i];
		if (builtin__string__eq(m.name, f.name)) {
			builtin__array_set(&t->methods, i, &(v__ast__Fn[]) { f });
			return i;
		}
	}
	return -1;
}
_result_v__ast__Fn v__ast__Table_register_aggregate_method(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind__aggregate) {
		v__ast__Table_panic(t, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("table.register_aggregate_method: sym.name: "), 0xfe10, {.d_s = sym->name}}, {_S(", sym.kind: "), 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_S(" is not an aggregate, name: "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__ast__Aggregate agg_info = *(v__ast__Aggregate*)builtin____as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 480);
	bool found_once = false;
	v__ast__Fn new_fn = ((v__ast__Fn){.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.dep_names = builtin____new_array(0, 0, sizeof(string)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.file = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.usages = 0,.return_type = 0,.from_embedded_type = 0,.ctdefine_idx = 0,.file_mode = 0,.language = 0,.is_expand_simple_interpolation = 0,.is_c_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_must_use = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.is_static_type_method = 0,.no_body = 0,.is_file_translated = 0,.is_conditional = 0,.is_variadic = 0,});
	for (int _t1 = 0; _t1 < agg_info.types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1];
		v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
		_option_v__ast__Fn _t2;
		if (_t2 = v__ast__TypeSymbol_find_method(ts, name), _t2.state == 0) {
			v__ast__Fn type_method = *(v__ast__Fn*)_t2.data;
			if (!found_once) {
				found_once = true;
				new_fn = type_method;
			} else if (!v__ast__Fn_method_equals(&new_fn, (voidptr)&type_method)) {
				return (_result_v__ast__Fn){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("method `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_S("."), 0xfe10, {.d_s = name}}, {_S("` signature is different"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
		} else {
			return (_result_v__ast__Fn){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("unknown method: `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_S("."), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	v__ast__TypeSymbol_register_method(sym, new_fn);
	_result_v__ast__Fn _t5;
	builtin___result_ok(&(v__ast__Fn[]) { new_fn }, (_result*)(&_t5), sizeof(v__ast__Fn));
	 
	return _t5;
}
bool v__ast__Table_has_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	_result_v__ast__Fn _t1 = v__ast__Table_find_method(t, s, name);
	if (_t1.is_error) {
		return false;
	}
	
 ;
	return true;
}
_result_v__ast__Fn v__ast__Table_find_method(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		_option_v__ast__Fn _t1;
		if (_t1 = v__ast__TypeSymbol_find_method(ts, name), _t1.state == 0) {
			v__ast__Fn method = *(v__ast__Fn*)_t1.data;
			_result_v__ast__Fn _t2;
			builtin___result_ok(&(v__ast__Fn[]) { method }, (_result*)(&_t2), sizeof(v__ast__Fn));
			 
			return _t2;
		}
		if (ts->kind == v__ast__Kind__aggregate) {
			_result_v__ast__Fn _t3;
			if (_t3 = v__ast__Table_register_aggregate_method(t, ts, name), !_t3.is_error) {
				v__ast__Fn method = *(v__ast__Fn*)_t3.data;
				_result_v__ast__Fn _t4;
				builtin___result_ok(&(v__ast__Fn[]) { method }, (_result*)(&_t4), sizeof(v__ast__Fn));
				 
				return _t4;
			} else {
				IError err = _t3.err;
				return (_result_v__ast__Fn){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
		}
		if (ts->parent_idx == 0) {
			break;
		}
		ts = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, ts->parent_idx));
	}
	return (_result_v__ast__Fn){ .is_error=true, .err=builtin___v_error(_S("unknown method")), .data={E_STRUCT} };
}
Array_Array_v__ast__Type v__ast__Table_get_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, v__ast__GetEmbedsOptions options) {
	Array_Array_v__ast__Type embeds = builtin____new_array_with_default(0, 0, sizeof(Array_v__ast__Type), 0);
	v__ast__TypeSymbol* unalias_sym = ((sym->info)._typ == 482 /* v.ast.Alias */ ? (v__ast__Table_sym(t, (*sym->info._v__ast__Alias).parent_type)) : (sym));
	if ((unalias_sym->info)._typ == 457 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < (*unalias_sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*unalias_sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			Array_v__ast__Type preceding = builtin__array_clone_to_depth(&options.preceding, 0);
			builtin__array_push((array*)&preceding, _MOV((v__ast__Type[]){ embed }));
			_PUSH_MANY(&embeds, (v__ast__Table_get_embeds(t, embed_sym, ((v__ast__GetEmbedsOptions){.preceding = preceding,}))), _t3, Array_Array_v__ast__Type);
		}
		if ((*unalias_sym->info._v__ast__Struct).embeds.len == 0 && options.preceding.len > 0) {
			builtin__array_push((array*)&embeds, _MOV((Array_v__ast__Type[]){ options.preceding }));
		}
	}
	return embeds;
}
_result_multi_return_v__ast__Fn_Array_v__ast__Type v__ast__Table_find_method_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name) {
	if ((sym->info)._typ == 457 /* v.ast.Struct */) {
		Array_v__ast__Fn found_methods = builtin____new_array_with_default(0, 0, sizeof(v__ast__Fn), 0);
		Array_v__ast__Type embed_of_found_methods = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_option_v__ast__Fn _t2;
			if (_t2 = v__ast__TypeSymbol_find_method_with_generic_parent(embed_sym, method_name), _t2.state == 0) {
				v__ast__Fn m = *(v__ast__Fn*)_t2.data;
				builtin__array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ m }));
				builtin__array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
			} else {
				_result_multi_return_v__ast__Fn_Array_v__ast__Type _t5 = v__ast__Table_find_method_from_embeds(t, embed_sym, method_name);
				if (_t5.is_error) {
					continue;
				}
				
 				multi_return_v__ast__Fn_Array_v__ast__Type mr_12668 = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)_t5.data);
				v__ast__Fn method = mr_12668.arg0;
				Array_v__ast__Type types = mr_12668.arg1;
				builtin__array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ method }));
				builtin__array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
				_PUSH_MANY(&embed_of_found_methods, (types), _t8, Array_v__ast__Type);
			}
		}
		if (found_methods.len == 1) {
			_result_multi_return_v__ast__Fn_Array_v__ast__Type _t9;
			builtin___result_ok(&(multi_return_v__ast__Fn_Array_v__ast__Type[]) { (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=(*(v__ast__Fn*)builtin__array_get(found_methods, 0)), .arg1=embed_of_found_methods} }, (_result*)(&_t9), sizeof(multi_return_v__ast__Fn_Array_v__ast__Type));
			return _t9;
		} else if (found_methods.len > 1) {
			return (_result_multi_return_v__ast__Fn_Array_v__ast__Type){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ambiguous method `"), 0xfe10, {.d_s = method_name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((sym->info)._typ == 485 /* v.ast.Interface */) {
		Array_v__ast__Fn found_methods = builtin____new_array_with_default(0, 0, sizeof(v__ast__Fn), 0);
		Array_v__ast__Type embed_of_found_methods = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		for (int _t11 = 0; _t11 < (*sym->info._v__ast__Interface).embeds.len; ++_t11) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Interface).embeds.data)[_t11];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_option_v__ast__Fn _t12;
			if (_t12 = v__ast__TypeSymbol_find_method_with_generic_parent(embed_sym, method_name), _t12.state == 0) {
				v__ast__Fn m = *(v__ast__Fn*)_t12.data;
				builtin__array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ m }));
				builtin__array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
			} else {
				_result_multi_return_v__ast__Fn_Array_v__ast__Type _t15 = v__ast__Table_find_method_from_embeds(t, embed_sym, method_name);
				if (_t15.is_error) {
					continue;
				}
				
 				multi_return_v__ast__Fn_Array_v__ast__Type mr_13345 = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)_t15.data);
				v__ast__Fn method = mr_13345.arg0;
				Array_v__ast__Type types = mr_13345.arg1;
				builtin__array_push((array*)&found_methods, _MOV((v__ast__Fn[]){ method }));
				builtin__array_push((array*)&embed_of_found_methods, _MOV((v__ast__Type[]){ embed }));
				_PUSH_MANY(&embed_of_found_methods, (types), _t18, Array_v__ast__Type);
			}
		}
		if (found_methods.len == 1) {
			_result_multi_return_v__ast__Fn_Array_v__ast__Type _t19;
			builtin___result_ok(&(multi_return_v__ast__Fn_Array_v__ast__Type[]) { (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=(*(v__ast__Fn*)builtin__array_get(found_methods, 0)), .arg1=embed_of_found_methods} }, (_result*)(&_t19), sizeof(multi_return_v__ast__Fn_Array_v__ast__Type));
			return _t19;
		} else if (found_methods.len > 1) {
			return (_result_multi_return_v__ast__Fn_Array_v__ast__Type){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ambiguous method `"), 0xfe10, {.d_s = method_name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((sym->info)._typ == 480 /* v.ast.Aggregate */) {
		for (int _t21 = 0; _t21 < (*sym->info._v__ast__Aggregate).types.len; ++_t21) {
			v__ast__Type typ = ((v__ast__Type*)(*sym->info._v__ast__Aggregate).types.data)[_t21];
			v__ast__TypeSymbol* agg_sym = v__ast__Table_sym(t, typ);
			_result_multi_return_v__ast__Fn_Array_v__ast__Type _t22 = v__ast__Table_find_method_from_embeds(t, agg_sym, method_name);
			if (_t22.is_error) {
				continue;
			}
			
 			multi_return_v__ast__Fn_Array_v__ast__Type mr_13810 = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)_t22.data);
			v__ast__Fn method = mr_13810.arg0;
			Array_v__ast__Type embed_types = mr_13810.arg1;
			if (embed_types.len != 0) {
				_result_multi_return_v__ast__Fn_Array_v__ast__Type _t23;
				builtin___result_ok(&(multi_return_v__ast__Fn_Array_v__ast__Type[]) { (multi_return_v__ast__Fn_Array_v__ast__Type){.arg0=method, .arg1=embed_types} }, (_result*)(&_t23), sizeof(multi_return_v__ast__Fn_Array_v__ast__Type));
				return _t23;
			}
		}
	}
	return (_result_multi_return_v__ast__Fn_Array_v__ast__Type){ .is_error=true, .err=builtin___v_error(_S("")), .data={E_STRUCT} };
}
_result_v__ast__Fn v__ast__Table_find_method_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string method_name) {
	_result_v__ast__Fn _t1;
	if (_t1 = v__ast__Table_find_method(t, sym, method_name), !_t1.is_error) {
		v__ast__Fn func = *(v__ast__Fn*)_t1.data;
		_result_v__ast__Fn _t2;
		builtin___result_ok(&(v__ast__Fn[]) { func }, (_result*)(&_t2), sizeof(v__ast__Fn));
		 
		return _t2;
	} else {
		_result_multi_return_v__ast__Fn_Array_v__ast__Type _t3 = v__ast__Table_find_method_from_embeds(t, sym, method_name);
		if (_t3.is_error) {
			IError err = _t3.err;
			return (_result_v__ast__Fn){ .is_error=true, .err=err, .data={E_STRUCT} };
		}
		
 		multi_return_v__ast__Fn_Array_v__ast__Type mr_14257 = (*(multi_return_v__ast__Fn_Array_v__ast__Type*)_t3.data);
		v__ast__Fn func = mr_14257.arg0;
		_result_v__ast__Fn _t5;
		builtin___result_ok(&(v__ast__Fn[]) { func }, (_result*)(&_t5), sizeof(v__ast__Fn));
		 
		return _t5;
	}
	return (_result_v__ast__Fn){0};
}
_option_i64 v__ast__Table_find_enum_field_val(v__ast__Table* t, string name, string field_) {
	i64 val = ((i64)(0));
	v__ast__EnumDecl enum_decl = (*(v__ast__EnumDecl*)builtin__map_get(ADDR(map, t->enum_decls), &(string[]){name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,} }));
	Array_i64 enum_vals = builtin____new_array_with_default(0, 0, sizeof(i64), 0);
	for (int _t1 = 0; _t1 < enum_decl.fields.len; ++_t1) {
		v__ast__EnumField field = ((v__ast__EnumField*)enum_decl.fields.data)[_t1];
		if (builtin__string__eq(field.name, field_)) {
			if (field.has_expr) {
				if ((field.expr)._typ == 286 /* v.ast.IntegerLiteral */) {
					val = builtin__string_i64((*field.expr._v__ast__IntegerLiteral).val);
					break;
				}
				return (_option_i64){ .state=2, .err=_const_none__, .data={E_STRUCT} };
			} else {
				if (enum_vals.len > 0) {
					val = (i64)((*(i64*)builtin__array_last(enum_vals)) + 1);
				} else {
					val = 0;
				}
				break;
			}
		} else {
			if (field.has_expr) {
				if ((field.expr)._typ == 286 /* v.ast.IntegerLiteral */) {
					builtin__array_push((array*)&enum_vals, _MOV((i64[]){ builtin__string_i64((*field.expr._v__ast__IntegerLiteral).val) }));
				} else {
					return (_option_i64){ .state=2, .err=_const_none__, .data={E_STRUCT} };
				}
			} else {
				if (enum_vals.len > 0) {
					builtin__array_push((array*)&enum_vals, _MOV((i64[]){ (i64)((*(i64*)builtin__array_last(enum_vals)) + 1) }));
				} else {
					builtin__array_push((array*)&enum_vals, _MOV((i64[]){ 0 }));
				}
			}
		}
	}
	_option_i64 _t8; /* if prepend */
	if (enum_decl.is_flag) {
		builtin___option_ok(&(i64[]) { ((i64)((((u64)(1)) << ((u64)(val))))) }, (_option*)(&_t8), sizeof(i64));
		goto _t9;
	};
	{
		builtin___option_ok(&(i64[]) { val }, (_option*)(&_t8), sizeof(i64));
	}
	_t9: {};
		return _t8;
}
Array_string v__ast__Table_get_enum_field_names(v__ast__Table* t, string name) {
	v__ast__EnumDecl enum_decl = (*(v__ast__EnumDecl*)builtin__map_get(ADDR(map, t->enum_decls), &(string[]){name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,} }));
	Array_string field_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < enum_decl.fields.len; ++_t1) {
		v__ast__EnumField field = ((v__ast__EnumField*)enum_decl.fields.data)[_t1];
		builtin__array_push((array*)&field_names, _MOV((string[]){ builtin__string_clone(field.name) }));
	}
	return field_names;
}
Array_i64 v__ast__Table_get_enum_field_vals(v__ast__Table* t, string name) {
	v__ast__EnumDecl enum_decl = (*(v__ast__EnumDecl*)builtin__map_get(ADDR(map, t->enum_decls), &(string[]){name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,} }));
	Array_i64 enum_vals = builtin____new_array_with_default(0, 0, sizeof(i64), 0);
	i64 last_val = ((i64)(0));
	for (int _t1 = 0; _t1 < enum_decl.fields.len; ++_t1) {
		v__ast__EnumField field = ((v__ast__EnumField*)enum_decl.fields.data)[_t1];
		if (field.has_expr) {
			if ((field.expr)._typ == 286 /* v.ast.IntegerLiteral */) {
				builtin__array_push((array*)&enum_vals, _MOV((i64[]){ builtin__string_i64((*field.expr._v__ast__IntegerLiteral).val) }));
				last_val = builtin__string_i64((*field.expr._v__ast__IntegerLiteral).val);
			}
		} else {
			if (enum_vals.len > 0) {
				builtin__array_push((array*)&enum_vals, _MOV((i64[]){ (i64)(last_val + 1) }));
				last_val++;
			} else {
				builtin__array_push((array*)&enum_vals, _MOV((i64[]){ 0 }));
			}
		}
	}
	return enum_vals;
}
Array_v__ast__Fn v__ast__Table_get_embed_methods(v__ast__Table* t, v__ast__TypeSymbol* sym) {
	Array_v__ast__Fn methods = builtin____new_array_with_default(0, 0, sizeof(v__ast__Fn), 0);
	if ((sym->info)._typ == 457 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_PUSH_MANY(&methods, (embed_sym->methods), _t2, Array_v__ast__Fn);
			_PUSH_MANY(&methods, (v__ast__Table_get_embed_methods(t, embed_sym)), _t3, Array_v__ast__Fn);
		}
	}
	return methods;
}
VV_LOC _result_v__ast__StructField v__ast__Table_register_aggregate_field(v__ast__Table* t, v__ast__TypeSymbol* sym, string name) {
	if (sym->kind != v__ast__Kind__aggregate) {
		v__ast__Table_panic(t, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("table.register_aggregate_field: sym.name: "), 0xfe10, {.d_s = sym->name}}, {_S(", sym.kind: "), 0xfe10, {.d_s = v__ast__Kind_str(sym->kind)}}, {_S(" is not an aggregate, name: "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	v__ast__Aggregate agg_info = *(v__ast__Aggregate*)builtin____as_cast((sym->info)._v__ast__Aggregate,(sym->info)._typ, 480);
	bool found_once = false;
	v__ast__StructField new_field = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,});
	for (int _t1 = 0; _t1 < agg_info.types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)agg_info.types.data)[_t1];
		v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
		_result_v__ast__StructField _t2;
		if (_t2 = v__ast__Table_find_field(t, ts, name), !_t2.is_error) {
			v__ast__StructField type_field = *(v__ast__StructField*)_t2.data;
			if (!found_once) {
				found_once = true;
				new_field = type_field;
			} else if (new_field.typ != type_field.typ) {
				return (_result_v__ast__StructField){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("field `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_S("."), 0xfe10, {.d_s = name}}, {_S("` type is different"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
			}
			new_field = ((v__ast__StructField){.anon_struct_decl = (new_field).anon_struct_decl,.attrs = (new_field).attrs,.pre_comments = (new_field).pre_comments,.comments = (new_field).comments,.next_comments = (new_field).next_comments,.default_val = (new_field).default_val,.name = (new_field).name,.default_expr = (new_field).default_expr,.pos = (new_field).pos,.type_pos = (new_field).type_pos,.option_pos = (new_field).option_pos,.default_expr_typ = (new_field).default_expr_typ,.container_typ = (new_field).container_typ,.typ = (new_field).typ,.unaliased_typ = (new_field).unaliased_typ,.i = (new_field).i,.is_pub = new_field.is_pub && type_field.is_pub,.has_break_line = (new_field).has_break_line,.is_recursive = (new_field).is_recursive,.is_mut = new_field.is_mut && type_field.is_mut,.has_prev_newline = (new_field).has_prev_newline,.has_default_expr = (new_field).has_default_expr,.is_part_of_union = (new_field).is_part_of_union,.is_global = (new_field).is_global,.is_volatile = (new_field).is_volatile,.is_deprecated = (new_field).is_deprecated,.is_embed = (new_field).is_embed,});
		} else {
			return (_result_v__ast__StructField){ .is_error=true, .err=builtin___v_error(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("type `"), 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_S("` has no field or method `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	}
	builtin__array_push((array*)&agg_info.fields, _MOV((v__ast__StructField[]){ new_field }));
	_result_v__ast__StructField _t6;
	builtin___result_ok(&(v__ast__StructField[]) { new_field }, (_result*)(&_t6), sizeof(v__ast__StructField));
	 
	return _t6;
}
bool v__ast__Table_struct_has_field(v__ast__Table* t, v__ast__TypeSymbol* struct_, string name) {
	_result_v__ast__StructField _t1 = v__ast__Table_find_field(t, struct_, name);
	if (_t1.is_error) {
		return false;
	}
	
 ;
	return true;
}
Array_v__ast__StructField v__ast__Table_struct_fields(v__ast__Table* t, v__ast__TypeSymbol* sym) {
	Array_v__ast__StructField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	if ((sym->info)._typ == 457 /* v.ast.Struct */) {
		_PUSH_MANY(&fields, ((*sym->info._v__ast__Struct).fields), _t1, Array_v__ast__StructField);
		for (int _t2 = 0; _t2 < (*sym->info._v__ast__Struct).embeds.len; ++_t2) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t2];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_PUSH_MANY(&fields, (v__ast__Table_struct_fields(t, embed_sym)), _t3, Array_v__ast__StructField);
		}
	}
	return fields;
}
_result_v__ast__StructField v__ast__Table_find_field(v__ast__Table* t, v__ast__TypeSymbol* s, string name) {
	v__ast__TypeSymbol* ts = s;
	for (;;) {
		if (ts->info._typ == 457 /* v.ast.Struct */) {
			_option_v__ast__StructField _t1;
			if (_t1 = v__ast__Struct_find_field((*ts->info._v__ast__Struct), name), _t1.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t1.data;
				_result_v__ast__StructField _t2;
				builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t2), sizeof(v__ast__StructField));
				 
				return _t2;
			}
		}
		else if (ts->info._typ == 480 /* v.ast.Aggregate */) {
			_option_v__ast__StructField _t3;
			if (_t3 = v__ast__Aggregate_find_field(&(*ts->info._v__ast__Aggregate), name), _t3.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t3.data;
				_result_v__ast__StructField _t4;
				builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t4), sizeof(v__ast__StructField));
				 
				return _t4;
			}
			_result_v__ast__StructField _t5 = v__ast__Table_register_aggregate_field(t, ts, name);
			if (_t5.is_error) {
				IError err = _t5.err;
				return (_result_v__ast__StructField){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			v__ast__StructField field = (*(v__ast__StructField*)_t5.data);
			_result_v__ast__StructField _t7;
			builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t7), sizeof(v__ast__StructField));
			 
			return _t7;
		}
		else if (ts->info._typ == 485 /* v.ast.Interface */) {
			_option_v__ast__StructField _t8;
			if (_t8 = v__ast__Interface_find_field(&(*ts->info._v__ast__Interface), name), _t8.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t8.data;
				_result_v__ast__StructField _t9;
				builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t9), sizeof(v__ast__StructField));
				 
				return _t9;
			}
		}
		else if (ts->info._typ == 486 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, ts);
			_option_v__ast__StructField _t10;
			if (_t10 = v__ast__SumType_find_sum_type_field(&(*ts->info._v__ast__SumType), name), _t10.state == 0) {
				v__ast__StructField field = *(v__ast__StructField*)_t10.data;
				_result_v__ast__StructField _t11;
				builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t11), sizeof(v__ast__StructField));
				 
				return _t11;
			}
			string missing_variants = v__ast__Table_find_missing_variants(t, (voidptr)&(*ts->info._v__ast__SumType), name);
			return (_result_v__ast__StructField){ .is_error=true, .err=builtin___v_error(builtin__str_intp(4, _MOV((StrIntpData[]){{_S("field `"), 0xfe10, {.d_s = name}}, {_S("` does not exist or have the same type in these sumtype `"), 0xfe10, {.d_s = ts->name}}, {_S("` variants: "), 0xfe10, {.d_s = missing_variants}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
		
		else {
		}
		
		if (ts->parent_idx == 0) {
			break;
		}
		ts = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, ts->parent_idx));
	}
	return (_result_v__ast__StructField){ .is_error=true, .err=builtin___v_error(_S("")), .data={E_STRUCT} };
}
_result_multi_return_v__ast__StructField_Array_v__ast__Type v__ast__Table_find_field_from_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name) {
	if ((sym->info)._typ == 457 /* v.ast.Struct */) {
		Array_v__ast__StructField found_fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		Array_v__ast__Type embeds_of_found_fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		for (int _t1 = 0; _t1 < (*sym->info._v__ast__Struct).embeds.len; ++_t1) {
			v__ast__Type embed = ((v__ast__Type*)(*sym->info._v__ast__Struct).embeds.data)[_t1];
			v__ast__TypeSymbol* embed_sym = v__ast__Table_sym(t, embed);
			_result_v__ast__StructField _t2;
			if (_t2 = v__ast__Table_find_field(t, embed_sym, field_name), !_t2.is_error) {
				v__ast__StructField field = *(v__ast__StructField*)_t2.data;
				builtin__array_push((array*)&found_fields, _MOV((v__ast__StructField[]){ field }));
				builtin__array_push((array*)&embeds_of_found_fields, _MOV((v__ast__Type[]){ embed }));
			} else {
				_result_multi_return_v__ast__StructField_Array_v__ast__Type _t5 = v__ast__Table_find_field_from_embeds(t, embed_sym, field_name);
				if (_t5.is_error) {
					continue;
				}
				
 				multi_return_v__ast__StructField_Array_v__ast__Type mr_19231 = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)_t5.data);
				v__ast__StructField field = mr_19231.arg0;
				Array_v__ast__Type types = mr_19231.arg1;
				builtin__array_push((array*)&found_fields, _MOV((v__ast__StructField[]){ field }));
				builtin__array_push((array*)&embeds_of_found_fields, _MOV((v__ast__Type[]){ embed }));
				_PUSH_MANY(&embeds_of_found_fields, (types), _t8, Array_v__ast__Type);
			}
		}
		if (found_fields.len == 1) {
			_result_multi_return_v__ast__StructField_Array_v__ast__Type _t9;
			builtin___result_ok(&(multi_return_v__ast__StructField_Array_v__ast__Type[]) { (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=(*(v__ast__StructField*)builtin__array_get(found_fields, 0)), .arg1=embeds_of_found_fields} }, (_result*)(&_t9), sizeof(multi_return_v__ast__StructField_Array_v__ast__Type));
			return _t9;
		} else if (found_fields.len > 1) {
			return (_result_multi_return_v__ast__StructField_Array_v__ast__Type){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ambiguous field `"), 0xfe10, {.d_s = field_name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
		}
	} else if ((sym->info)._typ == 480 /* v.ast.Aggregate */) {
		for (int _t11 = 0; _t11 < (*sym->info._v__ast__Aggregate).types.len; ++_t11) {
			v__ast__Type typ = ((v__ast__Type*)(*sym->info._v__ast__Aggregate).types.data)[_t11];
			v__ast__TypeSymbol* agg_sym = v__ast__Table_sym(t, typ);
			_result_multi_return_v__ast__StructField_Array_v__ast__Type _t12 = v__ast__Table_find_field_from_embeds(t, agg_sym, field_name);
			if (_t12.is_error) {
				continue;
			}
			
 			multi_return_v__ast__StructField_Array_v__ast__Type mr_19686 = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)_t12.data);
			v__ast__StructField field = mr_19686.arg0;
			Array_v__ast__Type embed_types = mr_19686.arg1;
			if (embed_types.len > 0) {
				_result_multi_return_v__ast__StructField_Array_v__ast__Type _t13;
				builtin___result_ok(&(multi_return_v__ast__StructField_Array_v__ast__Type[]) { (multi_return_v__ast__StructField_Array_v__ast__Type){.arg0=field, .arg1=embed_types} }, (_result*)(&_t13), sizeof(multi_return_v__ast__StructField_Array_v__ast__Type));
				return _t13;
			}
		}
	} else if ((sym->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* unalias_sym = v__ast__Table_sym(t, (*sym->info._v__ast__Alias).parent_type);
		return v__ast__Table_find_field_from_embeds(t, unalias_sym, field_name);
	}
	return (_result_multi_return_v__ast__StructField_Array_v__ast__Type){ .is_error=true, .err=builtin___v_error(_S("")), .data={E_STRUCT} };
}
_result_v__ast__StructField v__ast__Table_find_field_with_embeds(v__ast__Table* t, v__ast__TypeSymbol* sym, string field_name) {
	_result_v__ast__StructField _t1;
	if (_t1 = v__ast__Table_find_field(t, sym, field_name), !_t1.is_error) {
		v__ast__StructField field = *(v__ast__StructField*)_t1.data;
		_result_v__ast__StructField _t2;
		builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t2), sizeof(v__ast__StructField));
		 
		return _t2;
	} else {
		IError err = _t1.err;
		IError first_err = err;
		_result_multi_return_v__ast__StructField_Array_v__ast__Type _t3 = v__ast__Table_find_field_from_embeds(t, sym, field_name);
		if (_t3.is_error) {
			return (_result_v__ast__StructField){ .is_error=true, .err=first_err, .data={E_STRUCT} };
		}
		
 		multi_return_v__ast__StructField_Array_v__ast__Type mr_20289 = (*(multi_return_v__ast__StructField_Array_v__ast__Type*)_t3.data);
		v__ast__StructField field = mr_20289.arg0;
		_result_v__ast__StructField _t5;
		builtin___result_ok(&(v__ast__StructField[]) { field }, (_result*)(&_t5), sizeof(v__ast__StructField));
		 
		return _t5;
	}
	return (_result_v__ast__StructField){0};
}
void v__ast__Table_resolve_common_sumtype_fields(v__ast__Table* t, v__ast__TypeSymbol* sym) {
	v__ast__SumType info = *(v__ast__SumType*)builtin____as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 486);
	if (info.found_fields) {
		return;
	}
	Map_string_v__ast__StructField field_map = builtin__new_map(sizeof(string), sizeof(v__ast__StructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	Map_string_int field_usages = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (int _t1 = 0; _t1 < info.variants.len; ++_t1) {
		v__ast__Type variant = ((v__ast__Type*)info.variants.data)[_t1];
		v__ast__TypeSymbol* v_sym = v__ast__Table_final_sym(t, variant);
		Array_v__ast__StructField _t2 = builtin____new_array(0, 0, sizeof(v__ast__StructField));
		if (v_sym->info._typ == 457 /* v.ast.Struct */) {
			_t2 = v__ast__Table_struct_fields(t, v_sym);
		}
		else if (v_sym->info._typ == 486 /* v.ast.SumType */) {
			v__ast__Table_resolve_common_sumtype_fields(t, v_sym);
			_t2 = (*v_sym->info._v__ast__SumType).fields;
		}
		
		else {
			_t2 = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
		}
		Array_v__ast__StructField fields = _t2;
		for (int _t3 = 0; _t3 < fields.len; ++_t3) {
			v__ast__StructField field = ((v__ast__StructField*)fields.data)[_t3];
			if (!_IN_MAP(ADDR(string, field.name), ADDR(map, field_map))) {
(*(v__ast__StructField*)builtin__map_get_and_set((map*)&field_map, &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.anon_struct_decl = (v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.option_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,} })) = field;
				(*(int*)builtin__map_get_and_set((map*)&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			} else if (v__ast__StructField_equals(&field, (voidptr)&(*(v__ast__StructField*)builtin__map_get(ADDR(map, field_map), &(string[]){field.name}, &(v__ast__StructField[]){ (v__ast__StructField){.anon_struct_decl = (v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.option_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,} })))) {
				(*(int*)builtin__map_get_and_set((map*)&field_usages, &(string[]){field.name}, &(int[]){ 0 }))++;
			}
		}
	}
	int _t5 = field_usages.key_values.len;
	for (int _t4 = 0; _t4 < _t5; ++_t4 ) {
		int _t6 = field_usages.key_values.len - _t5;
		_t5 = field_usages.key_values.len;
		if (_t6 < 0) {
			_t4 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&field_usages.key_values, _t4)) {continue;}
		string field = *(string*)builtin__DenseArray_key(&field_usages.key_values, _t4);
		field = builtin__string_clone(field);
		int nr_definitions = (*(int*)builtin__DenseArray_value(&field_usages.key_values, _t4));
		if (nr_definitions == info.variants.len) {
			builtin__array_push((array*)&info.fields, _MOV((v__ast__StructField[]){ (*(v__ast__StructField*)builtin__map_get((map*)&field_map, &(string[]){field}, &(v__ast__StructField[]){ (v__ast__StructField){.anon_struct_decl = (v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.option_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,} })) }));
		}
	}
	info.found_fields = true;
	sym->info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(&info, false);
}
inline v__ast__Type v__ast__Table_find_type(v__ast__Table* t, string name) {
	return v__ast__idx_to_type((*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 })));
}
inline int v__ast__Table_find_type_idx(v__ast__Table* t, string name) {
	return (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
}
inline int v__ast__Table_find_type_idx_fn_scoped(v__ast__Table* t, string name, v__ast__Scope* scope) {
	if (scope != ((void*)0)) {
		int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){builtin__str_intp(3, _MOV((StrIntpData[]){{_S("_"), 0xfe10, {.d_s = name}}, {_S("_"), 0xfe07, {.d_i32 = scope->start_pos}}, {_SLIT0, 0, { .d_c = 0 }}}))}, &(int[]){ 0 }));
		if (idx != 0) {
			return idx;
		}
	}
	return (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
}
inline _option_v__ast__TypeSymbol_ptr v__ast__Table_find_sym(v__ast__Table* t, string name) {
	int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (idx > 0) {
		_option_v__ast__TypeSymbol_ptr _t1;
		builtin___option_ok(&(v__ast__TypeSymbol*[]) { (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx)) }, (_option*)(&_t1), sizeof(v__ast__TypeSymbol*));
		 
		return _t1;
	}
	return (_option_v__ast__TypeSymbol_ptr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
inline multi_return_ref_v__ast__TypeSymbol_int v__ast__Table_find_sym_and_type_idx(v__ast__Table* t, string name) {
	int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (idx > 0) {
		return (multi_return_ref_v__ast__TypeSymbol_int){.arg0=(*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx)), .arg1=idx};
	}
	return (multi_return_ref_v__ast__TypeSymbol_int){.arg0=_const_v__ast__invalid_type_symbol, .arg1=idx};
}
inline v__ast__TypeSymbol* v__ast__Table_sym_by_idx(v__ast__Table* t, int idx) {
	return (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx));
}
v__ast__TypeSymbol* v__ast__Table_sym(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0 && idx < t->type_symbols.len) {
		return ((v__ast__TypeSymbol**)t->type_symbols.data)[idx];
	}
	v__ast__Table_panic(t, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("table.sym: invalid type (typ="), 0xfe10, {.d_s = v__ast__Type_str(typ)}}, {_S(" idx="), 0xfe07, {.d_i32 = idx}}, {_S("). Compiler bug. This should never happen. Please report the bug using `v bug file.v`.\n"), 0, { .d_c = 0 }}})));
	return _const_v__ast__invalid_type_symbol;
}
v__ast__TypeSymbol* v__ast__Table_final_sym(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0 && idx < t->type_symbols.len) {
		v__ast__TypeSymbol* cur_sym = ((v__ast__TypeSymbol**)t->type_symbols.data)[idx];
		if ((cur_sym->info)._typ == 482 /* v.ast.Alias */) {
			idx = v__ast__Type_idx((*cur_sym->info._v__ast__Alias).parent_type);
		}
		return ((v__ast__TypeSymbol**)t->type_symbols.data)[idx];
	}
	v__ast__Table_panic(t, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("table.final_sym: invalid type (typ="), 0xfe10, {.d_s = v__ast__Type_str(typ)}}, {_S(" idx="), 0xfe07, {.d_i32 = idx}}, {_S("). Compiler bug. This should never happen. Please report the bug using `v bug file.v`."), 0, { .d_c = 0 }}})));
	return _const_v__ast__invalid_type_symbol;
}
v__ast__Type v__ast__Table_final_type(v__ast__Table* t, v__ast__Type typ) {
	int idx = v__ast__Type_idx(typ);
	if (idx > 0 && idx < t->type_symbols.len) {
		v__ast__TypeSymbol* cur_sym = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx));
		if ((cur_sym->info)._typ == 482 /* v.ast.Alias */) {
			idx = v__ast__Type_idx((*cur_sym->info._v__ast__Alias).parent_type);
			v__ast__TypeSymbol* aliased_sym = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx));
			if ((aliased_sym->info)._typ == 490 /* v.ast.Enum */) {
				return (*aliased_sym->info._v__ast__Enum).typ;
			}
			return (*cur_sym->info._v__ast__Alias).parent_type;
		} else if ((cur_sym->info)._typ == 490 /* v.ast.Enum */) {
			return (*cur_sym->info._v__ast__Enum).typ;
		}
	}
	return typ;
}
inline string v__ast__Table_get_type_name(v__ast__Table* t, v__ast__Type typ) {
	return v__ast__Table_sym(t, typ)->name;
}
inline string v__ast__Table_get_final_type_name(v__ast__Table* t, v__ast__Type typ) {
	return v__ast__Table_final_sym(t, typ)->name;
}
inline v__ast__Type v__ast__Table_unalias_num_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if ((sym->info)._typ == 482 /* v.ast.Alias */) {
		if ((*sym->info._v__ast__Alias).parent_type <= _const_v__ast__char_type && (*sym->info._v__ast__Alias).parent_type >= _const_v__ast__void_type) {
			return (*sym->info._v__ast__Alias).parent_type;
		}
	}
	return typ;
}
inline v__ast__Type v__ast__Table_unaliased_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if ((sym->info)._typ == 482 /* v.ast.Alias */) {
		return (*sym->info._v__ast__Alias).parent_type;
	}
	return typ;
}
void v__ast__Table_update_sym_by_idx(v__ast__Table* t, int existing_idx, v__ast__TypeSymbol* sym) {
	v__ast__Table_delete_cached_type_to_str(t, v__ast__idx_to_type(existing_idx), 0);
	builtin__array_set(&t->type_symbols, existing_idx, &(v__ast__TypeSymbol*[]) { ((v__ast__TypeSymbol*)builtin__memdup(&(v__ast__TypeSymbol){.generic_types = (sym)->generic_types,.methods = (sym)->methods,.mod = (sym)->mod,.name = (sym)->name,.cname = (sym)->cname,.rname = (sym)->rname,.ngname = (sym)->ngname,.info = (sym)->info,.align = -1,.idx = existing_idx,.size = -1,.parent_idx = (sym)->parent_idx,.kind = (sym)->kind,.language = (sym)->language,.is_pub = (sym)->is_pub,.is_builtin = (sym)->is_builtin,}, sizeof(v__ast__TypeSymbol))) });
	for (int _t1 = 0; _t1 < t->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* esym = ((v__ast__TypeSymbol**)t->type_symbols.data)[_t1];
		if (esym->size != -1 && (esym->info)._typ == 482 /* v.ast.Alias */ && _us32_eq((*(v__ast__Alias*)builtin____as_cast((esym->info)._v__ast__Alias,(esym->info)._typ, 482)).parent_type,existing_idx)) {
			esym->size = -1;
			esym->align = -1;
		}
	}
}
VV_LOC int v__ast__Table_rewrite_already_registered_symbol(v__ast__Table* t, v__ast__TypeSymbol typ, int existing_idx) {
	v__ast__TypeSymbol* existing_symbol = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, existing_idx));
	if (existing_symbol->kind == v__ast__Kind__placeholder) {
		builtin__array_set(&t->type_symbols, existing_idx, &(v__ast__TypeSymbol*[]) { ((v__ast__TypeSymbol*)builtin__memdup(&(v__ast__TypeSymbol){.generic_types = (typ).generic_types,.methods = existing_symbol->methods,.mod = (typ).mod,.name = (typ).name,.cname = (typ).cname,.rname = (typ).rname,.ngname = (typ).ngname,.info = (typ).info,.align = (typ).align,.idx = existing_idx,.size = (typ).size,.parent_idx = (typ).parent_idx,.kind = (typ).kind,.language = (typ).language,.is_pub = (typ).is_pub,.is_builtin = existing_symbol->is_builtin,}, sizeof(v__ast__TypeSymbol))) });
		return existing_idx;
	}
	if ((existing_idx >= 21 && existing_idx <= 24) || existing_idx == 30) {
		if (existing_idx == 21) {
			{ // Unsafe block
				*existing_symbol = ((v__ast__TypeSymbol){.generic_types = (typ).generic_types,.methods = (typ).methods,.mod = (typ).mod,.name = (typ).name,.cname = (typ).cname,.rname = (typ).rname,.ngname = (typ).ngname,.info = (typ).info,.align = (typ).align,.idx = existing_idx,.size = (typ).size,.parent_idx = (typ).parent_idx,.kind = existing_symbol->kind,.language = (typ).language,.is_pub = (typ).is_pub,.is_builtin = existing_symbol->is_builtin,});
			}
		} else {
			builtin__array_set(&t->type_symbols, existing_idx, &(v__ast__TypeSymbol*[]) { ((v__ast__TypeSymbol*)builtin__memdup(&(v__ast__TypeSymbol){.generic_types = (typ).generic_types,.methods = (typ).methods,.mod = (typ).mod,.name = (typ).name,.cname = (typ).cname,.rname = (typ).rname,.ngname = (typ).ngname,.info = (typ).info,.align = (typ).align,.idx = existing_idx,.size = (typ).size,.parent_idx = (typ).parent_idx,.kind = (typ).kind,.language = (typ).language,.is_pub = (typ).is_pub,.is_builtin = existing_symbol->is_builtin,}, sizeof(v__ast__TypeSymbol))) });
		}
		return existing_idx;
	}
	return _const_v__ast__invalid_type_idx;
}
inline int v__ast__Table_register_sym(v__ast__Table* t, v__ast__TypeSymbol sym) {
	int idx = -2;
	string sym_name = ((sym.info)._typ == 457 /* v.ast.Struct */ && ((*(v__ast__Struct*)builtin____as_cast((sym.info)._v__ast__Struct,(sym.info)._typ, 457)).scoped_name).len != 0 ? ((*sym.info._v__ast__Struct).scoped_name) : (sym.name));
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){sym_name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		idx = v__ast__Table_rewrite_already_registered_symbol(t, sym, existing_idx);
		if (idx != -2) {
			return idx;
		}
	}
	if (builtin__fast_string_eq(sym.mod, _S("main"))) {
		existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){builtin__string_trim_string_left(sym_name, _S("main."))}, &(int[]){ 0 }));
		if (existing_idx > 0) {
			idx = v__ast__Table_rewrite_already_registered_symbol(t, sym, existing_idx);
			if (idx != -2) {
				return idx;
			}
		}
	}
	idx = t->type_symbols.len;
	builtin__array_push((array*)&t->type_symbols, _MOV((v__ast__TypeSymbol*[]){ ((v__ast__TypeSymbol*)builtin__memdup(&(v__ast__TypeSymbol){.generic_types = (sym).generic_types,.methods = (sym).methods,.mod = (sym).mod,.name = (sym).name,.cname = (sym).cname,.rname = (sym).rname,.ngname = (sym).ngname,.info = (sym).info,.align = (sym).align,.idx = (sym).idx,.size = (sym).size,.parent_idx = (sym).parent_idx,.kind = (sym).kind,.language = (sym).language,.is_pub = (sym).is_pub,.is_builtin = (sym).is_builtin,}, sizeof(v__ast__TypeSymbol))) }));
	(*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->idx = idx;
	if (((*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->ngname).len == 0) {
		(*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->ngname = v__ast__strip_generic_params(sym.name);
	}
	builtin__map_set(&t->type_idxs, &(string[]){sym_name}, &(int[]) { idx });
	return idx;
}
inline void v__ast__Table_register_enum_decl(v__ast__Table* t, v__ast__EnumDecl enum_decl) {
(*(v__ast__EnumDecl*)builtin__map_get_and_set((map*)&t->enum_decls, &(string[]){enum_decl.name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,} })) = enum_decl;
}
inline void v__ast__Table_register_anon_struct(v__ast__Table* t, string name, int sym_idx) {
	builtin__map_set(&t->anon_struct_names, &(string[]){name}, &(int[]) { sym_idx });
}
inline void v__ast__Table_register_anon_union(v__ast__Table* t, string name, int sym_idx) {
	builtin__map_set(&t->anon_union_names, &(string[]){name}, &(int[]) { sym_idx });
}
bool v__ast__Table_known_type(v__ast__Table* t, string name) {
	return (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 })) != 0 || builtin__string__eq(t->parsing_type, name) || (_SLIT_EQ(name.str, name.len, "i32") || _SLIT_EQ(name.str, name.len, "byte"));
}
inline string v__ast__strip_generic_params(string name) {
	return builtin__string_all_before(name, _S("["));
}
void v__ast__Table_start_parsing_type(v__ast__Table* t, string type_name) {
	t->parsing_type = type_name;
}
void v__ast__Table_reset_parsing_type(v__ast__Table* t) {
	t->parsing_type = _S("");
}
bool v__ast__Table_known_type_idx(v__ast__Table* t, v__ast__Type typ) {
	if (typ == 0) {
		return false;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);

	if (sym->kind == (v__ast__Kind__placeholder)) {
		return sym->language != v__ast__Language__v || builtin__string_starts_with(sym->name, _S("C."));
	}
	else if (sym->kind == (v__ast__Kind__array)) {
		return v__ast__Table_known_type_idx(t, (*(v__ast__Array*)builtin____as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 452)).elem_type);
	}
	else if (sym->kind == (v__ast__Kind__array_fixed)) {
		return v__ast__Table_known_type_idx(t, (*(v__ast__ArrayFixed*)builtin____as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 491)).elem_type);
	}
	else if (sym->kind == (v__ast__Kind__map)) {
		v__ast__Map info = *(v__ast__Map*)builtin____as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 453);
		return v__ast__Table_known_type_idx(t, info.key_type) && v__ast__Table_known_type_idx(t, info.value_type);
	}
	else {
	}
	return true;
}
inline string v__ast__Table_array_name(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(elem_type))) : (_S("")));
	string opt = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__option) ? (_S("?")) : (_S("")));
	string res = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__result) ? (_S("!")) : (_S("")));
	string name = ((elem_type_sym->info)._typ == 457 /* v.ast.Struct */ && ((*(v__ast__Struct*)builtin____as_cast((elem_type_sym->info)._v__ast__Struct,(elem_type_sym->info)._typ, 457)).scoped_name).len != 0 ? ((*elem_type_sym->info._v__ast__Struct).scoped_name) : (elem_type_sym->name));
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("[]"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_array_cname(v__ast__Table* t, v__ast__Type elem_type) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string suffix = (v__ast__Type_is_ptr(elem_type) ? (builtin__string_repeat(_S("_ptr"), v__ast__Type_nr_muls(elem_type))) : (_S("")));
	string opt = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__option) ? (_S("_option_")) : (_S("")));
	string res = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__result) ? (_S("_result_")) : (_S("")));
	string cname = v__ast__TypeSymbol_scoped_cname(elem_type_sym);
	if (builtin__string_contains(elem_type_sym->cname, _S("["))) {
		string type_name = builtin__string_replace_each(cname, _const_v__ast__map_cname_escape_seq);
		return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("Array_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("Array_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = cname}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string v__ast__Table_array_fixed_name(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = (v__ast__Type_is_ptr(elem_type) ? (builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(elem_type))) : (_S("")));
	string opt = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__option) ? (_S("?")) : (_S("")));
	string res = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__result) ? (_S("!")) : (_S("")));
	string size_str = ((size_expr)._typ == 277 /* v.ast.EmptyExpr */ || !(size == 0 || size == 987654321) ? (builtin__int_str(size)) : (v__ast__Expr_str(size_expr)));
	string name = ((elem_type_sym->info)._typ == 457 /* v.ast.Struct */ && ((*(v__ast__Struct*)builtin____as_cast((elem_type_sym->info)._v__ast__Struct,(elem_type_sym->info)._typ, 457)).scoped_name).len != 0 ? ((*elem_type_sym->info._v__ast__Struct).scoped_name) : (elem_type_sym->name));
	return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("["), 0xfe10, {.d_s = size_str}}, {_S("]"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_array_fixed_cname(v__ast__Table* t, v__ast__Type elem_type, int size) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string suffix = (v__ast__Type_is_ptr(elem_type) ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_ptr"), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(elem_type)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_S("")));
	string opt = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__option) ? (_S("_option_")) : (_S("")));
	string res = (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__result) ? (_S("_result_")) : (_S("")));
	string cname = v__ast__TypeSymbol_scoped_cname(elem_type_sym);
	if (builtin__string_contains(elem_type_sym->cname, _S("["))) {
		string type_name = builtin__string_replace_each(cname, _const_v__ast__map_cname_escape_seq);
		return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("Array_fixed_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_S("_"), 0xfe07, {.d_i32 = size}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("Array_fixed_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = cname}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_S("_"), 0xfe07, {.d_i32 = size}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline string v__ast__Table_chan_name(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string ptr = _S("");
	if (is_mut) {
		ptr = _S("mut ");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		ptr = _S("&");
	}
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("chan "), 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = elem_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_chan_cname(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(t, elem_type);
	string suffix = _S("");
	if (is_mut) {
		suffix = _S("_mut");
	} else if (v__ast__Type_is_ptr(elem_type)) {
		suffix = _S("_ptr");
	}
	string type_name = (builtin__string_contains(elem_type_sym->cname, _S("[")) ? (builtin__string_replace_each(elem_type_sym->cname, _const_v__ast__map_cname_escape_seq)) : (elem_type_sym->cname));
	return builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("chan_"), 0xfe10, {.d_s = type_name}}, {_SLIT0, 0, { .d_c = 0 }}})), suffix);
}
inline string v__ast__Table_promise_name(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_idx(return_type) == 1) {
		return _S("Promise[JS.Any, JS.Any]");
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Promise["), 0xfe10, {.d_s = return_type_sym->name}}, {_S(", JS.Any]"), 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_promise_cname(v__ast__Table* t, v__ast__Type return_type) {
	if (return_type == _const_v__ast__void_type) {
		return _S("Promise_Any_Any");
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Promise_"), 0xfe10, {.d_s = return_type_sym->name}}, {_S("_Any"), 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_thread_name(v__ast__Table* t, v__ast__Type return_type) {
	if (v__ast__Type_idx(return_type) == 1) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__option)) {
			return _S("thread ?");
		} else if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__result)) {
			return _S("thread !");
		} else {
			return _S("thread");
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string ptr = (v__ast__Type_is_ptr(return_type) ? (_S("&")) : (_S("")));
	string opt = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__option) ? (_S("?")) : (_S("")));
	string res = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__result) ? (_S("!")) : (_S("")));
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("thread "), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = return_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_thread_cname(v__ast__Table* t, v__ast__Type return_type) {
	if (return_type == _const_v__ast__void_type) {
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__option)) {
			return _S("__v_thread_Option_void");
		} else if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__result)) {
			return _S("__v_thread_Result_void");
		} else {
			return _S("__v_thread");
		}
	}
	v__ast__TypeSymbol* return_type_sym = v__ast__Table_sym(t, return_type);
	string suffix = (v__ast__Type_is_ptr(return_type) ? (_S("_ptr")) : (_S("")));
	string opt = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__option) ? (_S("_option_")) : (_S("")));
	string res = (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__result) ? (_S("_result_")) : (_S("")));
	return builtin__str_intp(5, _MOV((StrIntpData[]){{_S("__v_thread_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = return_type_sym->cname}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_map_name(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_sym(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_sym(t, value_type);
	string ptr = (v__ast__Type_is_ptr(value_type) ? (builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(value_type))) : (_S("")));
	string opt = (v__ast__Type_has_flag(value_type, v__ast__TypeFlag__option) ? (_S("?")) : (_S("")));
	string res = (v__ast__Type_has_flag(value_type, v__ast__TypeFlag__result) ? (_S("!")) : (_S("")));
	return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("map["), 0xfe10, {.d_s = key_type_sym->name}}, {_S("]"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = ptr}}, {_SLIT0, 0xfe10, {.d_s = value_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
inline string v__ast__Table_map_cname(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	v__ast__TypeSymbol* key_type_sym = v__ast__Table_sym(t, key_type);
	v__ast__TypeSymbol* value_type_sym = v__ast__Table_sym(t, value_type);
	string suffix = (v__ast__Type_is_ptr(value_type) ? (builtin__string_repeat(_S("_ptr"), v__ast__Type_nr_muls(value_type))) : (_S("")));
	string opt = (v__ast__Type_has_flag(value_type, v__ast__TypeFlag__option) ? (_S("_option_")) : (_S("")));
	string res = (v__ast__Type_has_flag(value_type, v__ast__TypeFlag__result) ? (_S("_result_")) : (_S("")));
	if (builtin__string_contains(value_type_sym->cname, _S("["))) {
		string type_name = builtin__string_replace_each(value_type_sym->cname, _const_v__ast__map_cname_escape_seq);
		return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("Map_"), 0xfe10, {.d_s = key_type_sym->cname}}, {_S("_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = type_name}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		return builtin__str_intp(6, _MOV((StrIntpData[]){{_S("Map_"), 0xfe10, {.d_s = key_type_sym->cname}}, {_S("_"), 0xfe10, {.d_s = opt}}, {_SLIT0, 0xfe10, {.d_s = res}}, {_SLIT0, 0xfe10, {.d_s = value_type_sym->cname}}, {_SLIT0, 0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
int v__ast__Table_find_or_register_chan(v__ast__Table* t, v__ast__Type elem_type, bool is_mut) {
	string name = v__ast__Table_chan_name(t, elem_type, is_mut);
	string cname = v__ast__Table_chan_cname(t, elem_type, is_mut);
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__ast__TypeSymbol chan_sym = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Chan_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Chan, (((v__ast__Chan){.elem_type = elem_type,.is_mut = is_mut,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = _const_v__ast__chan_type_idx,
		.kind = v__ast__Kind__chan,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	});
	return v__ast__Table_register_sym(t, chan_sym);
}
int v__ast__Table_find_or_register_map(v__ast__Table* t, v__ast__Type key_type, v__ast__Type value_type) {
	string name = v__ast__Table_map_name(t, key_type, value_type);
	string cname = v__ast__Table_map_cname(t, key_type, value_type);
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__ast__TypeSymbol map_sym = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Map_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Map, (((v__ast__Map){.key_type = key_type,.value_type = value_type,.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = _const_v__ast__map_type_idx,
		.kind = v__ast__Kind__map,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	});
	return v__ast__Table_register_sym(t, map_sym);
}
int v__ast__Table_find_or_register_thread(v__ast__Table* t, v__ast__Type return_type) {
	string name = v__ast__Table_thread_name(t, return_type);
	string cname = v__ast__Table_thread_cname(t, return_type);
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__ast__TypeSymbol thread_sym = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, (((v__ast__Thread){.return_type = return_type,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = _const_v__ast__thread_type_idx,
		.kind = v__ast__Kind__thread,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	});
	return v__ast__Table_register_sym(t, thread_sym);
}
int v__ast__Table_find_or_register_promise(v__ast__Table* t, v__ast__Type return_type) {
	string name = v__ast__Table_promise_name(t, return_type);
	string cname = v__ast__Table_promise_cname(t, return_type);
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__ast__TypeSymbol promise_type = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, (((v__ast__Struct){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Type)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.concrete_types = builtin__new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){return_type, (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){_S("JS.Any")}, &(int[]){ 0 }))})),.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.parent_type = 0,.is_anon = 0,.is_generic = 0,.is_shared = 0,.is_markused = 0,.has_option = 0,.is_heap = 0,.is_union = 0,.is_minify = 0,.is_typedef = 0,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){_S("Promise")}, &(int[]){ 0 })),
		.kind = v__ast__Kind__struct,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	});
	return v__ast__Table_register_sym(t, promise_type);
}
int v__ast__Table_find_or_register_array(v__ast__Table* t, v__ast__Type elem_type) {
	string name = v__ast__Table_array_name(t, elem_type);
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	string cname = v__ast__Table_array_cname(t, elem_type);
	v__ast__TypeSymbol array_type_ = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Array_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Array, (((v__ast__Array){.nr_dims = 1,.elem_type = elem_type,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = _const_v__ast__array_type_idx,
		.kind = v__ast__Kind__array,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	});
	return v__ast__Table_register_sym(t, array_type_);
}
int v__ast__Table_find_or_register_array_with_dims(v__ast__Table* t, v__ast__Type elem_type, int nr_dims) {
	if (nr_dims == 1) {
		return v__ast__Table_find_or_register_array(t, elem_type);
	}
	return v__ast__Table_find_or_register_array(t, v__ast__idx_to_type(v__ast__Table_find_or_register_array_with_dims(t, elem_type, (int)(nr_dims - 1))));
}
int v__ast__Table_find_or_register_array_fixed(v__ast__Table* t, v__ast__Type elem_type, int size, v__ast__Expr size_expr, bool is_fn_ret) {
	string prefix = (is_fn_ret ? (_S("_v_")) : (_S("")));
	string name = builtin__string__plus(prefix, v__ast__Table_array_fixed_name(t, elem_type, size, size_expr));
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	string cname = builtin__string__plus(prefix, v__ast__Table_array_fixed_cname(t, elem_type, size));
	v__ast__TypeSymbol array_fixed_type = ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.name = name,.cname = cname,.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = v__ast__strip_generic_params(name),.info = v__ast__ArrayFixed_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__ArrayFixed, (((v__ast__ArrayFixed){.size_expr = size_expr,.size = size,.elem_type = elem_type,.is_fn_ret = is_fn_ret,}))), false),.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__array_fixed,.language = 0,.is_pub = 0,.is_builtin = 0,});
	return v__ast__Table_register_sym(t, array_fixed_type);
}
int v__ast__Table_find_or_register_multi_return(v__ast__Table* t, Array_v__ast__Type mr_typs) {
	string name = _S("(");
	string cname = _S("multi_return");
	for (int i = 0; i < mr_typs.len; ++i) {
		v__ast__Type mr_typ = ((v__ast__Type*)mr_typs.data)[i];
		v__ast__TypeSymbol* mr_type_sym = v__ast__Table_sym(t, v__ast__mktyp(mr_typ));
		multi_return_string_string mr_38368 = (v__ast__Type_is_ptr(mr_typ) ? ((multi_return_string_string){.arg0=_S("&"),.arg1=_S("ref_")}) : ((multi_return_string_string){.arg0=_S(""),.arg1=_S("")}));
		string ref = mr_38368.arg0;
		string cref = mr_38368.arg1;
		name = builtin__string__plus(name, (v__ast__Type_has_flag(mr_typ, v__ast__TypeFlag__option) ? (_S("?")) : (_S(""))));
		name = builtin__string__plus(name, (v__ast__Type_has_flag(mr_typ, v__ast__TypeFlag__result) ? (_S("!")) : (_S(""))));
		name = builtin__string__plus(name, builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ref}}, {_SLIT0, 0xfe10, {.d_s = mr_type_sym->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		cname = builtin__string__plus(cname, (v__ast__Type_has_flag(mr_typ, v__ast__TypeFlag__option) ? (_S("_option")) : (_S(""))));
		cname = builtin__string__plus(cname, (v__ast__Type_has_flag(mr_typ, v__ast__TypeFlag__result) ? (_S("_result")) : (_S(""))));
		cname = builtin__string__plus(cname, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("_"), 0xfe10, {.d_s = cref}}, {_SLIT0, 0xfe10, {.d_s = mr_type_sym->cname}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (i < (int)(mr_typs.len - 1)) {
			name = builtin__string__plus(name, _S(", "));
		}
	}
	name = builtin__string__plus(name, _S(")"));
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	v__ast__TypeSymbol multireg_sym = ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.name = name,.cname = cname,.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = v__ast__strip_generic_params(name),.info = v__ast__MultiReturn_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__MultiReturn, (((v__ast__MultiReturn){.types = mr_typs,}))), false),.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__multi_return,.language = 0,.is_pub = 0,.is_builtin = 0,});
	return v__ast__Table_register_sym(t, multireg_sym);
}
int v__ast__Table_find_or_register_fn_type(v__ast__Table* t, v__ast__Fn f, bool is_anon, bool has_decl) {
	string name = ((f.name).len == 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("fn "), 0xfe10, {.d_s = v__ast__Table_fn_type_source_signature(t, (voidptr)&f)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (builtin__string_clone(f.name)));
	string cname = ((f.name).len == 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("anon_fn_"), 0xfe10, {.d_s = v__ast__Table_fn_type_signature(t, (voidptr)&f)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (builtin__string_replace_each(v__util__no_dots(builtin__string_clone(f.name)), _const_v__ast__fn_type_escape_seq)));
	bool anon = (f.name).len == 0 || is_anon;
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){name}, &(int[]){ 0 }));
	if (existing_idx > 0 && (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, existing_idx))->kind != v__ast__Kind__placeholder) {
		if (((*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, existing_idx))->info)._typ == 495 /* v.ast.FnType */ && !has_decl) {
			(*(*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, existing_idx))->info._v__ast__FnType).has_decl = has_decl;
		}
		return existing_idx;
	}
	return v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = f.mod,
		.name = name,
		.cname = cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__FnType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__FnType, (((v__ast__FnType){.is_anon = anon,.has_decl = has_decl,.func = f,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__function,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	}));
}
int v__ast__Table_find_or_register_generic_inst(v__ast__Table* t, v__ast__Type parent_typ, Array_v__ast__Type concrete_types) {
	v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, parent_typ);
	if ((parent_sym->info)._typ != 457 /* v.ast.Struct */) {
		return 0;
	}
	v__ast__Struct struct_info = *(v__ast__Struct*)builtin____as_cast((parent_sym->info)._v__ast__Struct,(parent_sym->info)._typ, 457);
	if (struct_info.generic_types.len == 0 || concrete_types.len != struct_info.generic_types.len) {
		return 0;
	}
	string inst_name = builtin__string__plus(parent_sym->ngname, _S("["));
	string inst_cname = builtin__string__plus(parent_sym->cname, _S("_T_"));
	for (int i = 0; i < concrete_types.len; ++i) {
		v__ast__Type ct = ((v__ast__Type*)concrete_types.data)[i];
		v__ast__TypeSymbol* ct_sym = v__ast__Table_sym(t, ct);
		inst_name = builtin__string__plus(inst_name, ct_sym->name);
		inst_cname = builtin__string__plus(inst_cname, ct_sym->cname);
		if (i < (int)(concrete_types.len - 1)) {
			inst_name = builtin__string__plus(inst_name, _S(", "));
			inst_cname = builtin__string__plus(inst_cname, _S("_T_"));
		}
	}
	inst_name = builtin__string__plus(inst_name, _S("]"));
	int existing_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){inst_name}, &(int[]){ 0 }));
	if (existing_idx > 0) {
		return existing_idx;
	}
	return v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = parent_sym->mod,
		.name = inst_name,
		.cname = inst_cname,
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = parent_sym->ngname,
		.info = v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__GenericInst, (((v__ast__GenericInst){.parent_idx = v__ast__Type_idx(parent_typ),.concrete_types = concrete_types,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__generic_inst,
		.language = 0,
		.is_pub = 0,
		.is_builtin = 0,
	}));
}
int v__ast__Table_add_placeholder_type(v__ast__Table* t, string name, string cname, v__ast__Language language) {
	string modname = _S("");
	if (builtin__string_contains(name, _S("."))) {
		modname = builtin__string_all_before_last(name, _S("."));
	}
	v__ast__TypeSymbol placeholder_sym = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = modname,
		.name = name,
		.cname = builtin__string_replace_each(v__util__no_dots(cname), builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("&"), _S("")}))),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__placeholder,
		.language = language,
		.is_pub = true,
		.is_builtin = (Array_string_contains(_const_v__ast__builtins, name)),
	});
	return v__ast__Table_register_sym(t, placeholder_sym);
}
inline v__ast__Type v__ast__Table_value_type(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_final_sym(t, typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		v__ast__Array array_info = *(v__ast__Array*)builtin____as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 452);
		return array_info.elem_type;
	}
	if (sym->kind == v__ast__Kind__array) {
		v__ast__Array info = *(v__ast__Array*)builtin____as_cast((sym->info)._v__ast__Array,(sym->info)._typ, 452);
		return info.elem_type;
	}
	if (sym->kind == v__ast__Kind__array_fixed) {
		v__ast__ArrayFixed info = *(v__ast__ArrayFixed*)builtin____as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 491);
		return info.elem_type;
	}
	if (sym->kind == v__ast__Kind__map) {
		v__ast__Map info = *(v__ast__Map*)builtin____as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 453);
		return info.value_type;
	}
	if (sym->kind == v__ast__Kind__string && v__ast__Type_is_ptr(typ)) {
		return _const_v__ast__string_type;
	}
	if (sym->kind == v__ast__Kind__byteptr || sym->kind == v__ast__Kind__string) {
		return _const_v__ast__u8_type;
	}
	if (v__ast__Type_is_ptr(typ)) {
		return v__ast__Type_deref(typ);
	}
	return _const_v__ast__void_type;
}
void v__ast__Table_register_fn_generic_types(v__ast__Table* t, string fn_name) {
	(*(Array_Array_v__ast__Type*)builtin__map_get_and_set((map*)&t->fn_generic_types, &(string[]){fn_name}, &(Array_Array_v__ast__Type[]){ builtin____new_array(0, 0, sizeof(Array_v__ast__Type)) })) = builtin____new_array_with_default(0, 0, sizeof(Array_v__ast__Type), 0);
}
bool v__ast__Table_register_fn_concrete_types(v__ast__Table* t, string fn_name, Array_v__ast__Type types) {
	Array_Array_v__ast__Type* _t2 = (Array_Array_v__ast__Type*)(builtin__map_get_check(ADDR(map, t->fn_generic_types), &(string[]){fn_name}));
	_option_Array_Array_v__ast__Type _t1 = {0};
	if (_t2) {
		*((Array_Array_v__ast__Type*)&_t1.data) = *((Array_Array_v__ast__Type*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t1.state != 0) {
		return false;
	}
	
	Array_Array_v__ast__Type a = (*(Array_Array_v__ast__Type*)_t1.data);
	if ((Array_Array_v__ast__Type_contains(a, types))) {
		return false;
	}
	builtin__array_push((array*)&a, &types);
	(*(Array_Array_v__ast__Type*)builtin__map_get_and_set((map*)&t->fn_generic_types, &(string[]){fn_name}, &(Array_Array_v__ast__Type[]){ builtin____new_array(0, 0, sizeof(Array_v__ast__Type)) })) = a;
	return true;
}
bool v__ast__Table_sumtype_has_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type variant, bool is_as) {
	v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, parent);
	if (parent_sym->kind == v__ast__Kind__sum_type) {
		v__ast__SumType parent_info = *(v__ast__SumType*)builtin____as_cast((parent_sym->info)._v__ast__SumType,(parent_sym->info)._typ, 486);
		v__ast__TypeSymbol* var_sym = v__ast__Table_sym(t, variant);

		if (var_sym->kind == (v__ast__Kind__aggregate)) {
			return v__ast__Table_sumtype_check_aggregate_variant(t, parent, (voidptr)&variant, is_as);
		}
		else if (var_sym->kind == (v__ast__Kind__alias)) {
			return v__ast__Table_sumtype_check_alias_variant(t, parent, variant, is_as);
		}
		else if (var_sym->kind == (v__ast__Kind__function)) {
			return v__ast__Table_sumtype_check_function_variant(t, parent_info, variant, is_as);
		}
		else {
			return v__ast__Table_sumtype_check_variant_in_type(t, parent_info, variant, is_as);
		}
	}
	return false;
}
VV_LOC bool v__ast__Table_sumtype_check_function_variant(v__ast__Table* t, v__ast__SumType parent_info, v__ast__Type variant, bool is_as) {
	v__ast__Fn variant_fn = (({ v__ast__TypeInfo _t1 = v__ast__Table_sym(t, variant)->info; *(v__ast__FnType*)builtin____as_cast(_t1._v__ast__FnType,_t1._typ, 495); })).func;
	string variant_fn_sig = v__ast__Table_fn_type_source_signature(t, (voidptr)&variant_fn);
	for (int _t2 = 0; _t2 < parent_info.variants.len; ++_t2) {
		v__ast__Type v = ((v__ast__Type*)parent_info.variants.data)[_t2];
		v__ast__TypeSymbol* v_sym = v__ast__Table_sym(t, v);
		if ((v_sym->info)._typ == 495 /* v.ast.FnType */) {
			if (builtin__string__eq(v__ast__Table_fn_type_source_signature(t, (voidptr)&(*v_sym->info._v__ast__FnType).func), variant_fn_sig) && (!is_as || v__ast__Type_nr_muls(v) == v__ast__Type_nr_muls(variant))) {
				return true;
			}
		}
	}
	return false;
}
VV_LOC bool v__ast__Table_sumtype_check_variant_in_type(v__ast__Table* t, v__ast__SumType parent_info, v__ast__Type variant, bool is_as) {
	for (int _t1 = 0; _t1 < parent_info.variants.len; ++_t1) {
		v__ast__Type v = ((v__ast__Type*)parent_info.variants.data)[_t1];
		if (v__ast__Type_idx(v) == v__ast__Type_idx(variant) && v__ast__Type_has_flag(variant, v__ast__TypeFlag__option) == v__ast__Type_has_flag(v, v__ast__TypeFlag__option) && (!is_as || v__ast__Type_nr_muls(v) == v__ast__Type_nr_muls(variant))) {
			return true;
		}
	}
	return false;
}
VV_LOC bool v__ast__Table_sumtype_check_aggregate_variant(v__ast__Table* t, v__ast__Type parent_type, v__ast__Type* aggregate_type, bool is_as) {
	v__ast__Aggregate aggregate_sym = ({ v__ast__TypeInfo _t1 = v__ast__Table_sym(t, *aggregate_type)->info; *(v__ast__Aggregate*)builtin____as_cast(_t1._v__ast__Aggregate,_t1._typ, 480); });
	for (int _t2 = 0; _t2 < aggregate_sym.types.len; ++_t2) {
		v__ast__Type var_type = ((v__ast__Type*)aggregate_sym.types.data)[_t2];
		if (!v__ast__Table_sumtype_has_variant(t, parent_type, var_type, is_as)) {
			return false;
		}
	}
	return true;
}
VV_LOC bool v__ast__Table_sumtype_check_alias_variant(v__ast__Table* t, v__ast__Type parent_type, v__ast__Type alias_type, bool is_as) {
	v__ast__SumType parent_sym = ({ v__ast__TypeInfo _t1 = v__ast__Table_sym(t, parent_type)->info; *(v__ast__SumType*)builtin____as_cast(_t1._v__ast__SumType,_t1._typ, 486); });
	if (!v__ast__Table_sumtype_check_variant_in_type(t, parent_sym, alias_type, is_as)) {
		v__ast__Alias alias_info = ({ v__ast__TypeInfo _t2 = v__ast__Table_sym(t, alias_type)->info; *(v__ast__Alias*)builtin____as_cast(_t2._v__ast__Alias,_t2._typ, 482); });
		return parent_type == alias_info.parent_type || v__ast__Table_sumtype_has_variant(t, parent_type, alias_info.parent_type, is_as);
	}
	return true;
}
bool v__ast__Table_is_sumtype_or_in_variant(v__ast__Table* t, v__ast__Type parent, v__ast__Type typ) {
	if (typ == 0) {
		return false;
	}
	if (v__ast__Table_sym(t, typ)->kind == v__ast__Kind__sum_type && v__ast__Type_idx(parent) == v__ast__Type_idx(typ) && v__ast__Type_nr_muls(parent) == v__ast__Type_nr_muls(typ)) {
		return true;
	}
	return v__ast__Table_sumtype_has_variant(t, parent, typ, false);
}
inline bool v__ast__Table_is_interface_var(v__ast__Table* t, v__ast__ScopeObject var) {
	return (var)._typ == 341 /* v.ast.Var */ && (*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).orig_type != 0 && v__ast__Table_sym(t, (*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).orig_type)->kind == v__ast__Kind__interface && v__ast__Table_sym(t, (*(v__ast__Type*)builtin__array_last((*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).smartcasts)))->kind != v__ast__Kind__interface;
}
inline bool v__ast__Table_is_interface_smartcast(v__ast__Table* t, v__ast__ScopeObject var) {
	return (var)._typ == 341 /* v.ast.Var */ && (*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).orig_type != 0 && v__ast__Table_sym(t, (*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).orig_type)->kind == v__ast__Kind__interface && (*(v__ast__Var*)builtin____as_cast((var)._v__ast__Var,(var)._typ, 341)).smartcasts.len > 0;
}
Array_string v__ast__Table_known_type_names(v__ast__Table* t) {
	Array_string res = builtin____new_array_with_default(0, t->type_idxs.len, sizeof(string), 0);
	Map_string_int _t1 = t->type_idxs;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int idx = (*(int*)builtin__DenseArray_value(&_t1.key_values, _t2));
		v__ast__Type typ = v__ast__idx_to_type(idx);
		if (!(idx == 0 || idx == _const_v__ast__int_literal_type_idx || idx == _const_v__ast__float_literal_type_idx) && v__ast__Table_known_type_idx(t, typ)) {
			v__ast__TypeSymbol* tsym = v__ast__Table_sym(t, typ);
			if (!(tsym->kind == v__ast__Kind__function || tsym->kind == v__ast__Kind__chan)) {
				builtin__array_push((array*)&res, _MOV((string[]){ v__ast__Table_type_to_str(t, typ) }));
			} else if ((tsym->info)._typ == 492 /* v.ast.Chan */ && v__ast__Table_sym(t, (*(v__ast__Chan*)builtin____as_cast((tsym->info)._v__ast__Chan,(tsym->info)._typ, 492)).elem_type)->kind != v__ast__Kind__placeholder) {
				builtin__array_push((array*)&res, _MOV((string[]){ v__ast__Table_type_to_str(t, (*tsym->info._v__ast__Chan).elem_type) }));
			}
		}
	}
	return res;
}
bool v__ast__Table_has_deep_child_no_ref(v__ast__Table* t, v__ast__TypeSymbol* ts, string name) {
	if ((ts->info)._typ == 457 /* v.ast.Struct */) {
		for (int _t1 = 0; _t1 < (*ts->info._v__ast__Struct).fields.len; ++_t1) {
			v__ast__StructField field = ((v__ast__StructField*)(*ts->info._v__ast__Struct).fields.data)[_t1];
			v__ast__TypeSymbol* sym = v__ast__Table_sym(t, field.typ);
			if (!v__ast__Type_is_ptr(field.typ) && !v__ast__Type_has_flag(field.typ, v__ast__TypeFlag__option) && (builtin__string__eq(sym->name, name) || v__ast__Table_has_deep_child_no_ref(t, sym, name))) {
				return true;
			}
		}
	}
	return false;
}
void v__ast__Table_complete_interface_check(v__ast__Table* t) {
	v__util__timing_start(_S("Table.complete_interface_check"));
	for (int tk = 0; tk < t->type_symbols.len; ++tk) {
		v__ast__TypeSymbol* tsym = ((v__ast__TypeSymbol**)t->type_symbols.data)[tk];
		v__ast__Type tk_typ = v__ast__idx_to_type(tk);
		if (tsym->kind != v__ast__Kind__struct) {
			continue;
		}
		Map_int_v__ast__InterfaceDecl _t1 = t->interfaces;
		int _t3 = _t1.key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = _t1.key_values.len - _t3;
			_t3 = _t1.key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
			v__ast__InterfaceDecl* idecl = ((v__ast__InterfaceDecl*)builtin__DenseArray_value(&_t1.key_values, _t2));
			if (idecl->typ == 0) {
				continue;
			}
			if (idecl->methods.len == 0 && idecl->fields.len == 0 && !builtin__string__eq(tsym->mod, v__ast__Table_sym(t, idecl->typ)->mod)) {
				continue;
			}
			if (v__ast__Table_does_type_implement_interface(t, tk_typ, idecl->typ)) {
				builtin__array_push((array*)&(*(Array_v__ast__Type*)builtin__map_get_and_set((map*)&t->iface_types, &(string[]){idecl->name}, &(Array_v__ast__Type[]){ builtin____new_array(0, 0, sizeof(v__ast__Type)) })), _MOV((v__ast__Type[]){ tk_typ }));
			}
		}
	}
	{ // defer begin
		v__util__timing_measure(_S("Table.complete_interface_check"));
	} // defer end
}
v__ast__Type v__ast__Table_bitsize_to_type(v__ast__Table* t, int bit_size) {
	switch (bit_size) {
		case 8: {
			return _const_v__ast__i8_type;
		}
		case 16: {
			return _const_v__ast__i16_type;
		}
		case 32: {
			return _const_v__ast__i32_type;
		}
		case 64: {
			return _const_v__ast__i64_type;
		}
		default: {
			{
				if ((int)(bit_size % 8) != 0) {
					v__ast__Table_panic(t, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("table.bitsize_to_type: compiler bug: bitsizes must be multiples of 8, but passed bit_size is "), 0xfe07, {.d_i32 = bit_size}}, {_SLIT0, 0, { .d_c = 0 }}})));
				}
				return v__ast__new_type(v__ast__Table_find_or_register_array_fixed(t, _const_v__ast__u8_type, (int)(bit_size / 8), _const_v__ast__empty_expr, false));
			}
		}
	}
	
	return 0;
}
bool v__ast__Table_does_type_implement_interface(v__ast__Table* t, v__ast__Type typ, v__ast__Type inter_typ) {
	if (v__ast__Type_idx(typ) == v__ast__Type_idx(inter_typ)) {
		return true;
	}
	if (v__ast__Type_idx(inter_typ) == 30 && v__ast__Type_idx(typ) == 20) {
		return true;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->language != v__ast__Language__v) {
		return false;
	}
	if ((sym->info)._typ == 457 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			return false;
		}
	}
	v__ast__TypeSymbol* inter_sym = v__ast__Table_sym(t, inter_typ);
	if (sym->kind == v__ast__Kind__interface && inter_sym->kind == v__ast__Kind__interface) {
		return false;
	}
	if ((inter_sym->info)._typ == 485 /* v.ast.Interface */) {
		Array_v__ast__Attr attrs = (*(v__ast__InterfaceDecl*)builtin__map_get(ADDR(map, t->interfaces), &(int[]){inter_typ}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,} })).attrs;
		for (int _t6 = 0; _t6 < attrs.len; ++_t6) {
			v__ast__Attr attr = ((v__ast__Attr*)attrs.data)[_t6];
			if (builtin__fast_string_eq(attr.name, _S("single_impl"))) {
				return false;
			}
		}
		for (int _t8 = 0; _t8 < (*inter_sym->info._v__ast__Interface).types.len; ++_t8) {
			v__ast__Type tt = ((v__ast__Type*)(*inter_sym->info._v__ast__Interface).types.data)[_t8];
			if (v__ast__Type_idx(tt) == v__ast__Type_idx(typ)) {
				return true;
			}
		}
		for (int _t10 = 0; _t10 < (*inter_sym->info._v__ast__Interface).methods.len; ++_t10) {
			v__ast__Fn imethod = ((v__ast__Fn*)(*inter_sym->info._v__ast__Interface).methods.data)[_t10];
			_result_v__ast__Fn _t11;
			if (_t11 = v__ast__Table_find_method_with_embeds(t, sym, imethod.name), !_t11.is_error) {
				v__ast__Fn method = *(v__ast__Fn*)_t11.data;
				string msg = v__ast__Table_is_same_method(t, (voidptr)&imethod, (voidptr)&method);
				if (msg.len > 0) {
					return false;
				}
				continue;
			}
			if (sym->info._typ == 486 /* v.ast.SumType */) {
				_option_v__ast__Fn _t13;
				if (_t13 = v__ast__TypeSymbol_find_method_with_generic_parent(sym, imethod.name), _t13.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t13.data;
					string msg = v__ast__Table_is_same_method(t, (voidptr)&imethod, (voidptr)&method);
					if (msg.len > 0) {
						return false;
					}
					continue;
				}
			}
			else if (sym->info._typ == 457 /* v.ast.Struct */) {
				_option_v__ast__Fn _t15;
				if (_t15 = v__ast__TypeSymbol_find_method_with_generic_parent(sym, imethod.name), _t15.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t15.data;
					string msg = v__ast__Table_is_same_method(t, (voidptr)&imethod, (voidptr)&method);
					if (msg.len > 0) {
						return false;
					}
					continue;
				}
			}
			else if (sym->info._typ == 485 /* v.ast.Interface */) {
				_option_v__ast__Fn _t17;
				if (_t17 = v__ast__TypeSymbol_find_method_with_generic_parent(sym, imethod.name), _t17.state == 0) {
					v__ast__Fn method = *(v__ast__Fn*)_t17.data;
					string msg = v__ast__Table_is_same_method(t, (voidptr)&imethod, (voidptr)&method);
					if (msg.len > 0) {
						return false;
					}
					continue;
				}
			}
			
			else {
			}
			
			return false;
		}
		for (int _t20 = 0; _t20 < (*inter_sym->info._v__ast__Interface).fields.len; ++_t20) {
			v__ast__StructField ifield = ((v__ast__StructField*)(*inter_sym->info._v__ast__Interface).fields.data)[_t20];
			if (ifield.typ == _const_v__ast__voidptr_type || ifield.typ == _const_v__ast__nil_type) {
				if (v__ast__Table_struct_has_field(t, sym, ifield.name)) {
					continue;
				} else {
					return false;
				}
			}
			_result_v__ast__StructField _t22;
			if (_t22 = v__ast__Table_find_field_with_embeds(t, sym, ifield.name), !_t22.is_error) {
				v__ast__StructField field = *(v__ast__StructField*)_t22.data;
				if (ifield.typ != field.typ) {
					return false;
				} else if (ifield.is_mut && !(field.is_mut || field.is_global)) {
					return false;
				}
				continue;
			}
			return false;
		}
		if (typ != _const_v__ast__voidptr_type && typ != _const_v__ast__nil_type && typ != _const_v__ast__none_type && !Array_v__ast__Type_contains((*inter_sym->info._v__ast__Interface).types, typ)) {
			builtin__array_push((array*)&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ typ }));
		}
		if (!Array_v__ast__Type_contains((*inter_sym->info._v__ast__Interface).types, _const_v__ast__voidptr_type)) {
			builtin__array_push((array*)&(*inter_sym->info._v__ast__Interface).types, _MOV((v__ast__Type[]){ _const_v__ast__voidptr_type }));
		}
		return true;
	}
	return false;
}
multi_return_v__ast__Type_string v__ast__Table_convert_generic_static_type_name(v__ast__Table* t, string fn_name, Array_string generic_names, Array_v__ast__Type concrete_types) {
	_option_int _t1;
	if (_t1 = builtin__string_index(fn_name, _S("__static__")), _t1.state == 0) {
		int index = *(int*)_t1.data;
		if (index > 0) {
			string generic_name = builtin__string_substr(fn_name, 0, index);
			bool valid_generic = v__util__is_generic_type_name(generic_name) && (Array_string_contains(generic_names, generic_name));
			if (valid_generic) {
				v__ast__Type name_type = v__ast__Type_set_flag(v__ast__Table_find_type(t, generic_name), v__ast__TypeFlag__generic);
				_option_v__ast__Type _t2;
				if (_t2 = v__ast__Table_convert_generic_type(t, name_type, generic_names, concrete_types), _t2.state == 0) {
					v__ast__Type typ = *(v__ast__Type*)_t2.data;
					return (multi_return_v__ast__Type_string){.arg0=name_type, .arg1=builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Table_type_to_str(t, typ)}}, {_SLIT0, 0xfe10, {.d_s = builtin__string_substr(fn_name, index, 2147483647)}}, {_SLIT0, 0, { .d_c = 0 }}}))};
				}
			}
		}
	}
	return (multi_return_v__ast__Type_string){.arg0=_const_v__ast__void_type, .arg1=fn_name};
}
_option_v__ast__Type v__ast__Table_convert_generic_type(v__ast__Table* t, v__ast__Type generic_type, Array_string generic_names, Array_v__ast__Type to_types) {
	if (generic_names.len != to_types.len) {
		return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	int type_idx = v__ast__Type_idx(generic_type);
	if (type_idx == 0 || type_idx >= t->type_symbols.len) {
		return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, generic_type);
	if ((Array_string_contains(generic_names, sym->name))) {
		int index = Array_string_index(generic_names, sym->name);
		if (index >= to_types.len) {
			return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		}
		v__ast__Type typ = (*(v__ast__Type*)builtin__array_get(to_types, index));
		if (typ == 0) {
			return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
		}
		v__ast__Type rtyp = v__ast__Type_derive_add_muls(typ, generic_type);
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
			rtyp = v__ast__Type_set_flag(rtyp, v__ast__TypeFlag__generic);
		} else {
			rtyp = v__ast__Type_clear_flag(rtyp, v__ast__TypeFlag__generic);
		}
		if (!v__ast__Type_has_flag(generic_type, v__ast__TypeFlag__result) && v__ast__Type_has_flag(typ, v__ast__TypeFlag__option)) {
			rtyp = v__ast__Type_set_flag(rtyp, v__ast__TypeFlag__option);
			if (v__ast__Type_is_ptr(generic_type)) {
				rtyp = v__ast__Type_set_flag(rtyp, v__ast__TypeFlag__option_mut_param_t);
			}
		}
		_option_v__ast__Type _t5;
		builtin___option_ok(&(v__ast__Type[]) { rtyp }, (_option*)(&_t5), sizeof(v__ast__Type));
		 
		return _t5;
	}
	if (sym->info._typ == 452 /* v.ast.Array */) {
		multi_return_int_v__ast__Type mr_52495 = v__ast__Table_get_array_dims(t, (*sym->info._v__ast__Array));
		int dims = mr_52495.arg0;
		v__ast__Type elem_type = mr_52495.arg1;
		_option_v__ast__Type _t6;
		if (_t6 = v__ast__Table_convert_generic_type(t, elem_type, generic_names, to_types), _t6.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t6.data;
			int idx = v__ast__Table_find_or_register_array_with_dims(t, typ, dims);
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t7;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t7), sizeof(v__ast__Type));
				 
				return _t7;
			} else {
				_option_v__ast__Type _t8;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t8), sizeof(v__ast__Type));
				 
				return _t8;
			}
		}
	}
	else if (sym->info._typ == 491 /* v.ast.ArrayFixed */) {
		_option_v__ast__Type _t9;
		if (_t9 = v__ast__Table_convert_generic_type(t, (*sym->info._v__ast__ArrayFixed).elem_type, generic_names, to_types), _t9.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t9.data;
			int idx = v__ast__Table_find_or_register_array_fixed(t, typ, (*sym->info._v__ast__ArrayFixed).size, v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, (((v__ast__None){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false), false);
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t10;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t10), sizeof(v__ast__Type));
				 
				return _t10;
			} else {
				_option_v__ast__Type _t11;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t11), sizeof(v__ast__Type));
				 
				return _t11;
			}
		}
	}
	else if (sym->info._typ == 492 /* v.ast.Chan */) {
		_option_v__ast__Type _t12;
		if (_t12 = v__ast__Table_convert_generic_type(t, (*sym->info._v__ast__Chan).elem_type, generic_names, to_types), _t12.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t12.data;
			int idx = v__ast__Table_find_or_register_chan(t, typ, v__ast__Type_nr_muls(typ) > 0);
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t13;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t13), sizeof(v__ast__Type));
				 
				return _t13;
			} else {
				_option_v__ast__Type _t14;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t14), sizeof(v__ast__Type));
				 
				return _t14;
			}
		}
	}
	else if (sym->info._typ == 493 /* v.ast.Thread */) {
		_option_v__ast__Type _t15;
		if (_t15 = v__ast__Table_convert_generic_type(t, (*sym->info._v__ast__Thread).return_type, generic_names, to_types), _t15.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t15.data;
			int idx = v__ast__Table_find_or_register_thread(t, typ);
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t16;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t16), sizeof(v__ast__Type));
				 
				return _t16;
			} else {
				_option_v__ast__Type _t17;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t17), sizeof(v__ast__Type));
				 
				return _t17;
			}
		}
	}
	else if (sym->info._typ == 495 /* v.ast.FnType */) {
		v__ast__Fn func = (*sym->info._v__ast__FnType).func;
		bool has_generic = false;
		if (v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag__generic)) {
			_option_v__ast__Type _t18;
			if (_t18 = v__ast__Table_convert_generic_type(t, func.return_type, generic_names, to_types), _t18.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t18.data;
				func.return_type = typ;
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
					has_generic = true;
				}
			}
		}
		func.params = builtin__array_clone_to_depth(&func.params, 0);
		for (int _t19 = 0; _t19 < func.params.len; ++_t19) {
			v__ast__Param* param = ((v__ast__Param*)func.params.data) + _t19;
			if (v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t20;
				if (_t20 = v__ast__Table_convert_generic_type(t, param->typ, generic_names, to_types), _t20.state == 0) {
					v__ast__Type typ = *(v__ast__Type*)_t20.data;
					param->typ = typ;
					if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
						has_generic = true;
					}
				}
			}
		}
		func.name = _S("");
		func.generic_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		int idx = v__ast__Table_find_or_register_fn_type(t, func, true, false);
		if (has_generic) {
			_option_v__ast__Type _t21;
			builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t21), sizeof(v__ast__Type));
			 
			return _t21;
		} else {
			_option_v__ast__Type _t22;
			builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t22), sizeof(v__ast__Type));
			 
			return _t22;
		}
	}
	else if (sym->info._typ == 494 /* v.ast.MultiReturn */) {
		Array_v__ast__Type types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
		bool type_changed = false;
		for (int _t23 = 0; _t23 < (*sym->info._v__ast__MultiReturn).types.len; ++_t23) {
			v__ast__Type ret_type = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t23];
			_option_v__ast__Type _t24;
			if (_t24 = v__ast__Table_convert_generic_type(t, ret_type, generic_names, to_types), _t24.state == 0) {
				v__ast__Type typ = *(v__ast__Type*)_t24.data;
				builtin__array_push((array*)&types, _MOV((v__ast__Type[]){ typ }));
				type_changed = true;
			} else {
				builtin__array_push((array*)&types, _MOV((v__ast__Type[]){ ret_type }));
			}
		}
		if (type_changed) {
			int idx = v__ast__Table_find_or_register_multi_return(t, types);
			bool _t28 = false;
			Array_v__ast__Type _t28_orig = types;
			int _t28_len = _t28_orig.len;
			for (int _t29 = 0; _t29 < _t28_len; ++_t29) {
				v__ast__Type it = ((v__ast__Type*) _t28_orig.data)[_t29];
				if (v__ast__Type_has_flag(it, v__ast__TypeFlag__generic)) {
					_t28 = true;
					break;
				}
			}
			bool _t27 =_t28;
			
			if (_t27) {
				_option_v__ast__Type _t30;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t30), sizeof(v__ast__Type));
				 
				return _t30;
			} else {
				_option_v__ast__Type _t31;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t31), sizeof(v__ast__Type));
				 
				return _t31;
			}
		}
	}
	else if (sym->info._typ == 453 /* v.ast.Map */) {
		bool type_changed = false;
		v__ast__Type unwrapped_key_type = (*sym->info._v__ast__Map).key_type;
		v__ast__Type unwrapped_value_type = (*sym->info._v__ast__Map).value_type;
		_option_v__ast__Type _t32;
		if (_t32 = v__ast__Table_convert_generic_type(t, (*sym->info._v__ast__Map).key_type, generic_names, to_types), _t32.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t32.data;
			unwrapped_key_type = typ;
			type_changed = true;
		}
		_option_v__ast__Type _t33;
		if (_t33 = v__ast__Table_convert_generic_type(t, (*sym->info._v__ast__Map).value_type, generic_names, to_types), _t33.state == 0) {
			v__ast__Type typ = *(v__ast__Type*)_t33.data;
			unwrapped_value_type = typ;
			type_changed = true;
		}
		if (type_changed) {
			if (to_types.len == 1 && v__ast__Type_has_flag((*sym->info._v__ast__Map).value_type, v__ast__TypeFlag__generic) && v__ast__Table_type_kind(t, (*(v__ast__Type*)builtin__array_get(to_types, 0))) == v__ast__Kind__alias && v__ast__Table_final_sym(t, (*(v__ast__Type*)builtin__array_get(to_types, 0)))->kind == v__ast__Kind__map) {
				_option_v__ast__Type _t34;
				builtin___option_ok(&(v__ast__Type[]) { unwrapped_value_type }, (_option*)(&_t34), sizeof(v__ast__Type));
				 
				return _t34;
			}
			int idx = v__ast__Table_find_or_register_map(t, unwrapped_key_type, unwrapped_value_type);
			if (v__ast__Type_has_flag(unwrapped_key_type, v__ast__TypeFlag__generic) || v__ast__Type_has_flag(unwrapped_value_type, v__ast__TypeFlag__generic)) {
				_option_v__ast__Type _t35;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t35), sizeof(v__ast__Type));
				 
				return _t35;
			} else {
				_option_v__ast__Type _t36;
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t36), sizeof(v__ast__Type));
				 
				return _t36;
			}
		}
	}
	else if (sym->info._typ == 457 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			string nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_S("["), 0, { .d_c = 0 }}}));
			string rnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->rname}}, {_S("["), 0, { .d_c = 0 }}}));
			string cnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
			Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
			Array_v__ast__Type t_to_types = builtin__array_clone_to_depth(&to_types, 0);
			bool has_generic = false;
			if (sym->generic_types.len > 0 && sym->generic_types.len == (*sym->info._v__ast__Struct).generic_types.len && !Array_v__ast__Type_arr_eq(sym->generic_types, (*sym->info._v__ast__Struct).generic_types)) {
				Array_string _t37 = {0};
				Array_v__ast__Type _t37_orig = (*sym->info._v__ast__Struct).generic_types;
				int _t37_len = _t37_orig.len;
				_t37 = builtin____new_array(0, _t37_len, sizeof(string));

				for (int _t39 = 0; _t39 < _t37_len; ++_t39) {
					v__ast__Type it = ((v__ast__Type*) _t37_orig.data)[_t39];
					string _t38 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t37, &_t38);
				}
				t_generic_names =_t37;
				t_to_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				for (int _t40 = 0; _t40 < sym->generic_types.len; ++_t40) {
					v__ast__Type t_typ = ((v__ast__Type*)sym->generic_types.data)[_t40];
					if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
						builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ t_typ }));
					} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
						string tname = v__ast__Table_sym(t, t_typ)->name;
						int index = Array_string_index(generic_names, tname);
						if (index >= 0 && index < to_types.len) {
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(to_types, index)) }));
						}
					} else {
						_option_v__ast__Type _t43;
						if (_t43 = v__ast__Table_convert_generic_type(t, t_typ, generic_names, to_types), _t43.state == 0) {
							v__ast__Type tt = *(v__ast__Type*)_t43.data;
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ tt }));
						}
					}
				}
			}
			for (int i = 0; i < (*sym->info._v__ast__Struct).generic_types.len; ++i) {
				_option_v__ast__Type _t45;
				if (_t45 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__Struct).generic_types, i)), t_generic_names, t_to_types), _t45.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t45.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					if (v__ast__Type_is_ptr(ct)) {
						nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
					}
					nrt = builtin__string__plus(nrt, gts->name);
					rnrt = builtin__string__plus(rnrt, gts->name);
					cnrt = builtin__string__plus(cnrt, gts->cname);
					if (i != (int)((*sym->info._v__ast__Struct).generic_types.len - 1)) {
						nrt = builtin__string__plus(nrt, _S(", "));
						rnrt = builtin__string__plus(rnrt, _S(", "));
						cnrt = builtin__string__plus(cnrt, _S("_"));
					}
					if (v__ast__Type_has_flag(ct, v__ast__TypeFlag__generic) && ct != (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__Struct).generic_types, i))) {
						has_generic = true;
					}
				} else {
					return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
				}
			}
			nrt = builtin__string__plus(nrt, _S("]"));
			rnrt = builtin__string__plus(rnrt, _S("]"));
			int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){rnrt}, &(int[]){ 0 }));
				if (idx == 0) {
					idx = v__ast__Table_add_placeholder_type(t, nrt, cnrt, v__ast__Language__v);
				}
			}
			_option_v__ast__Type _t48; /* if prepend */
			if (has_generic) {
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t48), sizeof(v__ast__Type));
				goto _t49;
			};
			{
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t48), sizeof(v__ast__Type));
			}
	_t49: {};
						return _t48;
		}
	}
	else if (sym->info._typ == 485 /* v.ast.Interface */) {
		if ((*sym->info._v__ast__Interface).is_generic) {
			string nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_S("["), 0, { .d_c = 0 }}}));
			string rnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->rname}}, {_S("["), 0, { .d_c = 0 }}}));
			string cnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
			Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
			Array_v__ast__Type t_to_types = builtin__array_clone_to_depth(&to_types, 0);
			bool has_generic = false;
			if (sym->generic_types.len > 0 && sym->generic_types.len == (*sym->info._v__ast__Interface).generic_types.len && !Array_v__ast__Type_arr_eq(sym->generic_types, (*sym->info._v__ast__Interface).generic_types)) {
				Array_string _t50 = {0};
				Array_v__ast__Type _t50_orig = (*sym->info._v__ast__Interface).generic_types;
				int _t50_len = _t50_orig.len;
				_t50 = builtin____new_array(0, _t50_len, sizeof(string));

				for (int _t52 = 0; _t52 < _t50_len; ++_t52) {
					v__ast__Type it = ((v__ast__Type*) _t50_orig.data)[_t52];
					string _t51 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t50, &_t51);
				}
				t_generic_names =_t50;
				t_to_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				for (int _t53 = 0; _t53 < sym->generic_types.len; ++_t53) {
					v__ast__Type t_typ = ((v__ast__Type*)sym->generic_types.data)[_t53];
					if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
						builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ t_typ }));
					} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
						string tname = v__ast__Table_sym(t, t_typ)->name;
						int index = Array_string_index(generic_names, tname);
						if (index >= 0 && index < to_types.len) {
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(to_types, index)) }));
						}
					} else {
						_option_v__ast__Type _t56;
						if (_t56 = v__ast__Table_convert_generic_type(t, t_typ, generic_names, to_types), _t56.state == 0) {
							v__ast__Type tt = *(v__ast__Type*)_t56.data;
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ tt }));
						}
					}
				}
			}
			for (int i = 0; i < (*sym->info._v__ast__Interface).generic_types.len; ++i) {
				_option_v__ast__Type _t58;
				if (_t58 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__Interface).generic_types, i)), t_generic_names, t_to_types), _t58.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t58.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					if (v__ast__Type_is_ptr(ct)) {
						nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
					}
					nrt = builtin__string__plus(nrt, gts->name);
					rnrt = builtin__string__plus(rnrt, gts->name);
					cnrt = builtin__string__plus(cnrt, gts->cname);
					if (i != (int)((*sym->info._v__ast__Interface).generic_types.len - 1)) {
						nrt = builtin__string__plus(nrt, _S(", "));
						rnrt = builtin__string__plus(rnrt, _S(", "));
						cnrt = builtin__string__plus(cnrt, _S("_"));
					}
					if (v__ast__Type_has_flag(ct, v__ast__TypeFlag__generic) && ct != (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__Interface).generic_types, i))) {
						has_generic = true;
					}
				} else {
					return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
				}
			}
			nrt = builtin__string__plus(nrt, _S("]"));
			rnrt = builtin__string__plus(rnrt, _S("]"));
			int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){rnrt}, &(int[]){ 0 }));
				if (idx == 0) {
					idx = v__ast__Table_add_placeholder_type(t, nrt, cnrt, v__ast__Language__v);
				}
			}
			_option_v__ast__Type _t61; /* if prepend */
			if (has_generic) {
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t61), sizeof(v__ast__Type));
				goto _t62;
			};
			{
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t61), sizeof(v__ast__Type));
			}
	_t62: {};
						return _t61;
		}
	}
	else if (sym->info._typ == 486 /* v.ast.SumType */) {
		if ((*sym->info._v__ast__SumType).is_generic) {
			string nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->name}}, {_S("["), 0, { .d_c = 0 }}}));
			string rnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->rname}}, {_S("["), 0, { .d_c = 0 }}}));
			string cnrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = sym->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
			Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
			Array_v__ast__Type t_to_types = builtin__array_clone_to_depth(&to_types, 0);
			bool has_generic = false;
			if (sym->generic_types.len > 0 && sym->generic_types.len == (*sym->info._v__ast__SumType).generic_types.len && !Array_v__ast__Type_arr_eq(sym->generic_types, (*sym->info._v__ast__SumType).generic_types)) {
				Array_string _t63 = {0};
				Array_v__ast__Type _t63_orig = (*sym->info._v__ast__SumType).generic_types;
				int _t63_len = _t63_orig.len;
				_t63 = builtin____new_array(0, _t63_len, sizeof(string));

				for (int _t65 = 0; _t65 < _t63_len; ++_t65) {
					v__ast__Type it = ((v__ast__Type*) _t63_orig.data)[_t65];
					string _t64 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t63, &_t64);
				}
				t_generic_names =_t63;
				t_to_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
				for (int _t66 = 0; _t66 < sym->generic_types.len; ++_t66) {
					v__ast__Type t_typ = ((v__ast__Type*)sym->generic_types.data)[_t66];
					if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
						builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ t_typ }));
					} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
						string tname = v__ast__Table_sym(t, t_typ)->name;
						int index = Array_string_index(generic_names, tname);
						if (index >= 0 && index < to_types.len) {
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(to_types, index)) }));
						}
					} else {
						_option_v__ast__Type _t69;
						if (_t69 = v__ast__Table_convert_generic_type(t, t_typ, generic_names, to_types), _t69.state == 0) {
							v__ast__Type tt = *(v__ast__Type*)_t69.data;
							builtin__array_push((array*)&t_to_types, _MOV((v__ast__Type[]){ tt }));
						}
					}
				}
			}
			for (int i = 0; i < (*sym->info._v__ast__SumType).generic_types.len; ++i) {
				_option_v__ast__Type _t71;
				if (_t71 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__SumType).generic_types, i)), t_generic_names, t_to_types), _t71.state == 0) {
					v__ast__Type ct = *(v__ast__Type*)_t71.data;
					v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
					if (v__ast__Type_is_ptr(ct)) {
						nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
					}
					nrt = builtin__string__plus(nrt, gts->name);
					rnrt = builtin__string__plus(rnrt, gts->name);
					cnrt = builtin__string__plus(cnrt, gts->cname);
					if (i != (int)((*sym->info._v__ast__SumType).generic_types.len - 1)) {
						nrt = builtin__string__plus(nrt, _S(", "));
						rnrt = builtin__string__plus(rnrt, _S(", "));
						cnrt = builtin__string__plus(cnrt, _S("_"));
					}
					if (v__ast__Type_has_flag(ct, v__ast__TypeFlag__generic) && ct != (*(v__ast__Type*)builtin__array_get((*sym->info._v__ast__SumType).generic_types, i))) {
						has_generic = true;
					}
				} else {
					return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
				}
			}
			nrt = builtin__string__plus(nrt, _S("]"));
			rnrt = builtin__string__plus(rnrt, _S("]"));
			int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
			if (idx == 0) {
				idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){rnrt}, &(int[]){ 0 }));
				if (idx == 0) {
					idx = v__ast__Table_add_placeholder_type(t, nrt, cnrt, v__ast__Language__v);
				}
			}
			_option_v__ast__Type _t74; /* if prepend */
			if (has_generic) {
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t74), sizeof(v__ast__Type));
				goto _t75;
			};
			{
				builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t74), sizeof(v__ast__Type));
			}
	_t75: {};
						return _t74;
		}
	}
	else if (sym->info._typ == 498 /* v.ast.UnknownTypeInfo */) {
		if (builtin__string_contains(sym->name, _S("[")) && builtin__string_contains(sym->name, _S("]"))) {
			string base_name = builtin__string_all_before(sym->name, _S("["));
			string generic_part = builtin__string_trim_right(builtin__string_all_after(sym->name, _S("[")), _S("]"));
			Array_string converted_args = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			bool has_generic = false;
			bool changed = false;
			Array_string _t76 = {0};
			Array_string _t76_orig = builtin__string_split(generic_part, _S(","));
			int _t76_len = _t76_orig.len;
			_t76 = builtin____new_array(0, _t76_len, sizeof(string));

			for (int _t78 = 0; _t78 < _t76_len; ++_t78) {
				string it = ((string*) _t76_orig.data)[_t78];
				string _t77 = builtin__string_trim_space(it);
				builtin__array_push((array*)&_t76, &_t77);
			}
			Array_string args =_t76;
			for (int _t79 = 0; _t79 < args.len; ++_t79) {
				string arg = ((string*)args.data)[_t79];
				if ((Array_string_contains(generic_names, arg))) {
					int idx = Array_string_index(generic_names, arg);
					if (idx < to_types.len) {
						v__ast__Type converted_type = (*(v__ast__Type*)builtin__array_get(to_types, idx));
						string converted_type_str = v__ast__Table_type_to_str(t, converted_type);
						if (!builtin__string__eq(converted_type_str, arg)) {
							builtin__array_push((array*)&converted_args, _MOV((string[]){ builtin__string_clone(converted_type_str) }));
							changed = true;
							if (v__ast__Type_has_flag(converted_type, v__ast__TypeFlag__generic)) {
								has_generic = true;
							}
						} else {
							builtin__array_push((array*)&converted_args, _MOV((string[]){ builtin__string_clone(arg) }));
						}
					} else {
						builtin__array_push((array*)&converted_args, _MOV((string[]){ builtin__string_clone(arg) }));
					}
				} else {
					builtin__array_push((array*)&converted_args, _MOV((string[]){ builtin__string_clone(arg) }));
				}
			}
			if (changed) {
				string new_name = builtin__string__plus(builtin__string__plus(builtin__string__plus(base_name, _S("[")), Array_string_join(converted_args, _S(", "))), _S("]"));
				int new_idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){new_name}, &(int[]){ 0 }));
				if (new_idx == 0) {
					new_idx = v__ast__Table_add_placeholder_type(t, new_name, builtin__string_replace_each(v__util__no_dots(new_name), builtin__new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_S("["), _S("_T_"), _S("]"), _S(""), _S(", "), _S("_"), _S(" "), _S("")}))), sym->language);
				}
				_option_v__ast__Type _t85; /* if prepend */
				if (has_generic) {
					builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_set_flag(v__ast__Type_derive_add_muls(v__ast__new_type(new_idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t85), sizeof(v__ast__Type));
					goto _t86;
				};
				{
					builtin___option_ok(&(v__ast__Type[]) { v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(new_idx), generic_type), v__ast__TypeFlag__generic) }, (_option*)(&_t85), sizeof(v__ast__Type));
				}
	_t86: {};
								return _t85;
			}
		}
	}
	
	else {
	}
	
	return (_option_v__ast__Type){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
VV_LOC void v__ast__generic_names_push_with_filter(Array_string* to_names, Array_string from_names) {
	for (int _t1 = 0; _t1 < from_names.len; ++_t1) {
		string name = ((string*)from_names.data)[_t1];
		if (!(Array_string_contains(*to_names, name))) {
			builtin__array_push((array*)to_names, _MOV((string[]){ builtin__string_clone(name) }));
		}
	}
}
Array_string v__ast__Table_generic_type_names(v__ast__Table* t, v__ast__Type generic_type) {
	Array_string names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, generic_type);
	if (sym->name.len == 1 && builtin__u8_is_capital(builtin__string_at(sym->name, 0))) {
		builtin__array_push((array*)&names, _MOV((string[]){ builtin__string_clone(sym->name) }));
		return names;
	}
	if (sym->info._typ == 452 /* v.ast.Array */) {
		multi_return_int_v__ast__Type mr_60295 = v__ast__Table_get_array_dims(t, (*sym->info._v__ast__Array));
		v__ast__Type elem_type = mr_60295.arg1;
		_PUSH_MANY(&names, (v__ast__Table_generic_type_names(t, elem_type)), _t3, Array_string);
	}
	else if (sym->info._typ == 491 /* v.ast.ArrayFixed */) {
		_PUSH_MANY(&names, (v__ast__Table_generic_type_names(t, (*sym->info._v__ast__ArrayFixed).elem_type)), _t4, Array_string);
	}
	else if (sym->info._typ == 492 /* v.ast.Chan */) {
		_PUSH_MANY(&names, (v__ast__Table_generic_type_names(t, (*sym->info._v__ast__Chan).elem_type)), _t5, Array_string);
	}
	else if (sym->info._typ == 495 /* v.ast.FnType */) {
		_PUSH_MANY(&names, ((*sym->info._v__ast__FnType).func.generic_names), _t6, Array_string);
	}
	else if (sym->info._typ == 494 /* v.ast.MultiReturn */) {
		for (int _t7 = 0; _t7 < (*sym->info._v__ast__MultiReturn).types.len; ++_t7) {
			v__ast__Type ret_type = ((v__ast__Type*)(*sym->info._v__ast__MultiReturn).types.data)[_t7];
			v__ast__generic_names_push_with_filter(&names, v__ast__Table_generic_type_names(t, ret_type));
		}
	}
	else if (sym->info._typ == 453 /* v.ast.Map */) {
		_PUSH_MANY(&names, (v__ast__Table_generic_type_names(t, (*sym->info._v__ast__Map).key_type)), _t8, Array_string);
		v__ast__generic_names_push_with_filter(&names, v__ast__Table_generic_type_names(t, (*sym->info._v__ast__Map).value_type));
	}
	else if (sym->info._typ == 457 /* v.ast.Struct */) {
		if ((*sym->info._v__ast__Struct).is_generic) {
			if (sym->generic_types.len > 0) {
				for (int _t9 = 0; _t9 < sym->generic_types.len; ++_t9) {
					v__ast__Type typ = ((v__ast__Type*)sym->generic_types.data)[_t9];
					if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic) && v__ast__Table_sym(t, typ)->kind == v__ast__Kind__any) {
						builtin__array_push((array*)&names, _MOV((string[]){ builtin__string_clone(v__ast__Table_sym(t, typ)->name) }));
					}
				}
			} else {
				Array_string _t12 = {0};
				Array_v__ast__Type _t12_orig = (*sym->info._v__ast__Struct).generic_types;
				int _t12_len = _t12_orig.len;
				_t12 = builtin____new_array(0, _t12_len, sizeof(string));

				for (int _t14 = 0; _t14 < _t12_len; ++_t14) {
					v__ast__Type it = ((v__ast__Type*) _t12_orig.data)[_t14];
					string _t13 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t12, &_t13);
				}
				_PUSH_MANY(&names, (_t12), _t11, Array_string);
			}
		}
	}
	else if (sym->info._typ == 485 /* v.ast.Interface */) {
		if ((*sym->info._v__ast__Interface).is_generic) {
			if (sym->generic_types.len > 0) {
				for (int _t15 = 0; _t15 < sym->generic_types.len; ++_t15) {
					v__ast__Type typ = ((v__ast__Type*)sym->generic_types.data)[_t15];
					if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic) && v__ast__Table_sym(t, typ)->kind == v__ast__Kind__any) {
						builtin__array_push((array*)&names, _MOV((string[]){ builtin__string_clone(v__ast__Table_sym(t, typ)->name) }));
					}
				}
			} else {
				Array_string _t18 = {0};
				Array_v__ast__Type _t18_orig = (*sym->info._v__ast__Interface).generic_types;
				int _t18_len = _t18_orig.len;
				_t18 = builtin____new_array(0, _t18_len, sizeof(string));

				for (int _t20 = 0; _t20 < _t18_len; ++_t20) {
					v__ast__Type it = ((v__ast__Type*) _t18_orig.data)[_t20];
					string _t19 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t18, &_t19);
				}
				_PUSH_MANY(&names, (_t18), _t17, Array_string);
			}
		}
	}
	else if (sym->info._typ == 486 /* v.ast.SumType */) {
		if ((*sym->info._v__ast__SumType).is_generic) {
			if (sym->generic_types.len > 0) {
				for (int _t21 = 0; _t21 < sym->generic_types.len; ++_t21) {
					v__ast__Type typ = ((v__ast__Type*)sym->generic_types.data)[_t21];
					if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic) && v__ast__Table_sym(t, typ)->kind == v__ast__Kind__any) {
						builtin__array_push((array*)&names, _MOV((string[]){ builtin__string_clone(v__ast__Table_sym(t, typ)->name) }));
					}
				}
			} else {
				Array_string _t24 = {0};
				Array_v__ast__Type _t24_orig = (*sym->info._v__ast__SumType).generic_types;
				int _t24_len = _t24_orig.len;
				_t24 = builtin____new_array(0, _t24_len, sizeof(string));

				for (int _t26 = 0; _t26 < _t24_len; ++_t26) {
					v__ast__Type it = ((v__ast__Type*) _t24_orig.data)[_t26];
					string _t25 = v__ast__Table_sym(t, it)->name;
					builtin__array_push((array*)&_t24, &_t25);
				}
				_PUSH_MANY(&names, (_t24), _t23, Array_string);
			}
		}
	}
	
	else {
	}
	
	return names;
}
v__ast__Type v__ast__Table_unwrap_generic_type(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types) {
	return v__ast__Table_unwrap_generic_type_ex(t, typ, generic_names, concrete_types, false);
}
v__ast__Type v__ast__Table_unwrap_generic_type_ex(v__ast__Table* t, v__ast__Type typ, Array_string generic_names, Array_v__ast__Type concrete_types, bool recheck_concrete_types) {
	Array_v__ast__Type final_concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__StructField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	string nrt = _S("");
	string c_nrt = _S("");
	v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
	if (ts->info._typ == 452 /* v.ast.Array */) {
		multi_return_int_v__ast__Type mr_61915 = v__ast__Table_get_array_dims(t, (*ts->info._v__ast__Array));
		int dims = mr_61915.arg0;
		v__ast__Type elem_type = mr_61915.arg1;
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type_ex(t, elem_type, generic_names, concrete_types, recheck_concrete_types);
		int idx = v__ast__Table_find_or_register_array_with_dims(t, unwrap_typ, dims);
		return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
	}
	else if (ts->info._typ == 491 /* v.ast.ArrayFixed */) {
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type_ex(t, (*ts->info._v__ast__ArrayFixed).elem_type, generic_names, concrete_types, recheck_concrete_types);
		int idx = v__ast__Table_find_or_register_array_fixed(t, unwrap_typ, (*ts->info._v__ast__ArrayFixed).size, v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, (((v__ast__None){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false), false);
		return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
	}
	else if (ts->info._typ == 492 /* v.ast.Chan */) {
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type(t, (*ts->info._v__ast__Chan).elem_type, generic_names, concrete_types);
		int idx = v__ast__Table_find_or_register_chan(t, unwrap_typ, v__ast__Type_nr_muls(unwrap_typ) > 0);
		return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
	}
	else if (ts->info._typ == 493 /* v.ast.Thread */) {
		v__ast__Type unwrap_typ = v__ast__Table_unwrap_generic_type_ex(t, (*ts->info._v__ast__Thread).return_type, generic_names, concrete_types, recheck_concrete_types);
		int idx = v__ast__Table_find_or_register_thread(t, unwrap_typ);
		return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
	}
	else if (ts->info._typ == 453 /* v.ast.Map */) {
		v__ast__Type unwrap_key_type = v__ast__Table_unwrap_generic_type_ex(t, (*ts->info._v__ast__Map).key_type, generic_names, concrete_types, recheck_concrete_types);
		v__ast__Type unwrap_value_type = v__ast__Table_unwrap_generic_type_ex(t, (*ts->info._v__ast__Map).value_type, generic_names, concrete_types, recheck_concrete_types);
		int idx = v__ast__Table_find_or_register_map(t, unwrap_key_type, unwrap_value_type);
		return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
	}
	else if (ts->info._typ == 495 /* v.ast.FnType */) {
		v__ast__Fn unwrapped_fn = (*ts->info._v__ast__FnType).func;
		unwrapped_fn.params = builtin__array_clone_to_depth(&unwrapped_fn.params, 0);
		bool has_generic = false;
		for (int i = 0; i < unwrapped_fn.params.len; ++i) {
			v__ast__Param param = ((v__ast__Param*)unwrapped_fn.params.data)[i];
			if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
				(*(v__ast__Param*)builtin__array_get(unwrapped_fn.params, i)).typ = v__ast__Table_unwrap_generic_type_ex(t, param.typ, generic_names, concrete_types, recheck_concrete_types);
				has_generic = true;
			}
		}
		if (v__ast__Type_has_flag(unwrapped_fn.return_type, v__ast__TypeFlag__generic)) {
			unwrapped_fn.return_type = v__ast__Table_unwrap_generic_type_ex(t, unwrapped_fn.return_type, generic_names, concrete_types, recheck_concrete_types);
			has_generic = true;
		}
		if (has_generic) {
			int idx = v__ast__Table_find_or_register_fn_type(t, unwrapped_fn, true, false);
			return v__ast__Type_clear_flag(v__ast__Type_derive_add_muls(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		}
		return typ;
	}
	else if (ts->info._typ == 457 /* v.ast.Struct */) {
		if (!(*ts->info._v__ast__Struct).is_generic) {
			return typ;
		}
		Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
		Array_v__ast__Type t_concrete_types = builtin__array_clone_to_depth(&concrete_types, 0);
		if (ts->generic_types.len > 0 && ts->generic_types.len == (*ts->info._v__ast__Struct).generic_types.len && !Array_v__ast__Type_arr_eq(ts->generic_types, (*ts->info._v__ast__Struct).generic_types)) {
			Array_string _t9 = {0};
			Array_v__ast__Type _t9_orig = (*ts->info._v__ast__Struct).generic_types;
			int _t9_len = _t9_orig.len;
			_t9 = builtin____new_array(0, _t9_len, sizeof(string));

			for (int _t11 = 0; _t11 < _t9_len; ++_t11) {
				v__ast__Type it = ((v__ast__Type*) _t9_orig.data)[_t11];
				string _t10 = v__ast__Table_sym(t, it)->name;
				builtin__array_push((array*)&_t9, &_t10);
			}
			t_generic_names =_t9;
			t_concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (int _t12 = 0; _t12 < ts->generic_types.len; ++_t12) {
				v__ast__Type t_typ = ((v__ast__Type*)ts->generic_types.data)[_t12];
				if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
					string tname = v__ast__Table_sym(t, t_typ)->name;
					int index = Array_string_index(generic_names, tname);
					if (index >= 0 && index < concrete_types.len) {
						builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(concrete_types, index)) }));
					}
				} else {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ v__ast__Table_unwrap_generic_type(t, t_typ, generic_names, concrete_types) }));
				}
			}
		}
		nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_S("["), 0, { .d_c = 0 }}}));
		c_nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__Struct).generic_types.len; ++i) {
			_option_v__ast__Type _t16;
			if (_t16 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Struct).generic_types, i)), t_generic_names, t_concrete_types), _t16.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t16.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				if (v__ast__Type_is_ptr(ct)) {
					nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
				}
				nrt = builtin__string__plus(nrt, gts->name);
				c_nrt = builtin__string__plus(c_nrt, gts->cname);
				if (i != (int)((*ts->info._v__ast__Struct).generic_types.len - 1)) {
					nrt = builtin__string__plus(nrt, _S(", "));
					c_nrt = builtin__string__plus(c_nrt, _S("_"));
				}
			} else {
				return typ;
			}
		}
		nrt = builtin__string__plus(nrt, _S("]"));
		int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			if (recheck_concrete_types) {
				fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__Struct).fields, 0);
				for (int i = 0; i < fields.len; ++i) {
					if (!v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
						continue;
					}
					if ((Array_v__ast__Kind_contains(builtin__new_array_from_c_array(3, 3, sizeof(v__ast__Kind), _MOV((v__ast__Kind[3]){v__ast__Kind__array, v__ast__Kind__array_fixed, v__ast__Kind__map})), v__ast__Table_type_kind(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ))) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						v__ast__Table_unwrap_generic_type_ex(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types, recheck_concrete_types);
					}
				}
				for (int i = 0; i < (*ts->info._v__ast__Struct).generic_types.len; ++i) {
					_option_v__ast__Type _t18;
					if (_t18 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Struct).generic_types, i)), t_generic_names, t_concrete_types), _t18.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t18.data;
						builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
					}
				}
				if (final_concrete_types.len > 0) {
					v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
				}
			}
			return v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		}
		if (idx == 0) {
			idx = v__ast__Table_add_placeholder_type(t, nrt, c_nrt, v__ast__Language__v);
		}
		if (_IN_MAP(ADDR(string, nrt), ADDR(map, t->unwrap_generic_type_in_depth))) {
			return v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
		}
		builtin__map_set(&t->unwrap_generic_type_in_depth, &(string[]){nrt}, &(int[]) { 1 });
		fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__Struct).fields, 0);
		for (int i = 0; i < fields.len; ++i) {
			if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
				v__ast__Type orig_type = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
				v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ);
				if (sym->kind == v__ast__Kind__struct && v__ast__Type_idx((*(v__ast__StructField*)builtin__array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
					(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
				} else {
					_option_v__ast__Type _t22;
					if (_t22 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types), _t22.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t22.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
					}
					if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic) && (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
					}
				}
				if ((*(v__ast__StructField*)builtin__array_get(fields, i)).is_embed) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, typ);
					v__ast__TypeInfo parent_info = parent_sym->info;
					if ((parent_info)._typ == 457 /* v.ast.Struct */) {
						for (int _t23 = 0; _t23 < (*parent_info._v__ast__Struct).embeds.len; ++_t23) {
							v__ast__Type* embed = ((v__ast__Type*)(*parent_info._v__ast__Struct).embeds.data) + _t23;
							if (*embed == orig_type) {
								*embed = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
								break;
							}
						}
					}
				}
			}
			if ((*(v__ast__StructField*)builtin__array_get(fields, i)).has_default_expr) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, v__ast__TypeFlag__generic)) {
					_option_v__ast__Type _t24;
					if (_t24 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, t_generic_names, t_concrete_types), _t24.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t24.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = t_typ;
					}
				} else if ((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == 0 || (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == _const_v__ast__nil_type) {
					if (v__ast__Expr_is_nil((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr) && v__ast__Type_is_any_kind_of_pointer((*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
					}
				}
			}
		}
		for (int i = 0; i < (*ts->info._v__ast__Struct).generic_types.len; ++i) {
			_option_v__ast__Type _t25;
			if (_t25 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Struct).generic_types, i)), t_generic_names, t_concrete_types), _t25.state == 0) {
				v__ast__Type t_typ = *(v__ast__Type*)_t25.data;
				builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
			}
		}
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
	}
	else if (ts->info._typ == 485 /* v.ast.Interface */) {
		if (!(*ts->info._v__ast__Interface).is_generic) {
			v__ast__Type _t27 = typ;
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t27;
		}
		Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
		Array_v__ast__Type t_concrete_types = builtin__array_clone_to_depth(&concrete_types, 0);
		if (ts->generic_types.len > 0 && ts->generic_types.len == (*ts->info._v__ast__Interface).generic_types.len && !Array_v__ast__Type_arr_eq(ts->generic_types, (*ts->info._v__ast__Interface).generic_types)) {
			Array_string _t28 = {0};
			Array_v__ast__Type _t28_orig = (*ts->info._v__ast__Interface).generic_types;
			int _t28_len = _t28_orig.len;
			_t28 = builtin____new_array(0, _t28_len, sizeof(string));

			for (int _t30 = 0; _t30 < _t28_len; ++_t30) {
				v__ast__Type it = ((v__ast__Type*) _t28_orig.data)[_t30];
				string _t29 = v__ast__Table_sym(t, it)->name;
				builtin__array_push((array*)&_t28, &_t29);
			}
			t_generic_names =_t28;
			t_concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (int _t31 = 0; _t31 < ts->generic_types.len; ++_t31) {
				v__ast__Type t_typ = ((v__ast__Type*)ts->generic_types.data)[_t31];
				if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
					string tname = v__ast__Table_sym(t, t_typ)->name;
					int index = Array_string_index(generic_names, tname);
					if (index >= 0 && index < concrete_types.len) {
						builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(concrete_types, index)) }));
					}
				} else {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ v__ast__Table_unwrap_generic_type(t, t_typ, generic_names, concrete_types) }));
				}
			}
		}
		nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_S("["), 0, { .d_c = 0 }}}));
		c_nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__Interface).generic_types.len; ++i) {
			_option_v__ast__Type _t35;
			if (_t35 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Interface).generic_types, i)), t_generic_names, t_concrete_types), _t35.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t35.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				if (v__ast__Type_is_ptr(ct)) {
					nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
				}
				nrt = builtin__string__plus(nrt, gts->name);
				c_nrt = builtin__string__plus(c_nrt, gts->cname);
				if (i != (int)((*ts->info._v__ast__Interface).generic_types.len - 1)) {
					nrt = builtin__string__plus(nrt, _S(", "));
					c_nrt = builtin__string__plus(c_nrt, _S("_"));
				}
			} else {
				v__ast__Type _t36 = typ;
					{ // defer begin
						builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
					} // defer end
				return _t36;
			}
		}
		nrt = builtin__string__plus(nrt, _S("]"));
		int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			if (recheck_concrete_types) {
				fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__Interface).fields, 0);
				for (int i = 0; i < fields.len; ++i) {
					if (!v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
						continue;
					}
					if ((Array_v__ast__Kind_contains(builtin__new_array_from_c_array(3, 3, sizeof(v__ast__Kind), _MOV((v__ast__Kind[3]){v__ast__Kind__array, v__ast__Kind__array_fixed, v__ast__Kind__map})), v__ast__Table_type_kind(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ))) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						v__ast__Table_unwrap_generic_type_ex(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types, recheck_concrete_types);
					}
				}
				for (int i = 0; i < (*ts->info._v__ast__Interface).generic_types.len; ++i) {
					_option_v__ast__Type _t37;
					if (_t37 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Interface).generic_types, i)), t_generic_names, t_concrete_types), _t37.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t37.data;
						builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
					}
				}
				if (final_concrete_types.len > 0) {
					v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
				}
			}
			v__ast__Type _t39 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t39;
		}
		if (idx == 0) {
			idx = v__ast__Table_add_placeholder_type(t, nrt, c_nrt, v__ast__Language__v);
		}
		if (_IN_MAP(ADDR(string, nrt), ADDR(map, t->unwrap_generic_type_in_depth))) {
			v__ast__Type _t40 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t40;
		}
		builtin__map_set(&t->unwrap_generic_type_in_depth, &(string[]){nrt}, &(int[]) { 1 });
		fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__Interface).fields, 0);
		for (int i = 0; i < fields.len; ++i) {
			if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
				v__ast__Type orig_type = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
				v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ);
				if (sym->kind == v__ast__Kind__struct && v__ast__Type_idx((*(v__ast__StructField*)builtin__array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
					(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
				} else {
					_option_v__ast__Type _t41;
					if (_t41 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types), _t41.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t41.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
					}
					if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic) && (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
					}
				}
				if ((*(v__ast__StructField*)builtin__array_get(fields, i)).is_embed) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, typ);
					v__ast__TypeInfo parent_info = parent_sym->info;
					if ((parent_info)._typ == 457 /* v.ast.Struct */) {
						for (int _t42 = 0; _t42 < (*parent_info._v__ast__Struct).embeds.len; ++_t42) {
							v__ast__Type* embed = ((v__ast__Type*)(*parent_info._v__ast__Struct).embeds.data) + _t42;
							if (*embed == orig_type) {
								*embed = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
								break;
							}
						}
					}
				}
			}
			if ((*(v__ast__StructField*)builtin__array_get(fields, i)).has_default_expr) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, v__ast__TypeFlag__generic)) {
					_option_v__ast__Type _t43;
					if (_t43 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, t_generic_names, t_concrete_types), _t43.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t43.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = t_typ;
					}
				} else if ((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == 0 || (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == _const_v__ast__nil_type) {
					if (v__ast__Expr_is_nil((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr) && v__ast__Type_is_any_kind_of_pointer((*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
					}
				}
			}
		}
		for (int i = 0; i < (*ts->info._v__ast__Interface).generic_types.len; ++i) {
			_option_v__ast__Type _t44;
			if (_t44 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__Interface).generic_types, i)), t_generic_names, t_concrete_types), _t44.state == 0) {
				v__ast__Type t_typ = *(v__ast__Type*)_t44.data;
				builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
			}
		}
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
	}
	else if (ts->info._typ == 486 /* v.ast.SumType */) {
		if (!(*ts->info._v__ast__SumType).is_generic) {
			v__ast__Type _t46 = typ;
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t46;
		}
		Array_string t_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
		Array_v__ast__Type t_concrete_types = builtin__array_clone_to_depth(&concrete_types, 0);
		if (ts->generic_types.len > 0 && ts->generic_types.len == (*ts->info._v__ast__SumType).generic_types.len && !Array_v__ast__Type_arr_eq(ts->generic_types, (*ts->info._v__ast__SumType).generic_types)) {
			Array_string _t47 = {0};
			Array_v__ast__Type _t47_orig = (*ts->info._v__ast__SumType).generic_types;
			int _t47_len = _t47_orig.len;
			_t47 = builtin____new_array(0, _t47_len, sizeof(string));

			for (int _t49 = 0; _t49 < _t47_len; ++_t49) {
				v__ast__Type it = ((v__ast__Type*) _t47_orig.data)[_t49];
				string _t48 = v__ast__Table_sym(t, it)->name;
				builtin__array_push((array*)&_t47, &_t48);
			}
			t_generic_names =_t47;
			t_concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (int _t50 = 0; _t50 < ts->generic_types.len; ++_t50) {
				v__ast__Type t_typ = ((v__ast__Type*)ts->generic_types.data)[_t50];
				if (!v__ast__Type_has_flag(t_typ, v__ast__TypeFlag__generic)) {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
				} else if (v__ast__Table_sym(t, t_typ)->kind == v__ast__Kind__any) {
					string tname = v__ast__Table_sym(t, t_typ)->name;
					int index = Array_string_index(generic_names, tname);
					if (index >= 0 && index < concrete_types.len) {
						builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ (*(v__ast__Type*)builtin__array_get(concrete_types, index)) }));
					}
				} else {
					builtin__array_push((array*)&t_concrete_types, _MOV((v__ast__Type[]){ v__ast__Table_unwrap_generic_type(t, t_typ, generic_names, concrete_types) }));
				}
			}
		}
		nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->name}}, {_S("["), 0, { .d_c = 0 }}}));
		c_nrt = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = ts->cname}}, {_S("_T_"), 0, { .d_c = 0 }}}));
		for (int i = 0; i < (*ts->info._v__ast__SumType).generic_types.len; ++i) {
			_option_v__ast__Type _t54;
			if (_t54 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__SumType).generic_types, i)), t_generic_names, t_concrete_types), _t54.state == 0) {
				v__ast__Type ct = *(v__ast__Type*)_t54.data;
				v__ast__TypeSymbol* gts = v__ast__Table_sym(t, ct);
				if (v__ast__Type_is_ptr(ct)) {
					nrt = builtin__string__plus(nrt, builtin__string_repeat(_S("&"), v__ast__Type_nr_muls(ct)));
				}
				nrt = builtin__string__plus(nrt, gts->name);
				c_nrt = builtin__string__plus(c_nrt, gts->cname);
				if (i != (int)((*ts->info._v__ast__SumType).generic_types.len - 1)) {
					nrt = builtin__string__plus(nrt, _S(", "));
					c_nrt = builtin__string__plus(c_nrt, _S("_"));
				}
			} else {
				v__ast__Type _t55 = typ;
					{ // defer begin
						builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
					} // defer end
					{ // defer begin
						builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
					} // defer end
				return _t55;
			}
		}
		nrt = builtin__string__plus(nrt, _S("]"));
		int idx = (*(int*)builtin__map_get(ADDR(map, t->type_idxs), &(string[]){nrt}, &(int[]){ 0 }));
		if (idx != 0 && (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, idx))->kind != v__ast__Kind__placeholder) {
			if (recheck_concrete_types) {
				fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__SumType).fields, 0);
				for (int i = 0; i < fields.len; ++i) {
					if (!v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
						continue;
					}
					if ((Array_v__ast__Kind_contains(builtin__new_array_from_c_array(3, 3, sizeof(v__ast__Kind), _MOV((v__ast__Kind[3]){v__ast__Kind__array, v__ast__Kind__array_fixed, v__ast__Kind__map})), v__ast__Table_type_kind(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ))) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						v__ast__Table_unwrap_generic_type_ex(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types, recheck_concrete_types);
					}
				}
				for (int i = 0; i < (*ts->info._v__ast__SumType).generic_types.len; ++i) {
					_option_v__ast__Type _t56;
					if (_t56 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__SumType).generic_types, i)), t_generic_names, t_concrete_types), _t56.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t56.data;
						builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
					}
				}
				if (final_concrete_types.len > 0) {
					v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
				}
			}
			v__ast__Type _t58 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t58;
		}
		if (idx == 0) {
			idx = v__ast__Table_add_placeholder_type(t, nrt, c_nrt, v__ast__Language__v);
		}
		if (_IN_MAP(ADDR(string, nrt), ADDR(map, t->unwrap_generic_type_in_depth))) {
			v__ast__Type _t59 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(idx), typ), v__ast__TypeFlag__generic);
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
				{ // defer begin
					builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
				} // defer end
			return _t59;
		}
		builtin__map_set(&t->unwrap_generic_type_in_depth, &(string[]){nrt}, &(int[]) { 1 });
		fields = builtin__array_clone_to_depth(&(*ts->info._v__ast__SumType).fields, 0);
		for (int i = 0; i < fields.len; ++i) {
			if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
				v__ast__Type orig_type = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
				v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ);
				if (sym->kind == v__ast__Kind__struct && v__ast__Type_idx((*(v__ast__StructField*)builtin__array_get(fields, i)).typ) != v__ast__Type_idx(typ)) {
					(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
				} else {
					_option_v__ast__Type _t60;
					if (_t60 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types), _t60.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t60.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
					}
					if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic) && (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map) && v__ast__Table_check_if_elements_need_unwrap(t, typ, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, t_generic_names, t_concrete_types);
					}
				}
				if ((*(v__ast__StructField*)builtin__array_get(fields, i)).is_embed) {
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, typ);
					v__ast__TypeInfo parent_info = parent_sym->info;
					if ((parent_info)._typ == 457 /* v.ast.Struct */) {
						for (int _t61 = 0; _t61 < (*parent_info._v__ast__Struct).embeds.len; ++_t61) {
							v__ast__Type* embed = ((v__ast__Type*)(*parent_info._v__ast__Struct).embeds.data) + _t61;
							if (*embed == orig_type) {
								*embed = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
								break;
							}
						}
					}
				}
			}
			if ((*(v__ast__StructField*)builtin__array_get(fields, i)).has_default_expr) {
				if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, v__ast__TypeFlag__generic)) {
					_option_v__ast__Type _t62;
					if (_t62 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ, t_generic_names, t_concrete_types), _t62.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t62.data;
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = t_typ;
					}
				} else if ((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == 0 || (*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ == _const_v__ast__nil_type) {
					if (v__ast__Expr_is_nil((*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr) && v__ast__Type_is_any_kind_of_pointer((*(v__ast__StructField*)builtin__array_get(fields, i)).typ)) {
						(*(v__ast__StructField*)builtin__array_get(fields, i)).default_expr_typ = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
					}
				}
			}
		}
		for (int i = 0; i < (*ts->info._v__ast__SumType).generic_types.len; ++i) {
			_option_v__ast__Type _t63;
			if (_t63 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get((*ts->info._v__ast__SumType).generic_types, i)), t_generic_names, t_concrete_types), _t63.state == 0) {
				v__ast__Type t_typ = *(v__ast__Type*)_t63.data;
				builtin__array_push((array*)&final_concrete_types, _MOV((v__ast__Type[]){ t_typ }));
			}
		}
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
		{ // defer begin
			builtin__map_delete(&t->unwrap_generic_type_in_depth, &(string[]){nrt});
		} // defer end
	}
	
	else {
	}
	
	if (ts->info._typ == 457 /* v.ast.Struct */) {
		v__ast__Struct info = (*ts->info._v__ast__Struct);
		info.is_generic = false;
		info.concrete_types = final_concrete_types;
		info.parent_type = v__ast__Type_set_flag(typ, v__ast__TypeFlag__generic);
		info.fields = fields;
		int new_idx = v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
			.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
			.mod = ts->mod,
			.name = nrt,
			.cname = v__util__no_dots(c_nrt),
			.rname = (string){.str=(byteptr)"", .is_lit=1},
			.ngname = (string){.str=(byteptr)"", .is_lit=1},
			.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(&info, false),
			.align = -1,
			.idx = 0,
			.size = -1,
			.parent_idx = 0,
			.kind = v__ast__Kind__struct,
			.language = 0,
			.is_pub = ts->is_pub,
			.is_builtin = 0,
		}));
		if (final_concrete_types.len > 0) {
			v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
		}
		v__ast__Type _t65 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(new_idx), typ), v__ast__TypeFlag__generic);
		return _t65;
	}
	else if (ts->info._typ == 486 /* v.ast.SumType */) {
		Array_v__ast__Type variants = builtin__array_clone_to_depth(&(*ts->info._v__ast__SumType).variants, 0);
		for (int i = 0; i < variants.len; ++i) {
			if (v__ast__Type_has_flag((*(v__ast__Type*)builtin__array_get(variants, i)), v__ast__TypeFlag__generic)) {
				v__ast__TypeSymbol* sym = v__ast__Table_sym(t, (*(v__ast__Type*)builtin__array_get(variants, i)));
				if (sym->kind == v__ast__Kind__struct || sym->kind == v__ast__Kind__sum_type || sym->kind == v__ast__Kind__interface) {
					builtin__array_set(&variants, i, &(v__ast__Type[]) { v__ast__Table_unwrap_generic_type(t, (*(v__ast__Type*)builtin__array_get(variants, i)), generic_names, concrete_types) });
				} else {
					_option_v__ast__Type _t66;
					if (_t66 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get(variants, i)), generic_names, concrete_types), _t66.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t66.data;
						builtin__array_set(&variants, i, &(v__ast__Type[]) { t_typ });
					}
				}
			}
		}
		v__ast__SumType info = (*ts->info._v__ast__SumType);
		info.is_generic = false;
		info.concrete_types = final_concrete_types;
		info.parent_type = v__ast__Type_set_flag(typ, v__ast__TypeFlag__generic);
		info.fields = fields;
		info.variants = variants;
		int new_idx = v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
			.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
			.mod = ts->mod,
			.name = nrt,
			.cname = v__util__no_dots(c_nrt),
			.rname = (string){.str=(byteptr)"", .is_lit=1},
			.ngname = (string){.str=(byteptr)"", .is_lit=1},
			.info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(&info, false),
			.align = -1,
			.idx = 0,
			.size = -1,
			.parent_idx = 0,
			.kind = v__ast__Kind__sum_type,
			.language = 0,
			.is_pub = ts->is_pub,
			.is_builtin = 0,
		}));
		if (final_concrete_types.len > 0) {
			v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
		}
		v__ast__Type _t67 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(new_idx), typ), v__ast__TypeFlag__generic);
		return _t67;
	}
	else if (ts->info._typ == 485 /* v.ast.Interface */) {
		Array_v__ast__Fn imethods = builtin__array_clone_to_depth(&(*ts->info._v__ast__Interface).methods, 0);
		Array_string gn_names = v__ast__Table_get_real_generic_names(t, typ, generic_names);
		for (int _t68 = 0; _t68 < imethods.len; ++_t68) {
			v__ast__Fn* method = ((v__ast__Fn*)imethods.data) + _t68;
			_option_v__ast__Type _t69;
			if (_t69 = v__ast__Table_convert_generic_type(t, method->return_type, gn_names, builtin__array_slice(concrete_types, 0, gn_names.len)), _t69.state == 0) {
				v__ast__Type unwrap_typ = *(v__ast__Type*)_t69.data;
				method->return_type = unwrap_typ;
			}
			for (int _t70 = 0; _t70 < method->params.len; ++_t70) {
				v__ast__Param* param = ((v__ast__Param*)method->params.data) + _t70;
				_option_v__ast__Type _t71;
				if (_t71 = v__ast__Table_convert_generic_type(t, param->typ, gn_names, concrete_types), _t71.state == 0) {
					v__ast__Type unwrap_typ = *(v__ast__Type*)_t71.data;
					param->typ = unwrap_typ;
				}
			}
		}
		Array_v__ast__Fn all_methods = builtin__array_clone_to_depth(&ts->methods, 0);
		for (int _t72 = 0; _t72 < imethods.len; ++_t72) {
			v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t72];
			for (int _t73 = 0; _t73 < all_methods.len; ++_t73) {
				v__ast__Fn* method = ((v__ast__Fn*)all_methods.data) + _t73;
				if (builtin__string__eq(imethod.name, method->name)) {
					*method = imethod;
				}
			}
		}
		v__ast__Interface info = (*ts->info._v__ast__Interface);
		bool _t74 = false;
		Array_v__ast__Type _t74_orig = final_concrete_types;
		int _t74_len = _t74_orig.len;
		for (int _t75 = 0; _t75 < _t74_len; ++_t75) {
			v__ast__Type it = ((v__ast__Type*) _t74_orig.data)[_t75];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag__generic)) {
				_t74 = true;
				break;
			}
		}
		info.is_generic =_t74;
		info.concrete_types = final_concrete_types;
		info.parent_type = v__ast__Type_set_flag(typ, v__ast__TypeFlag__generic);
		info.fields = fields;
		info.methods = imethods;
		int new_idx = v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
			.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
			.mod = ts->mod,
			.name = nrt,
			.cname = v__util__no_dots(c_nrt),
			.rname = (string){.str=(byteptr)"", .is_lit=1},
			.ngname = (string){.str=(byteptr)"", .is_lit=1},
			.info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info, false),
			.align = -1,
			.idx = 0,
			.size = -1,
			.parent_idx = 0,
			.kind = v__ast__Kind__interface,
			.language = 0,
			.is_pub = ts->is_pub,
			.is_builtin = 0,
		}));
		v__ast__TypeSymbol* ts_copy = v__ast__Table_sym(t, v__ast__idx_to_type(new_idx));
		for (int _t76 = 0; _t76 < all_methods.len; ++_t76) {
			v__ast__Fn method = ((v__ast__Fn*)all_methods.data)[_t76];
			v__ast__TypeSymbol_register_method(ts_copy, method);
		}
		if (final_concrete_types.len > 0) {
			v__ast__Table_unwrap_method_types(t, ts, generic_names, concrete_types, final_concrete_types);
		}
		v__ast__Type _t77 = v__ast__Type_clear_flag(v__ast__Type_derive(v__ast__new_type(new_idx), typ), v__ast__TypeFlag__generic);
		return _t77;
	}
	
	else {
		if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
			_option_v__ast__Type _t78;
			if (_t78 = v__ast__Table_convert_generic_type(t, typ, generic_names, concrete_types), _t78.state == 0) {
				v__ast__Type converted = *(v__ast__Type*)_t78.data;
				v__ast__Type _t79 = converted;
				return _t79;
			}
		}
	}
	
	v__ast__Type _t80 = typ;
	return _t80;
}
VV_LOC void v__ast__Table_unwrap_method_types(v__ast__Table* t, v__ast__TypeSymbol* ts, Array_string generic_names, Array_v__ast__Type concrete_types, Array_v__ast__Type final_concrete_types) {
	Array_v__ast__Type needs_unwrap_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__Fn _t1 = v__ast__TypeSymbol_get_methods(ts);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn method = ((v__ast__Fn*)_t1.data)[_t2];
		for (int i = 1; i < method.params.len; ++i) {
			if (v__ast__Type_has_flag((*(v__ast__Param*)builtin__array_get(method.params, i)).typ, v__ast__TypeFlag__generic) && (*(v__ast__Param*)builtin__array_get(method.params, i)).typ != (*(v__ast__Param*)builtin__array_get(method.params, 0)).typ) {
				if (!(Array_v__ast__Type_contains(needs_unwrap_types, (*(v__ast__Param*)builtin__array_get(method.params, i)).typ))) {
					builtin__array_push((array*)&needs_unwrap_types, _MOV((v__ast__Type[]){ (*(v__ast__Param*)builtin__array_get(method.params, i)).typ }));
				}
			}
			if (v__ast__Type_has_flag(method.return_type, v__ast__TypeFlag__generic) && method.return_type != (*(v__ast__Param*)builtin__array_get(method.params, 0)).typ) {
				if (!(Array_v__ast__Type_contains(needs_unwrap_types, method.return_type))) {
					builtin__array_push((array*)&needs_unwrap_types, _MOV((v__ast__Type[]){ method.return_type }));
				}
			}
		}
		if (final_concrete_types.len == method.generic_names.len) {
			v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), final_concrete_types);
		}
	}
	for (int _t5 = 0; _t5 < needs_unwrap_types.len; ++_t5) {
		v__ast__Type typ_ = ((v__ast__Type*)needs_unwrap_types.data)[_t5];
		v__ast__Table_unwrap_generic_type(t, typ_, generic_names, concrete_types);
	}
}
void v__ast__Table_generic_insts_to_concrete(v__ast__Table* t) {
	for (int _t1 = 0; _t1 < t->type_symbols.len; ++_t1) {
		v__ast__TypeSymbol* sym = ((v__ast__TypeSymbol**)t->type_symbols.data)[_t1];
		if (sym->kind == v__ast__Kind__generic_inst) {
			v__ast__GenericInst info = *(v__ast__GenericInst*)builtin____as_cast((sym->info)._v__ast__GenericInst,(sym->info)._typ, 496);
			v__ast__TypeSymbol* parent = (*(v__ast__TypeSymbol**)builtin__array_get(t->type_symbols, info.parent_idx));
			if (parent->kind == v__ast__Kind__placeholder) {
				sym->kind = v__ast__Kind__placeholder;
				continue;
			}
			if (parent->info._typ == 457 /* v.ast.Struct */) {
				v__ast__Struct parent_info = (*parent->info._v__ast__Struct);
				if (!parent_info.is_generic) {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("struct `"), 0xfe10, {.d_s = parent->name}}, {_S("` is not a generic struct, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				Array_v__ast__StructField fields = builtin__array_clone_to_depth(&parent_info.fields, 0);
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_string generic_names = v__ast__Table_get_generic_names(t, parent_info.generic_types);
					for (int i = 0; i < fields.len; ++i) {
						if (v__ast__Type_has_flag((*(v__ast__StructField*)builtin__array_get(fields, i)).typ, v__ast__TypeFlag__generic)) {
							v__ast__Type orig_type = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
							if (v__ast__Type_idx((*(v__ast__StructField*)builtin__array_get(fields, i)).typ) != info.parent_idx) {
								(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = v__ast__Table_unwrap_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, generic_names, info.concrete_types);
							}
							_option_v__ast__Type _t2;
							if (_t2 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, generic_names, info.concrete_types), _t2.state == 0) {
								v__ast__Type t_typ = *(v__ast__Type*)_t2.data;
								(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
							}
							if ((*(v__ast__StructField*)builtin__array_get(fields, i)).is_embed) {
								for (int _t3 = 0; _t3 < parent_info.embeds.len; ++_t3) {
									v__ast__Type* embed = ((v__ast__Type*)parent_info.embeds.data) + _t3;
									if (*embed == orig_type) {
										*embed = (*(v__ast__StructField*)builtin__array_get(fields, i)).typ;
										break;
									}
								}
							}
						}
					}
					parent_info.is_generic = false;
					parent_info.concrete_types = builtin__array_clone_to_depth(&info.concrete_types, 0);
					parent_info.fields = fields;
					parent_info.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic);
					sym->info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, (((v__ast__Struct){.generic_types = (parent_info).generic_types,.embeds = (parent_info).embeds,.fields = (parent_info).fields,.attrs = (parent_info).attrs,.concrete_types = builtin__array_clone_to_depth(&info.concrete_types, 0),.scoped_name = (parent_info).scoped_name,.name_pos = (parent_info).name_pos,.parent_type = (parent_info).parent_type,.is_anon = (parent_info).is_anon,.is_generic = false,.is_shared = (parent_info).is_shared,.is_markused = (parent_info).is_markused,.has_option = (parent_info).has_option,.is_heap = (parent_info).is_heap,.is_union = (parent_info).is_union,.is_minify = (parent_info).is_minify,.is_typedef = (parent_info).is_typedef,}))), false);
					sym->is_pub = true;
					sym->kind = parent->kind;
					v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(t, parent_info.parent_type);
					for (int _t4 = 0; _t4 < parent_sym->methods.len; ++_t4) {
						v__ast__Fn method = ((v__ast__Fn*)parent_sym->methods.data)[_t4];
						if (method.generic_names.len == info.concrete_types.len) {
							v__ast__Table_register_fn_concrete_types(t, v__ast__Fn_fkey(&method), info.concrete_types);
						}
					}
				} else {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of struct `"), 0xfe10, {.d_s = parent->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			else if (parent->info._typ == 485 /* v.ast.Interface */) {
				v__ast__Interface parent_info = (*parent->info._v__ast__Interface);
				if (!parent_info.is_generic) {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("interface `"), 0xfe10, {.d_s = parent->name}}, {_S("` is not a generic interface, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_v__ast__StructField fields = builtin__array_clone_to_depth(&parent_info.fields, 0);
					Array_string generic_names = v__ast__Table_get_generic_names(t, parent_info.generic_types);
					for (int i = 0; i < fields.len; ++i) {
						_option_v__ast__Type _t5;
						if (_t5 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, generic_names, info.concrete_types), _t5.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t5.data;
							(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
						}
					}
					Array_v__ast__Fn imethods = builtin__array_clone_to_depth(&parent_info.methods, 0);
					for (int _t6 = 0; _t6 < imethods.len; ++_t6) {
						v__ast__Fn* method = ((v__ast__Fn*)imethods.data) + _t6;
						builtin__array_clear(&method->generic_names);
						_option_v__ast__Type _t7;
						if (_t7 = v__ast__Table_convert_generic_type(t, method->return_type, generic_names, info.concrete_types), _t7.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t7.data;
							method->return_type = pt;
						}
						method->params = builtin__array_clone_to_depth(&method->params, 0);
						for (int _t8 = 0; _t8 < method->params.len; ++_t8) {
							v__ast__Param* param = ((v__ast__Param*)method->params.data) + _t8;
							_option_v__ast__Type _t9;
							if (_t9 = v__ast__Table_convert_generic_type(t, param->typ, generic_names, info.concrete_types), _t9.state == 0) {
								v__ast__Type pt = *(v__ast__Type*)_t9.data;
								param->typ = pt;
							}
						}
						v__ast__TypeSymbol_register_method(sym, *method);
					}
					Array_v__ast__Fn all_methods = builtin__array_clone_to_depth(&parent->methods, 0);
					for (int _t10 = 0; _t10 < imethods.len; ++_t10) {
						v__ast__Fn imethod = ((v__ast__Fn*)imethods.data)[_t10];
						for (int _t11 = 0; _t11 < all_methods.len; ++_t11) {
							v__ast__Fn* method = ((v__ast__Fn*)all_methods.data) + _t11;
							if (builtin__string__eq(imethod.name, method->name)) {
								*method = imethod;
							}
						}
					}
					sym->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, (((v__ast__Interface){.generic_types = (parent_info).generic_types,.fields = fields,.methods = imethods,.embeds = (parent_info).embeds,.types = (parent_info).types,.concrete_types = builtin__array_clone_to_depth(&info.concrete_types, 0),.conversions = (parent_info).conversions,.name_pos = (parent_info).name_pos,.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic),.is_markused = (parent_info).is_markused,.is_generic = false,}))), false);
					sym->is_pub = true;
					sym->kind = parent->kind;
					sym->methods = all_methods;
				} else {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of interface `"), 0xfe10, {.d_s = parent->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			else if (parent->info._typ == 486 /* v.ast.SumType */) {
				v__ast__SumType parent_info = (*parent->info._v__ast__SumType);
				if (!parent_info.is_generic) {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sumtype `"), 0xfe10, {.d_s = parent->name}}, {_S("` is not a generic sumtype, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
					continue;
				}
				if (parent_info.generic_types.len == info.concrete_types.len) {
					Array_v__ast__StructField fields = builtin__array_clone_to_depth(&parent_info.fields, 0);
					Array_v__ast__Type variants = builtin__array_clone_to_depth(&parent_info.variants, 0);
					Array_string generic_names = v__ast__Table_get_generic_names(t, parent_info.generic_types);
					for (int i = 0; i < fields.len; ++i) {
						_option_v__ast__Type _t12;
						if (_t12 = v__ast__Table_convert_generic_type(t, (*(v__ast__StructField*)builtin__array_get(fields, i)).typ, generic_names, info.concrete_types), _t12.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t12.data;
							(*(v__ast__StructField*)builtin__array_get(fields, i)).typ = t_typ;
						}
					}
					for (int i = 0; i < variants.len; ++i) {
						if (v__ast__Type_has_flag((*(v__ast__Type*)builtin__array_get(variants, i)), v__ast__TypeFlag__generic)) {
							v__ast__TypeSymbol* t_sym = v__ast__Table_sym(t, (*(v__ast__Type*)builtin__array_get(variants, i)));
							if (t_sym->kind == v__ast__Kind__struct && v__ast__Type_idx((*(v__ast__Type*)builtin__array_get(variants, i))) != info.parent_idx) {
								builtin__array_set(&variants, i, &(v__ast__Type[]) { v__ast__Table_unwrap_generic_type(t, (*(v__ast__Type*)builtin__array_get(variants, i)), generic_names, info.concrete_types) });
							} else {
								_option_v__ast__Type _t13;
								if (_t13 = v__ast__Table_convert_generic_type(t, (*(v__ast__Type*)builtin__array_get(variants, i)), generic_names, info.concrete_types), _t13.state == 0) {
									v__ast__Type t_typ = *(v__ast__Type*)_t13.data;
									builtin__array_set(&variants, i, &(v__ast__Type[]) { t_typ });
								}
							}
						}
					}
					sym->info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, (((v__ast__SumType){.fields = fields,.variants = variants,.generic_types = (parent_info).generic_types,.concrete_types = builtin__array_clone_to_depth(&info.concrete_types, 0),.name_pos = (parent_info).name_pos,.parent_type = v__ast__Type_set_flag(v__ast__new_type(info.parent_idx), v__ast__TypeFlag__generic),.found_fields = (parent_info).found_fields,.is_anon = (parent_info).is_anon,.is_generic = false,}))), false);
					sym->is_pub = true;
					sym->kind = parent->kind;
				} else {
					v__util__verror(_S("generic error"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of sumtype `"), 0xfe10, {.d_s = parent->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})));
					VUNREACHABLE();
				}
			}
			else if (parent->info._typ == 495 /* v.ast.FnType */) {
				v__ast__FnType parent_info = (*parent->info._v__ast__FnType);
				v__ast__Fn function = parent_info.func;
				function.params = builtin__array_clone_to_depth(&function.params, 0);
				for (int _t14 = 0; _t14 < function.params.len; ++_t14) {
					v__ast__Param* param = ((v__ast__Param*)function.params.data) + _t14;
					if (v__ast__Type_has_flag(param->typ, v__ast__TypeFlag__generic)) {
						_option_v__ast__Type _t15;
						if (_t15 = v__ast__Table_convert_generic_type(t, param->typ, function.generic_names, info.concrete_types), _t15.state == 0) {
							v__ast__Type t_typ = *(v__ast__Type*)_t15.data;
							param->typ = t_typ;
						}
					}
				}
				if (v__ast__Type_has_flag(function.return_type, v__ast__TypeFlag__generic)) {
					_option_v__ast__Type _t16;
					if (_t16 = v__ast__Table_convert_generic_type(t, function.return_type, function.generic_names, info.concrete_types), _t16.state == 0) {
						v__ast__Type t_typ = *(v__ast__Type*)_t16.data;
						function.return_type = t_typ;
					}
				}
				function.generic_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				sym->info = v__ast__FnType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__FnType, (((v__ast__FnType){.is_anon = (parent_info).is_anon,.has_decl = (parent_info).has_decl,.func = function,}))), false);
				sym->is_pub = true;
				sym->kind = parent->kind;
			}
			
			else {
			}
			
		}
	}
}
Array_string v__ast__Table_get_real_generic_names(v__ast__Table* t, v__ast__Type typ, Array_string generic_names) {
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
		string typ_name = v__ast__Table_type_to_str(t, typ);
		if (builtin__string_contains(typ_name, _S(">["))) {
			return builtin__string_split(builtin__string_all_before_last((*(string*)builtin__array_get(builtin__string_split(typ_name, _S(">[")), 1)), _S("]")), _S(","));
		}
	}
	return generic_names;
}
Array_string v__ast__Table_get_generic_names(v__ast__Table* t, Array_v__ast__Type generic_types) {
	Array_string generic_names = builtin____new_array_with_default(0, generic_types.len, sizeof(string), 0);
	for (int _t1 = 0; _t1 < generic_types.len; ++_t1) {
		v__ast__Type typ = ((v__ast__Type*)generic_types.data)[_t1];
		if (!v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
			continue;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
		v__ast__TypeInfo info = sym->info;
		if (info._typ == 494 /* v.ast.MultiReturn */) {
			_PUSH_MANY(&generic_names, (v__ast__Table_get_generic_names(t, (*info._v__ast__MultiReturn).types)), _t2, Array_string);
		}
		
		else {
			builtin__array_push((array*)&generic_names, _MOV((string[]){ builtin__string_clone(sym->name) }));
		}
		
	}
	return generic_names;
}
bool v__ast__Table_check_if_elements_need_unwrap(v__ast__Table* t, v__ast__Type root_typ, v__ast__Type typ) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (!(sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__map)) {
		return false;
	}
	Array_v__ast__Type typs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (sym->info._typ == 452 /* v.ast.Array */) {
		builtin__array_push((array*)&typs, _MOV((v__ast__Type[]){ ((*sym->info._v__ast__Array)).elem_type }));
	}
	else if (sym->info._typ == 491 /* v.ast.ArrayFixed */) {
		builtin__array_push((array*)&typs, _MOV((v__ast__Type[]){ ((*sym->info._v__ast__ArrayFixed)).elem_type }));
	}
	else if (sym->info._typ == 453 /* v.ast.Map */) {
		builtin__array_push((array*)&typs, _MOV((v__ast__Type[]){ ((*sym->info._v__ast__Map)).key_type }));
		builtin__array_push((array*)&typs, _MOV((v__ast__Type[]){ ((*sym->info._v__ast__Map)).value_type }));
	}
	
	else {
	}
	
	for (int _t6 = 0; _t6 < typs.len; ++_t6) {
		v__ast__Type typ_ = ((v__ast__Type*)typs.data)[_t6];
		if (v__ast__Type_has_flag(typ_, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* t_sym = v__ast__Table_sym(t, typ_);
			if (t_sym->info._typ == 457 /* v.ast.Struct */) {
				if ((*t_sym->info._v__ast__Struct).is_generic && (*t_sym->info._v__ast__Struct).generic_types.len > 0 && (*t_sym->info._v__ast__Struct).concrete_types.len == 0 && v__ast__Type_idx(typ_) != v__ast__Type_idx(root_typ)) {
					return true;
				}
			}
			else if (t_sym->info._typ == 485 /* v.ast.Interface */) {
				if ((*t_sym->info._v__ast__Interface).is_generic && (*t_sym->info._v__ast__Interface).generic_types.len > 0 && (*t_sym->info._v__ast__Interface).concrete_types.len == 0 && v__ast__Type_idx(typ_) != v__ast__Type_idx(root_typ)) {
					return true;
				}
			}
			else if (t_sym->info._typ == 486 /* v.ast.SumType */) {
				if ((*t_sym->info._v__ast__SumType).is_generic && (*t_sym->info._v__ast__SumType).generic_types.len > 0 && (*t_sym->info._v__ast__SumType).concrete_types.len == 0 && v__ast__Type_idx(typ_) != v__ast__Type_idx(root_typ)) {
					return true;
				}
			}
			
			else {
			}
			
		}
		if (v__ast__Table_check_if_elements_need_unwrap(t, root_typ, typ_)) {
			return true;
		}
	}
	return false;
}
Array_string v__ast__Table_dependent_names_in_expr(v__ast__Table* t, v__ast__Expr expr) {
	Array_string names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (expr._typ == 261 /* v.ast.ArrayInit */) {
		for (int _t1 = 0; _t1 < (*expr._v__ast__ArrayInit).exprs.len; ++_t1) {
			v__ast__Expr elem_expr = ((v__ast__Expr*)(*expr._v__ast__ArrayInit).exprs.data)[_t1];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, elem_expr)), _t2, Array_string);
		}
		if ((*expr._v__ast__ArrayInit).has_len) {
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__ArrayInit).len_expr)), _t3, Array_string);
		}
		if ((*expr._v__ast__ArrayInit).has_cap) {
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__ArrayInit).cap_expr)), _t4, Array_string);
		}
		if ((*expr._v__ast__ArrayInit).has_init) {
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__ArrayInit).init_expr)), _t5, Array_string);
		}
	}
	else if (expr._typ == 267 /* v.ast.CallExpr */) {
		if ((*expr._v__ast__CallExpr).is_method) {
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__CallExpr).left)), _t6, Array_string);
		}
		for (int _t7 = 0; _t7 < (*expr._v__ast__CallExpr).args.len; ++_t7) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*expr._v__ast__CallExpr).args.data)[_t7];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, arg.expr)), _t8, Array_string);
		}
		_option_v__ast__Fn _t9;
		if (_t9 = v__ast__Table_find_fn(t, (*expr._v__ast__CallExpr).name), _t9.state == 0) {
			v__ast__Fn func = *(v__ast__Fn*)_t9.data;
			_PUSH_MANY(&names, (func.dep_names), _t10, Array_string);
		}
	}
	else if (expr._typ == 268 /* v.ast.CastExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__CastExpr).expr)), _t11, Array_string);
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__CastExpr).arg)), _t12, Array_string);
	}
	else if (expr._typ == 281 /* v.ast.Ident */) {
		if ((*expr._v__ast__Ident).kind == v__ast__IdentKind__global || (*expr._v__ast__Ident).kind == v__ast__IdentKind__constant) {
			builtin__array_push((array*)&names, _MOV((string[]){ v__util__no_dots((*expr._v__ast__Ident).name) }));
		}
	}
	else if (expr._typ == 284 /* v.ast.IndexExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__IndexExpr).left)), _t14, Array_string);
	}
	else if (expr._typ == 282 /* v.ast.IfExpr */) {
		for (int _t15 = 0; _t15 < (*expr._v__ast__IfExpr).branches.len; ++_t15) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)(*expr._v__ast__IfExpr).branches.data)[_t15];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, branch.cond)), _t16, Array_string);
			for (int _t17 = 0; _t17 < branch.stmts.len; ++_t17) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t17];
				_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, stmt)), _t18, Array_string);
			}
		}
	}
	else if (expr._typ == 285 /* v.ast.InfixExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__InfixExpr).left)), _t19, Array_string);
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__InfixExpr).right)), _t20, Array_string);
	}
	else if (expr._typ == 291 /* v.ast.MapInit */) {
		for (int _t21 = 0; _t21 < (*expr._v__ast__MapInit).keys.len; ++_t21) {
			v__ast__Expr key = ((v__ast__Expr*)(*expr._v__ast__MapInit).keys.data)[_t21];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, key)), _t22, Array_string);
		}
		for (int _t23 = 0; _t23 < (*expr._v__ast__MapInit).vals.len; ++_t23) {
			v__ast__Expr val = ((v__ast__Expr*)(*expr._v__ast__MapInit).vals.data)[_t23];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, val)), _t24, Array_string);
		}
	}
	else if (expr._typ == 292 /* v.ast.MatchExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__MatchExpr).cond)), _t25, Array_string);
		for (int _t26 = 0; _t26 < (*expr._v__ast__MatchExpr).branches.len; ++_t26) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)(*expr._v__ast__MatchExpr).branches.data)[_t26];
			for (int _t27 = 0; _t27 < branch.stmts.len; ++_t27) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t27];
				_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, stmt)), _t28, Array_string);
			}
		}
	}
	else if (expr._typ == 297 /* v.ast.ParExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__ParExpr).expr)), _t29, Array_string);
	}
	else if (expr._typ == 298 /* v.ast.PostfixExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__PostfixExpr).expr)), _t30, Array_string);
	}
	else if (expr._typ == 299 /* v.ast.PrefixExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__PrefixExpr).right)), _t31, Array_string);
	}
	else if (expr._typ == 306 /* v.ast.StringInterLiteral */) {
		for (int _t32 = 0; _t32 < (*expr._v__ast__StringInterLiteral).exprs.len; ++_t32) {
			v__ast__Expr inter_expr = ((v__ast__Expr*)(*expr._v__ast__StringInterLiteral).exprs.data)[_t32];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, inter_expr)), _t33, Array_string);
		}
	}
	else if (expr._typ == 302 /* v.ast.SelectorExpr */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__SelectorExpr).expr)), _t34, Array_string);
	}
	else if (expr._typ == 236 /* v.ast.StructInit */) {
		if ((*expr._v__ast__StructInit).has_update_expr) {
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*expr._v__ast__StructInit).update_expr)), _t35, Array_string);
		}
		for (int _t36 = 0; _t36 < (*expr._v__ast__StructInit).init_fields.len; ++_t36) {
			v__ast__StructInitField field = ((v__ast__StructInitField*)(*expr._v__ast__StructInit).init_fields.data)[_t36];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, field.expr)), _t37, Array_string);
		}
	}
	
	else {
	}
	
	return names;
}
Array_string v__ast__Table_dependent_names_in_stmt(v__ast__Table* t, v__ast__Stmt stmt) {
	Array_string names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (stmt._typ == 313 /* v.ast.AssignStmt */) {
		for (int _t1 = 0; _t1 < (*stmt._v__ast__AssignStmt).left.len; ++_t1) {
			v__ast__Expr expr = ((v__ast__Expr*)(*stmt._v__ast__AssignStmt).left.data)[_t1];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, expr)), _t2, Array_string);
		}
		for (int _t3 = 0; _t3 < (*stmt._v__ast__AssignStmt).right.len; ++_t3) {
			v__ast__Expr expr = ((v__ast__Expr*)(*stmt._v__ast__AssignStmt).right.data)[_t3];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, expr)), _t4, Array_string);
		}
	}
	else if (stmt._typ == 321 /* v.ast.ExprStmt */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*stmt._v__ast__ExprStmt).expr)), _t5, Array_string);
	}
	else if (stmt._typ == 323 /* v.ast.ForInStmt */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*stmt._v__ast__ForInStmt).cond)), _t6, Array_string);
		for (int _t7 = 0; _t7 < (*stmt._v__ast__ForInStmt).stmts.len; ++_t7) {
			v__ast__Stmt stmt_ = ((v__ast__Stmt*)(*stmt._v__ast__ForInStmt).stmts.data)[_t7];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, stmt_)), _t8, Array_string);
		}
	}
	else if (stmt._typ == 324 /* v.ast.ForStmt */) {
		for (int _t9 = 0; _t9 < (*stmt._v__ast__ForStmt).stmts.len; ++_t9) {
			v__ast__Stmt stmt_ = ((v__ast__Stmt*)(*stmt._v__ast__ForStmt).stmts.data)[_t9];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, stmt_)), _t10, Array_string);
		}
	}
	else if (stmt._typ == 322 /* v.ast.ForCStmt */) {
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, (*stmt._v__ast__ForCStmt).init)), _t11, Array_string);
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, (*stmt._v__ast__ForCStmt).cond)), _t12, Array_string);
		_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, (*stmt._v__ast__ForCStmt).inc)), _t13, Array_string);
		for (int _t14 = 0; _t14 < (*stmt._v__ast__ForCStmt).stmts.len; ++_t14) {
			v__ast__Stmt stmt_ = ((v__ast__Stmt*)(*stmt._v__ast__ForCStmt).stmts.data)[_t14];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_stmt(t, stmt_)), _t15, Array_string);
		}
	}
	else if (stmt._typ == 332 /* v.ast.Return */) {
		for (int _t16 = 0; _t16 < (*stmt._v__ast__Return).exprs.len; ++_t16) {
			v__ast__Expr expr = ((v__ast__Expr*)(*stmt._v__ast__Return).exprs.data)[_t16];
			_PUSH_MANY(&names, (v__ast__Table_dependent_names_in_expr(t, expr)), _t17, Array_string);
		}
	}
	
	else {
	}
	
	return names;
}
multi_return_int_v__ast__Type v__ast__Table_get_array_dims(v__ast__Table* t, v__ast__Array arr) {
	int dims = 1;
	v__ast__Type elem_type = arr.elem_type;
	v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(t, elem_type);
	for (;;) {
		if (!((elem_sym->info)._typ == 452 /* v.ast.Array */)) break;
		dims++;
		elem_type = (*elem_sym->info._v__ast__Array).elem_type;
		elem_sym = v__ast__Table_sym(t, elem_type);
	}
	return (multi_return_int_v__ast__Type){.arg0=dims, .arg1=elem_type};
}
multi_return_string_string v__ast__Table_get_trace_fn_name(v__ast__Table* t, v__ast__FnDecl cur_fn, v__ast__CallExpr node) {
	Array_string _t1 = {0};
	Array_v__ast__Type _t1_orig = node.concrete_types;
	int _t1_len = _t1_orig.len;
	_t1 = builtin____new_array(0, _t1_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
		v__ast__Type it = ((v__ast__Type*) _t1_orig.data)[_t3];
		string _t2 = v__ast__Table_type_to_str(t, it);
		builtin__array_push((array*)&_t1, &_t2);
	}
	string generic_name = Array_string_join(_t1, _S("_"));
	string hash_fn = builtin__str_intp(5, _MOV((StrIntpData[]){{_S("_v__trace__"), 0xfe10, {.d_s = cur_fn.name}}, {_S("_"), 0xfe10, {.d_s = node.name}}, {_S("_"), 0xfe10, {.d_s = generic_name}}, {_S("_"), 0xfe07, {.d_i32 = node.pos.line_nr}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string fn_name = (node.concrete_types.len > 0 ? (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node.name}}, {_S("_T_"), 0xfe10, {.d_s = generic_name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (node.name));
	return (multi_return_string_string){.arg0=hash_fn, .arg1=fn_name};
}
Array_v__ast__Attr v__ast__Table_get_attrs(v__ast__Table* t, v__ast__TypeSymbol sym) {
	if (sym.info._typ == 490 /* v.ast.Enum */) {
		return (*(v__ast__EnumDecl*)builtin__map_get(ADDR(map, t->enum_decls), &(string[]){sym.name}, &(v__ast__EnumDecl[]){ (v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,} })).attrs;
	}
	else if (sym.info._typ == 457 /* v.ast.Struct */) {
		return (*sym.info._v__ast__Struct).attrs;
	}
	else if (sym.info._typ == 495 /* v.ast.FnType */) {
		return (*sym.info._v__ast__FnType).func.attrs;
	}
	else if (sym.info._typ == 485 /* v.ast.Interface */) {
		return (*(v__ast__InterfaceDecl*)builtin__map_get(ADDR(map, t->interfaces), &(int[]){sym.idx}, &(v__ast__InterfaceDecl[]){ (v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,} })).attrs;
	}
	else if (sym.info._typ == 486 /* v.ast.SumType */) {
		return (*(v__ast__SumTypeDecl*)builtin__map_get(ADDR(map, t->sumtypes), &(int[]){sym.idx}, &(v__ast__SumTypeDecl[]){ (v__ast__SumTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.typ = 0,.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.variants = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.is_markused = 0,} })).attrs;
	}
	
	else {
		return builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	}
	
	return builtin____new_array(0, 0, sizeof(v__ast__Attr));
}
int v__ast__Table_get_veb_result_type_idx(v__ast__Table* t) {
	if (t->veb_res_idx_cache > 0) {
		return t->veb_res_idx_cache;
	}
	t->veb_res_idx_cache = v__ast__Table_find_type(t, _S("veb.Result"));
	return t->veb_res_idx_cache;
}
inline void v__ast__Table_register_vls_info(v__ast__Table* t, string key, v__ast__VlsInfo val) {
(*(v__ast__VlsInfo*)builtin__map_get_and_set((map*)&t->vls_info, &(string[]){key}, &(v__ast__VlsInfo[]){ (v__ast__VlsInfo){.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.doc = (string){.str=(byteptr)"", .is_lit=1},} })) = val;
}
v__ast__Type v__ast__Table_unwrap(v__ast__Table* t, v__ast__Type typ) {
	v__ast__TypeSymbol* ts = v__ast__Table_sym(t, typ);
	return ((ts->info)._typ == 482 /* v.ast.Alias */ ? (v__ast__Table_unwrap(t, (*ts->info._v__ast__Alias).parent_type)) : (typ));
}
inline v__ast__Type v__ast__idx_to_type(int idx) {
	return ((((u32)(idx))));
}
v__ast__Language v__ast__pref_arch_to_table_language(v__pref__Arch pref_arch) {
	v__ast__Language _t2 = 0;
	switch (pref_arch) {
		case v__pref__Arch__amd64: {
			_t2 = v__ast__Language__amd64;
			break;
		}
		case v__pref__Arch__arm64: {
			_t2 = v__ast__Language__arm64;
			break;
		}
		case v__pref__Arch__arm32: {
			_t2 = v__ast__Language__arm32;
			break;
		}
		case v__pref__Arch__rv64: {
			_t2 = v__ast__Language__rv64;
			break;
		}
		case v__pref__Arch__rv32: {
			_t2 = v__ast__Language__rv32;
			break;
		}
		case v__pref__Arch__i386: {
			_t2 = v__ast__Language__i386;
			break;
		}
		case v__pref__Arch__s390x: {
			_t2 = v__ast__Language__s390x;
			break;
		}
		case v__pref__Arch__ppc64le: {
			_t2 = v__ast__Language__ppc64le;
			break;
		}
		case v__pref__Arch__loongarch64: {
			_t2 = v__ast__Language__loongarch64;
			break;
		}
		case v__pref__Arch__js_node: case v__pref__Arch__js_browser: case v__pref__Arch__js_freestanding: {
			_t2 = v__ast__Language__js;
			break;
		}
		case v__pref__Arch__wasm32: {
			_t2 = v__ast__Language__wasm32;
			break;
		}
		case v__pref__Arch___auto: case v__pref__Arch___max: {
			_t2 = v__ast__Language__v;
			break;
		}
	}
	return _t2;
}
string v__ast__ShareType_str(v__ast__ShareType t) {

	if (t == (v__ast__ShareType__mut_t)) {
		return _S("mut");
	}
	else if (t == (v__ast__ShareType__shared_t)) {
		return _S("shared");
	}
	else if (t == (v__ast__ShareType__atomic_t)) {
		return _S("atomic");
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
_option_v__token__Pos v__ast__TypeInfo_get_name_pos(v__ast__TypeInfo ti) {
	_option_v__token__Pos _t2 = (_option_v__token__Pos){.state=2, .err=_const_none__, .data={E_STRUCT}};
	if (ti._typ == 457 /* v.ast.Struct */) {
		builtin___option_ok(&(v__token__Pos[]) { (*ti._v__ast__Struct).name_pos }, (_option*)(&_t2), sizeof(v__token__Pos));
	}
	else if (ti._typ == 482 /* v.ast.Alias */) {
		builtin___option_ok(&(v__token__Pos[]) { (*ti._v__ast__Alias).name_pos }, (_option*)(&_t2), sizeof(v__token__Pos));
	}
	else if (ti._typ == 486 /* v.ast.SumType */) {
		builtin___option_ok(&(v__token__Pos[]) { (*ti._v__ast__SumType).name_pos }, (_option*)(&_t2), sizeof(v__token__Pos));
	}
	else if (ti._typ == 490 /* v.ast.Enum */) {
		builtin___option_ok(&(v__token__Pos[]) { (*ti._v__ast__Enum).name_pos }, (_option*)(&_t2), sizeof(v__token__Pos));
	}
	else if (ti._typ == 485 /* v.ast.Interface */) {
		builtin___option_ok(&(v__token__Pos[]) { (*ti._v__ast__Interface).name_pos }, (_option*)(&_t2), sizeof(v__token__Pos));
	}
	
	else {
		_t2.state = 2;
		_t2.err = _const_none__;
	}
	return _t2;
}
string v__ast__Type_atomic_typename(v__ast__Type t) {
	int idx = v__ast__Type_idx(t);

	if (idx == (_const_v__ast__u32_type_idx)) {
		return _S("atomic_uint");
	}
	else if (idx == (_const_v__ast__int_type_idx)) {
		return _S("_Atomic int");
	}
	else if (idx == (_const_v__ast__i32_type_idx)) {
		return _S("_Atomic int");
	}
	else if (idx == (_const_v__ast__u64_type_idx)) {
		return _S("atomic_ullong");
	}
	else if (idx == (_const_v__ast__i64_type_idx)) {
		return _S("atomic_llong");
	}
	else {
		return _S("unknown_atomic");
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
v__ast__ShareType v__ast__sharetype_from_flags(bool is_shared, bool is_atomic) {
	return ((v__ast__ShareType)((((int)(((u32[]){(is_atomic)?1:0}[0] << 1))) | (int[]){(is_shared)?1:0}[0])));
}
v__ast__ShareType v__ast__Type_share(v__ast__Type t) {
	return v__ast__sharetype_from_flags(v__ast__Type_has_flag(t, v__ast__TypeFlag__shared_f), v__ast__Type_has_flag(t, v__ast__TypeFlag__atomic_f));
}
inline int v__ast__Type_idx(v__ast__Type t) {
	return (((u16)(t)) & 0xffff);
}
inline bool v__ast__Type_is_void(v__ast__Type t) {
	return t == _const_v__ast__void_type;
}
inline bool v__ast__Type_is_full(v__ast__Type t) {
	return t != 0 && t != _const_v__ast__void_type;
}
inline int v__ast__Type_nr_muls(v__ast__Type t) {
	return (((t >> 16)) & 0xff);
}
inline bool v__ast__Type_is_ptr(v__ast__Type t) {
	return (((t >> 16)) & 0xff) != 0;
}
inline bool v__ast__Type_is_pointer(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__pointer_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_voidptr(v__ast__Type typ) {
	return v__ast__Type_idx(typ) == 2;
}
inline bool v__ast__Type_is_any_kind_of_pointer(v__ast__Type t) {
	return (((t >> 16)) & 0xff) != 0 || (Array_int_contains(_const_v__ast__pointer_type_idxs, ((((u16)(t)) & 0xffff))));
}
inline v__ast__Type v__ast__Type_set_nr_muls(v__ast__Type t, int nr_muls) {
	if (nr_muls < 0 || nr_muls > 255) {
		builtin___v_panic(_S("set_nr_muls: nr_muls must be between 0 & 255"));
		VUNREACHABLE();
	}
	return ((t & 0xff00ffffU) | (((u32)(nr_muls)) << 16));
}
inline v__ast__Type v__ast__Type_ref(v__ast__Type t) {
	v__ast__Type nr_muls = (((t >> 16)) & 0xff);
	if (nr_muls == 255) {
		builtin___v_panic(_S("ref: nr_muls is already at max of 255"));
		VUNREACHABLE();
	}
	return ((t & 0xff00ffffU) | ((nr_muls + 1) << 16));
}
inline v__ast__Type v__ast__Type_deref(v__ast__Type t) {
	v__ast__Type nr_muls = (((t >> 16)) & 0xff);
	if (nr_muls == 0) {
		builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("deref: type `"), 0xfe10, {.d_s = v__ast__Type_str(t)}}, {_S("` is not a pointer"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return ((t & 0xff00ffffU) | ((nr_muls - 1) << 16));
}
inline int v__ast__Type_flags(v__ast__Type t) {
	return (t >> 16);
}
inline bool v__ast__Type_has_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	return ((t & ((u32)(flag)))) != 0;
}
inline v__ast__Type v__ast__Type_set_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	return (t | ((u32)(flag)));
}
inline v__ast__Type v__ast__Type_clear_flag(v__ast__Type t, v__ast__TypeFlag flag) {
	return (t & ~(((u32)(flag))));
}
inline v__ast__Type v__ast__Type_clear_flags(v__ast__Type t, Array_v__ast__TypeFlag flags) {
	if (flags.len == 0) {
		return (t & 0xffffff);
	} else {
		u32 typ = ((u32)(t));
		for (int _t2 = 0; _t2 < flags.len; ++_t2) {
			v__ast__TypeFlag flag = ((v__ast__TypeFlag*)flags.data)[_t2];
			typ = (typ & ~(((u32)(flag))));
		}
		return typ;
	}
	return 0;
}
inline v__ast__Type v__ast__Type_clear_ref(v__ast__Type t) {
	return (t & ~0x00FF0000);
}
inline v__ast__Type v__ast__Type_clear_option_and_result(v__ast__Type t) {
	return (t & ~0x03000000);
}
inline bool v__ast__Type_has_option_or_result(v__ast__Type t) {
	return (t & 0x03000000) != 0;
}
inline string v__ast__TypeSymbol_scoped_name(v__ast__TypeSymbol* ts) {
	return ((ts->info)._typ == 457 /* v.ast.Struct */ && ((*(v__ast__Struct*)builtin____as_cast((ts->info)._v__ast__Struct,(ts->info)._typ, 457)).scoped_name).len != 0 ? ((*ts->info._v__ast__Struct).scoped_name) : (ts->name));
}
inline string v__ast__TypeSymbol_scoped_cname(v__ast__TypeSymbol* ts) {
	return ((ts->info)._typ == 457 /* v.ast.Struct */ && ((*(v__ast__Struct*)builtin____as_cast((ts->info)._v__ast__Struct,(ts->info)._typ, 457)).scoped_name).len != 0 ? (builtin__string_replace((*ts->info._v__ast__Struct).scoped_name, _S("."), _S("__"))) : (ts->cname));
}
Array_string v__ast__TypeSymbol_debug(v__ast__TypeSymbol* ts) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__TypeSymbol_dbg_common(ts, &res);
	builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("info: "), 0xfe10, {.d_s = v__ast__TypeInfo_str(ts->info)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	Array_string _t3 = {0};
	Array_v__ast__Fn _t3_orig = ts->methods;
	int _t3_len = _t3_orig.len;
	_t3 = builtin____new_array(0, _t3_len, sizeof(string));

	for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
		v__ast__Fn it = ((v__ast__Fn*) _t3_orig.data)[_t5];
		string _t4 = v__ast__Fn_str(it);
		builtin__array_push((array*)&_t3, &_t4);
	}
	builtin__array_push((array*)&res, _MOV((string[]){ builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("methods ("), 0xfe07, {.d_i32 = ts->methods.len}}, {_S("): "), 0, { .d_c = 0 }}})), Array_string_join(_t3, _S(", "))) }));
	return res;
}
Array_string v__ast__TypeSymbol_dbg(v__ast__TypeSymbol* ts) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__TypeSymbol_dbg_common(ts, &res);
	return res;
}
VV_LOC void v__ast__TypeSymbol_dbg_common(v__ast__TypeSymbol* ts, Array_string* res) {
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("idx: 0x"), 0xfe10, {.d_s = builtin__int_hex(ts->idx)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parent_idx: 0x"), 0xfe10, {.d_s = builtin__int_hex(ts->parent_idx)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("mod: "), 0xfe10, {.d_s = ts->mod}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("name: "), 0xfe10, {.d_s = ts->name}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cname: "), 0xfe10, {.d_s = ts->cname}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("kind: "), 0xfe10, {.d_s = v__ast__Kind_str(ts->kind)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("is_pub: "), 0xfe10, {.d_s = ts->is_pub ? _S("true") : _S("false")}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("language: "), 0xfe10, {.d_s = v__ast__Language_str(ts->language)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
}
int v__ast__TypeSymbol_nr_dims(v__ast__TypeSymbol* ts) {
	if (ts->info._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, (*ts->info._v__ast__Alias).parent_type);
		if ((parent_sym->info)._typ == 452 /* v.ast.Array */) {
			return (*parent_sym->info._v__ast__Array).nr_dims;
		}
		return 0;
	}
	else if (ts->info._typ == 452 /* v.ast.Array */) {
		v__ast__TypeSymbol* elem_sym = v__ast__Table_sym(global_table, (*ts->info._v__ast__Array).elem_type);
		if ((elem_sym->info)._typ == 482 /* v.ast.Alias */) {
			return (int)((*ts->info._v__ast__Array).nr_dims + v__ast__TypeSymbol_nr_dims(elem_sym));
		}
		return (*ts->info._v__ast__Array).nr_dims;
	}
	
	else {
		return 0;
	}
	
	return 0;
}
string v__ast__Type_str(v__ast__Type t) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("ast.Type(0x"), 0xfe10, {.d_s = builtin__u32_hex(t)}}, {_S(" = "), 0xfe06, {.d_u32 = ((u32)(t))}}, {_S(")"), 0, { .d_c = 0 }}}));
}
string v__ast__Table_type_str(v__ast__Table* t, v__ast__Type typ) {
	return v__ast__Table_sym(t, typ)->name;
}
Array_string v__ast__Type_debug(v__ast__Type t) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("idx: 0x"), 0x10fe10, {.d_s = builtin__int_hex(v__ast__Type_idx(t))}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("type: 0x"), 0x10fe10, {.d_s = builtin__u32_hex(t)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&res, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("nr_muls: "), 0xfe07, {.d_i32 = v__ast__Type_nr_muls(t)}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__option)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("option") }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__result)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("result") }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__variadic)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("variadic") }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__generic)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("generic") }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__shared_f)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("shared_f") }));
	}
	if (v__ast__Type_has_flag(t, v__ast__TypeFlag__atomic_f)) {
		builtin__array_push((array*)&res, _MOV((string[]){ _S("atomic_f") }));
	}
	return res;
}
inline v__ast__Type v__ast__Type_derive(v__ast__Type t, v__ast__Type t_from) {
	return (((0xffff0000U & t_from)) | ((u16)(t)));
}
inline v__ast__Type v__ast__Type_derive_add_muls(v__ast__Type t, v__ast__Type t_from) {
	return v__ast__Type_set_nr_muls((((((0xff000000U & t_from)) | ((u16)(t))))), (int)(v__ast__Type_nr_muls(t) + v__ast__Type_nr_muls(t_from)));
}
inline v__ast__Type v__ast__Type_idx_type(v__ast__Type t) {
	return v__ast__idx_to_type(v__ast__Type_idx(t));
}
inline v__ast__Type v__ast__new_type(int idx) {
	if (idx < 1 || idx > 65535) {
		builtin___v_panic(_S("new_type: idx must be between 1 & 65535"));
		VUNREACHABLE();
	}
	return idx;
}
inline v__ast__Type v__ast__new_type_ptr(int idx, int nr_muls) {
	if (idx < 1 || idx > 65535) {
		builtin___v_panic(_S("new_type_ptr: idx must be between 1 & 65535"));
		VUNREACHABLE();
	}
	if (nr_muls < 0 || nr_muls > 255) {
		builtin___v_panic(_S("new_type_ptr: nr_muls must be between 0 & 255"));
		VUNREACHABLE();
	}
	return (((((u32)(nr_muls)) << 16)) | ((u16)(idx)));
}
inline bool v__ast__Type_is_float(v__ast__Type typ) {
	return !v__ast__Type_is_ptr(typ) && (Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_int(v__ast__Type typ) {
	return !v__ast__Type_is_ptr(typ) && (Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_int_valptr(v__ast__Type typ) {
	return v__ast__Type_is_ptr(typ) && (Array_int_contains(_const_v__ast__integer_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_float_valptr(v__ast__Type typ) {
	return v__ast__Type_is_ptr(typ) && (Array_int_contains(_const_v__ast__float_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_pure_int(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__integer_type_idxs, ((int)(typ))));
}
inline bool v__ast__Type_is_pure_float(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__float_type_idxs, ((int)(typ))));
}
inline bool v__ast__Type_is_signed(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__signed_integer_type_idxs, v__ast__Type_idx(typ)));
}
inline bool v__ast__Type_is_unsigned(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__unsigned_integer_type_idxs, v__ast__Type_idx(typ)));
}
v__ast__Type v__ast__Type_flip_signedness(v__ast__Type typ) {
	v__ast__Type _t2 = 0;
	
	if (typ == (_const_v__ast__i8_type)) {
		_t2 = _const_v__ast__u8_type;
	}
	else if (typ == (_const_v__ast__i16_type)) {
		_t2 = _const_v__ast__u16_type;
	}
	else if (typ == (_const_v__ast__i32_type)) {
		_t2 = _const_v__ast__u32_type;
	}
	else if (typ == (_const_v__ast__i64_type)) {
		_t2 = _const_v__ast__u64_type;
	}
	else if (typ == (_const_v__ast__int_type)) {
		v__ast__Type _t3;
		#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
		#else
			_t3 = _const_v__ast__u32_type;
			;
		#endif
				_t2 = _t3;
	}
	else if (typ == (_const_v__ast__isize_type)) {
		_t2 = _const_v__ast__usize_type;
	}
	else if (typ == (_const_v__ast__u8_type)) {
		_t2 = _const_v__ast__i8_type;
	}
	else if (typ == (_const_v__ast__u16_type)) {
		_t2 = _const_v__ast__i16_type;
	}
	else if (typ == (_const_v__ast__u32_type)) {
		_t2 = _const_v__ast__i32_type;
	}
	else if (typ == (_const_v__ast__u64_type)) {
		_t2 = _const_v__ast__i64_type;
	}
	else if (typ == (_const_v__ast__usize_type)) {
		_t2 = _const_v__ast__isize_type;
	}
	else {
		_t2 = _const_v__ast__void_type;
	}return _t2;
}
inline bool v__ast__Type_is_int_literal(v__ast__Type typ) {
	return ((int)(typ)) == 28;
}
inline bool v__ast__Type_is_number(v__ast__Type typ) {
	return (Array_int_contains(_const_v__ast__number_type_idxs, v__ast__Type_clear_flags(typ, builtin____new_array(0, 0, sizeof(v__ast__TypeFlag)))));
}
inline bool v__ast__Type_is_string(v__ast__Type typ) {
	return v__ast__Type_idx(typ) == 21;
}
inline bool v__ast__Type_is_bool(v__ast__Type typ) {
	return v__ast__Type_idx(typ) == 19;
}
VV_LOC Array_v__ast__Type v__ast__new_charptr_types(void) {
	return builtin__new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__charptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__char_type_idx), 1)}));
}
VV_LOC Array_v__ast__Type v__ast__new_byteptr_types(void) {
	return builtin__new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__byteptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__u8_type_idx), 1)}));
}
VV_LOC Array_v__ast__Type v__ast__new_voidptr_types(void) {
	return builtin__new_array_from_c_array(2, 2, sizeof(v__ast__Type), _MOV((v__ast__Type[2]){_const_v__ast__voidptr_type, v__ast__Type_set_nr_muls(v__ast__new_type(_const_v__ast__voidptr_type_idx), 1)}));
}
Array_v__ast__Type v__ast__merge_types(Array_Array_v__ast__Type params) {
	Array_v__ast__Type res = builtin____new_array_with_default(0, params.len, sizeof(v__ast__Type), 0);
	for (int _t1 = 0; _t1 < params.len; ++_t1) {
		Array_v__ast__Type types = ((Array_v__ast__Type*)params.data)[_t1];
		for (int _t2 = 0; _t2 < types.len; ++_t2) {
			v__ast__Type t = ((v__ast__Type*)types.data)[_t2];
			if (!(Array_v__ast__Type_contains(res, t))) {
				builtin__array_push((array*)&res, _MOV((v__ast__Type[]){ t }));
			}
		}
	}
	return res;
}
v__ast__Type v__ast__mktyp(v__ast__Type typ) {
	return ((typ == (_const_v__ast__float_literal_type))? (_const_v__ast__f64_type) : (typ == (_const_v__ast__int_literal_type))? (_const_v__ast__int_type) : (typ));
}
v__ast__Kind v__ast__Table_type_kind(v__ast__Table* t, v__ast__Type typ) {
	if (v__ast__Type_nr_muls(typ) > 0 || v__ast__Type_has_option_or_result(typ)) {
		return v__ast__Kind__placeholder;
	}
	return v__ast__Table_sym(t, typ)->kind;
}
bool v__ast__Table_type_is_for_pointer_arithmetic(v__ast__Table* t, v__ast__Type typ) {
	if (v__ast__Table_sym(t, typ)->kind == v__ast__Kind__struct) {
		return false;
	} else {
		return v__ast__Type_is_any_kind_of_pointer(typ) || v__ast__Type_is_int_valptr(typ);
	}
	return 0;
}
string v__ast__TypeSymbol_str(v__ast__TypeSymbol* t) {
	return builtin__string_clone(t->name);
}
string v__ast__TypeSymbol_str_with_correct_nr_muls(v__ast__TypeSymbol* t, int n) {
	string prefix = strings__repeat('&', n);
	return builtin__string__plus(prefix, t->name);
}
VNORETURN VV_LOC void v__ast__TypeSymbol_no_info_panic(v__ast__TypeSymbol* t, string fname) {
	builtin___v_panic(builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fname}}, {_S(": no info for type: "), 0xfe10, {.d_s = t->name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}
inline v__ast__Enum v__ast__TypeSymbol_enum_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 490 /* v.ast.Enum */) {
		return (*t->info._v__ast__Enum);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 490 /* v.ast.Enum */) {
			return (*fsym->info._v__ast__Enum);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.enum_info"));
	VUNREACHABLE();
	return (v__ast__Enum){.vals = builtin____new_array(0, 0, sizeof(string)),.is_flag = 0,.is_multi_allowed = 0,.uses_exprs = 0,.typ = 0,.attrs = builtin__new_map(sizeof(string), sizeof(Array_v__ast__Attr), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},};
}
inline v__ast__MultiReturn v__ast__TypeSymbol_mr_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 494 /* v.ast.MultiReturn */) {
		return (*t->info._v__ast__MultiReturn);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 494 /* v.ast.MultiReturn */) {
			return (*fsym->info._v__ast__MultiReturn);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.mr_info"));
	VUNREACHABLE();
	return (v__ast__MultiReturn){.types = builtin____new_array(0, 0, sizeof(v__ast__Type)),};
}
inline v__ast__Array v__ast__TypeSymbol_array_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 452 /* v.ast.Array */) {
		return (*t->info._v__ast__Array);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 452 /* v.ast.Array */) {
			return (*fsym->info._v__ast__Array);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.array_info"));
	VUNREACHABLE();
	return (v__ast__Array){.nr_dims = 0,.elem_type = 0,};
}
inline v__ast__ArrayFixed v__ast__TypeSymbol_array_fixed_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 491 /* v.ast.ArrayFixed */) {
		return (*t->info._v__ast__ArrayFixed);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 491 /* v.ast.ArrayFixed */) {
			return (*fsym->info._v__ast__ArrayFixed);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.array_fixed_info"));
	VUNREACHABLE();
	return (v__ast__ArrayFixed){.size_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.size = 0,.elem_type = 0,.is_fn_ret = 0,};
}
inline v__ast__Chan v__ast__TypeSymbol_chan_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 492 /* v.ast.Chan */) {
		return (*t->info._v__ast__Chan);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 492 /* v.ast.Chan */) {
			return (*fsym->info._v__ast__Chan);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.chan_info"));
	VUNREACHABLE();
	return (v__ast__Chan){.elem_type = 0,.is_mut = 0,};
}
inline v__ast__Thread v__ast__TypeSymbol_thread_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 493 /* v.ast.Thread */) {
		return (*t->info._v__ast__Thread);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 493 /* v.ast.Thread */) {
			return (*fsym->info._v__ast__Thread);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.thread_info"));
	VUNREACHABLE();
	return (v__ast__Thread){.return_type = 0,};
}
inline v__ast__Map v__ast__TypeSymbol_map_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 453 /* v.ast.Map */) {
		return (*t->info._v__ast__Map);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 453 /* v.ast.Map */) {
			return (*fsym->info._v__ast__Map);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.map_info"));
	VUNREACHABLE();
	return (v__ast__Map){.key_type = 0,.value_type = 0,.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},};
}
inline v__ast__Struct v__ast__TypeSymbol_struct_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 457 /* v.ast.Struct */) {
		return (*t->info._v__ast__Struct);
	}
	if ((t->info)._typ == 482 /* v.ast.Alias */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type);
		if ((fsym->info)._typ == 457 /* v.ast.Struct */) {
			return (*fsym->info._v__ast__Struct);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.struct_info"));
	VUNREACHABLE();
	return (v__ast__Struct){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Type)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.parent_type = 0,.is_anon = 0,.is_generic = 0,.is_shared = 0,.is_markused = 0,.has_option = 0,.is_heap = 0,.is_union = 0,.is_minify = 0,.is_typedef = 0,};
}
inline v__ast__SumType v__ast__TypeSymbol_sumtype_info(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 486 /* v.ast.SumType */) {
		return (*t->info._v__ast__SumType);
	}
	if ((t->info)._typ == 486 /* v.ast.SumType */) {
		v__ast__TypeSymbol* fsym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__SumType).parent_type);
		if ((fsym->info)._typ == 486 /* v.ast.SumType */) {
			return (*fsym->info._v__ast__SumType);
		}
	}
	v__ast__TypeSymbol_no_info_panic(t, _S("TypeSymbol.sumtype_info"));
	VUNREACHABLE();
	return (v__ast__SumType){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.variants = builtin____new_array(0, 0, sizeof(v__ast__Type)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.parent_type = 0,.found_fields = 0,.is_anon = 0,.is_generic = 0,};
}
bool v__ast__TypeSymbol_is_heap(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 457 /* v.ast.Struct */) {
		return (*t->info._v__ast__Struct).is_heap;
	} else {
		return false;
	}
	return 0;
}
bool v__ast__ArrayFixed_is_compatible(v__ast__ArrayFixed* t, v__ast__ArrayFixed t2) {
	return t->size == t2.size && t->elem_type == t2.elem_type;
}
bool v__ast__TypeSymbol_is_empty_struct_array(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 491 /* v.ast.ArrayFixed */) {
		v__ast__TypeSymbol* elem_sym = v__ast__Table_final_sym(global_table, (*t->info._v__ast__ArrayFixed).elem_type);
		if ((elem_sym->info)._typ == 457 /* v.ast.Struct */) {
			return v__ast__Struct_is_empty_struct(&(*elem_sym->info._v__ast__Struct));
		}
	}
	return false;
}
inline bool v__ast__Struct_is_empty_struct(v__ast__Struct* t) {
	return t->fields.len == 0 && t->embeds.len == 0;
}
inline bool v__ast__Struct_is_unresolved_generic(v__ast__Struct* t) {
	return t->generic_types.len > 0 && t->concrete_types.len == 0;
}
bool v__ast__TypeSymbol_is_primitive_fixed_array(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 491 /* v.ast.ArrayFixed */) {
		return v__ast__TypeSymbol_is_primitive(v__ast__Table_final_sym(global_table, (*t->info._v__ast__ArrayFixed).elem_type));
	} else if ((t->info)._typ == 482 /* v.ast.Alias */) {
		return v__ast__TypeSymbol_is_primitive_fixed_array(v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type));
	} else {
		return false;
	}
	return 0;
}
bool v__ast__TypeSymbol_is_array_fixed(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 491 /* v.ast.ArrayFixed */) {
		return true;
	} else if ((t->info)._typ == 482 /* v.ast.Alias */) {
		return v__ast__TypeSymbol_is_array_fixed(v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type));
	} else {
		return false;
	}
	return 0;
}
bool v__ast__TypeSymbol_is_c_struct(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 457 /* v.ast.Struct */) {
		return t->language == v__ast__Language__c && !(*t->info._v__ast__Struct).is_anon;
	} else if ((t->info)._typ == 482 /* v.ast.Alias */) {
		return v__ast__TypeSymbol_is_c_struct(v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type));
	}
	return false;
}
bool v__ast__TypeSymbol_is_array_fixed_ret(v__ast__TypeSymbol* t) {
	if ((t->info)._typ == 491 /* v.ast.ArrayFixed */) {
		return (*t->info._v__ast__ArrayFixed).is_fn_ret;
	} else if ((t->info)._typ == 482 /* v.ast.Alias */) {
		return v__ast__TypeSymbol_is_array_fixed_ret(v__ast__Table_final_sym(global_table, (*t->info._v__ast__Alias).parent_type));
	} else {
		return false;
	}
	return 0;
}
void v__ast__Table_register_builtin_type_symbols(v__ast__Table* t) {
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = (string){.str=(byteptr)"", .is_lit=1},.name = _S("reserved_0"),.cname = (string){.str=(byteptr)"", .is_lit=1},.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__placeholder,.language = 0,.is_pub = 0,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("void"),.cname = _S("void"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__void,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("voidptr"),.cname = _S("voidptr"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__voidptr,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("byteptr"),.cname = _S("byteptr"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__byteptr,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("charptr"),.cname = _S("charptr"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__charptr,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("i8"),.cname = _S("i8"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__i8,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("i16"),.cname = _S("i16"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__i16,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("i32"),.cname = _S("i32"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__i32,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("int"),.cname = _const_v__ast__int_type_name,.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__int,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("i64"),.cname = _S("i64"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__i64,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("isize"),.cname = _S("isize"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__isize,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("u8"),.cname = _S("u8"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__u8,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("u16"),.cname = _S("u16"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__u16,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("u32"),.cname = _S("u32"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__u32,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("u64"),.cname = _S("u64"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__u64,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("usize"),.cname = _S("usize"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__usize,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("f32"),.cname = _S("f32"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__f32,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("f64"),.cname = _S("f64"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__f64,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("char"),.cname = _S("char"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__char,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("bool"),.cname = _S("bool"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__bool,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("none"),.cname = _S("none"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__none,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = _S("builtin"),
		.name = _S("string"),
		.cname = _S("string"),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__string,
		.language = 0,
		.is_pub = true,
		.is_builtin = true,
	}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("rune"),.cname = _S("rune"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__rune,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = _S("builtin"),
		.name = _S("array"),
		.cname = _S("array"),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__array,
		.language = 0,
		.is_pub = true,
		.is_builtin = true,
	}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = _S("builtin"),
		.name = _S("map"),
		.cname = _S("map"),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__map,
		.language = 0,
		.is_pub = true,
		.is_builtin = true,
	}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("chan"),.cname = _S("chan"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__chan,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("any"),.cname = _S("any"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__any,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("float literal"),.cname = _S("float_literal"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__float_literal,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("int literal"),.cname = _S("int_literal"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__int_literal,.language = 0,.is_pub = true,.is_builtin = 0,}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = _S("builtin"),
		.name = _S("thread"),
		.cname = _S("__v_thread"),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = v__ast__Thread_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Thread, (((v__ast__Thread){.return_type = _const_v__ast__void_type,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__thread,
		.language = 0,
		.is_pub = true,
		.is_builtin = 0,
	}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = _S("builtin"),
		.name = _S("IError"),
		.cname = _S("IError"),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__interface,
		.language = 0,
		.is_pub = true,
		.is_builtin = true,
	}));
	v__ast__Table_register_sym(t, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = _S("builtin"),.name = _S("nil"),.cname = _S("voidptr"),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__voidptr,.language = 0,.is_pub = true,.is_builtin = 0,}));
}
inline bool v__ast__TypeSymbol_is_pointer(v__ast__TypeSymbol* t) {
	return (t->kind == v__ast__Kind__byteptr || t->kind == v__ast__Kind__charptr || t->kind == v__ast__Kind__voidptr);
}
inline bool v__ast__TypeSymbol_is_int(v__ast__TypeSymbol* t) {
	bool res = (t->kind == v__ast__Kind__i8 || t->kind == v__ast__Kind__i16 || t->kind == v__ast__Kind__i32 || t->kind == v__ast__Kind__int || t->kind == v__ast__Kind__i64 || t->kind == v__ast__Kind__isize || t->kind == v__ast__Kind__u8 || t->kind == v__ast__Kind__u16 || t->kind == v__ast__Kind__u32 || t->kind == v__ast__Kind__u64 || t->kind == v__ast__Kind__usize || t->kind == v__ast__Kind__int_literal || t->kind == v__ast__Kind__rune);
	if (!res && t->kind == v__ast__Kind__alias) {
		return v__ast__Type_is_int((*(v__ast__Alias*)builtin____as_cast((t->info)._v__ast__Alias,(t->info)._typ, 482)).parent_type);
	}
	return res;
}
inline bool v__ast__TypeSymbol_is_float(v__ast__TypeSymbol* t) {
	return (t->kind == v__ast__Kind__f32 || t->kind == v__ast__Kind__f64 || t->kind == v__ast__Kind__float_literal);
}
inline bool v__ast__TypeSymbol_is_string(v__ast__TypeSymbol* t) {
	return t->kind == v__ast__Kind__string;
}
inline bool v__ast__TypeSymbol_is_number(v__ast__TypeSymbol* t) {
	return v__ast__TypeSymbol_is_int(t) || v__ast__TypeSymbol_is_float(t);
}
inline bool v__ast__TypeSymbol_is_bool(v__ast__TypeSymbol* t) {
	return t->kind == v__ast__Kind__bool;
}
inline bool v__ast__TypeSymbol_is_primitive(v__ast__TypeSymbol* t) {
	return v__ast__TypeSymbol_is_number(t) || v__ast__TypeSymbol_is_pointer(t) || v__ast__TypeSymbol_is_string(t) || v__ast__TypeSymbol_is_bool(t);
}
inline bool v__ast__TypeSymbol_is_builtin(v__ast__TypeSymbol* t) {
	return builtin__fast_string_eq(t->mod, _S("builtin"));
}
multi_return_int_int v__ast__Table_type_size(v__ast__Table* t, v__ast__Type typ) {
	if (v__ast__Type_has_option_or_result(typ)) {
		return v__ast__Table_type_size(t, _const_v__ast__error_type_idx);
	}
	if (v__ast__Type_nr_muls(typ) > 0) {
		return (multi_return_int_int){.arg0=t->pointer_size, .arg1=t->pointer_size};
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	if (sym->size != -1) {
		return (multi_return_int_int){.arg0=sym->size, .arg1=sym->align};
	}
	int size = 0;
	int align = 0;
	switch (sym->kind) {
		case v__ast__Kind__placeholder: case v__ast__Kind__void: case v__ast__Kind__none: case v__ast__Kind__generic_inst: {
			break;
		}
		case v__ast__Kind__voidptr: case v__ast__Kind__byteptr: case v__ast__Kind__charptr: case v__ast__Kind__function: case v__ast__Kind__usize: case v__ast__Kind__isize: case v__ast__Kind__any: case v__ast__Kind__thread: case v__ast__Kind__chan: {
			size = t->pointer_size;
			align = t->pointer_size;
			break;
		}
		case v__ast__Kind__i8: case v__ast__Kind__u8: case v__ast__Kind__char: case v__ast__Kind__bool: {
			size = 1;
			align = 1;
			break;
		}
		case v__ast__Kind__i16: case v__ast__Kind__u16: {
			size = 2;
			align = 2;
			break;
		}
		case v__ast__Kind__i32: case v__ast__Kind__u32: case v__ast__Kind__rune: case v__ast__Kind__f32: case v__ast__Kind__enum: {
			size = 4;
			align = 4;
			break;
		}
		case v__ast__Kind__int: {
			#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
			{
			}
			#else
			{
				size = 4;
				align = 4;
			}
			#endif
			break;
		}
		case v__ast__Kind__i64: case v__ast__Kind__u64: case v__ast__Kind__int_literal: case v__ast__Kind__f64: case v__ast__Kind__float_literal: {
			size = 8;
			align = 8;
			break;
		}
		case v__ast__Kind__alias: {
			multi_return_int_int mr_31431 = v__ast__Table_type_size(t, (*(v__ast__Alias*)builtin____as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 482)).parent_type);
			size = mr_31431.arg0;
			align = mr_31431.arg1;
			break;
		}
		case v__ast__Kind__struct: case v__ast__Kind__string: case v__ast__Kind__multi_return: {
			int max_alignment = 0;
			int total_size = 0;
			Array_v__ast__Type _t5; /* if prepend */
			if ((sym->info)._typ == 457 /* v.ast.Struct */) {
				Array_v__ast__Type _t7 = {0};
				Array_v__ast__StructField _t7_orig = (*sym->info._v__ast__Struct).fields;
				int _t7_len = _t7_orig.len;
				_t7 = builtin____new_array(0, _t7_len, sizeof(v__ast__Type));

				for (int _t9 = 0; _t9 < _t7_len; ++_t9) {
					v__ast__StructField it = ((v__ast__StructField*) _t7_orig.data)[_t9];
					v__ast__Type _t8 = it.typ;
					builtin__array_push((array*)&_t7, &_t8);
				}
				_t5 =_t7;
				goto _t6;
			};
			{
				_t5 = (*(v__ast__MultiReturn*)builtin____as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 494)).types;
			}
	_t6: {};
						Array_v__ast__Type types = _t5;
			for (int _t10 = 0; _t10 < types.len; ++_t10) {
				v__ast__Type ftyp = ((v__ast__Type*)types.data)[_t10];
				multi_return_int_int mr_31741 = v__ast__Table_type_size(t, ftyp);
				int field_size = mr_31741.arg0;
				int alignment = mr_31741.arg1;
				if (alignment > max_alignment) {
					max_alignment = alignment;
				}
				total_size = (int)(v__ast__round_up(total_size, alignment) + field_size);
			}
			size = v__ast__round_up(total_size, max_alignment);
			align = max_alignment;
			break;
		}
		case v__ast__Kind__sum_type: case v__ast__Kind__interface: case v__ast__Kind__aggregate: {
			if (sym->info._typ == 486 /* v.ast.SumType */) {
				size = (int)(((int)((*sym->info._v__ast__SumType).fields.len + 2)) * t->pointer_size);
				align = t->pointer_size;
			}
			else if (sym->info._typ == 480 /* v.ast.Aggregate */) {
				size = (int)(((int)((*sym->info._v__ast__Aggregate).fields.len + 2)) * t->pointer_size);
				align = t->pointer_size;
			}
			else if (sym->info._typ == 485 /* v.ast.Interface */) {
				size = (int)(((int)((*sym->info._v__ast__Interface).fields.len + 2)) * t->pointer_size);
				align = t->pointer_size;
				for (int _t11 = 0; _t11 < (*sym->info._v__ast__Interface).embeds.len; ++_t11) {
					v__ast__Type etyp = ((v__ast__Type*)(*sym->info._v__ast__Interface).embeds.data)[_t11];
					multi_return_int_int mr_32301 = v__ast__Table_type_size(t, etyp);
					int esize = mr_32301.arg0;
					size += (int)(esize - (int)(2 * t->pointer_size));
				}
			}
			
			else {
			}
			
			break;
		}
		case v__ast__Kind__array_fixed: {
			v__ast__ArrayFixed info = *(v__ast__ArrayFixed*)builtin____as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 491);
			multi_return_int_int mr_32498 = v__ast__Table_type_size(t, info.elem_type);
			int elem_size = mr_32498.arg0;
			int elem_align = mr_32498.arg1;
			size = (int)(info.size * elem_size);
			align = elem_align;
			break;
		}
		case v__ast__Kind__map: {
			int _t12; /* if prepend */
			if (t->pointer_size == 8) {
				int _t14;
				#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
				#else
					_t14 = 120;
					;
				#endif
								_t12 = _t14;
				goto _t13;
			};
			{
				_t12 = 80;
			}
	_t13: {};
						size = _t12;
			align = t->pointer_size;
			break;
		}
		case v__ast__Kind__array: {
			int _t15; /* if prepend */
			if (t->pointer_size == 8) {
				int _t17;
				#if defined(CUSTOM_DEFINE_new_int) && defined(TARGET_IS_64BIT)
				#else
					_t17 = 32;
					;
				#endif
								_t15 = _t17;
				goto _t16;
			};
			{
				_t15 = 24;
			}
	_t16: {};
						size = _t15;
			align = t->pointer_size;
			break;
		}
	}
	
	sym->size = size;
	sym->align = align;
	return (multi_return_int_int){.arg0=size, .arg1=align};
}
inline VV_LOC int v__ast__round_up(int n, int multiple) {
	return (((int)((int)(n + multiple) - 1)) & -multiple);
}
string v__ast__Kind_str(v__ast__Kind k) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (k) {
		case v__ast__Kind__placeholder: {
			_t2 = _S("placeholder");
			break;
		}
		case v__ast__Kind__void: {
			_t2 = _S("void");
			break;
		}
		case v__ast__Kind__voidptr: {
			_t2 = _S("voidptr");
			break;
		}
		case v__ast__Kind__charptr: {
			_t2 = _S("charptr");
			break;
		}
		case v__ast__Kind__byteptr: {
			_t2 = _S("byteptr");
			break;
		}
		case v__ast__Kind__struct: {
			_t2 = _S("struct");
			break;
		}
		case v__ast__Kind__int: {
			_t2 = _S("int");
			break;
		}
		case v__ast__Kind__i8: {
			_t2 = _S("i8");
			break;
		}
		case v__ast__Kind__i16: {
			_t2 = _S("i16");
			break;
		}
		case v__ast__Kind__i32: {
			_t2 = _S("i32");
			break;
		}
		case v__ast__Kind__i64: {
			_t2 = _S("i64");
			break;
		}
		case v__ast__Kind__isize: {
			_t2 = _S("isize");
			break;
		}
		case v__ast__Kind__u8: {
			_t2 = _S("u8");
			break;
		}
		case v__ast__Kind__u16: {
			_t2 = _S("u16");
			break;
		}
		case v__ast__Kind__u32: {
			_t2 = _S("u32");
			break;
		}
		case v__ast__Kind__u64: {
			_t2 = _S("u64");
			break;
		}
		case v__ast__Kind__usize: {
			_t2 = _S("usize");
			break;
		}
		case v__ast__Kind__int_literal: {
			_t2 = _S("int_literal");
			break;
		}
		case v__ast__Kind__f32: {
			_t2 = _S("f32");
			break;
		}
		case v__ast__Kind__f64: {
			_t2 = _S("f64");
			break;
		}
		case v__ast__Kind__float_literal: {
			_t2 = _S("float_literal");
			break;
		}
		case v__ast__Kind__string: {
			_t2 = _S("string");
			break;
		}
		case v__ast__Kind__char: {
			_t2 = _S("char");
			break;
		}
		case v__ast__Kind__bool: {
			_t2 = _S("bool");
			break;
		}
		case v__ast__Kind__none: {
			_t2 = _S("none");
			break;
		}
		case v__ast__Kind__array: {
			_t2 = _S("array");
			break;
		}
		case v__ast__Kind__array_fixed: {
			_t2 = _S("array_fixed");
			break;
		}
		case v__ast__Kind__map: {
			_t2 = _S("map");
			break;
		}
		case v__ast__Kind__chan: {
			_t2 = _S("chan");
			break;
		}
		case v__ast__Kind__multi_return: {
			_t2 = _S("multi_return");
			break;
		}
		case v__ast__Kind__sum_type: {
			_t2 = _S("sum_type");
			break;
		}
		case v__ast__Kind__alias: {
			_t2 = _S("alias");
			break;
		}
		case v__ast__Kind__enum: {
			_t2 = _S("enum");
			break;
		}
		case v__ast__Kind__any: {
			_t2 = _S("any");
			break;
		}
		case v__ast__Kind__function: {
			_t2 = _S("function");
			break;
		}
		case v__ast__Kind__interface: {
			_t2 = _S("interface");
			break;
		}
		case v__ast__Kind__generic_inst: {
			_t2 = _S("generic_inst");
			break;
		}
		case v__ast__Kind__rune: {
			_t2 = _S("rune");
			break;
		}
		case v__ast__Kind__aggregate: {
			_t2 = _S("aggregate");
			break;
		}
		case v__ast__Kind__thread: {
			_t2 = _S("thread");
			break;
		}
	}
	return _t2;
}
string Array_v__ast__Kind_str(Array_v__ast__Kind kinds) {
	string kinds_str = _S("");
	for (int i = 0; i < kinds.len; ++i) {
		v__ast__Kind k = ((v__ast__Kind*)kinds.data)[i];
		kinds_str = builtin__string__plus(kinds_str, v__ast__Kind_str(k));
		if (i < (int)(kinds.len - 1)) {
			kinds_str = builtin__string__plus(kinds_str, _S("_"));
		}
	}
	return kinds_str;
}
string v__ast__Table_type_to_str(v__ast__Table* t, v__ast__Type typ) {
	return v__ast__Table_type_to_str_using_aliases(t, typ, builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	);
}
string v__ast__Table_type_to_code(v__ast__Table* t, v__ast__Type typ) {

	if (typ == (_const_v__ast__int_literal_type) || typ == (_const_v__ast__float_literal_type)) {
		return v__ast__Kind_str(v__ast__Table_sym(t, typ)->kind);
	}
	else {
		return v__ast__Table_type_to_str_using_aliases(t, typ, builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
		);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
string v__ast__Table_clean_generics_type_str(v__ast__Table* t, v__ast__Type typ) {
	string result = v__ast__Table_type_to_str(t, typ);
	return builtin__string_all_before(result, _S("["));
}
VV_LOC string v__ast__strip_extra_struct_types(string name) {
	int start = 0;
	bool is_start = false;
	int nested_count = 0;
	Array_string strips = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < name.len; ++i) {
		u8 ch = name.str[i];
		if (ch == '<') {
			if (is_start) {
				nested_count++;
			} else {
				is_start = true;
				start = i;
			}
		} else if (ch == '>') {
			if (nested_count > 0) {
				nested_count--;
			} else {
				builtin__array_push((array*)&strips, _MOV((string[]){ builtin__string_substr(name, start, (int)(i + 1)) }));
				builtin__array_push((array*)&strips, _MOV((string[]){ _S("") }));
				is_start = false;
			}
		}
	}
	if (strips.len > 0) {
		return builtin__string_replace_each(name, strips);
	} else {
		return name;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
void v__ast__Table_delete_cached_type_to_str(v__ast__Table* t, v__ast__Type typ, int import_aliases_len) {
	u64 cache_key = (((((u64)(import_aliases_len)) << 32)) | ((u64)(typ)));
	v__ast__Table* mt = ((v__ast__Table*)(t));
	sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
	/*lock*/ {
		builtin__map_delete(&mt->cached_type_to_str->val, &(u64[]){cache_key});
	}
	sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
}
string v__ast__Table_type_to_str_using_aliases(v__ast__Table* t, v__ast__Type typ, Map_string_string import_aliases) {
	u64 cache_key = (((((u64)(import_aliases.len)) << 32)) | ((u64)(typ)));
	string* _t2 = (string*)(builtin__map_get_check(ADDR(map, t->cached_type_to_str->val), &(u64[]){cache_key}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		string cached_res = (*(string*)_t1.data);
		return cached_res;
	}
	v__ast__TypeSymbol* sym = v__ast__Table_sym(t, typ);
	string res = sym->name;
	v__ast__Table* mt = ((v__ast__Table*)(t));
	switch (sym->kind) {
		case v__ast__Kind__int_literal: case v__ast__Kind__float_literal: {
			break;
		}
		case v__ast__Kind__i8: case v__ast__Kind__i16: case v__ast__Kind__i32: case v__ast__Kind__int: case v__ast__Kind__i64: case v__ast__Kind__isize: case v__ast__Kind__u8: case v__ast__Kind__u16: case v__ast__Kind__u32: case v__ast__Kind__u64: case v__ast__Kind__usize: case v__ast__Kind__f32: case v__ast__Kind__f64: case v__ast__Kind__char: case v__ast__Kind__rune: case v__ast__Kind__string: case v__ast__Kind__bool: case v__ast__Kind__none: case v__ast__Kind__voidptr: case v__ast__Kind__byteptr: case v__ast__Kind__charptr: {
			res = v__ast__Kind_str(sym->kind);
			break;
		}
		case v__ast__Kind__array: {
			if (typ == _const_v__ast__array_type) {
				res = _S("array");
				string _t4 = res;
					{ // defer begin
						sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
						/*lock*/ {
							builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
						}
						sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
					} // defer end
				return _t4;
			}
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
				res = v__ast__Table_type_to_str_using_aliases(t, v__ast__Table_value_type(t, typ), import_aliases);
			} else {
				if ((sym->info)._typ == 452 /* v.ast.Array */) {
					string elem_str = v__ast__Table_type_to_str_using_aliases(t, (*sym->info._v__ast__Array).elem_type, import_aliases);
					res = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("[]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
				} else {
					res = _S("array");
				}
			}
			break;
		}
		case v__ast__Kind__array_fixed: {
			v__ast__ArrayFixed info = *(v__ast__ArrayFixed*)builtin____as_cast((sym->info)._v__ast__ArrayFixed,(sym->info)._typ, 491);
			string elem_str = v__ast__Table_type_to_str_using_aliases(t, info.elem_type, import_aliases);
			if ((info.size_expr)._typ == 277 /* v.ast.EmptyExpr */) {
				res = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("["), 0xfe07, {.d_i32 = info.size}}, {_S("]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else if ((info.size_expr)._typ == 281 /* v.ast.Ident */) {
				string size_str = v__ast__Table_shorten_user_defined_typenames(t, (*info.size_expr._v__ast__Ident).name, import_aliases);
				res = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("["), 0xfe10, {.d_s = size_str}}, {_S("]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				res = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("["), 0xfe10, {.d_s = v__ast__Expr_str(info.size_expr)}}, {_S("]"), 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
			break;
		}
		case v__ast__Kind__chan: {
			if (!builtin__fast_string_eq(sym->mod, _S("builtin")) && !builtin__fast_string_eq(sym->name, _S("chan"))) {
				v__ast__Chan info = *(v__ast__Chan*)builtin____as_cast((sym->info)._v__ast__Chan,(sym->info)._typ, 492);
				v__ast__Type elem_type = info.elem_type;
				string mut_str = _S("");
				if (info.is_mut) {
					mut_str = _S("mut ");
					elem_type = v__ast__Type_set_nr_muls(elem_type, (int)(v__ast__Type_nr_muls(elem_type) - 1));
				}
				string elem_str = v__ast__Table_type_to_str_using_aliases(t, elem_type, import_aliases);
				res = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("chan "), 0xfe10, {.d_s = mut_str}}, {_SLIT0, 0xfe10, {.d_s = elem_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
			break;
		}
		case v__ast__Kind__function: {
			v__ast__FnType info = *(v__ast__FnType*)builtin____as_cast((sym->info)._v__ast__FnType,(sym->info)._typ, 495);
			if (!t->is_fmt) {
				res = v__ast__Table_fn_signature(t, (voidptr)&info.func, ((v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = true,}));
			} else {
				if (builtin__string_starts_with(res, _S("fn ("))) {
					bool _t5 = false;
					Array_v__ast__Param _t5_orig = info.func.params;
					int _t5_len = _t5_orig.len;
					for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
						v__ast__Param it = ((v__ast__Param*) _t5_orig.data)[_t6];
						if ((it.name).len != 0) {
							_t5 = true;
							break;
						}
					}
					bool has_names =_t5;
					res = v__ast__Table_fn_signature_using_aliases(t, (voidptr)&info.func, import_aliases, ((v__ast__FnSignatureOpts){.skip_receiver = 0,.type_only = !has_names,}));
				} else {
					res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
				}
			}
			break;
		}
		case v__ast__Kind__map: {
			if (((int)(typ)) == 24) {
				res = _S("map");
				string _t7 = res;
					{ // defer begin
						sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
						/*lock*/ {
							builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
						}
						sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
					} // defer end
				return _t7;
			}
			v__ast__Map info = *(v__ast__Map*)builtin____as_cast((sym->info)._v__ast__Map,(sym->info)._typ, 453);
			string key_str = v__ast__Table_type_to_str_using_aliases(t, info.key_type, import_aliases);
			string val_str = v__ast__Table_type_to_str_using_aliases(t, info.value_type, import_aliases);
			res = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("map["), 0xfe10, {.d_s = key_str}}, {_S("]"), 0xfe10, {.d_s = val_str}}, {_SLIT0, 0, { .d_c = 0 }}}));
			break;
		}
		case v__ast__Kind__multi_return: {
			res = _S("(");
			v__ast__MultiReturn info = *(v__ast__MultiReturn*)builtin____as_cast((sym->info)._v__ast__MultiReturn,(sym->info)._typ, 494);
			for (int i = 0; i < info.types.len; ++i) {
				v__ast__Type typ2 = ((v__ast__Type*)info.types.data)[i];
				if (i > 0) {
					res = builtin__string__plus(res, _S(", "));
				}
				res = builtin__string__plus(res, v__ast__Table_type_to_str_using_aliases(t, typ2, import_aliases));
			}
			res = builtin__string__plus(res, _S(")"));
			break;
		}
		case v__ast__Kind__struct: case v__ast__Kind__interface: case v__ast__Kind__sum_type: {
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
				if (sym->info._typ == 457 /* v.ast.Struct */) {
					res = builtin__string__plus(res, _S("["));
					for (int i = 0; i < (*sym->info._v__ast__Struct).generic_types.len; ++i) {
						v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__Struct).generic_types.data)[i];
						res = builtin__string__plus(res, v__ast__Table_sym(t, gtyp)->name);
						if (i != (int)((*sym->info._v__ast__Struct).generic_types.len - 1)) {
							res = builtin__string__plus(res, _S(", "));
						}
					}
					res = builtin__string__plus(res, _S("]"));
				}
				else if (sym->info._typ == 485 /* v.ast.Interface */) {
					res = builtin__string__plus(res, _S("["));
					for (int i = 0; i < (*sym->info._v__ast__Interface).generic_types.len; ++i) {
						v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__Interface).generic_types.data)[i];
						res = builtin__string__plus(res, v__ast__Table_sym(t, gtyp)->name);
						if (i != (int)((*sym->info._v__ast__Interface).generic_types.len - 1)) {
							res = builtin__string__plus(res, _S(", "));
						}
					}
					res = builtin__string__plus(res, _S("]"));
				}
				else if (sym->info._typ == 486 /* v.ast.SumType */) {
					res = builtin__string__plus(res, _S("["));
					for (int i = 0; i < (*sym->info._v__ast__SumType).generic_types.len; ++i) {
						v__ast__Type gtyp = ((v__ast__Type*)(*sym->info._v__ast__SumType).generic_types.data)[i];
						res = builtin__string__plus(res, v__ast__Table_sym(t, gtyp)->name);
						if (i != (int)((*sym->info._v__ast__SumType).generic_types.len - 1)) {
							res = builtin__string__plus(res, _S(", "));
						}
					}
					res = builtin__string__plus(res, _S("]"));
				}
				
				else {
				}
				
			} else if ((sym->info)._typ == 486 /* v.ast.SumType */ && (*(v__ast__SumType*)builtin____as_cast((sym->info)._v__ast__SumType,(sym->info)._typ, 486)).is_anon) {
				Array_string _t8 = {0};
				Array_v__ast__Type _t8_orig = (*sym->info._v__ast__SumType).variants;
				int _t8_len = _t8_orig.len;
				_t8 = builtin____new_array(0, _t8_len, sizeof(string));

				for (int _t10 = 0; _t10 < _t8_len; ++_t10) {
					v__ast__Type it = ((v__ast__Type*) _t8_orig.data)[_t10];
					string _t9 = v__ast__Table_shorten_user_defined_typenames(t, v__ast__Table_sym(t, it)->name, import_aliases);
					builtin__array_push((array*)&_t8, &_t9);
				}
				Array_string variant_names =_t8;
				res = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_string_join(variant_names, _S("|"))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			} else {
				res = v__ast__strip_extra_struct_types(res);
				res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
			}
			break;
		}
		case v__ast__Kind__generic_inst: {
			v__ast__GenericInst info = *(v__ast__GenericInst*)builtin____as_cast((sym->info)._v__ast__GenericInst,(sym->info)._typ, 496);
			res = v__ast__Table_shorten_user_defined_typenames(t, builtin__string_all_before(sym->name, _S("[")), import_aliases);
			res = builtin__string__plus(res, _S("["));
			for (int i = 0; i < info.concrete_types.len; ++i) {
				v__ast__Type ctyp = ((v__ast__Type*)info.concrete_types.data)[i];
				res = builtin__string__plus(res, v__ast__Table_type_to_str_using_aliases(t, ctyp, import_aliases));
				if (i != (int)(info.concrete_types.len - 1)) {
					res = builtin__string__plus(res, _S(", "));
				}
			}
			res = builtin__string__plus(res, _S("]"));
			break;
		}
		case v__ast__Kind__void: {
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__option)) {
				res = _S("?");
				string _t11 = res;
					{ // defer begin
						sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
						/*lock*/ {
							builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
						}
						sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
					} // defer end
				return _t11;
			}
			if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__result)) {
				res = _S("!");
				string _t12 = res;
					{ // defer begin
						sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
						/*lock*/ {
							builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
						}
						sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
					} // defer end
				return _t12;
			}
			res = _S("void");
			string _t13 = res;
				{ // defer begin
					sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
					/*lock*/ {
						builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
					}
					sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
				} // defer end
			return _t13;
		}
		case v__ast__Kind__thread: {
			v__ast__Type rtype = v__ast__TypeSymbol_thread_info(sym).return_type;
			if (rtype != 1) {
				res = builtin__string__plus(_S("thread "), v__ast__Table_type_to_str_using_aliases(t, rtype, import_aliases));
			}
			break;
		}
		case v__ast__Kind__alias: case v__ast__Kind__any: case v__ast__Kind__placeholder: case v__ast__Kind__enum: {
			res = v__ast__Table_shorten_user_defined_typenames(t, res, import_aliases);
			break;
		}
		case v__ast__Kind__aggregate: {
			break;
		}
	}
	
	int nr_muls = v__ast__Type_nr_muls(typ);
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__shared_f)) {
		nr_muls--;
		res = builtin__string__plus(_S("shared "), res);
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__atomic_f)) {
		nr_muls--;
		res = builtin__string__plus(_S("atomic "), res);
	}
	if (nr_muls > 0 && !v__ast__Type_has_flag(typ, v__ast__TypeFlag__variadic)) {
		res = builtin__string__plus(strings__repeat('&', nr_muls), res);
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__option) && builtin__string_at(res, 0) != '?') {
		res = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("?"), 0xfe10, {.d_s = res}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__result)) {
		res = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("!"), 0xfe10, {.d_s = res}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	string _t14 = res;
		{ // defer begin
			sync__RwMutex_lock(&mt->cached_type_to_str->mtx);
			/*lock*/ {
				builtin__map_set(&mt->cached_type_to_str->val, &(u64[]){cache_key}, &(string[]) { res });
			}
			sync__RwMutex_unlock(&mt->cached_type_to_str->mtx);;
		} // defer end
	return _t14;
}
VV_LOC string v__ast__Table_shorten_user_defined_typenames(v__ast__Table* t, string original_name, Map_string_string import_aliases) {
	string* _t2 = (string*)(builtin__map_get_check(ADDR(map, import_aliases), &(string[]){original_name}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		string alias = (*(string*)_t1.data);
		return alias;
	}
	_option_multi_return_string_string _t4 = builtin__string_rsplit_once(original_name, _S("."));
	if (_t4.state != 0) {
		return original_name;
	}
	
 	multi_return_string_string mr_41775 = (*(multi_return_string_string*)_t4.data);
	string mod = mr_41775.arg0;
	string typ = mr_41775.arg1;
	if (!builtin__string_contains(mod, _S("["))) {
		if (!t->is_fmt) {
			mod = builtin__string_all_after_last(mod, _S("."));
		}
		string* _t7 = (string*)(builtin__map_get_check(ADDR(map, import_aliases), &(string[]){mod}));
		_option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = builtin___v_error(_S("map key does not exist"));
		}
		
		if (_t6.state == 0) {
			string alias = (*(string*)_t6.data);
			mod = alias;
		} else if ((t->cmod_prefix).len != 0) {
			string* _t9 = (string*)(builtin__map_get_check(ADDR(map, import_aliases), &(string[]){builtin__string__plus(t->cmod_prefix, mod)}));
			_option_string _t8 = {0};
			if (_t9) {
				*((string*)&_t8.data) = *((string*)_t9);
			} else {
				_t8.state = 2; _t8.err = builtin___v_error(_S("map key does not exist"));
			}
			
			if (_t8.state == 0) {
				string alias = (*(string*)_t8.data);
				mod = alias;
			} else {
				return builtin__string_all_after(original_name, t->cmod_prefix);
			}
		}
	}
	if (builtin__string_contains(original_name, _S("[]"))) {
		_option_multi_return_string_string _t11;
		if (_t11 = builtin__string_split_once(original_name, _S("[")), _t11.state == 0) {
			string lhs = (*(multi_return_string_string*)_t11.data).arg0;
			string typ_after_lsbr = (*(multi_return_string_string*)_t11.data).arg1;
			_option_multi_return_string_string _t12;
			if (_t12 = builtin__string_rsplit_once(lhs, _S(".")), _t12.state == 0) {
				string mod_ = (*(multi_return_string_string*)_t12.data).arg0;
				string typ_before_lsbr = (*(multi_return_string_string*)_t12.data).arg1;
				mod = mod_;
				typ = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = typ_before_lsbr}}, {_S("["), 0xfe10, {.d_s = typ_after_lsbr}}, {_SLIT0, 0, { .d_c = 0 }}}));
			}
		}
	}
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_S("."), 0xfe10, {.d_s = typ}}, {_SLIT0, 0, { .d_c = 0 }}}));
}
string v__ast__Table_fn_signature(v__ast__Table* t, v__ast__Fn* func, v__ast__FnSignatureOpts opts) {
	return v__ast__Table_fn_signature_using_aliases(t, func, builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	, opts);
}
string v__ast__Table_fn_signature_using_aliases(v__ast__Table* t, v__ast__Fn* func, Map_string_string import_aliases, v__ast__FnSignatureOpts opts) {
	strings__Builder sb = strings__new_builder(20);
	if (!opts.skip_receiver) {
		strings__Builder_write_string(&sb, _S("fn "));
	}
	if (!opts.type_only) {
		strings__Builder_write_string(&sb, func->name);
	}
	strings__Builder_write_string(&sb, _S("("));
	int start = (int[]){(func->is_method && opts.skip_receiver)?1:0}[0];
	for (int i = start; i < func->params.len; ++i) {
		if (i != start) {
			strings__Builder_write_string(&sb, _S(", "));
		}
		v__ast__Param param = (*(v__ast__Param*)builtin__array_get(func->params, i));
		v__ast__Type typ = param.typ;
		if (param.is_mut) {
			if (v__ast__Type_is_ptr(param.typ)) {
				typ = v__ast__Type_deref(typ);
			}
			strings__Builder_write_string(&sb, _S("mut "));
		}
		if (!opts.type_only) {
			strings__Builder_write_string(&sb, param.name);
			strings__Builder_write_string(&sb, _S(" "));
		}
		string styp = v__ast__Table_type_to_str_using_aliases(t, typ, import_aliases);
		if (i == (int)(func->params.len - 1) && func->is_variadic) {
			strings__Builder_write_string(&sb, _S("..."));
			strings__Builder_write_string(&sb, styp);
		} else {
			strings__Builder_write_string(&sb, styp);
		}
	}
	strings__Builder_write_string(&sb, _S(")"));
	if (func->return_type != _const_v__ast__void_type) {
		strings__Builder_write_string(&sb, _S(" "));
		strings__Builder_write_string(&sb, v__ast__Table_type_to_str_using_aliases(t, func->return_type, import_aliases));
	}
	return strings__Builder_str(&sb);
}
string v__ast__TypeSymbol_symbol_name_except_generic(v__ast__TypeSymbol* t) {
	string prefix = _S("");
	string name = t->name;
	for (int i = 0; i < t->name.len; ++i) {
		u8 ch = t->name.str[i];
		if (ch == '&' || ch == '[' || ch == ']') {
			continue;
		}
		if (i > 0) {
			prefix = builtin__string_substr(t->name, 0, i);
			name = builtin__string_substr(t->name, i, 2147483647);
		}
		break;
	}
	if (builtin__string_contains(name, _S("["))) {
		name = builtin__string_all_before(name, _S("["));
	}
	return builtin__string__plus(prefix, name);
}
string v__ast__TypeSymbol_embed_name(v__ast__TypeSymbol* t) {
	if (builtin__string_contains(t->name, _S("<"))) {
		return (*(string*)builtin__array_last(builtin__string_split((*(string*)builtin__array_get(builtin__string_split(t->name, _S("<")), 0)), _S("."))));
	} else if (builtin__string_contains(t->name, _S("["))) {
		return (*(string*)builtin__array_last(builtin__string_split((*(string*)builtin__array_get(builtin__string_split(t->name, _S("[")), 0)), _S("."))));
	} else {
		return (*(string*)builtin__array_last(builtin__string_split(t->name, _S("."))));
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
bool v__ast__TypeSymbol_has_method(v__ast__TypeSymbol* t, string name) {
	Array_v__ast__Fn _t1 = t->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (method->name.len == name.len && builtin__string__eq(method->name, name)) {
			return true;
		}
	}
	return false;
}
bool v__ast__TypeSymbol_has_method_with_generic_parent(v__ast__TypeSymbol* t, string name) {
	_option_v__ast__Fn _t1 = v__ast__TypeSymbol_find_method_with_generic_parent(t, name);
	if (_t1.state != 0) {
		return false;
	}
	
 	v__ast__Fn m = (*(v__ast__Fn*)_t1.data);
	return t->kind != v__ast__Kind__interface || !m.no_body;
}
_option_v__ast__Fn v__ast__TypeSymbol_find_method(v__ast__TypeSymbol* t, string name) {
	Array_v__ast__Fn _t1 = t->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (method->name.len == name.len && builtin__string__eq(method->name, name)) {
			_option_v__ast__Fn _t3;
			builtin___option_ok(&(v__ast__Fn[]) { *method }, (_option*)(&_t3), sizeof(v__ast__Fn));
			 
			return _t3;
		}
	}
	return (_option_v__ast__Fn){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__Fn v__ast__TypeSymbol_find_method_with_generic_parent(v__ast__TypeSymbol* t, string name) {
	_option_v__ast__Fn _t1;
	if (_t1 = v__ast__TypeSymbol_find_method(t, name), _t1.state == 0) {
		v__ast__Fn m = *(v__ast__Fn*)_t1.data;
		_option_v__ast__Fn _t2;
		builtin___option_ok(&(v__ast__Fn[]) { m }, (_option*)(&_t2), sizeof(v__ast__Fn));
		 
		return _t2;
	}
	v__ast__Table* table = global_table;
	if (t->info._typ == 457 /* v.ast.Struct */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Struct).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__Struct).parent_type);
			_option_v__ast__Fn _t3;
			if (_t3 = v__ast__TypeSymbol_find_method(parent_sym, name), _t3.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t3.data;
				if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t4 = {0};
					Array_v__ast__Type _t4_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t4_len = _t4_orig.len;
					_t4 = builtin____new_array(0, _t4_len, sizeof(string));

					for (int _t6 = 0; _t6 < _t4_len; ++_t6) {
						v__ast__Type it = ((v__ast__Type*) _t4_orig.data)[_t6];
						string _t5 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t4, &_t5);
					}
					Array_string generic_names =_t4;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types);
					} else {
						_option_v__ast__Type _t7;
						if (_t7 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t7.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t7.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t8 = 0; _t8 < method.params.len; ++_t8) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t8;
						_option_v__ast__Type _t9;
						if (_t9 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t9.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t9.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t10;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t10), sizeof(v__ast__Fn));
					 
					return _t10;
				}
				else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t11 = {0};
					Array_v__ast__Type _t11_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t11_len = _t11_orig.len;
					_t11 = builtin____new_array(0, _t11_len, sizeof(string));

					for (int _t13 = 0; _t13 < _t11_len; ++_t13) {
						v__ast__Type it = ((v__ast__Type*) _t11_orig.data)[_t13];
						string _t12 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t11, &_t12);
					}
					Array_string generic_names =_t11;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types);
					} else {
						_option_v__ast__Type _t14;
						if (_t14 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t14.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t14.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t15 = 0; _t15 < method.params.len; ++_t15) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t15;
						_option_v__ast__Type _t16;
						if (_t16 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t16.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t16.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t17;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t17), sizeof(v__ast__Fn));
					 
					return _t17;
				}
				else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t18 = {0};
					Array_v__ast__Type _t18_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t18_len = _t18_orig.len;
					_t18 = builtin____new_array(0, _t18_len, sizeof(string));

					for (int _t20 = 0; _t20 < _t18_len; ++_t20) {
						v__ast__Type it = ((v__ast__Type*) _t18_orig.data)[_t20];
						string _t19 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t18, &_t19);
					}
					Array_string generic_names =_t18;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types);
					} else {
						_option_v__ast__Type _t21;
						if (_t21 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t21.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t21.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t22 = 0; _t22 < method.params.len; ++_t22) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t22;
						_option_v__ast__Type _t23;
						if (_t23 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t23.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t23.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t24;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t24), sizeof(v__ast__Fn));
					 
					return _t24;
				}
				
				else {
				}
				
			}
		}
	}
	else if (t->info._typ == 485 /* v.ast.Interface */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Interface).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__Interface).parent_type);
			_option_v__ast__Fn _t25;
			if (_t25 = v__ast__TypeSymbol_find_method(parent_sym, name), _t25.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t25.data;
				if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t26 = {0};
					Array_v__ast__Type _t26_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t26_len = _t26_orig.len;
					_t26 = builtin____new_array(0, _t26_len, sizeof(string));

					for (int _t28 = 0; _t28 < _t26_len; ++_t28) {
						v__ast__Type it = ((v__ast__Type*) _t26_orig.data)[_t28];
						string _t27 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t26, &_t27);
					}
					Array_string generic_names =_t26;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types);
					} else {
						_option_v__ast__Type _t29;
						if (_t29 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t29.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t29.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t30 = 0; _t30 < method.params.len; ++_t30) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t30;
						_option_v__ast__Type _t31;
						if (_t31 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t31.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t31.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t32;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t32), sizeof(v__ast__Fn));
					 
					return _t32;
				}
				else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t33 = {0};
					Array_v__ast__Type _t33_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t33_len = _t33_orig.len;
					_t33 = builtin____new_array(0, _t33_len, sizeof(string));

					for (int _t35 = 0; _t35 < _t33_len; ++_t35) {
						v__ast__Type it = ((v__ast__Type*) _t33_orig.data)[_t35];
						string _t34 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t33, &_t34);
					}
					Array_string generic_names =_t33;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types);
					} else {
						_option_v__ast__Type _t36;
						if (_t36 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t36.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t36.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t37 = 0; _t37 < method.params.len; ++_t37) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t37;
						_option_v__ast__Type _t38;
						if (_t38 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t38.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t38.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t39;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t39), sizeof(v__ast__Fn));
					 
					return _t39;
				}
				else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t40 = {0};
					Array_v__ast__Type _t40_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t40_len = _t40_orig.len;
					_t40 = builtin____new_array(0, _t40_len, sizeof(string));

					for (int _t42 = 0; _t42 < _t40_len; ++_t42) {
						v__ast__Type it = ((v__ast__Type*) _t40_orig.data)[_t42];
						string _t41 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t40, &_t41);
					}
					Array_string generic_names =_t40;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types);
					} else {
						_option_v__ast__Type _t43;
						if (_t43 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t43.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t43.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t44 = 0; _t44 < method.params.len; ++_t44) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t44;
						_option_v__ast__Type _t45;
						if (_t45 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t45.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t45.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t46;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t46), sizeof(v__ast__Fn));
					 
					return _t46;
				}
				
				else {
				}
				
			}
		}
	}
	else if (t->info._typ == 486 /* v.ast.SumType */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__SumType).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(table, (*t->info._v__ast__SumType).parent_type);
			_option_v__ast__Fn _t47;
			if (_t47 = v__ast__TypeSymbol_find_method(parent_sym, name), _t47.state == 0) {
				v__ast__Fn x = *(v__ast__Fn*)_t47.data;
				if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
					v__ast__Fn method = x;
					Array_string _t48 = {0};
					Array_v__ast__Type _t48_orig = (*parent_sym->info._v__ast__Struct).generic_types;
					int _t48_len = _t48_orig.len;
					_t48 = builtin____new_array(0, _t48_len, sizeof(string));

					for (int _t50 = 0; _t50 < _t48_len; ++_t50) {
						v__ast__Type it = ((v__ast__Type*) _t48_orig.data)[_t50];
						string _t49 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t48, &_t49);
					}
					Array_string generic_names =_t48;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types);
					} else {
						_option_v__ast__Type _t51;
						if (_t51 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Struct).concrete_types), _t51.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t51.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t52 = 0; _t52 < method.params.len; ++_t52) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t52;
						_option_v__ast__Type _t53;
						if (_t53 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Struct).concrete_types), _t53.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t53.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t54;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t54), sizeof(v__ast__Fn));
					 
					return _t54;
				}
				else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
					v__ast__Fn method = x;
					Array_string _t55 = {0};
					Array_v__ast__Type _t55_orig = (*parent_sym->info._v__ast__Interface).generic_types;
					int _t55_len = _t55_orig.len;
					_t55 = builtin____new_array(0, _t55_len, sizeof(string));

					for (int _t57 = 0; _t57 < _t55_len; ++_t57) {
						v__ast__Type it = ((v__ast__Type*) _t55_orig.data)[_t57];
						string _t56 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t55, &_t56);
					}
					Array_string generic_names =_t55;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types);
					} else {
						_option_v__ast__Type _t58;
						if (_t58 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__Interface).concrete_types), _t58.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t58.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t59 = 0; _t59 < method.params.len; ++_t59) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t59;
						_option_v__ast__Type _t60;
						if (_t60 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__Interface).concrete_types), _t60.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t60.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t61;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t61), sizeof(v__ast__Fn));
					 
					return _t61;
				}
				else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
					v__ast__Fn method = x;
					Array_string _t62 = {0};
					Array_v__ast__Type _t62_orig = (*parent_sym->info._v__ast__SumType).generic_types;
					int _t62_len = _t62_orig.len;
					_t62 = builtin____new_array(0, _t62_len, sizeof(string));

					for (int _t64 = 0; _t64 < _t62_len; ++_t64) {
						v__ast__Type it = ((v__ast__Type*) _t62_orig.data)[_t64];
						string _t63 = v__ast__Table_sym(table, it)->name;
						builtin__array_push((array*)&_t62, &_t63);
					}
					Array_string generic_names =_t62;
					v__ast__TypeSymbol* return_sym = v__ast__Table_sym(table, method.return_type);
					if (return_sym->kind == v__ast__Kind__struct || return_sym->kind == v__ast__Kind__interface || return_sym->kind == v__ast__Kind__sum_type) {
						method.return_type = v__ast__Table_unwrap_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types);
					} else {
						_option_v__ast__Type _t65;
						if (_t65 = v__ast__Table_convert_generic_type(table, method.return_type, generic_names, (*t->info._v__ast__SumType).concrete_types), _t65.state == 0) {
							v__ast__Type rt = *(v__ast__Type*)_t65.data;
							method.return_type = rt;
						}
					}
					method.params = builtin__array_clone_to_depth(&method.params, 0);
					for (int _t66 = 0; _t66 < method.params.len; ++_t66) {
						v__ast__Param* param = ((v__ast__Param*)method.params.data) + _t66;
						_option_v__ast__Type _t67;
						if (_t67 = v__ast__Table_convert_generic_type(table, param->typ, generic_names, (*t->info._v__ast__SumType).concrete_types), _t67.state == 0) {
							v__ast__Type pt = *(v__ast__Type*)_t67.data;
							param->typ = pt;
						}
					}
					_option_v__ast__Fn _t68;
					builtin___option_ok(&(v__ast__Fn[]) { method }, (_option*)(&_t68), sizeof(v__ast__Fn));
					 
					return _t68;
				}
				
				else {
				}
				
			}
		}
	}
	
	else {
	}
	
	return (_option_v__ast__Fn){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__TypeSymbol_is_js_compatible(v__ast__TypeSymbol* t) {
	v__ast__Table* table = global_table;
	if (t->kind == v__ast__Kind__void) {
		return true;
	}
	if (t->kind == v__ast__Kind__function) {
		return true;
	}
	if (t->language == v__ast__Language__js || builtin__string_starts_with(t->name, _S("JS."))) {
		return true;
	}
	if (t->info._typ == 486 /* v.ast.SumType */) {
		for (int _t4 = 0; _t4 < (*t->info._v__ast__SumType).variants.len; ++_t4) {
			v__ast__Type variant = ((v__ast__Type*)(*t->info._v__ast__SumType).variants.data)[_t4];
			v__ast__TypeSymbol* sym = v__ast__Table_final_sym(table, variant);
			if (!v__ast__TypeSymbol_is_js_compatible(sym)) {
				return false;
			}
		}
		return true;
	}
	
	else {
		return true;
	}
	
	return 0;
}
multi_return_bool_bool_int v__ast__TypeSymbol_str_method_info(v__ast__TypeSymbol* t) {
	bool has_str_method = false;
	bool expects_ptr = false;
	int nr_args = 0;
	_option_v__ast__Fn _t1;
	if (_t1 = v__ast__TypeSymbol_find_method_with_generic_parent(t, _S("str")), _t1.state == 0) {
		v__ast__Fn sym_str_method = *(v__ast__Fn*)_t1.data;
		has_str_method = t->kind != v__ast__Kind__interface || !sym_str_method.no_body;
		nr_args = sym_str_method.params.len;
		if (nr_args > 0) {
			expects_ptr = v__ast__Type_is_ptr((*(v__ast__Param*)builtin__array_get(sym_str_method.params, 0)).typ);
		}
	} else {
		expects_ptr = v__ast__TypeSymbol_is_c_struct(t);
	}
	return (multi_return_bool_bool_int){.arg0=has_str_method, .arg1=expects_ptr, .arg2=nr_args};
}
_option_v__ast__StructField v__ast__TypeSymbol_find_field(v__ast__TypeSymbol* t, string name) {
	if (t->info._typ == 457 /* v.ast.Struct */) {
		return v__ast__Struct_find_field((*t->info._v__ast__Struct), name);
	}
	else if (t->info._typ == 485 /* v.ast.Interface */) {
		return v__ast__Interface_find_field(&(*t->info._v__ast__Interface), name);
	}
	else if (t->info._typ == 486 /* v.ast.SumType */) {
		return v__ast__SumType_find_sum_type_field(&(*t->info._v__ast__SumType), name);
	}
	else if (t->info._typ == 480 /* v.ast.Aggregate */) {
		return v__ast__Aggregate_find_field(&(*t->info._v__ast__Aggregate), name);
	}
	
	else {
		return (_option_v__ast__StructField){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	
	return (_option_v__ast__StructField){.state=2, .err=_const_none__, .data={E_STRUCT}};
}
bool v__ast__TypeSymbol_has_field(v__ast__TypeSymbol* t, string name) {
	_option_v__ast__StructField _t1 = v__ast__TypeSymbol_find_field(t, name);
	if (_t1.state != 0) {
		return false;
	}
	
 ;
	return true;
}
VV_LOC _option_v__ast__StructField v__ast__Aggregate_find_field(v__ast__Aggregate* a, string name) {
	Array_v__ast__StructField _t1 = a->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (field->name.len == name.len && builtin__string__eq(field->name, name)) {
			_option_v__ast__StructField _t3;
			builtin___option_ok(&(v__ast__StructField[]) { *field }, (_option*)(&_t3), sizeof(v__ast__StructField));
			 
			return _t3;
		}
	}
	return (_option_v__ast__StructField){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__StructField v__ast__Interface_find_field(v__ast__Interface* i, string name) {
	Array_v__ast__StructField _t1 = i->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (field->name.len == name.len && builtin__string__eq(field->name, name)) {
			_option_v__ast__StructField _t3;
			builtin___option_ok(&(v__ast__StructField[]) { *field }, (_option*)(&_t3), sizeof(v__ast__StructField));
			 
			return _t3;
		}
	}
	return (_option_v__ast__StructField){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
_option_v__ast__Fn v__ast__Interface_find_method(v__ast__Interface* i, string name) {
	Array_v__ast__Fn _t1 = i->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (method->name.len == name.len && builtin__string__eq(method->name, name)) {
			_option_v__ast__Fn _t3;
			builtin___option_ok(&(v__ast__Fn[]) { *method }, (_option*)(&_t3), sizeof(v__ast__Fn));
			 
			return _t3;
		}
	}
	return (_option_v__ast__Fn){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
bool v__ast__Interface_has_method(v__ast__Interface* i, string name) {
	Array_v__ast__Fn _t1 = i->methods;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__Fn* method = ((v__ast__Fn*)_t1.data) + _t2;
		if (method->name.len == name.len && builtin__string__eq(method->name, name)) {
			return true;
		}
	}
	return false;
}
_option_v__ast__StructField v__ast__Struct_find_field(v__ast__Struct s, string name) {
	Array_v__ast__StructField _t1 = s.fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (name.len == field->name.len && builtin__string__eq(field->name, name)) {
			_option_v__ast__StructField _t3;
			builtin___option_ok(&(v__ast__StructField[]) { *field }, (_option*)(&_t3), sizeof(v__ast__StructField));
			 
			return _t3;
		}
	}
	return (_option_v__ast__StructField){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
v__ast__StructField v__ast__Struct_get_field(v__ast__Struct s, string name) {
	_option_v__ast__StructField _t1;
	if (_t1 = v__ast__Struct_find_field(s, name), _t1.state == 0) {
		v__ast__StructField field = *(v__ast__StructField*)_t1.data;
		return field;
	}
	builtin___v_panic(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown field `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	return (v__ast__StructField){.anon_struct_decl = (v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.option_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,};
}
_option_v__ast__StructField v__ast__SumType_find_sum_type_field(v__ast__SumType* s, string name) {
	Array_v__ast__StructField _t1 = s->fields;
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		v__ast__StructField* field = ((v__ast__StructField*)_t1.data) + _t2;
		if (builtin__string__eq(field->name, name)) {
			_option_v__ast__StructField _t3;
			builtin___option_ok(&(v__ast__StructField[]) { *field }, (_option*)(&_t3), sizeof(v__ast__StructField));
			 
			return _t3;
		}
	}
	return (_option_v__ast__StructField){ .state=2, .err=_const_none__, .data={E_STRUCT} };
}
string v__ast__Table_find_missing_variants(v__ast__Table* t, v__ast__SumType* s, string field_name) {
	Array_string res = builtin____new_array_with_default(0, 5, sizeof(string), 0);
	for (int _t1 = 0; _t1 < s->variants.len; ++_t1) {
		v__ast__Type variant = ((v__ast__Type*)s->variants.data)[_t1];
		v__ast__TypeSymbol* ts = v__ast__Table_sym(t, variant);
		if (ts->kind != v__ast__Kind__struct) {
			continue;
		}
		bool found = false;
		v__ast__Struct struct_info = *(v__ast__Struct*)builtin____as_cast((ts->info)._v__ast__Struct,(ts->info)._typ, 457);
		for (int _t2 = 0; _t2 < struct_info.fields.len; ++_t2) {
			v__ast__StructField field = ((v__ast__StructField*)struct_info.fields.data)[_t2];
			if (builtin__string__eq(field.name, field_name)) {
				found = true;
				break;
			}
		}
		if (!found) {
			builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(ts->name) }));
		}
	}
	string str = Array_string_join(res, _S(", "));
	return builtin__string_replace(str, _S("'"), _S("`"));
}
bool v__ast__Interface_defines_method(v__ast__Interface i, string name) {
	bool _t1 = false;
	Array_v__ast__Fn _t1_orig = i.methods;
	int _t1_len = _t1_orig.len;
	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__Fn it = ((v__ast__Fn*) _t1_orig.data)[_t2];
		if (builtin__string__eq(it.name, name)) {
			_t1 = true;
			break;
		}
	}
	if (_t1) {
		return true;
	}
	if (v__ast__Type_has_flag(i.parent_type, v__ast__TypeFlag__generic)) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, i.parent_type);
		v__ast__Interface parent_info = *(v__ast__Interface*)builtin____as_cast((parent_sym->info)._v__ast__Interface,(parent_sym->info)._typ, 485);
		bool _t4 = false;
		Array_v__ast__Fn _t4_orig = parent_info.methods;
		int _t4_len = _t4_orig.len;
		for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
			v__ast__Fn it = ((v__ast__Fn*) _t4_orig.data)[_t5];
			if (builtin__string__eq(it.name, name)) {
				_t4 = true;
				break;
			}
		}
		if (_t4) {
			return true;
		}
	}
	return false;
}
Array_string v__ast__Interface_get_methods(v__ast__Interface i) {
	if (i.methods.len > 0) {
		Array_string _t2 = {0};
		Array_v__ast__Fn _t2_orig = i.methods;
		int _t2_len = _t2_orig.len;
		_t2 = builtin____new_array(0, _t2_len, sizeof(string));

		for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
			v__ast__Fn it = ((v__ast__Fn*) _t2_orig.data)[_t4];
			string _t3 = it.name;
			builtin__array_push((array*)&_t2, &_t3);
		}
		return _t2;
	}
	if (v__ast__Type_has_flag(i.parent_type, v__ast__TypeFlag__generic)) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, i.parent_type);
		v__ast__Interface parent_info = *(v__ast__Interface*)builtin____as_cast((parent_sym->info)._v__ast__Interface,(parent_sym->info)._typ, 485);
		Array_string _t6 = {0};
		Array_v__ast__Fn _t6_orig = parent_info.methods;
		int _t6_len = _t6_orig.len;
		_t6 = builtin____new_array(0, _t6_len, sizeof(string));

		for (int _t8 = 0; _t8 < _t6_len; ++_t8) {
			v__ast__Fn it = ((v__ast__Fn*) _t6_orig.data)[_t8];
			string _t7 = it.name;
			builtin__array_push((array*)&_t6, &_t7);
		}
		return _t6;
	}
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
Array_v__ast__Fn v__ast__TypeSymbol_get_methods(v__ast__TypeSymbol* t) {
	Array_v__ast__Fn _t1 = {0};
	Array_v__ast__Fn _t1_orig = t->methods;
	int _t1_len = _t1_orig.len;
	_t1 = builtin____new_array(0, _t1_len, sizeof(v__ast__Fn));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__Fn it = ((v__ast__Fn*) _t1_orig.data)[_t2];
		if (it.attrs.len == 0) {
			builtin__array_push((array*)&_t1, &it);
		}
	}
	Array_v__ast__Fn methods =_t1;
	Array_v__ast__Fn _t3 = {0};
	Array_v__ast__Fn _t3_orig = t->methods;
	int _t3_len = _t3_orig.len;
	_t3 = builtin____new_array(0, _t3_len, sizeof(v__ast__Fn));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		v__ast__Fn it = ((v__ast__Fn*) _t3_orig.data)[_t4];
		if (it.attrs.len > 0) {
			builtin__array_push((array*)&_t3, &it);
		}
	}
	Array_v__ast__Fn methods_with_attrs =_t3;
	if (t->info._typ == 457 /* v.ast.Struct */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Struct).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, (*t->info._v__ast__Struct).parent_type);
			if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t6 = {0};
					Array_v__ast__Fn _t6_orig = parent_methods;
					int _t6_len = _t6_orig.len;
					_t6 = builtin____new_array(0, _t6_len, sizeof(v__ast__Fn));

					for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
						v__ast__Fn it = ((v__ast__Fn*) _t6_orig.data)[_t7];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t6, &it);
						}
					}
					_PUSH_MANY(&methods, (_t6), _t5, Array_v__ast__Fn);
					Array_v__ast__Fn _t9 = {0};
					Array_v__ast__Fn _t9_orig = parent_methods;
					int _t9_len = _t9_orig.len;
					_t9 = builtin____new_array(0, _t9_len, sizeof(v__ast__Fn));

					for (int _t10 = 0; _t10 < _t9_len; ++_t10) {
						v__ast__Fn it = ((v__ast__Fn*) _t9_orig.data)[_t10];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t9, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t9), _t8, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t12 = {0};
					Array_v__ast__Fn _t12_orig = parent_methods;
					int _t12_len = _t12_orig.len;
					_t12 = builtin____new_array(0, _t12_len, sizeof(v__ast__Fn));

					for (int _t13 = 0; _t13 < _t12_len; ++_t13) {
						v__ast__Fn it = ((v__ast__Fn*) _t12_orig.data)[_t13];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t12, &it);
						}
					}
					_PUSH_MANY(&methods, (_t12), _t11, Array_v__ast__Fn);
					Array_v__ast__Fn _t15 = {0};
					Array_v__ast__Fn _t15_orig = parent_methods;
					int _t15_len = _t15_orig.len;
					_t15 = builtin____new_array(0, _t15_len, sizeof(v__ast__Fn));

					for (int _t16 = 0; _t16 < _t15_len; ++_t16) {
						v__ast__Fn it = ((v__ast__Fn*) _t15_orig.data)[_t16];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t15, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t15), _t14, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t18 = {0};
					Array_v__ast__Fn _t18_orig = parent_methods;
					int _t18_len = _t18_orig.len;
					_t18 = builtin____new_array(0, _t18_len, sizeof(v__ast__Fn));

					for (int _t19 = 0; _t19 < _t18_len; ++_t19) {
						v__ast__Fn it = ((v__ast__Fn*) _t18_orig.data)[_t19];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t18, &it);
						}
					}
					_PUSH_MANY(&methods, (_t18), _t17, Array_v__ast__Fn);
					Array_v__ast__Fn _t21 = {0};
					Array_v__ast__Fn _t21_orig = parent_methods;
					int _t21_len = _t21_orig.len;
					_t21 = builtin____new_array(0, _t21_len, sizeof(v__ast__Fn));

					for (int _t22 = 0; _t22 < _t21_len; ++_t22) {
						v__ast__Fn it = ((v__ast__Fn*) _t21_orig.data)[_t22];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t21, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t21), _t20, Array_v__ast__Fn);
				}
			}
			
			else {
			}
			
		}
	}
	else if (t->info._typ == 485 /* v.ast.Interface */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__Interface).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, (*t->info._v__ast__Interface).parent_type);
			if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t24 = {0};
					Array_v__ast__Fn _t24_orig = parent_methods;
					int _t24_len = _t24_orig.len;
					_t24 = builtin____new_array(0, _t24_len, sizeof(v__ast__Fn));

					for (int _t25 = 0; _t25 < _t24_len; ++_t25) {
						v__ast__Fn it = ((v__ast__Fn*) _t24_orig.data)[_t25];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t24, &it);
						}
					}
					_PUSH_MANY(&methods, (_t24), _t23, Array_v__ast__Fn);
					Array_v__ast__Fn _t27 = {0};
					Array_v__ast__Fn _t27_orig = parent_methods;
					int _t27_len = _t27_orig.len;
					_t27 = builtin____new_array(0, _t27_len, sizeof(v__ast__Fn));

					for (int _t28 = 0; _t28 < _t27_len; ++_t28) {
						v__ast__Fn it = ((v__ast__Fn*) _t27_orig.data)[_t28];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t27, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t27), _t26, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t30 = {0};
					Array_v__ast__Fn _t30_orig = parent_methods;
					int _t30_len = _t30_orig.len;
					_t30 = builtin____new_array(0, _t30_len, sizeof(v__ast__Fn));

					for (int _t31 = 0; _t31 < _t30_len; ++_t31) {
						v__ast__Fn it = ((v__ast__Fn*) _t30_orig.data)[_t31];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t30, &it);
						}
					}
					_PUSH_MANY(&methods, (_t30), _t29, Array_v__ast__Fn);
					Array_v__ast__Fn _t33 = {0};
					Array_v__ast__Fn _t33_orig = parent_methods;
					int _t33_len = _t33_orig.len;
					_t33 = builtin____new_array(0, _t33_len, sizeof(v__ast__Fn));

					for (int _t34 = 0; _t34 < _t33_len; ++_t34) {
						v__ast__Fn it = ((v__ast__Fn*) _t33_orig.data)[_t34];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t33, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t33), _t32, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t36 = {0};
					Array_v__ast__Fn _t36_orig = parent_methods;
					int _t36_len = _t36_orig.len;
					_t36 = builtin____new_array(0, _t36_len, sizeof(v__ast__Fn));

					for (int _t37 = 0; _t37 < _t36_len; ++_t37) {
						v__ast__Fn it = ((v__ast__Fn*) _t36_orig.data)[_t37];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t36, &it);
						}
					}
					_PUSH_MANY(&methods, (_t36), _t35, Array_v__ast__Fn);
					Array_v__ast__Fn _t39 = {0};
					Array_v__ast__Fn _t39_orig = parent_methods;
					int _t39_len = _t39_orig.len;
					_t39 = builtin____new_array(0, _t39_len, sizeof(v__ast__Fn));

					for (int _t40 = 0; _t40 < _t39_len; ++_t40) {
						v__ast__Fn it = ((v__ast__Fn*) _t39_orig.data)[_t40];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t39, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t39), _t38, Array_v__ast__Fn);
				}
			}
			
			else {
			}
			
		}
	}
	else if (t->info._typ == 486 /* v.ast.SumType */) {
		if (v__ast__Type_has_flag((*t->info._v__ast__SumType).parent_type, v__ast__TypeFlag__generic)) {
			v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(global_table, (*t->info._v__ast__SumType).parent_type);
			if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t42 = {0};
					Array_v__ast__Fn _t42_orig = parent_methods;
					int _t42_len = _t42_orig.len;
					_t42 = builtin____new_array(0, _t42_len, sizeof(v__ast__Fn));

					for (int _t43 = 0; _t43 < _t42_len; ++_t43) {
						v__ast__Fn it = ((v__ast__Fn*) _t42_orig.data)[_t43];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t42, &it);
						}
					}
					_PUSH_MANY(&methods, (_t42), _t41, Array_v__ast__Fn);
					Array_v__ast__Fn _t45 = {0};
					Array_v__ast__Fn _t45_orig = parent_methods;
					int _t45_len = _t45_orig.len;
					_t45 = builtin____new_array(0, _t45_len, sizeof(v__ast__Fn));

					for (int _t46 = 0; _t46 < _t45_len; ++_t46) {
						v__ast__Fn it = ((v__ast__Fn*) _t45_orig.data)[_t46];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t45, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t45), _t44, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t48 = {0};
					Array_v__ast__Fn _t48_orig = parent_methods;
					int _t48_len = _t48_orig.len;
					_t48 = builtin____new_array(0, _t48_len, sizeof(v__ast__Fn));

					for (int _t49 = 0; _t49 < _t48_len; ++_t49) {
						v__ast__Fn it = ((v__ast__Fn*) _t48_orig.data)[_t49];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t48, &it);
						}
					}
					_PUSH_MANY(&methods, (_t48), _t47, Array_v__ast__Fn);
					Array_v__ast__Fn _t51 = {0};
					Array_v__ast__Fn _t51_orig = parent_methods;
					int _t51_len = _t51_orig.len;
					_t51 = builtin____new_array(0, _t51_len, sizeof(v__ast__Fn));

					for (int _t52 = 0; _t52 < _t51_len; ++_t52) {
						v__ast__Fn it = ((v__ast__Fn*) _t51_orig.data)[_t52];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t51, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t51), _t50, Array_v__ast__Fn);
				}
			}
			else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
				Array_v__ast__Fn parent_methods = parent_sym->methods;
				if (parent_methods.len > 0) {
					Array_v__ast__Fn _t54 = {0};
					Array_v__ast__Fn _t54_orig = parent_methods;
					int _t54_len = _t54_orig.len;
					_t54 = builtin____new_array(0, _t54_len, sizeof(v__ast__Fn));

					for (int _t55 = 0; _t55 < _t54_len; ++_t55) {
						v__ast__Fn it = ((v__ast__Fn*) _t54_orig.data)[_t55];
						if (it.attrs.len == 0) {
							builtin__array_push((array*)&_t54, &it);
						}
					}
					_PUSH_MANY(&methods, (_t54), _t53, Array_v__ast__Fn);
					Array_v__ast__Fn _t57 = {0};
					Array_v__ast__Fn _t57_orig = parent_methods;
					int _t57_len = _t57_orig.len;
					_t57 = builtin____new_array(0, _t57_len, sizeof(v__ast__Fn));

					for (int _t58 = 0; _t58 < _t57_len; ++_t58) {
						v__ast__Fn it = ((v__ast__Fn*) _t57_orig.data)[_t58];
						if (it.attrs.len > 0) {
							builtin__array_push((array*)&_t57, &it);
						}
					}
					_PUSH_MANY(&methods_with_attrs, (_t57), _t56, Array_v__ast__Fn);
				}
			}
			
			else {
			}
			
		}
	}
	
	else {
	}
	
	_PUSH_MANY(&methods, (methods_with_attrs), _t59, Array_v__ast__Fn);
	return methods;
}
VV_LOC _v_Array_fixed_bool_256 v__scanner__get_digit_table(void) {
	Array_fixed_bool_256 res = {0};
	for (int c = 0; c < 256; ++c) {
		res[c] = builtin__u8_is_digit(((u8)(c)));
	}
	_v_Array_fixed_bool_256 _t1 = {0};
	memcpy(_t1.ret_arr, res, sizeof(Array_fixed_bool_256));
	return _t1;
}
VV_LOC _v_Array_fixed_bool_256 v__scanner__get_letter_table(void) {
	Array_fixed_bool_256 res = {0};
	for (int c = 0; c < 256; ++c) {
		res[c] = builtin__u8_is_letter(((u8)(c)));
	}
	_v_Array_fixed_bool_256 _t1 = {0};
	memcpy(_t1.ret_arr, res, sizeof(Array_fixed_bool_256));
	return _t1;
}
_result_v__scanner__Scanner_ptr v__scanner__new_scanner_file(string file_path, i16 file_idx, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_) {
	if (!os__is_file(file_path)) {
		return (_result_v__scanner__Scanner_ptr){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = file_path}}, {_S(" is not a .v file"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	_result_string _t2 = v__util__read_file(file_path);
	if (_t2.is_error) {
		IError err = _t2.err;
		return (_result_v__scanner__Scanner_ptr){ .is_error=true, .err=err, .data={E_STRUCT} };
	}
	
 	string raw_text = (*(string*)_t2.data);
	v__scanner__Scanner* s = ((v__scanner__Scanner*)builtin__memdup(&(v__scanner__Scanner){.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),
		.str_segments = builtin____new_array_with_default(0, 10, sizeof(string), 0),
		.error_details = builtin____new_array(0, 0, sizeof(string)),
		.all_tokens = builtin____new_array_with_default(0, (int)(raw_text.len / 3), sizeof(v__token__Token), 0),
		.h_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.u32_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.u16_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.all_pos = builtin____new_array_with_default(0, 30, sizeof(int), 0),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),
		.str_helper_tokens = builtin____new_array_with_default(0, 16, sizeof(u8), 0),
		.file_path = file_path,
		.file_base = os__base(file_path),
		.text = raw_text,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref_,
		.pos = -1,
		.line_nr = 0,
		.nr_lines = 0,
		.last_nl_pos = -1,
		.last_lt = -1,
		.max_eofs = 50,
		.eofs = 0,
		.tidx = 0,
		.file_idx = file_idx,
		.quote = 0,
		.comments_mode = comments_mode,
		.is_inter_end = 0,
		.is_inter_start = 0,
		.is_nested_string = 0,
		.should_abort = 0,
		.is_inside_string = 0,
		.is_fmt = pref_->is_fmt,
		.is_print_rel_paths_on_error = true,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_inside_toplvl_statement = 0,
	}, sizeof(v__scanner__Scanner)));
	v__scanner__Scanner_scan_all_tokens_in_buffer(s);
	_result_v__scanner__Scanner_ptr _t4;
	builtin___result_ok(&(v__scanner__Scanner*[]) { s }, (_result*)(&_t4), sizeof(v__scanner__Scanner*));
	 
	return _t4;
}
v__scanner__Scanner* v__scanner__new_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_) {
	v__scanner__Scanner* s = v__scanner__new_plain_scanner(text, comments_mode, pref_);
	v__scanner__Scanner_scan_all_tokens_in_buffer(s);
	return s;
}
VV_LOC v__scanner__Scanner* v__scanner__new_plain_scanner(string text, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_) {
	return ((v__scanner__Scanner*)builtin__memdup(&(v__scanner__Scanner){.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),
		.str_segments = builtin____new_array_with_default(0, 10, sizeof(string), 0),
		.error_details = builtin____new_array(0, 0, sizeof(string)),
		.all_tokens = builtin____new_array_with_default(0, (int)(text.len / 3), sizeof(v__token__Token), 0),
		.h_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.u32_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.u16_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),
		.all_pos = builtin____new_array_with_default(0, 30, sizeof(int), 0),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),
		.str_helper_tokens = builtin____new_array_with_default(0, 16, sizeof(u8), 0),
		.file_path = _const_v__scanner__internally_generated_v_code,
		.file_base = _const_v__scanner__internally_generated_v_code,
		.text = text,
		.line_comment = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref_,
		.pos = -1,
		.line_nr = 0,
		.nr_lines = 0,
		.last_nl_pos = -1,
		.last_lt = -1,
		.max_eofs = 50,
		.eofs = 0,
		.tidx = 0,
		.file_idx = -1,
		.quote = 0,
		.comments_mode = comments_mode,
		.is_inter_end = 0,
		.is_inter_start = 0,
		.is_nested_string = 0,
		.should_abort = 0,
		.is_inside_string = 0,
		.is_fmt = pref_->is_fmt,
		.is_print_rel_paths_on_error = true,
		.is_print_line_on_error = true,
		.is_print_colored_error = true,
		.is_inside_toplvl_statement = 0,
	}, sizeof(v__scanner__Scanner)));
}
void v__scanner__Scanner_free(v__scanner__Scanner* s) {
	builtin__array_free(&s->all_tokens);
}
inline VV_LOC bool v__scanner__Scanner_should_parse_comment(v__scanner__Scanner* s) {
	return s->comments_mode == v__scanner__CommentsMode__parse_comments || (s->comments_mode == v__scanner__CommentsMode__toplevel_comments && !s->is_inside_toplvl_statement);
}
void v__scanner__Scanner_set_is_inside_toplevel_statement(v__scanner__Scanner* s, bool newstate) {
	s->is_inside_toplvl_statement = newstate;
}
void v__scanner__Scanner_set_current_tidx(v__scanner__Scanner* s, int cidx) {
	int tidx = (cidx < 0 ? (0) : (cidx));
	tidx = (tidx > s->all_tokens.len ? (s->all_tokens.len) : (tidx));
	s->tidx = tidx;
}
inline VV_LOC v__token__Token v__scanner__Scanner_new_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len) {
	int cidx = s->tidx;
	s->tidx++;
	int line_offset = (tok_kind == v__token__Kind__hash ? (0) : (1));
	int max_column = (int)((int)(v__scanner__Scanner_current_column(s) - len) + 1);
	if (max_column < 1) {
		max_column = 1;
	}
	return ((v__token__Token){
		.lit = lit,
		.pos = (int)((int)(s->pos - len) + 1),
		.len = len,
		.line_nr = (int)(s->line_nr + line_offset),
		.tidx = cidx,
		.file_idx = s->file_idx,
		.col = ((u16)(max_column)),
		.kind = tok_kind,
	});
}
inline VV_LOC v__token__Token v__scanner__Scanner_new_eof_token(v__scanner__Scanner* s) {
	return ((v__token__Token){
		.lit = _S(""),
		.pos = s->pos,
		.len = 1,
		.line_nr = (int)(s->line_nr + 1),
		.tidx = s->tidx,
		.file_idx = s->file_idx,
		.col = ((u16)(v__scanner__Scanner_current_column(s))),
		.kind = v__token__Kind__eof,
	});
}
inline VV_LOC v__token__Token v__scanner__Scanner_new_multiline_token(v__scanner__Scanner* s, v__token__Kind tok_kind, string lit, int len, int start_line) {
	int cidx = s->tidx;
	s->tidx++;
	int max_column = (int)((int)(v__scanner__Scanner_current_column(s) - len) + 1);
	if (max_column < 1) {
		max_column = 1;
	}
	return ((v__token__Token){
		.lit = lit,
		.pos = (int)((int)(s->pos - len) + 1),
		.len = len,
		.line_nr = (int)(start_line + 1),
		.tidx = cidx,
		.file_idx = s->file_idx,
		.col = ((u16)(max_column)),
		.kind = tok_kind,
	});
}
inline VV_LOC string v__scanner__Scanner_ident_name(v__scanner__Scanner* s) {
	int start = s->pos;
	s->pos++;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (_const_v__util__func_char_table[c]) {
			s->pos++;
			continue;
		}
		break;
	}
	string name = builtin__string_substr(s->text, start, s->pos);
	s->pos--;
	return name;
}
VV_LOC string v__scanner__Scanner_num_lit(v__scanner__Scanner* s, int start, int end) {
	if (s->is_fmt) {
		return builtin__string_substr(s->text, start, end);
	}
	{ // Unsafe block
		u8* txt = s->text.str;
		u8* b = builtin__malloc_noscan((int)((int)(end - start) + 1));
		int i_no_sep = 0;
		for (int i = start; i < end; ++i) {
			if (txt[i] != _const_v__scanner__num_sep) {
				b[i_no_sep] = txt[i];
				i_no_sep++;
			}
		}
		b[i_no_sep] = 0;
		return builtin__u8_vstring_with_len(b, i_no_sep);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
VV_LOC string v__scanner__Scanner_ident_bin_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && s->text.str[ s->pos] == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _S("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _S("cannot use `_` consecutively"));
		}
		if (!builtin__u8_is_bin_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!_const_v__scanner__digit_table[c] && !_const_v__scanner__letter_table[c]) || s->is_inside_string || s->is_nested_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("cannot use `_` at the end of a numeric literal"));
	} else if ((int)(start_pos + 2) == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("number part of this binary is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("this binary number has unsuitable digit `"), 0xfe10, {.d_s = builtin__rune_str(first_wrong_digit)}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	return number;
}
VV_LOC string v__scanner__Scanner_ident_hex_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	if ((int)(s->pos + 2) >= s->text.len) {
		return _S("0x");
	}
	s->pos += 2;
	if (s->pos < s->text.len && s->text.str[ s->pos] == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _S("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _S("cannot use `_` consecutively"));
		}
		if (!builtin__u8_is_hex_digit(c) && c != _const_v__scanner__num_sep) {
			if (!_const_v__scanner__letter_table[c] || s->is_inside_string || s->is_nested_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("cannot use `_` at the end of a numeric literal"));
	} else if ((int)(start_pos + 2) == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("number part of this hexadecimal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("this hexadecimal number has unsuitable digit `"), 0xfe10, {.d_s = builtin__rune_str(first_wrong_digit)}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	return number;
}
VV_LOC string v__scanner__Scanner_ident_oct_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	s->pos += 2;
	if (s->pos < s->text.len && s->text.str[ s->pos] == _const_v__scanner__num_sep) {
		v__scanner__Scanner_error(s, _S("separator `_` is only valid between digits in a numeric literal"));
	}
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _S("cannot use `_` consecutively"));
		}
		if (!builtin__u8_is_oct_digit(c) && c != _const_v__scanner__num_sep) {
			if ((!_const_v__scanner__digit_table[c] && !_const_v__scanner__letter_table[c]) || s->is_inside_string || s->is_nested_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("cannot use `_` at the end of a numeric literal"));
	} else if ((int)(start_pos + 2) == s->pos) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("number part of this octal is not provided"));
	} else if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("this octal number has unsuitable digit `"), 0xfe10, {.d_s = builtin__rune_str(first_wrong_digit)}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	return number;
}
VV_LOC string v__scanner__Scanner_ident_dec_number(v__scanner__Scanner* s) {
	bool has_wrong_digit = false;
	int first_wrong_digit_pos = 0;
	rune first_wrong_digit = '\0';
	int start_pos = s->pos;
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (c == _const_v__scanner__num_sep && s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
			v__scanner__Scanner_error(s, _S("cannot use `_` consecutively"));
		}
		if (!_const_v__scanner__digit_table[c] && c != _const_v__scanner__num_sep) {
			if (!_const_v__scanner__letter_table[c] || (c == 'e' || c == 'E') || s->is_inside_string || s->is_nested_string) {
				break;
			} else if (!has_wrong_digit) {
				has_wrong_digit = true;
				first_wrong_digit_pos = s->pos;
				first_wrong_digit = c;
			}
		}
		s->pos++;
	}
	if (s->text.str[ (int)(s->pos - 1)] == _const_v__scanner__num_sep) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("cannot use `_` at the end of a numeric literal"));
	}
	bool call_method = false;
	bool is_range = false;
	if (s->pos < s->text.len && s->text.str[ s->pos] == '.') {
		s->pos++;
		if (s->pos < s->text.len) {
			if (_const_v__scanner__digit_table[s->text.str[ s->pos]]) {
				for (;;) {
					if (!(s->pos < s->text.len)) break;
					u8 c = s->text.str[ s->pos];
					if (!_const_v__scanner__digit_table[c]) {
						if (!_const_v__scanner__letter_table[c] || (c == 'e' || c == 'E') || s->is_inside_string || s->is_nested_string) {
							if (c == '.' && (int)(s->pos + 1) < s->text.len && _const_v__scanner__letter_table[s->text.str[ (int)(s->pos + 1)]]) {
								call_method = true;
							}
							break;
						} else if (!has_wrong_digit) {
							has_wrong_digit = true;
							first_wrong_digit_pos = s->pos;
							first_wrong_digit = c;
						}
					}
					s->pos++;
				}
			} else if (s->text.str[ s->pos] == '.') {
				is_range = true;
				s->pos--;
			} else if (s->text.str[ s->pos] == 'e' || s->text.str[ s->pos] == 'E') {
			} else if (_const_v__scanner__letter_table[s->text.str[ s->pos]]) {
				call_method = true;
				s->pos--;
			} else {
				int symbol_length = 0;
				for (int i = (int)(s->pos - 2); i > 0 && _const_v__scanner__digit_table[s->text.str[ (int)(i - 1)]]; i--) {
					symbol_length++;
				}
				string float_symbol = builtin__string_substr(s->text, (int)((int)(s->pos - 2) - symbol_length), (int)(s->pos - 1));
				v__scanner__Scanner_warn(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("float literals should have a digit after the decimal point, e.g. `"), 0xfe10, {.d_s = float_symbol}}, {_S(".0`"), 0, { .d_c = 0 }}})));
			}
		}
	}
	bool has_exp = false;
	if (s->pos < s->text.len && (s->text.str[ s->pos] == 'e' || s->text.str[ s->pos] == 'E') && !s->is_inside_string) {
		has_exp = true;
		s->pos++;
		if (s->pos < s->text.len && (s->text.str[ s->pos] == '-' || s->text.str[ s->pos] == '+')) {
			s->pos++;
		}
		for (;;) {
			if (!(s->pos < s->text.len)) break;
			u8 c = s->text.str[ s->pos];
			if (!_const_v__scanner__digit_table[c]) {
				if (!_const_v__scanner__letter_table[c] || s->is_inside_string || s->is_nested_string) {
					if (c == '.' && (int)(s->pos + 1) < s->text.len && _const_v__scanner__letter_table[s->text.str[ (int)(s->pos + 1)]]) {
						call_method = true;
					}
					break;
				} else if (!has_wrong_digit) {
					has_wrong_digit = true;
					first_wrong_digit_pos = s->pos;
					first_wrong_digit = c;
				}
			}
			s->pos++;
		}
	}
	if (has_wrong_digit) {
		s->pos = first_wrong_digit_pos;
		if (!s->pref->translated) {
			v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("this number has unsuitable digit `"), 0xfe10, {.d_s = builtin__rune_str(first_wrong_digit)}}, {_S("`"), 0, { .d_c = 0 }}})));
		}
	} else if ((s->text.str[ (int)(s->pos - 1)] == 'e' || s->text.str[ (int)(s->pos - 1)] == 'E') && !s->is_inside_string) {
		s->pos--;
		v__scanner__Scanner_error(s, _S("exponent has no digits"));
	} else if (s->pos < s->text.len && s->text.str[ s->pos] == '.' && !is_range && !call_method) {
		if (has_exp) {
			v__scanner__Scanner_error(s, _S("exponential part should be integer"));
		} else {
			v__scanner__Scanner_error(s, _S("too many decimal points in number"));
		}
	}
	string number = v__scanner__Scanner_num_lit(s, start_pos, s->pos);
	s->pos--;
	return number;
}
VV_LOC string v__scanner__Scanner_ident_number(v__scanner__Scanner* s) {
	if (v__scanner__Scanner_expect(s, _S("0b"), s->pos)) {
		return v__scanner__Scanner_ident_bin_number(s);
	} else if (v__scanner__Scanner_expect(s, _S("0x"), s->pos)) {
		return v__scanner__Scanner_ident_hex_number(s);
	} else if (v__scanner__Scanner_expect(s, _S("0o"), s->pos)) {
		return v__scanner__Scanner_ident_oct_number(s);
	} else {
		return v__scanner__Scanner_ident_dec_number(s);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}
inline VV_LOC void v__scanner__Scanner_skip_whitespace(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len)) break;
		u8 c = s->text.str[ s->pos];
		if (c == 9 || c == 32) {
			s->pos++;
			continue;
		}
		if (c == 10) {
			v__scanner__Scanner_inc_line_number(s);
			s->pos++;
			continue;
		}
		if (_const_v__util__non_whitespace_table[c]) {
			return;
		}
		s->pos++;
	}
}
VV_LOC v__token__Token v__scanner__Scanner_end_of_file(v__scanner__Scanner* s) {
	s->eofs++;
	if (s->eofs > s->max_eofs) {
		s->line_nr--;
		if (builtin__fast_string_eq(s->file_path, _S("internally_generated_v_code"))) {
			builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("> internally_generated_v_code, start: "), 0xfe10, {.d_s = builtin__string_substr_ni(s->text, 0, 50)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("> internally_generated_v_code,   end: "), 0xfe10, {.d_s = builtin__string_substr_ni(s->text, -50, 2147483647)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("> internally_generated_v_code,   len: "), 0xfe07, {.d_i32 = s->text.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		builtin___v_panic(builtin__string__plus(builtin__string__plus(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("the end of file `"), 0xfe10, {.d_s = s->file_path}}, {_S("` has been reached "), 0xfe07, {.d_i32 = s->max_eofs}}, {_S(" times already, the v parser is probably stuck.\n"), 0, { .d_c = 0 }}})), _S("This should not happen. Please report the bug here, and include the last 2-3 lines of your source code:\n")), _S("https://github.com/vlang/v/issues/new?labels=Bug&template=bug_report.md")));
		VUNREACHABLE();
	}
	if (s->pos != s->text.len && s->eofs == 1) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->pos = s->text.len;
	return v__scanner__Scanner_new_eof_token(s);
}
VV_LOC void v__scanner__Scanner_scan_all_tokens_in_buffer(v__scanner__Scanner* s) {
	v__util__Timers* timers = v__util__get_timers();
	v__util__Timers_measure_pause(timers, _S("PARSE"));
	v__util__timing_start(_S("SCAN"));
	v__scanner__Scanner_scan_remaining_text(s);
	s->tidx = 0;
	{ // defer begin
		v__util__timing_measure_cumulative(_S("SCAN"));
		v__util__Timers_measure_resume(timers, _S("PARSE"));
	} // defer end
}
VV_LOC void v__scanner__Scanner_scan_remaining_text(v__scanner__Scanner* s) {
	bool is_skip_comments = s->comments_mode == v__scanner__CommentsMode__skip_comments;
	for (;;) {
		v__token__Token t = v__scanner__Scanner_text_scan(s);
		if (!(is_skip_comments && t.kind == v__token__Kind__comment)) {
			builtin__array_push((array*)&s->all_tokens, _MOV((v__token__Token[]){ t }));
			if (t.kind == v__token__Kind__eof || s->should_abort) {
				break;
			}
		}
	}
}
v__token__Token v__scanner__Scanner_scan(v__scanner__Scanner* s) {
	for (;;) {
		int cidx = s->tidx;
		s->tidx++;
		if (cidx >= s->all_tokens.len || s->should_abort) {
			return v__scanner__Scanner_end_of_file(s);
		}
		if (((v__token__Token*)s->all_tokens.data)[cidx].kind == v__token__Kind__comment && !v__scanner__Scanner_should_parse_comment(s)) {
			continue;
		}
		return ((v__token__Token*)s->all_tokens.data)[cidx];
	}
	return v__scanner__Scanner_new_eof_token(s);
}
inline v__token__Token v__scanner__Scanner_peek_token(v__scanner__Scanner* s, int n) {
	int idx = (int)(s->tidx + n);
	if (idx >= s->all_tokens.len || idx < 0) {
		return v__scanner__Scanner_new_eof_token(s);
	}
	v__token__Token t = ((v__token__Token*)s->all_tokens.data)[idx];
	return t;
}
inline VV_LOC u8 v__scanner__Scanner_look_ahead(v__scanner__Scanner* s, int n) {
	if ((int)(s->pos + n) < s->text.len) {
		return s->text.str[ (int)(s->pos + n)];
	} else {
		return '\0';
	}
	return 0;
}
v__token__Token v__scanner__Scanner_text_scan(v__scanner__Scanner* s) {
	for (;;) {
		s->pos++;
		if (!s->is_inside_string) {
			v__scanner__Scanner_skip_whitespace(s);
		}
		if (s->pos >= s->text.len || s->should_abort) {
			return v__scanner__Scanner_end_of_file(s);
		}
		if (s->is_inter_end) {
			if (s->text.str[ s->pos] == s->quote) {
				s->is_inter_end = false;
				builtin__array_delete_last(&s->str_helper_tokens);
				return v__scanner__Scanner_new_token(s, v__token__Kind__string, _S(""), 1);
			}
			s->is_inter_end = false;
			string ident_string = v__scanner__Scanner_ident_string(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind__string, ident_string, (int)(ident_string.len + 2));
		}
		v__scanner__Scanner_skip_whitespace(s);
		if (s->pos >= s->text.len) {
			return v__scanner__Scanner_end_of_file(s);
		}
		u8 c = s->text.str[ s->pos];
		u8 nextc = v__scanner__Scanner_look_ahead(s, 1);
		if (_const_v__util__name_char_table[c]) {
			string name = v__scanner__Scanner_ident_name(s);
			u8 next_char = v__scanner__Scanner_look_ahead(s, 1);
			int kind = v__token__KeywordsMatcherTrie_find(&_const_v__token__scanner_matcher, name);
			if (kind != -1 && !(s->is_inter_start && next_char == s->quote)) {
				return v__scanner__Scanner_new_token(s, ((v__token__Kind)(kind)), name, name.len);
			}
			if (s->is_inside_string) {
				if (next_char == s->quote) {
					s->is_inter_end = true;
					s->is_inter_start = false;
					s->is_inside_string = false;
				}
			}
			if (s->is_inter_start && next_char == '\\' && !(Array_rune_contains(builtin__new_array_from_c_array(8, 8, sizeof(rune), _MOV((rune[8]){'x', 'n', 'r', '\\', 't', 'e', '"', '\''})), v__scanner__Scanner_look_ahead(s, 2)))) {
				v__scanner__Scanner_warn(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown escape sequence \\"), 0xfe02, {.d_u8 = v__scanner__Scanner_look_ahead(s, 2)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
			if (s->is_inter_start && next_char == '(') {
				if (v__scanner__Scanner_look_ahead(s, 2) != ')') {
					v__scanner__Scanner_warn(s, _S("use `${f(expr)}` instead of `$f(expr)`"));
				}
			} else if (s->is_inter_start && next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__name, name, name.len);
		} else if (_const_v__scanner__digit_table[c] || (c == '.' && _const_v__scanner__digit_table[nextc])) {
			if (!s->is_inside_string) {
				int start_pos = s->pos;
				for (;;) {
					if (!(start_pos < s->text.len && s->text.str[ start_pos] == '0')) break;
					start_pos++;
				}
				int prefix_zero_num = (int)(start_pos - s->pos);
				if (start_pos == s->text.len || (c == '0' && !_const_v__scanner__digit_table[s->text.str[ start_pos]])) {
					prefix_zero_num--;
				}
				s->pos += prefix_zero_num;
			}
			string num = v__scanner__Scanner_ident_number(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind__number, num, num.len);
		}
		if (c == ')' && s->is_inter_start) {
			u8 next_char = v__scanner__Scanner_look_ahead(s, 1);
			if (next_char != '.') {
				s->is_inter_end = true;
				s->is_inter_start = false;
				if (next_char == s->quote) {
					s->is_inside_string = false;
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind__rpar, _S(""), 1);
			}
		}

		if (c == ('+')) {
			if (nextc == '+') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__inc, _S(""), 2);
			} else if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__plus_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__plus, _S(""), 1);
		}
		else if (c == ('-')) {
			if (nextc == '-') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__dec, _S(""), 2);
			} else if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__minus_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__minus, _S(""), 1);
		}
		else if (c == ('*')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__mult_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__mul, _S(""), 1);
		}
		else if (c == ('^')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__xor_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__xor, _S(""), 1);
		}
		else if (c == ('%')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__mod_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__mod, _S(""), 1);
		}
		else if (c == ('?')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__question, _S("?"), 1);
		}
		else if (c == (_const_v__scanner__single_quote) || c == (_const_v__scanner__double_quote)) {
			builtin__array_push((array*)&s->str_helper_tokens, _MOV((u8[]){ c }));
			int start_line = s->line_nr;
			string ident_string = v__scanner__Scanner_ident_string(s);
			return v__scanner__Scanner_new_multiline_token(s, v__token__Kind__string, ident_string, (int)(ident_string.len + 2), start_line);
		}
		else if (c == ('`')) {
			string ident_char = v__scanner__Scanner_ident_char(s);
			return v__scanner__Scanner_new_token(s, v__token__Kind__chartoken, ident_char, (int)(ident_char.len + 2));
		}
		else if (c == ('(')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__lpar, _S(""), 1);
		}
		else if (c == (')')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__rpar, _S(""), 1);
		}
		else if (c == ('[')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__lsbr, _S(""), 1);
		}
		else if (c == (']')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__rsbr, _S(""), 1);
		}
		else if (c == ('{')) {
			if (s->str_helper_tokens.len > 0) {
				if (255 != v__scanner__Scanner_str_quote(*s)) {
					builtin__array_push((array*)&s->str_helper_tokens, _MOV((u8[]){ 0 }));
				} else {
					builtin__array_push((array*)&s->str_helper_tokens, _MOV((u8[]){ c }));
				}
			}
			if (s->is_inside_string && s->text.str[ (int)(s->pos - 1)] == '$') {
				continue;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__lcbr, _S(""), 1);
		}
		else if (c == ('$')) {
			if (s->is_inside_string) {
				return v__scanner__Scanner_new_token(s, v__token__Kind__str_dollar, _S(""), 1);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind__dollar, _S(""), 1);
			}
		}
		else if (c == ('}')) {
			if (s->str_helper_tokens.len > 0) {
				builtin__array_delete_last(&s->str_helper_tokens);
				u8 quote = v__scanner__Scanner_str_quote(*s);
				if (255 != quote) {
					if (s->pos < (int)(s->text.len - 1)) {
						s->pos++;
					} else {
						v__scanner__Scanner_error(s, _S("unfinished string literal"));
					}
					if (s->text.str[ s->pos] == quote) {
						s->is_inside_string = false;
						builtin__array_delete_last(&s->str_helper_tokens);
						return v__scanner__Scanner_new_token(s, v__token__Kind__string, _S(""), 1);
					}
					string ident_string = v__scanner__Scanner_ident_string(s);
					return v__scanner__Scanner_new_token(s, v__token__Kind__string, ident_string, (int)(ident_string.len + 2));
				}
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__rcbr, _S(""), 1);
		}
		else if (c == ('&')) {
			if (nextc == '&') {
				if (v__scanner__Scanner_look_ahead(s, 2) == '=') {
					s->pos += 2;
					return v__scanner__Scanner_new_token(s, v__token__Kind__boolean_and_assign, _S(""), 3);
				}
			}
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__and_assign, _S(""), 2);
			}
			u8 afternextc = v__scanner__Scanner_look_ahead(s, 2);
			if (nextc == '&' && (builtin__u8_is_space(afternextc) || afternextc == '!')) {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__and, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__amp, _S(""), 1);
		}
		else if (c == ('|')) {
			if (nextc == '|') {
				if (v__scanner__Scanner_look_ahead(s, 2) == '=') {
					s->pos += 2;
					return v__scanner__Scanner_new_token(s, v__token__Kind__boolean_or_assign, _S(""), 3);
				}
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__logical_or, _S(""), 2);
			}
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__or_assign, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__pipe, _S(""), 1);
		}
		else if (c == (',')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__comma, _S(""), 1);
		}
		else if (c == ('@')) {
			if (s->text.str[ (int)(s->pos + 1)] == '[') {
				return v__scanner__Scanner_new_token(s, v__token__Kind__at, _S(""), 1);
			}
			string name = _S("");
			if (nextc != '\0') {
				s->pos++;
				name = v__scanner__Scanner_ident_name(s);
			}
			if (s->is_fmt) {
				return v__scanner__Scanner_new_token(s, v__token__Kind__name, builtin__string__plus(_S("@"), name), (int)(name.len + 1));
			}
			if ((Array_string_contains(_const_v__token__valid_at_tokens, builtin__string__plus(_S("@"), name))) || builtin__string_starts_with(name, _S("cc"))) {
				return v__scanner__Scanner_new_token(s, v__token__Kind__at, builtin__string__plus(_S("@"), name), (int)(name.len + 1));
			}
			if (!v__token__is_key(name)) {
				if (builtin__string_is_upper(name)) {
					string comptime_vars = Array_string_join(_const_v__token__valid_at_tokens, _S(", "));
					v__scanner__Scanner_add_error_detail(s, builtin__string_wrap(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("available compile time variables: "), 0xfe10, {.d_s = comptime_vars}}, {_SLIT0, 0, { .d_c = 0 }}})), ((WrapConfig){.width = 90,.end = _S("\n"),})));
				}
				v__scanner__Scanner_error(s, _S("@ must be used before keywords or compile time variables (e.g. `@type string` or `@FN`)"));
			} else {
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__name, name, name.len);
		}
		else if (c == ('.')) {
			if (nextc == '.') {
				s->pos++;
				if ((int)(s->pos + 1) < s->text.len && s->text.str[ (int)(s->pos + 1)] == '.') {
					s->pos++;
					return v__scanner__Scanner_new_token(s, v__token__Kind__ellipsis, _S(""), 3);
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind__dotdot, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__dot, _S(""), 1);
		}
		else if (c == ('#')) {
			if (nextc == '[') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__nilsbr, _S(""), 2);
			}
			int start = (int)(s->pos + 1);
			v__scanner__Scanner_ignore_line(s);
			if (nextc == '!') {
				string comment = builtin__string_trim_space(builtin__string_substr(s->text, (int)(start - 1), s->pos));
				if (s->line_nr != 1) {
					v__token__Pos comment_pos = ((v__token__Pos){.len = comment.len,.line_nr = (int)(s->line_nr - 1),.pos = start,.col = v__scanner__u16_col((int)(v__scanner__Scanner_current_column(s) - comment.len)),.file_idx = s->file_idx,.last_line = 0,});
					v__scanner__Scanner_error_with_pos(s, _S("a shebang is only valid at the top of the file"), comment_pos);
				}
				return v__scanner__Scanner_new_token(s, v__token__Kind__comment, comment, (int)(comment.len + 2));
			}
			string hash = builtin__string_trim_space(builtin__string_substr(s->text, start, s->pos));
			return v__scanner__Scanner_new_token(s, v__token__Kind__hash, hash, (int)(hash.len + 2));
		}
		else if (c == ('>')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__ge, _S(""), 2);
			} else if (nextc == '>') {
				if ((int)(s->pos + 2) < s->text.len) {
					if (s->text.str[ (int)(s->pos + 2)] == '=') {
						s->pos += 2;
						return v__scanner__Scanner_new_token(s, v__token__Kind__right_shift_assign, _S(""), 3);
					} else if (s->text.str[ (int)(s->pos + 2)] == '>') {
						if ((int)(s->pos + 3) < s->text.len && s->text.str[ (int)(s->pos + 3)] == '=') {
							s->pos += 3;
							return v__scanner__Scanner_new_token(s, v__token__Kind__unsigned_right_shift_assign, _S(""), 4);
						}
						s->pos += 2;
						return v__scanner__Scanner_new_token(s, v__token__Kind__unsigned_right_shift, _S(""), 3);
					}
				}
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__right_shift, _S(""), 2);
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__gt, _S(""), 1);
		}
		else if (c == ('<')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__le, _S(""), 2);
			} else if (nextc == '<') {
				if ((int)(s->pos + 2) < s->text.len && s->text.str[ (int)(s->pos + 2)] == '=') {
					s->pos += 2;
					return v__scanner__Scanner_new_token(s, v__token__Kind__left_shift_assign, _S(""), 3);
				}
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__left_shift, _S(""), 2);
			} else if (nextc == '-') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__arrow, _S(""), 2);
			} else {
				s->last_lt = s->pos;
				return v__scanner__Scanner_new_token(s, v__token__Kind__lt, _S(""), 1);
			}
		}
		else if (c == ('=')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__eq, _S(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind__assign, _S(""), 1);
			}
		}
		else if (c == (':')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__decl_assign, _S(""), 2);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind__colon, _S(""), 1);
			}
		}
		else if (c == (';')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__semicolon, _S(""), 1);
		}
		else if (c == ('!')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__ne, _S(""), 2);
			} else if (s->text.len > (int)(s->pos + 3) && nextc == 'i' && s->text.str[ (int)(s->pos + 2)] == 'n' && builtin__u8_is_space(s->text.str[ (int)(s->pos + 3)])) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind__not_in, _S(""), 3);
			} else if (s->text.len > (int)(s->pos + 3) && nextc == 'i' && s->text.str[ (int)(s->pos + 2)] == 's' && builtin__u8_is_space(s->text.str[ (int)(s->pos + 3)])) {
				s->pos += 2;
				return v__scanner__Scanner_new_token(s, v__token__Kind__not_is, _S(""), 3);
			} else {
				return v__scanner__Scanner_new_token(s, v__token__Kind__not, _S("!"), 1);
			}
		}
		else if (c == ('~')) {
			return v__scanner__Scanner_new_token(s, v__token__Kind__bit_not, _S(""), 1);
		}
		else if (c == ('/')) {
			if (nextc == '=') {
				s->pos++;
				return v__scanner__Scanner_new_token(s, v__token__Kind__div_assign, _S(""), 2);
			}
			if (nextc == '/') {
				int start = (int)(s->pos + 1);
				v__scanner__Scanner_ignore_line(s);
				int comment_line_end = s->pos;
				if (s->text.str[ (int)(s->pos - 1)] == 13) {
					comment_line_end--;
					s->pos--;
				}
				s->pos--;
				s->line_nr--;
				if (v__scanner__Scanner_should_parse_comment(s)) {
					s->line_comment = builtin__string_substr(s->text, (int)(start + 1), comment_line_end);
					string comment = s->line_comment;
					bool is_separate_line_comment = true;
					for (int j = (int)(start - 2); j >= 0 && s->text.str[ j] != 10; j--) {
						if (!(s->text.str[ j] == '\t' || s->text.str[ j] == ' ')) {
							is_separate_line_comment = false;
						}
					}
					if (is_separate_line_comment) {
						comment = builtin__string__plus(_S("\001"), comment);
					}
					return v__scanner__Scanner_new_token(s, v__token__Kind__comment, comment, (int)(s->line_comment.len + 2));
				}
				continue;
			} else if (nextc == '*') {
				int start = (int)(s->pos + 2);
				int start_line = s->line_nr;
				int nest_count = 1;
				s->pos++;
				for (;;) {
					if (!(nest_count > 0 && s->pos < (int)(s->text.len - 1))) break;
					s->pos++;
					if (s->pos >= (int)(s->text.len - 1)) {
						s->line_nr = start_line;
						v__scanner__Scanner_error(s, _S("unterminated multiline comment"));
					}
					if (s->text.str[ s->pos] == 10) {
						v__scanner__Scanner_inc_line_number(s);
						continue;
					}
					if (v__scanner__Scanner_expect(s, _S("/*"), s->pos) && s->text.str[ (int)(s->pos + 2)] != '/') {
						nest_count++;
						continue;
					}
					if (v__scanner__Scanner_expect(s, _S("*/"), s->pos)) {
						nest_count--;
					}
				}
				s->pos++;
				if (v__scanner__Scanner_should_parse_comment(s)) {
					string comment = builtin__string_substr(s->text, start, ((int)(s->pos - 1)));
					if (!builtin__string_contains(comment, _S("\n"))) {
						v__token__Pos comment_pos = ((v__token__Pos){.len = (int)(comment.len + 4),.line_nr = start_line,.pos = start,.col = v__scanner__u16_col((int)((int)(v__scanner__Scanner_current_column(s) - comment.len) - 4)),.file_idx = s->file_idx,.last_line = 0,});
						if (!s->pref->is_fmt) {
							v__scanner__Scanner_error_with_pos(s, _S("inline comment is deprecated, please use line comment"), comment_pos);
						}
						comment = builtin__string__plus(_S("\001"), builtin__string_trim(comment, _S(" ")));
					}
					return v__scanner__Scanner_new_multiline_token(s, v__token__Kind__comment, comment, (int)(comment.len + 4), start_line);
				}
				continue;
			}
			return v__scanner__Scanner_new_token(s, v__token__Kind__div, _S(""), 1);
		}
		else {
		}
		v__scanner__Scanner_invalid_character(s);
		break;
	}
	return v__scanner__Scanner_end_of_file(s);
}
VV_LOC void v__scanner__Scanner_invalid_character(v__scanner__Scanner* s) {
	int len = builtin__utf8_char_len(builtin__string_at(s->text, s->pos));
	int end = builtin__int_min((int)(s->pos + len), s->text.len);
	string c = builtin__string_substr(s->text, s->pos, end);
	v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid character `"), 0xfe10, {.d_s = c}}, {_S("`"), 0, { .d_c = 0 }}})));
}
inline VV_LOC int v__scanner__Scanner_current_column(v__scanner__Scanner* s) {
	return (int)(s->pos - s->last_nl_pos);
}
VV_LOC int v__scanner__Scanner_count_symbol_before(v__scanner__Scanner* s, int p, u8 sym) {
	int count = 0;
	for (int i = p; i >= 0; i--) {
		if (s->text.str[ i] != sym) {
			break;
		}
		count++;
	}
	return count;
}
string v__scanner__Scanner_ident_string(v__scanner__Scanner* s) {
	u8 quote = v__scanner__Scanner_str_quote(*s);
	if (255 == quote) {
		return _S("");
	}
	s->quote = quote;
	if (s->is_inside_string) {
		s->is_nested_string = true;
	} else {
		s->is_nested_string = false;
	}
	v__token__Pos lspos = ((v__token__Pos){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = ((u16)((int)((int)(s->pos - s->last_nl_pos) - 1))),.file_idx = s->file_idx,.last_line = 0,});
	u8 q = s->text.str[ s->pos];
	bool is_quote = (q == _const_v__scanner__single_quote || q == _const_v__scanner__double_quote);
	bool is_raw = is_quote && s->pos > 0 && s->text.str[ (int)(s->pos - 1)] == 'r' && !s->is_inside_string;
	bool is_cstr = is_quote && s->pos > 0 && s->text.str[ (int)(s->pos - 1)] == 'c' && !s->is_inside_string;
	int n_cr_chars = 0;
	int start = s->pos;
	u8 start_char = s->text.str[ start];
	if (start_char == s->quote) {
		start++;
	} else if (start_char == 10) {
		v__scanner__Scanner_inc_line_number(s);
	}
	s->is_inside_string = false;
	builtin__array_clear(&s->u16_escapes_pos);
	builtin__array_clear(&s->u32_escapes_pos);
	builtin__array_clear(&s->h_escapes_pos);
	int backslash_count = (start_char == _const_v__scanner__backslash ? (1) : (0));
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			if ((int)(lspos.line_nr + 1) < s->line_nr) {
				v__scanner__Scanner_add_error_detail_with_pos(s, _S("literal started here"), lspos);
			}
			v__scanner__Scanner_error(s, _S("unfinished string literal"));
			break;
		}
		u8 c = s->text.str[ s->pos];
		u8 prevc = s->text.str[ (int)(s->pos - 1)];
		if (c == _const_v__scanner__backslash) {
			backslash_count++;
		}
		if (c == s->quote && (is_raw || (backslash_count & 1) == 0)) {
			break;
		}
		if (c == 13) {
			n_cr_chars++;
		}
		if (c == 10) {
			v__scanner__Scanner_inc_line_number(s);
		}
		if ((backslash_count & 1) == 1 && !is_raw && !is_cstr) {
			if (c == 'x') {
				if (s->text.str[ (int)(s->pos + 1)] == s->quote || !(builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 1)]) && builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 2)]))) {
					v__scanner__Scanner_error(s, _S("`\\x` used without two following hex digits"));
				}
				builtin__array_push((array*)&s->h_escapes_pos, _MOV((int[]){ (int)(s->pos - 1) }));
			}
			if (c == 'u') {
				if (s->text.str[ (int)(s->pos + 1)] == s->quote || s->text.str[ (int)(s->pos + 2)] == s->quote || s->text.str[ (int)(s->pos + 3)] == s->quote || s->text.str[ (int)(s->pos + 4)] == s->quote || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 1)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 2)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 3)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 4)])) {
					v__scanner__Scanner_error(s, _S("`\\u` incomplete 16 bit unicode character value"));
				}
				builtin__array_push((array*)&s->u16_escapes_pos, _MOV((int[]){ (int)(s->pos - 1) }));
			}
			if (c == 'U') {
				if (s->text.str[ (int)(s->pos + 1)] == s->quote || s->text.str[ (int)(s->pos + 2)] == s->quote || s->text.str[ (int)(s->pos + 3)] == s->quote || s->text.str[ (int)(s->pos + 4)] == s->quote || s->text.str[ (int)(s->pos + 5)] == s->quote || s->text.str[ (int)(s->pos + 6)] == s->quote || s->text.str[ (int)(s->pos + 7)] == s->quote || s->text.str[ (int)(s->pos + 8)] == s->quote || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 1)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 2)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 3)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 4)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 5)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 6)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 7)]) || !builtin__u8_is_hex_digit(s->text.str[ (int)(s->pos + 8)])) {
					v__scanner__Scanner_error(s, _S("`\\U` incomplete 32 bit unicode character value"));
				}
				builtin__array_push((array*)&s->u32_escapes_pos, _MOV((int[]){ (int)(s->pos - 1) }));
			}
			if (!v__util__is_escape_sequence(c) && !_const_v__scanner__digit_table[c] && c != '\n') {
				v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = builtin__u8_ascii_str(c)}}, {_S("` unknown escape sequence"), 0, { .d_c = 0 }}})));
			}
		}
		if (prevc == '$' && c == '{' && !is_raw && (v__scanner__Scanner_count_symbol_before(s, (int)(s->pos - 2), _const_v__scanner__backslash) & 1) == 0) {
			s->is_inside_string = true;
			s->pos -= 2;
			break;
		}
		if (prevc == '$' && _const_v__util__name_char_table[c] && !is_raw && (v__scanner__Scanner_count_symbol_before(s, (int)(s->pos - 2), _const_v__scanner__backslash) & 1) == 0) {
			s->is_inside_string = true;
			s->is_inter_start = true;
			s->pos -= 2;
			break;
		}
		if (c != _const_v__scanner__backslash) {
			backslash_count = 0;
		}
	}
	string lit = _S("");
	int end = s->pos;
	if (s->is_inside_string) {
		end++;
	}
	if (start <= s->pos) {
		string string_so_far = builtin__string_substr(s->text, start, end);
		if (!s->is_fmt) {
			int segment_idx = 0;
			builtin__array_clear(&s->str_segments);
			if ((int)((int)(s->u16_escapes_pos.len + s->h_escapes_pos.len) + s->u32_escapes_pos.len) > 0) {
				builtin__array_clear(&s->all_pos);
				_PUSH_MANY(&s->all_pos, (s->u16_escapes_pos), _t5, Array_int);
				_PUSH_MANY(&s->all_pos, (s->u32_escapes_pos), _t6, Array_int);
				_PUSH_MANY(&s->all_pos, (s->h_escapes_pos), _t7, Array_int);
				if (s->all_pos.len > 0) { qsort(s->all_pos.data, s->all_pos.len, s->all_pos.element_size, (voidptr)compare_6896267785627929237_int); }
				;
				for (int _t8 = 0; _t8 < s->all_pos.len; ++_t8) {
					int pos = ((int*)s->all_pos.data)[_t8];
					builtin__array_push((array*)&s->str_segments, _MOV((string[]){ builtin__string_substr(string_so_far, segment_idx, ((int)(pos - start))) }));
					segment_idx = (int)(pos - start);
					if ((Array_int_contains(s->u16_escapes_pos, pos))) {
						v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_u16_escape_single(s, string_so_far, segment_idx);
						builtin__array_push((array*)&s->str_segments, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
						segment_idx = decoded.idx;
					}
					if ((Array_int_contains(s->u32_escapes_pos, pos))) {
						v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_u32_escape_single(s, string_so_far, segment_idx);
						builtin__array_push((array*)&s->str_segments, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
						segment_idx = decoded.idx;
					}
					if ((Array_int_contains(s->h_escapes_pos, pos))) {
						v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_h_escape_single(s, string_so_far, segment_idx);
						builtin__array_push((array*)&s->str_segments, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
						segment_idx = decoded.idx;
					}
				}
			}
			if (segment_idx < string_so_far.len) {
				builtin__array_push((array*)&s->str_segments, _MOV((string[]){ builtin__string_substr(string_so_far, segment_idx, 2147483647) }));
			}
			string_so_far = Array_string_join(s->str_segments, _S(""));
		}
		if (n_cr_chars > 0) {
			string_so_far = builtin__string_replace(string_so_far, _S("\r"), _S(""));
		}
		if (!is_raw && builtin__string_contains(string_so_far, _S("\\\n"))) {
			lit = v__scanner__trim_slash_line_break(string_so_far);
		} else {
			lit = string_so_far;
		}
	}
	if (s->text.str[ end] == quote) {
		builtin__array_delete_last(&s->str_helper_tokens);
	}
	return lit;
}
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_h_escape_single(v__scanner__Scanner* s, string str, int idx) {
	int end_idx = (int)(idx + 4);
	if ((int)(idx + 2) > str.len || end_idx > str.len) {
		v__scanner__Scanner_error_with_pos(s, _S("unfinished single hex escape started at"), v__scanner__Scanner_current_pos(s));
		return ((v__scanner__DecodedEscape){.idx = 0,.segment = _S(""),});
	}
	_result_u64 _t3 = strconv__parse_uint(builtin__string_substr(str, (int)(idx + 2), end_idx), 16, 8);
	if (_t3.is_error) {
		*(u64*) _t3.data = 0;
	}
	
 	return ((v__scanner__DecodedEscape){.idx = end_idx,.segment = Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){((u8)((*(u64*)_t3.data)))}))),});
}
VV_LOC string v__scanner__Scanner_decode_h_escapes(v__scanner__Scanner* s, string sinput, int start, Array_int escapes_pos) {
	if (escapes_pos.len == 0) {
		return sinput;
	}
	Array_string ss = builtin____new_array_with_default(0, (int)((int)(escapes_pos.len * 2) + 1), sizeof(string), 0);
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, 0, (int)((*(int*)builtin__array_first(escapes_pos)) - start)) }));
	for (int i = 0; i < escapes_pos.len; ++i) {
		int pos = ((int*)escapes_pos.data)[i];
		int idx = (int)(pos - start);
		v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_h_escape_single(s, sinput, idx);
		if (decoded.idx > sinput.len) {
			v__scanner__Scanner_error_with_pos(s, _S("unfinished hex escape started at"), v__scanner__Scanner_current_pos(s));
			return _S("");
		}
		builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
		if ((int)(i + 1) < escapes_pos.len) {
			builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, decoded.idx, (int)((*(int*)builtin__array_get(escapes_pos, (int)(i + 1))) - start)) }));
		} else {
			builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, decoded.idx, 2147483647) }));
		}
	}
	return Array_string_join(ss, _S(""));
}
VV_LOC string v__scanner__Scanner_decode_o_escapes(v__scanner__Scanner* s, string sinput, int start, Array_int escapes_pos) {
	if (escapes_pos.len == 0) {
		return sinput;
	}
	Array_string ss = builtin____new_array_with_default(0, escapes_pos.len, sizeof(string), 0);
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, 0, (int)((*(int*)builtin__array_first(escapes_pos)) - start)) }));
	for (int i = 0; i < escapes_pos.len; ++i) {
		int pos = ((int*)escapes_pos.data)[i];
		int idx = (int)(pos - start);
		int end_idx = (int)(idx + 4);
		if (end_idx > sinput.len) {
			v__scanner__Scanner_error_with_pos(s, _S("unfinished octal escape started at"), v__scanner__Scanner_current_pos(s));
			return _S("");
		}
		_result_u64 _t5 = strconv__parse_uint(builtin__string_substr(sinput, (int)(idx + 1), end_idx), 8, 8);
		if (_t5.is_error) {
			*(u64*) _t5.data = 0;
		}
		
 		builtin__array_push((array*)&ss, _MOV((string[]){ Array_u8_bytestr(builtin__new_array_from_c_array(1, 1, sizeof(u8), _MOV((u8[1]){((u8)((*(u64*)_t5.data)))}))) }));
		if ((int)(i + 1) < escapes_pos.len) {
			builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, end_idx, (int)((*(int*)builtin__array_get(escapes_pos, (int)(i + 1))) - start)) }));
		} else {
			builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(sinput, end_idx, 2147483647) }));
		}
	}
	return Array_string_join(ss, _S(""));
}
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_u16_escape_single(v__scanner__Scanner* s, string str, int idx) {
	int end_idx = (int)(idx + 6);
	if ((int)(idx + 2) > str.len || end_idx > str.len) {
		v__scanner__Scanner_error_with_pos(s, _S("unfinished u16 escape started at"), v__scanner__Scanner_current_pos(s));
		return ((v__scanner__DecodedEscape){.idx = 0,.segment = _S(""),});
	}
	_result_u64 _t2 = strconv__parse_uint(builtin__string_substr(str, (int)(idx + 2), end_idx), 16, 32);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	u64 escaped_code_point = (*(u64*)_t2.data);
	if (builtin__rune_length_in_bytes(((rune)(escaped_code_point))) == -1) {
		v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid unicode point `"), 0xfe10, {.d_s = str}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	return ((v__scanner__DecodedEscape){.idx = end_idx,.segment = builtin__utf32_to_str(((u32)(escaped_code_point))),});
}
VV_LOC string v__scanner__Scanner_decode_u16erune(v__scanner__Scanner* s, string str) {
	v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_u16_escape_single(s, str, 0);
	if (str.len == decoded.idx) {
		return decoded.segment;
	}
	Array_string ss = builtin____new_array_with_default(0, 2, sizeof(string), 0);
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(str, decoded.idx, 2147483647) }));
	return Array_string_join(ss, _S(""));
}
VV_LOC v__scanner__DecodedEscape v__scanner__Scanner_decode_u32_escape_single(v__scanner__Scanner* s, string str, int idx) {
	int end_idx = (int)(idx + 10);
	if ((int)(idx + 2) > str.len || end_idx > str.len) {
		v__scanner__Scanner_error_with_pos(s, _S("unfinished u32 escape started at"), v__scanner__Scanner_current_pos(s));
		return ((v__scanner__DecodedEscape){.idx = 0,.segment = _S(""),});
	}
	_result_u64 _t2 = strconv__parse_uint(builtin__string_substr(str, (int)(idx + 2), end_idx), 16, 32);
	if (_t2.is_error) {
		*(u64*) _t2.data = 0;
	}
	
 	u64 escaped_code_point = (*(u64*)_t2.data);
	if (builtin__rune_length_in_bytes(((rune)(escaped_code_point))) == -1) {
		v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid unicode point `"), 0xfe10, {.d_s = str}}, {_S("`"), 0, { .d_c = 0 }}})));
	}
	return ((v__scanner__DecodedEscape){.idx = end_idx,.segment = builtin__utf32_to_str(((u32)(escaped_code_point))),});
}
VV_LOC string v__scanner__Scanner_decode_u32erune(v__scanner__Scanner* s, string str) {
	v__scanner__DecodedEscape decoded = v__scanner__Scanner_decode_u32_escape_single(s, str, 0);
	if (str.len == decoded.idx) {
		return decoded.segment;
	}
	Array_string ss = builtin____new_array_with_default(0, 2, sizeof(string), 0);
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_clone(decoded.segment) }));
	builtin__array_push((array*)&ss, _MOV((string[]){ builtin__string_substr(str, decoded.idx, 2147483647) }));
	return Array_string_join(ss, _S(""));
}
VV_LOC string v__scanner__trim_slash_line_break(string s) {
	int start = 0;
	string ret_str = s;
	for (;;) {
		_option_int _t1 = builtin__string_index_after(ret_str, _S("\\\n"), start);
		if (_t1.state != 0) {
			break;
		}
		
 		int idx = (*(int*)_t1.data);
		start = idx;
		int nbackslashes = 0;
		for (int eidx = idx; eidx >= 0 && builtin__string_at(ret_str, eidx) == '\\'; eidx--) {
			nbackslashes++;
		}
		if (idx == 0 || ((nbackslashes & 1)) == 1) {
			ret_str = builtin__string__plus(builtin__string_substr(ret_str, 0, idx), builtin__string_trim_left(builtin__string_substr(ret_str, (int)(idx + 2), 2147483647), _S(" \n\t\v\f\r")));
		} else {
			start++;
		}
	}
	return ret_str;
}
string v__scanner__Scanner_ident_char(v__scanner__Scanner* s) {
	v__token__Pos lspos = ((v__token__Pos){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = ((u16)((int)((int)(s->pos - s->last_nl_pos) - 1))),.file_idx = s->file_idx,.last_line = 0,});
	int start = s->pos;
	rune slash = '\\';
	int len = 0;
	bool escaped_hex = v__scanner__Scanner_expect(s, _S("\\x"), (int)(start + 1)) && s->text.len > (int)(start + 3) && builtin__u8_is_hex_digit(builtin__string_at(s->text, (int)(start + 3)));
	bool escaped_unicode_16 = v__scanner__Scanner_expect(s, _S("\\u"), (int)(start + 1)) && s->text.len > (int)(start + 3) && builtin__u8_is_hex_digit(builtin__string_at(s->text, (int)(start + 3)));
	bool escaped_unicode_32 = v__scanner__Scanner_expect(s, _S("\\U"), (int)(start + 1)) && s->text.len > (int)(start + 3) && builtin__u8_is_hex_digit(builtin__string_at(s->text, (int)(start + 3)));
	bool escaped_octal = !escaped_hex && !escaped_unicode_16 && !escaped_unicode_32 && v__scanner__Scanner_expect(s, _S("\\"), (int)(start + 1)) && s->text.len > (int)(start + 2) && builtin__u8_is_oct_digit(builtin__string_at(s->text, (int)(start + 2)));
	for (;;) {
		s->pos++;
		if (s->pos >= s->text.len) {
			break;
		}
		if (builtin__string_at(s->text, s->pos) != slash) {
			len++;
		}
		bool double_slash = v__scanner__Scanner_expect(s, _S("\\\\"), (int)(s->pos - 2));
		if (builtin__string_at(s->text, s->pos) == '`' && (builtin__string_at(s->text, (int)(s->pos - 1)) != slash || double_slash)) {
			if (double_slash) {
				len++;
			}
			break;
		}
	}
	len--;
	string c = builtin__string_substr(s->text, (int)(start + 1), s->pos);
	if (s->is_fmt) {
		return c;
	}
	if (len != 1) {
		string orig = c;
		if ((c.len & 1) == 0 && (escaped_hex || escaped_unicode_16 || escaped_unicode_32 || escaped_octal)) {
			if (escaped_unicode_16) {
				c = v__scanner__Scanner_decode_u16erune(s, c);
			} else if (escaped_unicode_32) {
				c = v__scanner__Scanner_decode_u32erune(s, c);
			} else {
				Array_int escapes_pos = builtin____new_array_with_default(0, 0, sizeof(int), 0);
				for (int i = 0; i < c.len; ++i) {
					u8 v = c.str[i];
					if (v == '\\') {
						builtin__array_push((array*)&escapes_pos, _MOV((int[]){ i }));
					}
				}
				if (escaped_hex) {
					c = v__scanner__Scanner_decode_h_escapes(s, c, 0, escapes_pos);
				} else {
					c = v__scanner__Scanner_decode_o_escapes(s, c, 0, escapes_pos);
				}
			}
		}
		Array_rune u = builtin__string_runes(c);
		if (u.len != 1) {
			Array_string err_info = builtin____new_array_with_default(0, u.len, sizeof(string), 0);
			int i = 0;
			for (;;) {
				if (!(i < u.len)) break;
				if ((*(rune*)builtin__array_get(u, i)) != '\\' || i == (int)(u.len - 1)) {
					builtin__array_push((array*)&err_info, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = builtin__rune_str((*(rune*)builtin__array_get(u, i)))}}, {_S("`"), 0, { .d_c = 0 }}})) }));
					i++;
					continue;
				}
				builtin__array_push((array*)&err_info, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`\\"), 0xfe10, {.d_s = builtin__rune_str((*(rune*)builtin__array_get(u, (int)(i + 1))))}}, {_S("`"), 0, { .d_c = 0 }}})) }));
				i += 2;
			}
			if (escaped_hex || escaped_unicode_16 || escaped_unicode_32) {
				v__scanner__Scanner_error_with_pos(s, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("invalid character literal `"), 0xfe10, {.d_s = orig}}, {_S("` => `"), 0xfe10, {.d_s = c}}, {_S("` (["), 0xfe10, {.d_s = Array_string_join(err_info, _S(", "))}}, {_S("]) (escape sequence did not refer to a singular rune)"), 0, { .d_c = 0 }}})), lspos);
			} else if (u.len == 0) {
				v__scanner__Scanner_add_error_detail(s, _S("use quotes for strings, backticks for characters"));
				v__scanner__Scanner_error_with_pos(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid empty character literal `"), 0xfe10, {.d_s = orig}}, {_S("`"), 0, { .d_c = 0 }}})), lspos);
			} else {
				v__scanner__Scanner_add_error_detail(s, _S("use quotes for strings, backticks for characters"));
				v__scanner__Scanner_error_with_pos(s, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("invalid character literal `"), 0xfe10, {.d_s = orig}}, {_S("` => `"), 0xfe10, {.d_s = c}}, {_S("` (["), 0xfe10, {.d_s = Array_string_join(err_info, _S(", "))}}, {_S("]) (more than one character)"), 0, { .d_c = 0 }}})), lspos);
			}
		}
	} else if (builtin__string_ends_with(c, _S("\n"))) {
		v__scanner__Scanner_add_error_detail(s, _S("use quotes for strings, backticks for characters"));
		v__scanner__Scanner_error_with_pos(s, _S("invalid character literal, use `\\n` instead"), lspos);
	} else if (c.len > len) {
		u8 ch = builtin__string_at(c, (int)(c.len - 1));
		if (!v__util__is_escape_sequence(ch) && !_const_v__scanner__digit_table[builtin__v_fixed_index(ch, 256)]) {
			v__scanner__Scanner_error(s, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = builtin__u8_ascii_str(ch)}}, {_S("` unknown escape sequence"), 0, { .d_c = 0 }}})));
		}
	}
	if (_SLIT_EQ(c.str, c.len, "'")) {
		return builtin__string__plus(_S("\\"), c);
	}
	return c;
}
inline VV_LOC bool v__scanner__Scanner_expect(v__scanner__Scanner* s, string want, int start_pos) {
	int end_pos = (int)(start_pos + want.len);
	if (start_pos < 0 || end_pos < 0 || start_pos >= s->text.len || end_pos > s->text.len) {
		return false;
	}
	for (int pos = start_pos; pos < end_pos; ++pos) {
		if (s->text.str[ pos] != want.str[ (int)(pos - start_pos)]) {
			return false;
		}
	}
	return true;
}
inline VV_LOC void v__scanner__Scanner_ignore_line(v__scanner__Scanner* s) {
	v__scanner__Scanner_eat_to_end_of_line(s);
	v__scanner__Scanner_inc_line_number(s);
}
inline VV_LOC void v__scanner__Scanner_eat_to_end_of_line(v__scanner__Scanner* s) {
	for (;;) {
		if (!(s->pos < s->text.len && s->text.str[ s->pos] != 10)) break;
		s->pos++;
	}
}
inline VV_LOC void v__scanner__Scanner_inc_line_number(v__scanner__Scanner* s) {
	s->last_nl_pos = ((int)(s->text.len - 1) > s->pos ? (s->pos) : ((int)(s->text.len - 1)));
	s->line_nr++;
	if (s->line_nr > s->nr_lines) {
		s->nr_lines = s->line_nr;
	}
}
v__token__Pos v__scanner__Scanner_current_pos(v__scanner__Scanner* s) {
	return ((v__token__Pos){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = v__scanner__u16_col((int)(v__scanner__Scanner_current_column(s) - 1)),.file_idx = s->file_idx,.last_line = 0,});
}
void v__scanner__Scanner_note(v__scanner__Scanner* s, string msg) {
	if (s->pref->notes_are_errors) {
		v__scanner__Scanner_error_with_pos(s, msg, v__scanner__Scanner_current_pos(s));
		return;
	}
	v__token__Pos pos = ((v__token__Pos){.len = 0,.line_nr = s->line_nr,.pos = s->pos,.col = 0,.file_idx = s->file_idx,.last_line = 0,});
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		v__util__show_compiler_message(_S("notice:"), ((v__errors__CompilerMessage){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
	} else {
		builtin__array_push((array*)&s->notices, _MOV((v__errors__Notice[]){ ((v__errors__Notice){.CompilerMessage = ((v__errors__CompilerMessage){.message = msg,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter__scanner,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
	}
}
void v__scanner__Scanner_add_error_detail(v__scanner__Scanner* s, string msg) {
	builtin__array_push((array*)&s->error_details, _MOV((string[]){ builtin__string_clone(msg) }));
}
void v__scanner__Scanner_add_error_detail_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos) {
	v__scanner__Scanner_add_error_detail(s, builtin__string__plus(_S("\n"), v__util__formatted_error(_S("details:"), msg, s->file_path, pos)));
}
VV_LOC string v__scanner__Scanner_eat_details(v__scanner__Scanner* s) {
	string details = _S("");
	if (s->error_details.len > 0) {
		details = Array_string_join(s->error_details, _S("\n"));
		s->error_details = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	}
	return details;
}
void v__scanner__Scanner_warn(v__scanner__Scanner* s, string msg) {
	v__scanner__Scanner_warn_with_pos(s, msg, v__scanner__Scanner_current_pos(s));
}
void v__scanner__Scanner_warn_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos) {
	if (s->pref->warns_are_errors) {
		v__scanner__Scanner_error_with_pos(s, msg, pos);
		return;
	}
	string details = v__scanner__Scanner_eat_details(s);
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		v__util__show_compiler_message(_S("warning:"), ((v__errors__CompilerMessage){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
	} else {
		if (s->pref->message_limit >= 0 && s->warnings.len >= s->pref->message_limit) {
			s->should_abort = true;
			return;
		}
		builtin__array_push((array*)&s->warnings, _MOV((v__errors__Warning[]){ ((v__errors__Warning){.CompilerMessage = ((v__errors__CompilerMessage){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter__scanner,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
	}
}
void v__scanner__Scanner_error(v__scanner__Scanner* s, string msg) {
	v__scanner__Scanner_error_with_pos(s, msg, v__scanner__Scanner_current_pos(s));
}
void v__scanner__Scanner_error_with_pos(v__scanner__Scanner* s, string msg, v__token__Pos pos) {
	string details = v__scanner__Scanner_eat_details(s);
	if (s->pref->output_mode == v__pref__OutputMode__stdout && !s->pref->check_only) {
		v__util__show_compiler_message(_S("error:"), ((v__errors__CompilerMessage){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
		builtin___v_exit(1);
		VUNREACHABLE();
	} else {
		if (s->pref->fatal_errors) {
			v__util__show_compiler_message(_S("error:"), ((v__errors__CompilerMessage){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
			builtin___v_exit(1);
			VUNREACHABLE();
		}
		if (s->pref->message_limit >= 0 && s->errors.len >= s->pref->message_limit) {
			s->should_abort = true;
			return;
		}
		builtin__array_push((array*)&s->errors, _MOV((v__errors__Error[]){ ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = msg,.details = details,.file_path = s->file_path,.pos = pos,.reporter = v__errors__Reporter__scanner,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
	}
}
void v__scanner__Scanner_prepare_for_new_text(v__scanner__Scanner* s, string text) {
	s->text = text;
	s->pos = -1;
	s->tidx = 0;
	builtin__array_clear(&s->all_tokens);
	builtin__array_clear(&s->errors);
	builtin__array_clear(&s->error_details);
	builtin__array_clear(&s->warnings);
	builtin__array_clear(&s->notices);
	builtin__array_clear(&s->str_helper_tokens);
	builtin__array_clear(&s->str_segments);
	builtin__array_clear(&s->all_pos);
	builtin__array_clear(&s->u16_escapes_pos);
	builtin__array_clear(&s->u32_escapes_pos);
	builtin__array_clear(&s->h_escapes_pos);
	s->should_abort = false;
	s->eofs = 0;
	s->nr_lines = 0;
	s->line_nr = 0;
	s->last_nl_pos = -1;
	s->is_inside_toplvl_statement = false;
	s->is_inside_string = false;
	s->is_nested_string = false;
	s->is_inter_start = false;
	s->is_inter_end = false;
	s->last_lt = -1;
	s->quote = 0;
}
v__scanner__Scanner* v__scanner__new_silent_scanner(void) {
	v__pref__Preferences* p = v__pref__new_preferences();
	p->output_mode = v__pref__OutputMode__silent;
	return ((v__scanner__Scanner*)builtin__memdup(&(v__scanner__Scanner){.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.str_segments = builtin____new_array_with_default(0, 10, sizeof(string), 0),.error_details = builtin____new_array(0, 0, sizeof(string)),.all_tokens = builtin____new_array(0, 0, sizeof(v__token__Token)),.h_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),.u32_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),.u16_escapes_pos = builtin____new_array_with_default(0, 10, sizeof(int), 0),.all_pos = builtin____new_array_with_default(0, 30, sizeof(int), 0),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.str_helper_tokens = builtin____new_array_with_default(0, 16, sizeof(u8), 0),.file_path = (string){.str=(byteptr)"", .is_lit=1},.file_base = (string){.str=(byteptr)"", .is_lit=1},.text = (string){.str=(byteptr)"", .is_lit=1},.line_comment = (string){.str=(byteptr)"", .is_lit=1},.pref = p,.pos = -1,.line_nr = 0,.nr_lines = 0,.last_nl_pos = -1,.last_lt = -1,.max_eofs = 50,.eofs = 0,.tidx = 0,.file_idx = -1,.quote = 0,.comments_mode = 0,.is_inter_end = 0,.is_inter_start = 0,.is_nested_string = 0,.should_abort = 0,.is_inside_string = 0,.is_fmt = 0,.is_print_rel_paths_on_error = 0,.is_print_line_on_error = 0,.is_print_colored_error = 0,.is_inside_toplvl_statement = 0,}, sizeof(v__scanner__Scanner)));
}
VV_LOC u8 v__scanner__Scanner_str_quote(v__scanner__Scanner s) {
	if (s.str_helper_tokens.len == 0) {
		return 255;
	}
	u8 c = ((u8*)s.str_helper_tokens.data)[(int)(s.str_helper_tokens.len - 1)];
	if (c == '\'' || c == '"') {
		return c;
	}
	return 255;
}
inline VV_LOC u16 v__scanner__u16_col(int col) {
	return (col < 0 ? (((u16)(0))) : (((u16)(col))));
}
v__ast__Expr v__transformer__Transformer_array_init(v__transformer__Transformer* t, v__ast__ArrayInit* node) {
	for (int _t1 = 0; _t1 < node->exprs.len; ++_t1) {
		v__ast__Expr* expr = ((v__ast__Expr*)node->exprs.data) + _t1;
		*expr = v__transformer__Transformer_expr(t, expr);
	}
	if (node->has_len) {
		node->len_expr = v__transformer__Transformer_expr(t, &node->len_expr);
	}
	if (node->has_cap) {
		node->cap_expr = v__transformer__Transformer_expr(t, &node->cap_expr);
	}
	if (node->has_init) {
		node->init_expr = v__transformer__Transformer_expr(t, &node->init_expr);
	}
	if (t->pref->backend == v__pref__Backend__js_node || !t->pref->new_transform || t->skip_array_transform || node->is_fixed || t->inside_in || node->has_len || node->has_cap || node->exprs.len == 0) {
		return v__ast__ArrayInit_to_sumtype_v__ast__Expr(node, false);
	}
	int len = node->exprs.len;
	v__ast__CallArg len_arg = ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__int_str(len),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__int_type,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,});
	v__ast__CallArg sizeof_arg = ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, (((v__ast__SizeOf){.guessed_type = 0,.is_type = true,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.typ = node->elem_type,}))), false),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__int_type,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,});
	int fixed_array_idx = v__ast__Table_find_or_register_array_fixed(t->table, node->elem_type, len, _const_v__ast__empty_expr, false);
	v__ast__Type fixed_array_typ = (v__ast__Type_has_flag(node->elem_type, v__ast__TypeFlag__generic) ? (v__ast__Type_set_flag(v__ast__new_type(fixed_array_idx), v__ast__TypeFlag__generic)) : (v__ast__new_type(fixed_array_idx)));
	v__ast__CallArg fixed_array_arg = ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, (((v__ast__CastExpr){.arg = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.expr = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (((v__ast__ArrayInit){
		.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.ecmnts = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),
		.expr_types = node->expr_types,
		.exprs = node->exprs,
		.cap_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.init_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.len_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.elem_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.typ = fixed_array_typ,
		.init_type = 0,
		.elem_type = node->elem_type,
		.alias_type = 0,
		.has_callexpr = 0,
		.is_fixed = true,
		.is_option = 0,
		.has_val = true,
		.has_len = 0,
		.has_cap = 0,
		.has_init = 0,
		.has_index = 0,
	}))), false),.typname = _S("voidptr"),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__voidptr_type,.expr_type = fixed_array_typ,.has_arg = 0,}))), false),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__voidptr_type_idx,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,});
	v__ast__CallExpr call_expr = ((v__ast__CallExpr){.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.args = builtin__new_array_from_c_array(4, 4, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[4]){len_arg, len_arg, sizeof_arg, fixed_array_arg})),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = _S("new_array_from_c_array"),.const_name = (string){.str=(byteptr)"", .is_lit=1},.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.mod = _S("builtin"),.scope = ((void*)0),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.return_type = node->typ,.return_type_generic = 0,.nr_ret_values = -1,.fn_var_type = 0,.left_type = 0,.receiver_concrete_type = 0,.kind = 0,.language = 0,.is_unwrapped_fn_selector = 0,.is_method = 0,.is_field = 0,.is_fn_var = 0,.is_fn_a_const = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.is_file_translated = 0,.is_static_method = 0,.is_variadic = 0,.is_c_variadic = 0,.comptime_ret_val = 0,.should_be_skipped = 0,.free_receiver = 0,.is_return_used = 0,.is_expand_simple_interpolation = 0,});
	return v__ast__CallExpr_to_sumtype_v__ast__Expr(&call_expr, false);
}
void v__transformer__Transformer_find_new_array_len(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
	v__ast__Expr right = (*(v__ast__Expr*)builtin__array_get(node.right, 0));
	if ((right)._typ == 261 /* v.ast.ArrayInit */) {
		v__ast__Expr left = (*(v__ast__Expr*)builtin__array_get(node.left, 0));
		if ((left)._typ == 281 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).is_mut) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -2);
				return;
			}
			if (!(*right._v__ast__ArrayInit).has_len) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -1);
				return;
			}
			int len = ((int)(0));
			v__ast__Expr value = (*right._v__ast__ArrayInit).len_expr;
			if ((value)._typ == 286 /* v.ast.IntegerLiteral */) {
				len = (int)(builtin__string_int((*value._v__ast__IntegerLiteral).val) + 1);
			}
			v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, len);
		}
	}
}
VV_LOC bool v__transformer__IndexState_safe_access(v__transformer__IndexState* i, string key, int __v_new) {
	if (i->disabled) {
		return false;
	}
	int* _t3 = (int*)(builtin__map_get_check(ADDR(map, i->max_index), &(string[]){key}));
	_option_int _t2 = {0};
	if (_t3) {
		*((int*)&_t2.data) = *((int*)_t3);
	} else {
		_t2.state = 2; _t2.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t2.state != 0) {
		;
		builtin__map_set(&i->max_index, &(string[]){key}, &(int[]) { __v_new });
		return false;
	}
	
	int old = (*(int*)_t2.data);
	if (__v_new > old) {
		if (old < -1) {
			;
			return false;
		}
		;
		builtin__map_set(&i->max_index, &(string[]){key}, &(int[]) { __v_new });
		return false;
	}
	;
	return true;
}
VV_LOC int v__transformer__IndexState_safe_offset(v__transformer__IndexState* i, string key) {
	if (i->disabled) {
		return -2;
	}
	int* _t4 = (int*)(builtin__map_get_check(ADDR(map, i->max_index), &(string[]){key}));
	_option_int _t3 = {0};
	if (_t4) {
		*((int*)&_t3.data) = *((int*)_t4);
	} else {
		_t3.state = 2; _t3.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t3.state != 0) {
		*(int*) _t3.data = -1;
	}
	
	return (*(int*)_t3.data);
}
VV_LOC void v__transformer__IndexState_indent(v__transformer__IndexState* i, bool is_function) {
	Array_v__transformer__KeyVal kvs = builtin____new_array_with_default(0, i->max_index.len, sizeof(v__transformer__KeyVal), 0);
	Map_string_int _t1 = i->max_index;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&_t1.key_values, _t2);
		k = builtin__string_clone(k);
		int v = (*(int*)builtin__DenseArray_value(&_t1.key_values, _t2));
		builtin__array_push((array*)&kvs, _MOV((v__transformer__KeyVal[]){ ((v__transformer__KeyVal){.key = k,.value = v,}) }));
	}
	builtin__array_push((array*)&i->saved_disabled, _MOV((bool[]){ i->disabled }));
	builtin__array_push((array*)&i->saved_key_vals, &kvs);
	if (is_function) {
		i->disabled = false;
	}
	i->level += 1;
}
VV_LOC void v__transformer__IndexState_unindent(v__transformer__IndexState* i) {
	i->level -= 1;
	Array_string keys = builtin____new_array_with_default(0, i->max_index.len, sizeof(string), 0);
	Map_string_int _t1 = i->max_index;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string k = *(string*)builtin__DenseArray_key(&_t1.key_values, _t2);
		k = builtin__string_clone(k);
		builtin__array_push((array*)&keys, _MOV((string[]){ builtin__string_clone(k) }));
	}
	for (int _t6 = 0; _t6 < keys.len; ++_t6) {
		string k = ((string*)keys.data)[_t6];
		builtin__map_delete(&i->max_index, &(string[]){k});
	}
	Array_v__transformer__KeyVal _t7 = (*(Array_v__transformer__KeyVal*)builtin__array_pop(&i->saved_key_vals));
	for (int _t8 = 0; _t8 < _t7.len; ++_t8) {
		v__transformer__KeyVal saved = ((v__transformer__KeyVal*)_t7.data)[_t8];
		builtin__map_set(&i->max_index, &(string[]){saved.key}, &(int[]) { saved.value });
	}
	i->disabled = (*(bool*)builtin__array_pop(&i->saved_disabled));
}
v__transformer__Transformer* v__transformer__new_transformer(v__pref__Preferences* pref_) {
	return ((v__transformer__Transformer*)builtin__memdup(&(v__transformer__Transformer){.pref = pref_,.index = ((v__transformer__IndexState*)builtin__memdup(&(v__transformer__IndexState){.max_index = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.saved_disabled = builtin____new_array_with_default(0, 1000, sizeof(bool), 0),.saved_key_vals = builtin____new_array_with_default(0, 1000, sizeof(Array_v__transformer__KeyVal), 0),.disabled = 0,.level = 0,}, sizeof(v__transformer__IndexState))),.table = ((void*)0),.file = ((void*)0),.skip_array_transform = 0,.is_assert = 0,.inside_dump = 0,.inside_in = 0,.inside_sql = 0,.strings_builder_type = _const_v__ast__no_type,}, sizeof(v__transformer__Transformer)));
}
v__transformer__Transformer* v__transformer__new_transformer_with_table(v__ast__Table* table, v__pref__Preferences* pref_) {
	v__transformer__Transformer* transformer = v__transformer__new_transformer(pref_);
	transformer->table = table;
	return transformer;
}
void v__transformer__Transformer_transform_files(v__transformer__Transformer* t, Array_v__ast__File_ptr ast_files) {
	t->strings_builder_type = v__ast__Table_find_type(t->table, _S("strings.Builder"));
	for (int i = 0; i < ast_files.len; ++i) {
		v__ast__File* file = (*(v__ast__File**)builtin__array_get(ast_files, i));
		v__transformer__Transformer_transform(t, file);
	}
}
void v__transformer__Transformer_transform(v__transformer__Transformer* t, v__ast__File* ast_file) {
	t->file = ast_file;
	for (int _t1 = 0; _t1 < ast_file->stmts.len; ++_t1) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)ast_file->stmts.data) + _t1;
		*stmt = v__transformer__Transformer_stmt(t, stmt);
	}
}
void v__transformer__Transformer_find_new_range(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
	v__ast__Expr right = (*(v__ast__Expr*)builtin__array_get(node.right, 0));
	if ((right)._typ == 284 /* v.ast.IndexExpr */) {
		v__ast__Expr left = (*(v__ast__Expr*)builtin__array_get(node.left, 0));
		if ((left)._typ == 281 /* v.ast.Ident */) {
			if ((*left._v__ast__Ident).is_mut) {
				v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, -2);
				return;
			}
			v__ast__Expr index = (*right._v__ast__IndexExpr).index;
			if ((index)._typ == 300 /* v.ast.RangeExpr */) {
				v__ast__Expr range_low = (*index._v__ast__RangeExpr).low;
				if ((range_low)._typ == 286 /* v.ast.IntegerLiteral */) {
					v__ast__Expr sub_left = (*right._v__ast__IndexExpr).left;
					if ((sub_left)._typ == 281 /* v.ast.Ident */) {
						int safe = v__transformer__IndexState_safe_offset(t->index, (*sub_left._v__ast__Ident).name);
						int low = builtin__string_int((*range_low._v__ast__IntegerLiteral).val);
						if (safe >= low) {
							v__transformer__IndexState_safe_access(t->index, (*left._v__ast__Ident).name, (int)(safe - low));
						}
					}
				}
			}
		}
	}
}
void v__transformer__Transformer_find_mut_self_assign(v__transformer__Transformer* t, v__ast__AssignStmt node) {
	if (!t->pref->is_prod) {
		return;
	}
}
void v__transformer__Transformer_check_safe_array(v__transformer__Transformer* t, v__ast__IndexExpr* node) {
	if (!t->pref->is_prod) {
		return;
	}
	if (!node->is_array) {
		return;
	}
	v__ast__Expr index = node->index;
	v__ast__Expr name = node->left;
	if (index._typ == 286 /* v.ast.IntegerLiteral */) {
		bool is_direct = v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), builtin__string_int((*index._v__ast__IntegerLiteral).val));
		node->is_direct = is_direct;
	}
	else if (index._typ == 300 /* v.ast.RangeExpr */) {
		if ((*index._v__ast__RangeExpr).has_high) {
			v__ast__Expr high = (*index._v__ast__RangeExpr).high;
			if ((high)._typ == 286 /* v.ast.IntegerLiteral */) {
				v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), builtin__string_int((*high._v__ast__IntegerLiteral).val));
				return;
			}
		}
		if ((*index._v__ast__RangeExpr).has_low) {
			v__ast__Expr low = (*index._v__ast__RangeExpr).low;
			if ((low)._typ == 286 /* v.ast.IntegerLiteral */) {
				v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), builtin__string_int((*low._v__ast__IntegerLiteral).val));
				return;
			}
		}
	}
	else if (index._typ == 268 /* v.ast.CastExpr */) {
		if (!builtin__fast_string_eq((*index._v__ast__CastExpr).typname, _S("int"))) {
			return;
		}
		v__ast__Expr index_expr = (*index._v__ast__CastExpr).expr;
		if ((index_expr)._typ == 286 /* v.ast.IntegerLiteral */) {
			string val = (*index_expr._v__ast__IntegerLiteral).val;
			node->is_direct = v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str(name), builtin__string_int(val));
		}
	}
	else if (index._typ == 278 /* v.ast.EnumVal */) {
		;
	}
	else if (index._typ == 281 /* v.ast.Ident */) {
	}
	
	else {
	}
	
}
v__ast__Stmt v__transformer__Transformer_stmt(v__transformer__Transformer* t, v__ast__Stmt* node) {
	v__ast__Stmt* onode = node;
	if (node->_typ == 319 /* v.ast.EmptyStmt */) {
	}
	else if (node->_typ == 258 /* v.ast.NodeError */) {
	}
	else if (node->_typ == 311 /* v.ast.AsmStmt */) {
	}
	else if (node->_typ == 317 /* v.ast.DebuggerStmt */) {
	}
	else if (node->_typ == 312 /* v.ast.AssertStmt */) {
		v__transformer__Transformer_assert_stmt(t, &/*mut*/(*node->_v__ast__AssertStmt));
	}
	else if (node->_typ == 313 /* v.ast.AssignStmt */) {
		v__transformer__Transformer_assign_stmt(t, &/*mut*/(*node->_v__ast__AssignStmt));
	}
	else if (node->_typ == 314 /* v.ast.Block */) {
		v__transformer__IndexState_indent(t->index, false);
		for (int _t1 = 0; _t1 < (*node->_v__ast__Block).stmts.len; ++_t1) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__Block).stmts.data) + _t1;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 315 /* v.ast.BranchStmt */) {
		t->index->disabled = true;
	}
	else if (node->_typ == 316 /* v.ast.ComptimeFor */) {
		v__transformer__Transformer_comptime_for(t, &/*mut*/(*node->_v__ast__ComptimeFor));
	}
	else if (node->_typ == 231 /* v.ast.ConstDecl */) {
		v__transformer__Transformer_const_decl(t, &/*mut*/(*node->_v__ast__ConstDecl));
	}
	else if (node->_typ == 318 /* v.ast.DeferStmt */) {
		for (int _t2 = 0; _t2 < (*node->_v__ast__DeferStmt).stmts.len; ++_t2) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__DeferStmt).stmts.data) + _t2;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
	}
	else if (node->_typ == 320 /* v.ast.EnumDecl */) {
		v__transformer__Transformer_enum_decl(t, &/*mut*/(*node->_v__ast__EnumDecl));
	}
	else if (node->_typ == 321 /* v.ast.ExprStmt */) {
v__ast__Expr _t3 = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258};
		if ((*node->_v__ast__ExprStmt).expr._typ == 282 /* v.ast.IfExpr */) {
			_t3 = v__transformer__Transformer_expr_stmt_if_expr(t, (voidptr)&(*(*node->_v__ast__ExprStmt).expr._v__ast__IfExpr));
		}
		else if ((*node->_v__ast__ExprStmt).expr._typ == 292 /* v.ast.MatchExpr */) {
			_t3 = v__transformer__Transformer_expr_stmt_match_expr(t, (voidptr)&(*(*node->_v__ast__ExprStmt).expr._v__ast__MatchExpr));
		}
		
		else {
			_t3 = v__transformer__Transformer_expr(t, &(*node->_v__ast__ExprStmt).expr);
		}
		(*node->_v__ast__ExprStmt).expr = _t3;
		if (((*node->_v__ast__ExprStmt).expr)._typ == 267 /* v.ast.CallExpr */ && (*(v__ast__CallExpr*)builtin____as_cast(((*node->_v__ast__ExprStmt).expr)._v__ast__CallExpr,((*node->_v__ast__ExprStmt).expr)._typ, 267)).is_expand_simple_interpolation) {
			v__transformer__Transformer_simplify_nested_interpolation_in_sb(t, onode, (voidptr)&(*(*node->_v__ast__ExprStmt).expr._v__ast__CallExpr), (*node->_v__ast__ExprStmt).typ);
		}
	}
	else if (node->_typ == 229 /* v.ast.FnDecl */) {
		v__transformer__Transformer_fn_decl(t, &/*mut*/(*node->_v__ast__FnDecl));
	}
	else if (node->_typ == 322 /* v.ast.ForCStmt */) {
		v__transformer__Transformer_for_c_stmt(t, &/*mut*/(*node->_v__ast__ForCStmt));
	}
	else if (node->_typ == 323 /* v.ast.ForInStmt */) {
		v__transformer__IndexState_indent(t->index, false);
		for (int _t4 = 0; _t4 < (*node->_v__ast__ForInStmt).stmts.len; ++_t4) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__ForInStmt).stmts.data) + _t4;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	else if (node->_typ == 324 /* v.ast.ForStmt */) {
		return v__transformer__Transformer_for_stmt(t, &/*mut*/(*node->_v__ast__ForStmt));
	}
	else if (node->_typ == 325 /* v.ast.GlobalDecl */) {
		v__transformer__Transformer_global_decl(t, &/*mut*/(*node->_v__ast__GlobalDecl));
	}
	else if (node->_typ == 326 /* v.ast.GotoLabel */) {
	}
	else if (node->_typ == 327 /* v.ast.GotoStmt */) {
		t->index->disabled = true;
	}
	else if (node->_typ == 328 /* v.ast.HashStmt */) {
		for (int _t6 = 0; _t6 < (*node->_v__ast__HashStmt).ct_conds.len; ++_t6) {
			v__ast__Expr* cond = ((v__ast__Expr*)(*node->_v__ast__HashStmt).ct_conds.data) + _t6;
			*cond = v__transformer__Transformer_expr(t, cond);
		}
	}
	else if (node->_typ == 329 /* v.ast.Import */) {
	}
	else if (node->_typ == 330 /* v.ast.InterfaceDecl */) {
		v__transformer__Transformer_interface_decl(t, &/*mut*/(*node->_v__ast__InterfaceDecl));
	}
	else if (node->_typ == 331 /* v.ast.Module */) {
	}
	else if (node->_typ == 332 /* v.ast.Return */) {
		for (int _t7 = 0; _t7 < (*node->_v__ast__Return).exprs.len; ++_t7) {
			v__ast__Expr* expr = ((v__ast__Expr*)(*node->_v__ast__Return).exprs.data) + _t7;
			*expr = v__transformer__Transformer_expr(t, expr);
		}
	}
	else if (node->_typ == 333 /* v.ast.SemicolonStmt */) {
	}
	else if (node->_typ == 334 /* v.ast.SqlStmt */) {
	}
	else if (node->_typ == 228 /* v.ast.StructDecl */) {
		v__transformer__Transformer_struct_decl(t, &/*mut*/(*node->_v__ast__StructDecl));
	}
	else if (node->_typ == 257 /* v.ast.TypeDecl */) {
	}
	
	return *node;
}
void v__transformer__Transformer_comptime_for(v__transformer__Transformer* t, v__ast__ComptimeFor* node) {
	for (int _t1 = 0; _t1 < node->stmts.len; ++_t1) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)node->stmts.data) + _t1;
		*stmt = v__transformer__Transformer_stmt(t, stmt);
	}
}
void v__transformer__Transformer_assign_stmt(v__transformer__Transformer* t, v__ast__AssignStmt* node) {
	v__transformer__Transformer_find_new_array_len(t, *node);
	v__transformer__Transformer_find_new_range(t, *node);
	v__transformer__Transformer_find_mut_self_assign(t, *node);
	for (int _t1 = 0; _t1 < node->right.len; ++_t1) {
		v__ast__Expr* right = ((v__ast__Expr*)node->right.data) + _t1;
		*right = v__transformer__Transformer_expr(t, right);
	}
	for (int _t2 = 0; _t2 < node->left.len; ++_t2) {
		v__ast__Expr* left = ((v__ast__Expr*)node->left.data) + _t2;
		*left = v__transformer__Transformer_expr(t, left);
	}
}
void v__transformer__Transformer_const_decl(v__transformer__Transformer* t, v__ast__ConstDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__ConstField* field = ((v__ast__ConstField*)node->fields.data) + _t1;
		field->expr = v__transformer__Transformer_expr(t, &field->expr);
	}
}
void v__transformer__Transformer_enum_decl(v__transformer__Transformer* t, v__ast__EnumDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__EnumField* field = ((v__ast__EnumField*)node->fields.data) + _t1;
		if (field->has_expr) {
			field->expr = v__transformer__Transformer_expr(t, &field->expr);
		}
	}
}
void v__transformer__Transformer_global_decl(v__transformer__Transformer* t, v__ast__GlobalDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__GlobalField* field = ((v__ast__GlobalField*)node->fields.data) + _t1;
		field->expr = v__transformer__Transformer_expr(t, &field->expr);
	}
}
void v__transformer__Transformer_interface_decl(v__transformer__Transformer* t, v__ast__InterfaceDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__StructField* field = ((v__ast__StructField*)node->fields.data) + _t1;
		field->default_expr = v__transformer__Transformer_expr(t, &field->default_expr);
	}
}
void v__transformer__Transformer_struct_decl(v__transformer__Transformer* t, v__ast__StructDecl* node) {
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__StructField* field = ((v__ast__StructField*)node->fields.data) + _t1;
		field->default_expr = v__transformer__Transformer_expr(t, &field->default_expr);
	}
}
void v__transformer__Transformer_assert_stmt(v__transformer__Transformer* t, v__ast__AssertStmt* node) {
	t->is_assert = true;
	node->expr = v__transformer__Transformer_expr(t, &node->expr);
	if (!t->pref->is_prod) {
		return;
	}
	if ((node->expr)._typ == 285 /* v.ast.InfixExpr */) {
		v__ast__Expr right = (*node->expr._v__ast__InfixExpr).right;
		if (right._typ == 286 /* v.ast.IntegerLiteral */) {
			v__ast__Expr left = (*node->expr._v__ast__InfixExpr).left;
			if ((left)._typ == 302 /* v.ast.SelectorExpr */) {
				int len = builtin__string_int((*right._v__ast__IntegerLiteral).val);
				if (builtin__fast_string_eq((*left._v__ast__SelectorExpr).field_name, _S("len"))) {

					if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__eq)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), (int)(len - 1));
					}
					else if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__ge)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), (int)(len - 1));
					}
					else if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__gt)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*left._v__ast__SelectorExpr).expr), len);
					}
					else {
					}
				}
			}
		}
		else if (right._typ == 302 /* v.ast.SelectorExpr */) {
			v__ast__Expr left = (*node->expr._v__ast__InfixExpr).left;
			if ((left)._typ == 286 /* v.ast.IntegerLiteral */) {
				int len = builtin__string_int((*left._v__ast__IntegerLiteral).val);
				if (builtin__fast_string_eq((*right._v__ast__SelectorExpr).field_name, _S("len"))) {

					if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__eq)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), (int)(len - 1));
					}
					else if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__le)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), (int)(len - 1));
					}
					else if ((*node->expr._v__ast__InfixExpr).op == (v__token__Kind__lt)) {
						v__transformer__IndexState_safe_access(t->index, v__ast__Expr_str((*right._v__ast__SelectorExpr).expr), len);
					}
					else {
					}
				}
			}
		}
		
		else {
		}
		
	}
	t->is_assert = false;
}
v__ast__Expr v__transformer__Transformer_expr_stmt_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* node) {
	int stop_index = -1;
	Array_int unreachable_branches = builtin____new_array_with_default(0, node->branches.len, sizeof(int), 0);
	if (node->is_comptime) {
		return v__ast__IfExpr_to_sumtype_v__ast__Expr(node, false);
	}
	for (int i = 0; i < node->branches.len; ++i) {
		v__ast__IfBranch* branch = ((v__ast__IfBranch*)node->branches.data) + i;
		v__ast__Expr cond = v__transformer__Transformer_expr(t, &branch->cond);
		*branch = ((v__ast__IfBranch){.pos = ((*branch)).pos,.body_pos = ((*branch)).body_pos,.comments = ((*branch)).comments,.cond = cond,.stmts = ((*branch)).stmts,.scope = ((*branch)).scope,.id = ((*branch)).id,});
		if ((cond)._typ == 265 /* v.ast.BoolLiteral */) {
			if ((*cond._v__ast__BoolLiteral).val) {
				stop_index = i;
				break;
			} else {
				builtin__array_push((array*)&unreachable_branches, _MOV((int[]){ i }));
			}
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int _t3 = 0; _t3 < branch->stmts.len; ++_t3) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t3;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
	}
	if (stop_index != -1) {
		Array_int _t4 = {0};
		Array_int _t4_orig = unreachable_branches;
		int _t4_len = _t4_orig.len;
		_t4 = builtin____new_array(0, _t4_len, sizeof(int));

		for (int _t5 = 0; _t5 < _t4_len; ++_t5) {
			int it = ((int*) _t4_orig.data)[_t5];
			if (it < stop_index) {
				builtin__array_push((array*)&_t4, &it);
			}
		}
		unreachable_branches =_t4;
		node->branches = builtin__array_slice(node->branches, 0, (int)(stop_index + 1));
	}
	for (;;) {
		if (!(unreachable_branches.len != 0)) break;
		builtin__array_delete(&node->branches, (*(int*)builtin__array_pop(&unreachable_branches)));
	}
	if (node->branches.len == 1 && builtin__string__eq(builtin__charptr_vstring_literal(v_typeof_sumtype_v__ast__Expr( ((*(v__ast__IfBranch*)builtin__array_get(node->branches, 0)).cond)._typ )), _S("unknown v.ast.Expr"))) {
		(*(v__ast__IfBranch*)builtin__array_get(node->branches, 0)).cond = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = true,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
	}
	return v__ast__IfExpr_to_sumtype_v__ast__Expr(node, false);
}
v__ast__Expr v__transformer__Transformer_expr_stmt_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* node) {
	bool terminate = false;
	v__ast__Expr cond = v__transformer__Transformer_expr(t, &node->cond);
	node->cond = cond;
	for (int _t1 = 0; _t1 < node->branches.len; ++_t1) {
		v__ast__MatchBranch* branch = ((v__ast__MatchBranch*)node->branches.data) + _t1;
		if (branch->is_else) {
			v__transformer__IndexState_indent(t->index, false);
			for (int _t2 = 0; _t2 < branch->stmts.len; ++_t2) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t2;
				*stmt = v__transformer__Transformer_stmt(t, stmt);
			}
			v__transformer__IndexState_unindent(t->index);
			continue;
		}
		for (int _t3 = 0; _t3 < branch->exprs.len; ++_t3) {
			v__ast__Expr* expr = ((v__ast__Expr*)branch->exprs.data) + _t3;
			*expr = v__transformer__Transformer_expr(t, expr);
			if (cond._typ == 265 /* v.ast.BoolLiteral */) {
				if ((expr)->_typ == 265 /* v.ast.BoolLiteral */) {
					if ((*cond._v__ast__BoolLiteral).val == (*expr->_v__ast__BoolLiteral).val) {
						branch->exprs = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){v__ast__BoolLiteral_to_sumtype_v__ast__Expr(&(*expr->_v__ast__BoolLiteral), false)}));
						node->branches = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch}));
						terminate = true;
					}
				}
			}
			else if (cond._typ == 286 /* v.ast.IntegerLiteral */) {
				if ((expr)->_typ == 286 /* v.ast.IntegerLiteral */) {
					if (builtin__string_int((*cond._v__ast__IntegerLiteral).val) == builtin__string_int((*expr->_v__ast__IntegerLiteral).val)) {
						branch->exprs = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(&(*expr->_v__ast__IntegerLiteral), false)}));
						node->branches = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch}));
						terminate = true;
					}
				}
			}
			else if (cond._typ == 279 /* v.ast.FloatLiteral */) {
				if ((expr)->_typ == 279 /* v.ast.FloatLiteral */) {
					if (builtin__string_f32((*cond._v__ast__FloatLiteral).val) == builtin__string_f32((*expr->_v__ast__FloatLiteral).val)) {
						branch->exprs = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){v__ast__FloatLiteral_to_sumtype_v__ast__Expr(&(*expr->_v__ast__FloatLiteral), false)}));
						node->branches = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch}));
						terminate = true;
					}
				}
			}
			else if (cond._typ == 237 /* v.ast.StringLiteral */) {
				if ((expr)->_typ == 237 /* v.ast.StringLiteral */) {
					if (builtin__string__eq((*cond._v__ast__StringLiteral).val, (*expr->_v__ast__StringLiteral).val)) {
						branch->exprs = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Expr), _MOV((v__ast__Expr[1]){v__ast__StringLiteral_to_sumtype_v__ast__Expr(&(*expr->_v__ast__StringLiteral), false)}));
						node->branches = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__MatchBranch), _MOV((v__ast__MatchBranch[1]){*branch}));
						terminate = true;
					}
				}
			}
			
			else {
			}
			
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int _t4 = 0; _t4 < branch->stmts.len; ++_t4) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t4;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		v__transformer__IndexState_unindent(t->index);
		if (terminate) {
			break;
		}
	}
	return v__ast__MatchExpr_to_sumtype_v__ast__Expr(node, false);
}
void v__transformer__Transformer_for_c_stmt(v__transformer__Transformer* t, v__ast__ForCStmt* node) {
	if (node->has_init && !node->is_multi) {
		node->init = v__transformer__Transformer_stmt(t, &node->init);
	}
	if (node->has_cond) {
		node->cond = v__transformer__Transformer_expr(t, &node->cond);
	}
	v__transformer__IndexState_indent(t->index, false);
	for (int _t1 = 0; _t1 < node->stmts.len; ++_t1) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)node->stmts.data) + _t1;
		*stmt = v__transformer__Transformer_stmt(t, stmt);
	}
	v__transformer__IndexState_unindent(t->index);
	if (node->has_inc && !node->is_multi) {
		node->inc = v__transformer__Transformer_stmt(t, &node->inc);
	}
}
v__ast__Stmt v__transformer__Transformer_for_stmt(v__transformer__Transformer* t, v__ast__ForStmt* node) {
	node->cond = v__transformer__Transformer_expr(t, &node->cond);
	if (node->cond._typ == 265 /* v.ast.BoolLiteral */) {
		if (!(*(v__ast__BoolLiteral*)builtin____as_cast((node->cond)._v__ast__BoolLiteral,(node->cond)._typ, 265)).val) {
			return _const_v__ast__empty_stmt;
		}
	}
	
	else {
		if (!node->is_inf) {
			v__transformer__IndexState_indent(t->index, false);
			for (int _t2 = 0; _t2 < node->stmts.len; ++_t2) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)node->stmts.data) + _t2;
				*stmt = v__transformer__Transformer_stmt(t, stmt);
			}
			v__transformer__IndexState_unindent(t->index);
			return v__ast__ForStmt_to_sumtype_v__ast__Stmt(node, false);
		}
	}
	
	for (int _t4 = 0; _t4 < node->stmts.len; ++_t4) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)node->stmts.data) + _t4;
		*stmt = v__transformer__Transformer_stmt(t, stmt);
	}
	return v__ast__ForStmt_to_sumtype_v__ast__Stmt(node, false);
}
v__ast__Expr v__transformer__Transformer_expr(v__transformer__Transformer* t, v__ast__Expr* node) {
	if (t->inside_dump) {
		return *node;
	}
	if (node->_typ == 259 /* v.ast.AnonFn */) {
		(*node->_v__ast__AnonFn).decl = ({ v__ast__Stmt _t2 = v__transformer__Transformer_stmt(t, HEAP(v__ast__Stmt, v__ast__FnDecl_to_sumtype_v__ast__Stmt(&(*node->_v__ast__AnonFn).decl, true))); *(v__ast__FnDecl*)builtin____as_cast(_t2._v__ast__FnDecl,_t2._typ, 229); });
	}
	else if (node->_typ == 260 /* v.ast.ArrayDecompose */) {
		(*node->_v__ast__ArrayDecompose).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__ArrayDecompose).expr);
	}
	else if (node->_typ == 261 /* v.ast.ArrayInit */) {
		return v__transformer__Transformer_array_init(t, &/*mut*/(*node->_v__ast__ArrayInit));
	}
	else if (node->_typ == 262 /* v.ast.AsCast */) {
		(*node->_v__ast__AsCast).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__AsCast).expr);
	}
	else if (node->_typ == 266 /* v.ast.CTempVar */) {
		(*node->_v__ast__CTempVar).orig = v__transformer__Transformer_expr(t, &(*node->_v__ast__CTempVar).orig);
	}
	else if (node->_typ == 267 /* v.ast.CallExpr */) {
		(*node->_v__ast__CallExpr).left = v__transformer__Transformer_expr(t, &(*node->_v__ast__CallExpr).left);
		for (int _t4 = 0; _t4 < (*node->_v__ast__CallExpr).args.len; ++_t4) {
			v__ast__CallArg* arg = ((v__ast__CallArg*)(*node->_v__ast__CallExpr).args.data) + _t4;
			arg->expr = v__transformer__Transformer_expr(t, &arg->expr);
		}
		(*node->_v__ast__CallExpr).or_block = ({ v__ast__Expr _t5 = v__transformer__Transformer_expr(t, HEAP(v__ast__Expr, v__ast__OrExpr_to_sumtype_v__ast__Expr(&(*node->_v__ast__CallExpr).or_block, true))); *(v__ast__OrExpr*)builtin____as_cast(_t5._v__ast__OrExpr,_t5._typ, 296); });
	}
	else if (node->_typ == 268 /* v.ast.CastExpr */) {
		(*node->_v__ast__CastExpr).arg = v__transformer__Transformer_expr(t, &(*node->_v__ast__CastExpr).arg);
		(*node->_v__ast__CastExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__CastExpr).expr);
	}
	else if (node->_typ == 269 /* v.ast.ChanInit */) {
		(*node->_v__ast__ChanInit).cap_expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__ChanInit).cap_expr);
	}
	else if (node->_typ == 272 /* v.ast.ComptimeCall */) {
		for (int _t6 = 0; _t6 < (*node->_v__ast__ComptimeCall).args.len; ++_t6) {
			v__ast__CallArg* arg = ((v__ast__CallArg*)(*node->_v__ast__ComptimeCall).args.data) + _t6;
			arg->expr = v__transformer__Transformer_expr(t, &arg->expr);
		}
	}
	else if (node->_typ == 273 /* v.ast.ComptimeSelector */) {
		(*node->_v__ast__ComptimeSelector).left = v__transformer__Transformer_expr(t, &(*node->_v__ast__ComptimeSelector).left);
		(*node->_v__ast__ComptimeSelector).field_expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__ComptimeSelector).field_expr);
	}
	else if (node->_typ == 275 /* v.ast.ConcatExpr */) {
		for (int _t7 = 0; _t7 < (*node->_v__ast__ConcatExpr).vals.len; ++_t7) {
			v__ast__Expr* val = ((v__ast__Expr*)(*node->_v__ast__ConcatExpr).vals.data) + _t7;
			*val = v__transformer__Transformer_expr(t, val);
		}
	}
	else if (node->_typ == 276 /* v.ast.DumpExpr */) {
		bool old_inside_dump = t->inside_dump;
		t->inside_dump = true;
		(*node->_v__ast__DumpExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__DumpExpr).expr);
		t->inside_dump = old_inside_dump;
	}
	else if (node->_typ == 280 /* v.ast.GoExpr */) {
		v__transformer__Transformer_expr(t, HEAP(v__ast__Expr, v__ast__CallExpr_to_sumtype_v__ast__Expr(&(*node->_v__ast__GoExpr).call_expr, true)));
	}
	else if (node->_typ == 282 /* v.ast.IfExpr */) {
		return v__transformer__Transformer_if_expr(t, &/*mut*/(*node->_v__ast__IfExpr));
	}
	else if (node->_typ == 283 /* v.ast.IfGuardExpr */) {
		(*node->_v__ast__IfGuardExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__IfGuardExpr).expr);
	}
	else if (node->_typ == 284 /* v.ast.IndexExpr */) {
		v__transformer__Transformer_check_safe_array(t, &/*mut*/(*node->_v__ast__IndexExpr));
		(*node->_v__ast__IndexExpr).left = v__transformer__Transformer_expr(t, &(*node->_v__ast__IndexExpr).left);
		(*node->_v__ast__IndexExpr).index = v__transformer__Transformer_expr(t, &(*node->_v__ast__IndexExpr).index);
		(*node->_v__ast__IndexExpr).or_expr = ({ v__ast__Expr _t9 = v__transformer__Transformer_expr(t, HEAP(v__ast__Expr, v__ast__OrExpr_to_sumtype_v__ast__Expr(&(*node->_v__ast__IndexExpr).or_expr, true))); *(v__ast__OrExpr*)builtin____as_cast(_t9._v__ast__OrExpr,_t9._typ, 296); });
	}
	else if (node->_typ == 285 /* v.ast.InfixExpr */) {
		return v__transformer__Transformer_infix_expr(t, &/*mut*/(*node->_v__ast__InfixExpr));
	}
	else if (node->_typ == 287 /* v.ast.IsRefType */) {
		(*node->_v__ast__IsRefType).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__IsRefType).expr);
	}
	else if (node->_typ == 289 /* v.ast.Likely */) {
		(*node->_v__ast__Likely).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__Likely).expr);
	}
	else if (node->_typ == 290 /* v.ast.LockExpr */) {
		for (int _t11 = 0; _t11 < (*node->_v__ast__LockExpr).stmts.len; ++_t11) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__LockExpr).stmts.data) + _t11;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		for (int _t12 = 0; _t12 < (*node->_v__ast__LockExpr).lockeds.len; ++_t12) {
			v__ast__Expr* locked = ((v__ast__Expr*)(*node->_v__ast__LockExpr).lockeds.data) + _t12;
			*locked = v__transformer__Transformer_expr(t, locked);
		}
	}
	else if (node->_typ == 291 /* v.ast.MapInit */) {
		for (int _t13 = 0; _t13 < (*node->_v__ast__MapInit).keys.len; ++_t13) {
			v__ast__Expr* key = ((v__ast__Expr*)(*node->_v__ast__MapInit).keys.data) + _t13;
			*key = v__transformer__Transformer_expr(t, key);
		}
		for (int _t14 = 0; _t14 < (*node->_v__ast__MapInit).vals.len; ++_t14) {
			v__ast__Expr* val = ((v__ast__Expr*)(*node->_v__ast__MapInit).vals.data) + _t14;
			*val = v__transformer__Transformer_expr(t, val);
		}
	}
	else if (node->_typ == 292 /* v.ast.MatchExpr */) {
		return v__transformer__Transformer_match_expr(t, &/*mut*/(*node->_v__ast__MatchExpr));
	}
	else if (node->_typ == 296 /* v.ast.OrExpr */) {
		for (int _t16 = 0; _t16 < (*node->_v__ast__OrExpr).stmts.len; ++_t16) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)(*node->_v__ast__OrExpr).stmts.data) + _t16;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
		}
		if ((*node->_v__ast__OrExpr).stmts.len > 0) {
			v__ast__Stmt stmt = (*(v__ast__Stmt*)builtin__array_last((*node->_v__ast__OrExpr).stmts));
			if ((stmt)._typ == 321 /* v.ast.ExprStmt */ && ((*(v__ast__ExprStmt*)builtin____as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 321)).expr)._typ == 267 /* v.ast.CallExpr */) {
				(*(v__ast__CallExpr*)builtin____as_cast(((*(v__ast__ExprStmt*)builtin____as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 321)).expr)._v__ast__CallExpr,((*(v__ast__ExprStmt*)builtin____as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 321)).expr)._typ, 267)).is_return_used = true;
			}
		}
	}
	else if (node->_typ == 297 /* v.ast.ParExpr */) {
		v__ast__Expr inner_expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__ParExpr).expr);
		if ((inner_expr)._typ == 286 /* v.ast.IntegerLiteral */ || (inner_expr)._typ == 279 /* v.ast.FloatLiteral */ || (inner_expr)._typ == 265 /* v.ast.BoolLiteral */ || (inner_expr)._typ == 237 /* v.ast.StringLiteral */ || (inner_expr)._typ == 306 /* v.ast.StringInterLiteral */ || (inner_expr)._typ == 270 /* v.ast.CharLiteral */ || (inner_expr)._typ == 281 /* v.ast.Ident */) {
			return inner_expr;
		}
	}
	else if (node->_typ == 298 /* v.ast.PostfixExpr */) {
		(*node->_v__ast__PostfixExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__PostfixExpr).expr);
	}
	else if (node->_typ == 299 /* v.ast.PrefixExpr */) {
		(*node->_v__ast__PrefixExpr).right = v__transformer__Transformer_expr(t, &(*node->_v__ast__PrefixExpr).right);
		(*node->_v__ast__PrefixExpr).or_block = ({ v__ast__Expr _t18 = v__transformer__Transformer_expr(t, HEAP(v__ast__Expr, v__ast__OrExpr_to_sumtype_v__ast__Expr(&(*node->_v__ast__PrefixExpr).or_block, true))); *(v__ast__OrExpr*)builtin____as_cast(_t18._v__ast__OrExpr,_t18._typ, 296); });
	}
	else if (node->_typ == 300 /* v.ast.RangeExpr */) {
		(*node->_v__ast__RangeExpr).low = v__transformer__Transformer_expr(t, &(*node->_v__ast__RangeExpr).low);
		(*node->_v__ast__RangeExpr).high = v__transformer__Transformer_expr(t, &(*node->_v__ast__RangeExpr).high);
	}
	else if (node->_typ == 301 /* v.ast.SelectExpr */) {
		for (int _t19 = 0; _t19 < (*node->_v__ast__SelectExpr).branches.len; ++_t19) {
			v__ast__SelectBranch* branch = ((v__ast__SelectBranch*)(*node->_v__ast__SelectExpr).branches.data) + _t19;
			branch->stmt = v__transformer__Transformer_stmt(t, &branch->stmt);
			for (int _t20 = 0; _t20 < branch->stmts.len; ++_t20) {
				v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + _t20;
				*stmt = v__transformer__Transformer_stmt(t, stmt);
			}
		}
	}
	else if (node->_typ == 302 /* v.ast.SelectorExpr */) {
		(*node->_v__ast__SelectorExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__SelectorExpr).expr);
		if (((*node->_v__ast__SelectorExpr).expr)._typ == 237 /* v.ast.StringLiteral */ && builtin__fast_string_eq((*node->_v__ast__SelectorExpr).field_name, _S("len"))) {
			if (!builtin__string_contains((*(*node->_v__ast__SelectorExpr).expr._v__ast__StringLiteral).val, _S("\\")) || (*(*node->_v__ast__SelectorExpr).expr._v__ast__StringLiteral).is_raw) {
				return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__int_str((*(*node->_v__ast__SelectorExpr).expr._v__ast__StringLiteral).val.len),.pos = (*node->_v__ast__SelectorExpr).pos,}))), false);
			}
		}
	}
	else if (node->_typ == 303 /* v.ast.SizeOf */) {
		(*node->_v__ast__SizeOf).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__SizeOf).expr);
	}
	else if (node->_typ == 305 /* v.ast.SqlExpr */) {
		return v__transformer__Transformer_sql_expr(t, &/*mut*/(*node->_v__ast__SqlExpr));
	}
	else if (node->_typ == 306 /* v.ast.StringInterLiteral */) {
		for (int _t23 = 0; _t23 < (*node->_v__ast__StringInterLiteral).exprs.len; ++_t23) {
			v__ast__Expr* expr = ((v__ast__Expr*)(*node->_v__ast__StringInterLiteral).exprs.data) + _t23;
			*expr = v__transformer__Transformer_expr(t, expr);
		}
	}
	else if (node->_typ == 236 /* v.ast.StructInit */) {
		(*node->_v__ast__StructInit).update_expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__StructInit).update_expr);
		for (int _t24 = 0; _t24 < (*node->_v__ast__StructInit).init_fields.len; ++_t24) {
			v__ast__StructInitField* init_field = ((v__ast__StructInitField*)(*node->_v__ast__StructInit).init_fields.data) + _t24;
			init_field->expr = v__transformer__Transformer_expr(t, &init_field->expr);
		}
	}
	else if (node->_typ == 309 /* v.ast.UnsafeExpr */) {
		(*node->_v__ast__UnsafeExpr).expr = v__transformer__Transformer_expr(t, &(*node->_v__ast__UnsafeExpr).expr);
	}
	else if (node->_typ == 264 /* v.ast.AtExpr */) {
	}
	
	else {
	}
	
	return *node;
}
void v__transformer__Transformer_call_expr(v__transformer__Transformer* t, v__ast__CallExpr* node) {
	for (int _t1 = 0; _t1 < node->args.len; ++_t1) {
		v__ast__CallArg* arg = ((v__ast__CallArg*)node->args.data) + _t1;
		arg->expr = v__transformer__Transformer_expr(t, &arg->expr);
	}
}
VV_LOC void v__transformer__Transformer_trans_const_value_to_literal(v__transformer__Transformer* t, v__ast__Expr* expr) {
	v__ast__Expr expr_ = *expr;
	if ((expr_)._typ == 281 /* v.ast.Ident */) {
		_option_v__ast__Var_ptr _t1;
		if (_t1 = v__ast__Scope_find_var((*expr_._v__ast__Ident).scope, (*expr_._v__ast__Ident).name), _t1.state == 0) {
			return;
		}
		_option_v__ast__ConstField_ptr _t2;
		if (_t2 = v__ast__Scope_find_const(t->table->global_scope, v__ast__Ident_full_name(&(*expr_._v__ast__Ident))), _t2.state == 0) {
			v__ast__ConstField* obj = *(v__ast__ConstField**)_t2.data;
			if ((obj->expr)._typ == 265 /* v.ast.BoolLiteral */) {
				*expr = obj->expr;
			} else if ((obj->expr)._typ == 286 /* v.ast.IntegerLiteral */) {
				*expr = obj->expr;
			} else if ((obj->expr)._typ == 279 /* v.ast.FloatLiteral */) {
				*expr = obj->expr;
			} else if ((obj->expr)._typ == 237 /* v.ast.StringLiteral */) {
				*expr = obj->expr;
			} else if ((obj->expr)._typ == 285 /* v.ast.InfixExpr */) {
				v__ast__Expr folded_expr = v__transformer__Transformer_infix_expr(t, (voidptr)&(*obj->expr._v__ast__InfixExpr));
				if ((folded_expr)._typ == 265 /* v.ast.BoolLiteral */) {
					*expr = folded_expr;
				} else if ((folded_expr)._typ == 286 /* v.ast.IntegerLiteral */) {
					*expr = folded_expr;
				} else if ((folded_expr)._typ == 279 /* v.ast.FloatLiteral */) {
					*expr = folded_expr;
				} else if ((folded_expr)._typ == 237 /* v.ast.StringLiteral */) {
					*expr = folded_expr;
				}
			}
		}
	}
}
v__ast__Expr v__transformer__Transformer_infix_expr(v__transformer__Transformer* t, v__ast__InfixExpr* node) {
	if (node->op == v__token__Kind__not_in || node->op == v__token__Kind__key_in) {
		bool tmp_inside_in = t->inside_in;
		t->inside_in = true;
		node->left = v__transformer__Transformer_expr(t, &node->left);
		node->right = v__transformer__Transformer_expr(t, &node->right);
		t->inside_in = tmp_inside_in;
	} else {
		node->left = v__transformer__Transformer_expr(t, &node->left);
		node->right = v__transformer__Transformer_expr(t, &node->right);
	}
	if (!t->pref->translated) {
		v__transformer__Transformer_trans_const_value_to_literal(t, &node->left);
		v__transformer__Transformer_trans_const_value_to_literal(t, &node->right);
	}
	v__token__Pos pos = v__ast__Expr_pos(node->left);
	v__token__Pos_extend(pos, node->pos);
	v__token__Pos_extend(pos, v__ast__Expr_pos(node->right));
	if (t->pref->is_debug || t->is_assert) {
		return v__ast__InfixExpr_to_sumtype_v__ast__Expr(node, false);
	} else {
		if (node->left._typ == 265 /* v.ast.BoolLiteral */) {
			if (node->right._typ == 265 /* v.ast.BoolLiteral */) {

				if (node->op == (v__token__Kind__eq)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = (*node->left._v__ast__BoolLiteral).val == (*node->right._v__ast__BoolLiteral).val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else if (node->op == (v__token__Kind__ne)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = (*node->left._v__ast__BoolLiteral).val != (*node->right._v__ast__BoolLiteral).val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else if (node->op == (v__token__Kind__and)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = (*node->left._v__ast__BoolLiteral).val && (*node->right._v__ast__BoolLiteral).val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else if (node->op == (v__token__Kind__logical_or)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = (*node->left._v__ast__BoolLiteral).val || (*node->right._v__ast__BoolLiteral).val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else {
				}
			}
			
			else {
			}
			
		}
		else if (node->left._typ == 237 /* v.ast.StringLiteral */) {
			if (node->right._typ == 237 /* v.ast.StringLiteral */) {

				if (node->op == (v__token__Kind__eq)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = builtin__string__eq((*node->left._v__ast__StringLiteral).val, (*node->right._v__ast__StringLiteral).val),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else if (node->op == (v__token__Kind__ne)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = !builtin__string__eq((*node->left._v__ast__StringLiteral).val, (*node->right._v__ast__StringLiteral).val),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
				else if (node->op == (v__token__Kind__plus)) {
					return (t->pref->backend == v__pref__Backend__c ? (v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, (((v__ast__StringLiteral){.val = builtin__string__plus(v__util__smart_quote((*node->left._v__ast__StringLiteral).val, (*node->left._v__ast__StringLiteral).is_raw), v__util__smart_quote((*node->right._v__ast__StringLiteral).val, (*node->right._v__ast__StringLiteral).is_raw)),.pos = pos,.language = 0,.is_raw = 0,}))), false)) : (v__ast__InfixExpr_to_sumtype_v__ast__Expr(node, false)));
				}
				else {
				}
			}
			
			else {
			}
			
		}
		else if (node->left._typ == 286 /* v.ast.IntegerLiteral */) {
			if (node->right._typ == 286 /* v.ast.IntegerLiteral */) {
				i64 left_val = builtin__string_i64((*node->left._v__ast__IntegerLiteral).val);
				i64 right_val = builtin__string_i64((*node->right._v__ast__IntegerLiteral).val);
				switch (node->op) {
					case v__token__Kind__eq: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val == right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ne: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val != right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__gt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val > right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ge: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val >= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__lt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val < right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__le: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val <= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__plus: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((i64)(left_val + right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__mul: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((i64)(left_val * right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__minus: {
						if (left_val == -9223372036854775807LL && right_val == 1) {
							return v__ast__InfixExpr_to_sumtype_v__ast__Expr(node, false);
						}
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((i64)(left_val - right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__div: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((i64)(left_val / right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__mod: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((i64)(left_val % right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__xor: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((left_val ^ right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__pipe: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((left_val | right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__amp: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((left_val & right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__left_shift: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((left_val << right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__right_shift: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__i64_str(((left_val >> right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__unsigned_right_shift: {
						return v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = builtin__u64_str(((((u64)(((u64)(left_val)))) >> right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__unknown:
					case v__token__Kind__eof:
					case v__token__Kind__name:
					case v__token__Kind__number:
					case v__token__Kind__string:
					case v__token__Kind__str_inter:
					case v__token__Kind__chartoken:
					case v__token__Kind__inc:
					case v__token__Kind__dec:
					case v__token__Kind__and:
					case v__token__Kind__logical_or:
					case v__token__Kind__not:
					case v__token__Kind__bit_not:
					case v__token__Kind__question:
					case v__token__Kind__comma:
					case v__token__Kind__semicolon:
					case v__token__Kind__colon:
					case v__token__Kind__arrow:
					case v__token__Kind__hash:
					case v__token__Kind__dollar:
					case v__token__Kind__at:
					case v__token__Kind__str_dollar:
					case v__token__Kind__not_in:
					case v__token__Kind__not_is:
					case v__token__Kind__assign:
					case v__token__Kind__decl_assign:
					case v__token__Kind__plus_assign:
					case v__token__Kind__minus_assign:
					case v__token__Kind__div_assign:
					case v__token__Kind__mult_assign:
					case v__token__Kind__xor_assign:
					case v__token__Kind__mod_assign:
					case v__token__Kind__or_assign:
					case v__token__Kind__and_assign:
					case v__token__Kind__right_shift_assign:
					case v__token__Kind__left_shift_assign:
					case v__token__Kind__unsigned_right_shift_assign:
					case v__token__Kind__boolean_and_assign:
					case v__token__Kind__boolean_or_assign:
					case v__token__Kind__lcbr:
					case v__token__Kind__rcbr:
					case v__token__Kind__lpar:
					case v__token__Kind__rpar:
					case v__token__Kind__lsbr:
					case v__token__Kind__nilsbr:
					case v__token__Kind__rsbr:
					case v__token__Kind__comment:
					case v__token__Kind__nl:
					case v__token__Kind__dot:
					case v__token__Kind__dotdot:
					case v__token__Kind__ellipsis:
					case v__token__Kind__keyword_beg:
					case v__token__Kind__key_as:
					case v__token__Kind__key_asm:
					case v__token__Kind__key_assert:
					case v__token__Kind__key_atomic:
					case v__token__Kind__key_break:
					case v__token__Kind__key_const:
					case v__token__Kind__key_continue:
					case v__token__Kind__key_defer:
					case v__token__Kind__key_else:
					case v__token__Kind__key_enum:
					case v__token__Kind__key_false:
					case v__token__Kind__key_for:
					case v__token__Kind__key_fn:
					case v__token__Kind__key_global:
					case v__token__Kind__key_go:
					case v__token__Kind__key_goto:
					case v__token__Kind__key_if:
					case v__token__Kind__key_import:
					case v__token__Kind__key_in:
					case v__token__Kind__key_interface:
					case v__token__Kind__key_is:
					case v__token__Kind__key_match:
					case v__token__Kind__key_module:
					case v__token__Kind__key_mut:
					case v__token__Kind__key_nil:
					case v__token__Kind__key_shared:
					case v__token__Kind__key_lock:
					case v__token__Kind__key_rlock:
					case v__token__Kind__key_none:
					case v__token__Kind__key_return:
					case v__token__Kind__key_select:
					case v__token__Kind__key_like:
					case v__token__Kind__key_ilike:
					case v__token__Kind__key_sizeof:
					case v__token__Kind__key_isreftype:
					case v__token__Kind__key_likely:
					case v__token__Kind__key_unlikely:
					case v__token__Kind__key_offsetof:
					case v__token__Kind__key_struct:
					case v__token__Kind__key_true:
					case v__token__Kind__key_type:
					case v__token__Kind__key_typeof:
					case v__token__Kind__key_dump:
					case v__token__Kind__key_orelse:
					case v__token__Kind__key_union:
					case v__token__Kind__key_pub:
					case v__token__Kind__key_static:
					case v__token__Kind__key_volatile:
					case v__token__Kind__key_unsafe:
					case v__token__Kind__key_spawn:
					case v__token__Kind__key_implements:
					case v__token__Kind__keyword_end:
					case v__token__Kind___end_:
					default: {
						{
							break;
						}
					}
				}
				
			}
			
			else {
			}
			
		}
		else if (node->left._typ == 279 /* v.ast.FloatLiteral */) {
			if (node->right._typ == 279 /* v.ast.FloatLiteral */) {
				f64 left_val = builtin__string_f64((*node->left._v__ast__FloatLiteral).val);
				f64 right_val = builtin__string_f64((*node->right._v__ast__FloatLiteral).val);
				switch (node->op) {
					case v__token__Kind__eq: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val == right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ne: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val != right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__gt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val > right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ge: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val >= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__lt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val < right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__le: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val <= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__plus: {
						return v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = builtin__f64_str(((f64)(left_val + right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__mul: {
						return v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = builtin__f64_str(((f64)(left_val * right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__minus: {
						return v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = builtin__f64_str(((f64)(left_val - right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__div: {
						return v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = builtin__f64_str(((f64)(left_val / right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__unknown:
					case v__token__Kind__eof:
					case v__token__Kind__name:
					case v__token__Kind__number:
					case v__token__Kind__string:
					case v__token__Kind__str_inter:
					case v__token__Kind__chartoken:
					case v__token__Kind__mod:
					case v__token__Kind__xor:
					case v__token__Kind__pipe:
					case v__token__Kind__inc:
					case v__token__Kind__dec:
					case v__token__Kind__and:
					case v__token__Kind__logical_or:
					case v__token__Kind__not:
					case v__token__Kind__bit_not:
					case v__token__Kind__question:
					case v__token__Kind__comma:
					case v__token__Kind__semicolon:
					case v__token__Kind__colon:
					case v__token__Kind__arrow:
					case v__token__Kind__amp:
					case v__token__Kind__hash:
					case v__token__Kind__dollar:
					case v__token__Kind__at:
					case v__token__Kind__str_dollar:
					case v__token__Kind__left_shift:
					case v__token__Kind__right_shift:
					case v__token__Kind__unsigned_right_shift:
					case v__token__Kind__not_in:
					case v__token__Kind__not_is:
					case v__token__Kind__assign:
					case v__token__Kind__decl_assign:
					case v__token__Kind__plus_assign:
					case v__token__Kind__minus_assign:
					case v__token__Kind__div_assign:
					case v__token__Kind__mult_assign:
					case v__token__Kind__xor_assign:
					case v__token__Kind__mod_assign:
					case v__token__Kind__or_assign:
					case v__token__Kind__and_assign:
					case v__token__Kind__right_shift_assign:
					case v__token__Kind__left_shift_assign:
					case v__token__Kind__unsigned_right_shift_assign:
					case v__token__Kind__boolean_and_assign:
					case v__token__Kind__boolean_or_assign:
					case v__token__Kind__lcbr:
					case v__token__Kind__rcbr:
					case v__token__Kind__lpar:
					case v__token__Kind__rpar:
					case v__token__Kind__lsbr:
					case v__token__Kind__nilsbr:
					case v__token__Kind__rsbr:
					case v__token__Kind__comment:
					case v__token__Kind__nl:
					case v__token__Kind__dot:
					case v__token__Kind__dotdot:
					case v__token__Kind__ellipsis:
					case v__token__Kind__keyword_beg:
					case v__token__Kind__key_as:
					case v__token__Kind__key_asm:
					case v__token__Kind__key_assert:
					case v__token__Kind__key_atomic:
					case v__token__Kind__key_break:
					case v__token__Kind__key_const:
					case v__token__Kind__key_continue:
					case v__token__Kind__key_defer:
					case v__token__Kind__key_else:
					case v__token__Kind__key_enum:
					case v__token__Kind__key_false:
					case v__token__Kind__key_for:
					case v__token__Kind__key_fn:
					case v__token__Kind__key_global:
					case v__token__Kind__key_go:
					case v__token__Kind__key_goto:
					case v__token__Kind__key_if:
					case v__token__Kind__key_import:
					case v__token__Kind__key_in:
					case v__token__Kind__key_interface:
					case v__token__Kind__key_is:
					case v__token__Kind__key_match:
					case v__token__Kind__key_module:
					case v__token__Kind__key_mut:
					case v__token__Kind__key_nil:
					case v__token__Kind__key_shared:
					case v__token__Kind__key_lock:
					case v__token__Kind__key_rlock:
					case v__token__Kind__key_none:
					case v__token__Kind__key_return:
					case v__token__Kind__key_select:
					case v__token__Kind__key_like:
					case v__token__Kind__key_ilike:
					case v__token__Kind__key_sizeof:
					case v__token__Kind__key_isreftype:
					case v__token__Kind__key_likely:
					case v__token__Kind__key_unlikely:
					case v__token__Kind__key_offsetof:
					case v__token__Kind__key_struct:
					case v__token__Kind__key_true:
					case v__token__Kind__key_type:
					case v__token__Kind__key_typeof:
					case v__token__Kind__key_dump:
					case v__token__Kind__key_orelse:
					case v__token__Kind__key_union:
					case v__token__Kind__key_pub:
					case v__token__Kind__key_static:
					case v__token__Kind__key_volatile:
					case v__token__Kind__key_unsafe:
					case v__token__Kind__key_spawn:
					case v__token__Kind__key_implements:
					case v__token__Kind__keyword_end:
					case v__token__Kind___end_:
					default: {
						{
							break;
						}
					}
				}
				
			}
			
			else {
			}
			
		}
		else if (node->left._typ == 270 /* v.ast.CharLiteral */) {
			if (node->right._typ == 270 /* v.ast.CharLiteral */) {
				rune left_val = (*(rune*)builtin__array_get(builtin__string_runes((*node->left._v__ast__CharLiteral).val), 0));
				rune right_val = (*(rune*)builtin__array_get(builtin__string_runes((*node->right._v__ast__CharLiteral).val), 0));
				switch (node->op) {
					case v__token__Kind__eq: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val == right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ne: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val != right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__gt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val > right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__ge: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val >= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__lt: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val < right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__le: {
						return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = left_val <= right_val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
					}
					case v__token__Kind__plus: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((rune)(left_val + right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__mul: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((rune)(left_val * right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__minus: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((rune)(left_val - right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__div: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((rune)(left_val / right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__mod: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((rune)(left_val % right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__xor: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((left_val ^ right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__pipe: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((left_val | right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__amp: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((left_val & right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__left_shift: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((left_val << right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__right_shift: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__rune_str(((left_val >> right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__unsigned_right_shift: {
						return v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = builtin__u64_str(((((u64)(((u64)(left_val)))) >> right_val))),.pos = pos,}))), false);
					}
					case v__token__Kind__unknown:
					case v__token__Kind__eof:
					case v__token__Kind__name:
					case v__token__Kind__number:
					case v__token__Kind__string:
					case v__token__Kind__str_inter:
					case v__token__Kind__chartoken:
					case v__token__Kind__inc:
					case v__token__Kind__dec:
					case v__token__Kind__and:
					case v__token__Kind__logical_or:
					case v__token__Kind__not:
					case v__token__Kind__bit_not:
					case v__token__Kind__question:
					case v__token__Kind__comma:
					case v__token__Kind__semicolon:
					case v__token__Kind__colon:
					case v__token__Kind__arrow:
					case v__token__Kind__hash:
					case v__token__Kind__dollar:
					case v__token__Kind__at:
					case v__token__Kind__str_dollar:
					case v__token__Kind__not_in:
					case v__token__Kind__not_is:
					case v__token__Kind__assign:
					case v__token__Kind__decl_assign:
					case v__token__Kind__plus_assign:
					case v__token__Kind__minus_assign:
					case v__token__Kind__div_assign:
					case v__token__Kind__mult_assign:
					case v__token__Kind__xor_assign:
					case v__token__Kind__mod_assign:
					case v__token__Kind__or_assign:
					case v__token__Kind__and_assign:
					case v__token__Kind__right_shift_assign:
					case v__token__Kind__left_shift_assign:
					case v__token__Kind__unsigned_right_shift_assign:
					case v__token__Kind__boolean_and_assign:
					case v__token__Kind__boolean_or_assign:
					case v__token__Kind__lcbr:
					case v__token__Kind__rcbr:
					case v__token__Kind__lpar:
					case v__token__Kind__rpar:
					case v__token__Kind__lsbr:
					case v__token__Kind__nilsbr:
					case v__token__Kind__rsbr:
					case v__token__Kind__comment:
					case v__token__Kind__nl:
					case v__token__Kind__dot:
					case v__token__Kind__dotdot:
					case v__token__Kind__ellipsis:
					case v__token__Kind__keyword_beg:
					case v__token__Kind__key_as:
					case v__token__Kind__key_asm:
					case v__token__Kind__key_assert:
					case v__token__Kind__key_atomic:
					case v__token__Kind__key_break:
					case v__token__Kind__key_const:
					case v__token__Kind__key_continue:
					case v__token__Kind__key_defer:
					case v__token__Kind__key_else:
					case v__token__Kind__key_enum:
					case v__token__Kind__key_false:
					case v__token__Kind__key_for:
					case v__token__Kind__key_fn:
					case v__token__Kind__key_global:
					case v__token__Kind__key_go:
					case v__token__Kind__key_goto:
					case v__token__Kind__key_if:
					case v__token__Kind__key_import:
					case v__token__Kind__key_in:
					case v__token__Kind__key_interface:
					case v__token__Kind__key_is:
					case v__token__Kind__key_match:
					case v__token__Kind__key_module:
					case v__token__Kind__key_mut:
					case v__token__Kind__key_nil:
					case v__token__Kind__key_shared:
					case v__token__Kind__key_lock:
					case v__token__Kind__key_rlock:
					case v__token__Kind__key_none:
					case v__token__Kind__key_return:
					case v__token__Kind__key_select:
					case v__token__Kind__key_like:
					case v__token__Kind__key_ilike:
					case v__token__Kind__key_sizeof:
					case v__token__Kind__key_isreftype:
					case v__token__Kind__key_likely:
					case v__token__Kind__key_unlikely:
					case v__token__Kind__key_offsetof:
					case v__token__Kind__key_struct:
					case v__token__Kind__key_true:
					case v__token__Kind__key_type:
					case v__token__Kind__key_typeof:
					case v__token__Kind__key_dump:
					case v__token__Kind__key_orelse:
					case v__token__Kind__key_union:
					case v__token__Kind__key_pub:
					case v__token__Kind__key_static:
					case v__token__Kind__key_volatile:
					case v__token__Kind__key_unsafe:
					case v__token__Kind__key_spawn:
					case v__token__Kind__key_implements:
					case v__token__Kind__keyword_end:
					case v__token__Kind___end_:
					default: {
						{
							break;
						}
					}
				}
				
			}
			
			else {
			}
			
		}
		
		else {
			if (!t->inside_sql && builtin__string__eq(builtin__charptr_vstring_literal(v_typeof_sumtype_v__ast__Expr( (node->left)._typ )), builtin__charptr_vstring_literal(v_typeof_sumtype_v__ast__Expr( (node->right)._typ ))) && !(node->left_type == _const_v__ast__f32_type || node->left_type == _const_v__ast__f64_type) && (node->op == v__token__Kind__eq || node->op == v__token__Kind__ne) && (node->left)._typ != 236 /* v.ast.StructInit */ && (node->right)._typ != 236 /* v.ast.StructInit */) {
				string left_name = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(node->left)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				string right_name = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(node->right)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				if (builtin__string__eq(left_name, right_name)) {
					return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = (node->op == v__token__Kind__eq ? (true) : (false)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
				}
			}
		}
		
		return v__ast__InfixExpr_to_sumtype_v__ast__Expr(node, false);
	}
	return (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258};
}
v__ast__Expr v__transformer__Transformer_if_expr(v__transformer__Transformer* t, v__ast__IfExpr* node) {
	for (int _t1 = 0; _t1 < node->branches.len; ++_t1) {
		v__ast__IfBranch* branch = ((v__ast__IfBranch*)node->branches.data) + _t1;
		branch->cond = v__transformer__Transformer_expr(t, &branch->cond);
		v__transformer__IndexState_indent(t->index, false);
		for (int i = 0; i < branch->stmts.len; ++i) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + i;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
			if (i == (int)(branch->stmts.len - 1)) {
				if ((stmt)->_typ == 321 /* v.ast.ExprStmt */) {
					v__ast__Expr expr = (*stmt->_v__ast__ExprStmt).expr;
					if (expr._typ == 282 /* v.ast.IfExpr */) {
						if ((*expr._v__ast__IfExpr).branches.len == 1) {
							builtin__array_delete(&branch->stmts, (int)(branch->stmts.len - 1));
							_PUSH_MANY(&branch->stmts, ((*(v__ast__IfBranch*)builtin__array_get((*expr._v__ast__IfExpr).branches, 0)).stmts), _t2, Array_v__ast__Stmt);
							break;
						}
					}
					else if (expr._typ == 292 /* v.ast.MatchExpr */) {
						if ((*expr._v__ast__MatchExpr).branches.len == 1) {
							builtin__array_delete(&branch->stmts, (int)(branch->stmts.len - 1));
							_PUSH_MANY(&branch->stmts, ((*(v__ast__MatchBranch*)builtin__array_get((*expr._v__ast__MatchExpr).branches, 0)).stmts), _t3, Array_v__ast__Stmt);
							break;
						}
					}
					
					else {
					}
					
				}
			}
		}
		v__transformer__IndexState_unindent(t->index);
	}
	node->left = v__transformer__Transformer_expr(t, &node->left);
	return v__ast__IfExpr_to_sumtype_v__ast__Expr(node, false);
}
v__ast__Expr v__transformer__Transformer_match_expr(v__transformer__Transformer* t, v__ast__MatchExpr* node) {
	node->cond = v__transformer__Transformer_expr(t, &node->cond);
	for (int _t1 = 0; _t1 < node->branches.len; ++_t1) {
		v__ast__MatchBranch* branch = ((v__ast__MatchBranch*)node->branches.data) + _t1;
		for (int _t2 = 0; _t2 < branch->exprs.len; ++_t2) {
			v__ast__Expr* expr = ((v__ast__Expr*)branch->exprs.data) + _t2;
			*expr = v__transformer__Transformer_expr(t, expr);
		}
		v__transformer__IndexState_indent(t->index, false);
		for (int i = 0; i < branch->stmts.len; ++i) {
			v__ast__Stmt* stmt = ((v__ast__Stmt*)branch->stmts.data) + i;
			*stmt = v__transformer__Transformer_stmt(t, stmt);
			if (i == (int)(branch->stmts.len - 1)) {
				if ((stmt)->_typ == 321 /* v.ast.ExprStmt */) {
					v__ast__Expr expr = (*stmt->_v__ast__ExprStmt).expr;
					if (expr._typ == 282 /* v.ast.IfExpr */) {
						if ((*expr._v__ast__IfExpr).branches.len == 1) {
							builtin__array_delete(&branch->stmts, (int)(branch->stmts.len - 1));
							_PUSH_MANY(&branch->stmts, ((*(v__ast__IfBranch*)builtin__array_get((*expr._v__ast__IfExpr).branches, 0)).stmts), _t3, Array_v__ast__Stmt);
							break;
						}
					}
					else if (expr._typ == 292 /* v.ast.MatchExpr */) {
						if ((*expr._v__ast__MatchExpr).branches.len == 1) {
							builtin__array_delete(&branch->stmts, (int)(branch->stmts.len - 1));
							_PUSH_MANY(&branch->stmts, ((*(v__ast__MatchBranch*)builtin__array_get((*expr._v__ast__MatchExpr).branches, 0)).stmts), _t4, Array_v__ast__Stmt);
							break;
						}
					}
					
					else {
					}
					
				}
			}
		}
		v__transformer__IndexState_unindent(t->index);
	}
	return v__ast__MatchExpr_to_sumtype_v__ast__Expr(node, false);
}
v__ast__Expr v__transformer__Transformer_sql_expr(v__transformer__Transformer* t, v__ast__SqlExpr* node) {
	node->db_expr = v__transformer__Transformer_expr(t, &node->db_expr);
	if (node->has_where) {
		bool old_inside_sql = t->inside_sql;
		t->inside_sql = true;
		node->where_expr = v__transformer__Transformer_expr(t, &node->where_expr);
		t->inside_sql = old_inside_sql;
	}
	if (node->has_order) {
		node->order_expr = v__transformer__Transformer_expr(t, &node->order_expr);
	}
	if (node->has_limit) {
		node->limit_expr = v__transformer__Transformer_expr(t, &node->limit_expr);
	}
	if (node->has_offset) {
		node->offset_expr = v__transformer__Transformer_expr(t, &node->offset_expr);
	}
	for (int _t1 = 0; _t1 < node->fields.len; ++_t1) {
		v__ast__StructField* field = ((v__ast__StructField*)node->fields.data) + _t1;
		field->default_expr = v__transformer__Transformer_expr(t, &field->default_expr);
	}
	Map_int_v__ast__SqlExpr _t2 = node->sub_structs;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		v__ast__SqlExpr* sub_struct = ((v__ast__SqlExpr*)builtin__DenseArray_value(&_t2.key_values, _t3));
		*sub_struct = ({ v__ast__Expr _t6 = v__transformer__Transformer_expr(t, HEAP(v__ast__Expr, v__ast__SqlExpr_to_sumtype_v__ast__Expr(sub_struct, true))); *(v__ast__SqlExpr*)builtin____as_cast(_t6._v__ast__SqlExpr,_t6._typ, 305); });
	}
	return v__ast__SqlExpr_to_sumtype_v__ast__Expr(node, false);
}
void v__transformer__Transformer_fn_decl(v__transformer__Transformer* t, v__ast__FnDecl* node) {
	if (t->pref->trace_calls) {
		v__transformer__Transformer_fn_decl_trace_calls(t, node);
	}
	v__transformer__IndexState_indent(t->index, true);
	for (int _t1 = 0; _t1 < node->stmts.len; ++_t1) {
		v__ast__Stmt* stmt = ((v__ast__Stmt*)node->stmts.data) + _t1;
		*stmt = v__transformer__Transformer_stmt(t, stmt);
	}
	v__transformer__IndexState_unindent(t->index);
}
void v__transformer__Transformer_fn_decl_trace_calls(v__transformer__Transformer* t, v__ast__FnDecl* node) {
	if (node->no_body) {
		return;
	}
	if (builtin__string_starts_with(node->name, _S("v.trace_calls."))) {
		return;
	}
	string _t1; /* if prepend */
	if (node->is_method) {
		string receiver_name = v__ast__Table_type_to_str(global_table, node->receiver.typ);
		_t1 = builtin__str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->mod}}, {_S(" "), 0xfe10, {.d_s = receiver_name}}, {_S("."), 0xfe10, {.d_s = node->name}}, {_S("/"), 0xfe07, {.d_i32 = node->params.len}}, {_SLIT0, 0, { .d_c = 0 }}}));
		goto _t2;
	};
	{
		_t1 = builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = node->mod}}, {_S(" "), 0xfe10, {.d_s = node->name}}, {_S("/"), 0xfe07, {.d_i32 = node->params.len}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	_t2: {};
		string fname = _t1;
	bool _t3 = false;
	Array_string _t3_orig = t->pref->trace_fns;
	int _t3_len = _t3_orig.len;
	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		string it = ((string*) _t3_orig.data)[_t4];
		if (builtin__string_match_glob(fname, it)) {
			_t3 = true;
			break;
		}
	}
	if (!_t3) {
		return;
	}
	v__ast__ExprStmt expr_stmt = ((v__ast__ExprStmt){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){
		.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
		.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, (((v__ast__StringLiteral){.val = fname,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.language = 0,.is_raw = 0,}))), false),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__string_type_idx,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,})})),
		.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.name = _S("v.trace_calls.on_call"),
		.const_name = (string){.str=(byteptr)"", .is_lit=1},
		.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.mod = node->mod,
		.scope = node->scope,
		.pos = node->pos,
		.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.receiver_type = 0,
		.return_type = 0,
		.return_type_generic = 0,
		.nr_ret_values = -1,
		.fn_var_type = 0,
		.left_type = 0,
		.receiver_concrete_type = 0,
		.kind = 0,
		.language = v__ast__Language__v,
		.is_unwrapped_fn_selector = 0,
		.is_method = 0,
		.is_field = 0,
		.is_fn_var = 0,
		.is_fn_a_const = 0,
		.is_keep_alive = 0,
		.is_noreturn = 0,
		.is_ctor_new = 0,
		.is_file_translated = 0,
		.is_static_method = 0,
		.is_variadic = 0,
		.is_c_variadic = 0,
		.comptime_ret_val = 0,
		.should_be_skipped = 0,
		.free_receiver = 0,
		.is_return_used = 0,
		.is_expand_simple_interpolation = 0,
	}))), false),.is_expr = 0,.typ = 0,});
	builtin__array_prepend(&node->stmts, &(v__ast__Stmt[]){v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&expr_stmt, false)});
}
bool v__transformer__Transformer_simplify_nested_interpolation_in_sb(v__transformer__Transformer* t, v__ast__Stmt* onode, v__ast__CallExpr* nexpr, v__ast__Type ntype) {
	if (t->pref->autofree) {
		return false;
	}
	if (((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0)).expr)._typ != 306 /* v.ast.StringInterLiteral */) {
		return false;
	}
	v__ast__StringInterLiteral original = *(v__ast__StringInterLiteral*)builtin____as_cast(((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0)).expr)._v__ast__StringInterLiteral,((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0)).expr)._typ, 306);
	if (original.exprs.len != original.expr_types.len) {
		return false;
	}
	for (int idx = 0; idx < original.fwidths.len; ++idx) {
		int w = ((int*)original.fwidths.data)[idx];
		if (w != 0) {
			return false;
		}
		if ((*(int*)builtin__array_get(original.precisions, idx)) != 987698) {
			return false;
		}
		if ((*(bool*)builtin__array_get(original.need_fmts, idx))) {
			return false;
		}
		if ((*(v__ast__Type*)builtin__array_get(original.expr_types, idx)) == _const_v__ast__string_type) {
			continue;
		}
		if (!v__ast__Type_is_int((*(v__ast__Type*)builtin__array_get(original.expr_types, idx)))) {
			return false;
		}
	}
	Array_v__ast__Stmt calls = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	for (int _t8 = 0; _t8 < original.vals.len; ++_t8) {
		string val = ((string*)original.vals.data)[_t8];
		if ((val).len == 0) {
			builtin__array_push((array*)&calls, _MOV((v__ast__Stmt[]){ v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__EmptyStmt, (((v__ast__EmptyStmt){.pos = nexpr->pos,}))), false) }));
			continue;
		}
		v__ast__ExprStmt ncall = ((v__ast__ExprStmt){.pos = nexpr->pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){.or_block = (nexpr)->or_block,.expected_arg_types = (nexpr)->expected_arg_types,.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){((v__ast__CallArg){.comments = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).comments,.expr = v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, (((v__ast__StringLiteral){.val = val,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.language = 0,.is_raw = 0,}))), false),.pos = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).pos,.typ = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).typ,.share = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).share,.ct_expr = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).ct_expr,.is_tmp_autofree = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).is_tmp_autofree,.should_be_ptr = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).should_be_ptr,.is_mut = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).is_mut,})})),.concrete_types = (nexpr)->concrete_types,.raw_concrete_types = (nexpr)->raw_concrete_types,.from_embed_types = (nexpr)->from_embed_types,.comments = (nexpr)->comments,.name = (nexpr)->name,.const_name = (nexpr)->const_name,.left = (nexpr)->left,.mod = (nexpr)->mod,.scope = (nexpr)->scope,.pos = (nexpr)->pos,.concrete_list_pos = (nexpr)->concrete_list_pos,.name_pos = (nexpr)->name_pos,.receiver_type = (nexpr)->receiver_type,.return_type = (nexpr)->return_type,.return_type_generic = (nexpr)->return_type_generic,.nr_ret_values = (nexpr)->nr_ret_values,.fn_var_type = (nexpr)->fn_var_type,.left_type = (nexpr)->left_type,.receiver_concrete_type = (nexpr)->receiver_concrete_type,.kind = (nexpr)->kind,.language = (nexpr)->language,.is_unwrapped_fn_selector = (nexpr)->is_unwrapped_fn_selector,.is_method = (nexpr)->is_method,.is_field = (nexpr)->is_field,.is_fn_var = (nexpr)->is_fn_var,.is_fn_a_const = (nexpr)->is_fn_a_const,.is_keep_alive = (nexpr)->is_keep_alive,.is_noreturn = (nexpr)->is_noreturn,.is_ctor_new = (nexpr)->is_ctor_new,.is_file_translated = (nexpr)->is_file_translated,.is_static_method = (nexpr)->is_static_method,.is_variadic = (nexpr)->is_variadic,.is_c_variadic = (nexpr)->is_c_variadic,.comptime_ret_val = (nexpr)->comptime_ret_val,.should_be_skipped = (nexpr)->should_be_skipped,.free_receiver = (nexpr)->free_receiver,.is_return_used = (nexpr)->is_return_used,.is_expand_simple_interpolation = (nexpr)->is_expand_simple_interpolation,}))), false),.is_expr = 0,.typ = ntype,});
		builtin__array_push((array*)&calls, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&ncall, false) }));
	}
	for (int idx = 0; idx < original.exprs.len; ++idx) {
		v__ast__Expr expr = ((v__ast__Expr*)original.exprs.data)[idx];
		v__ast__ExprStmt ncall = ((v__ast__ExprStmt){.pos = nexpr->pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){.or_block = (nexpr)->or_block,.expected_arg_types = (nexpr)->expected_arg_types,.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){((v__ast__CallArg){.comments = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).comments,.expr = expr,.pos = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).pos,.typ = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).typ,.share = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).share,.ct_expr = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).ct_expr,.is_tmp_autofree = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).is_tmp_autofree,.should_be_ptr = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).should_be_ptr,.is_mut = ((*(v__ast__CallArg*)builtin__array_get(nexpr->args, 0))).is_mut,})})),.concrete_types = (nexpr)->concrete_types,.raw_concrete_types = (nexpr)->raw_concrete_types,.from_embed_types = (nexpr)->from_embed_types,.comments = (nexpr)->comments,.name = (nexpr)->name,.const_name = (nexpr)->const_name,.left = (nexpr)->left,.mod = (nexpr)->mod,.scope = (nexpr)->scope,.pos = (nexpr)->pos,.concrete_list_pos = (nexpr)->concrete_list_pos,.name_pos = (nexpr)->name_pos,.receiver_type = (nexpr)->receiver_type,.return_type = (nexpr)->return_type,.return_type_generic = (nexpr)->return_type_generic,.nr_ret_values = (nexpr)->nr_ret_values,.fn_var_type = (nexpr)->fn_var_type,.left_type = (nexpr)->left_type,.receiver_concrete_type = (nexpr)->receiver_concrete_type,.kind = (nexpr)->kind,.language = (nexpr)->language,.is_unwrapped_fn_selector = (nexpr)->is_unwrapped_fn_selector,.is_method = (nexpr)->is_method,.is_field = (nexpr)->is_field,.is_fn_var = (nexpr)->is_fn_var,.is_fn_a_const = (nexpr)->is_fn_a_const,.is_keep_alive = (nexpr)->is_keep_alive,.is_noreturn = (nexpr)->is_noreturn,.is_ctor_new = (nexpr)->is_ctor_new,.is_file_translated = (nexpr)->is_file_translated,.is_static_method = (nexpr)->is_static_method,.is_variadic = (nexpr)->is_variadic,.is_c_variadic = (nexpr)->is_c_variadic,.comptime_ret_val = (nexpr)->comptime_ret_val,.should_be_skipped = (nexpr)->should_be_skipped,.free_receiver = (nexpr)->free_receiver,.is_return_used = (nexpr)->is_return_used,.is_expand_simple_interpolation = (nexpr)->is_expand_simple_interpolation,}))), false),.is_expr = 0,.typ = ntype,});
		v__ast__Type etype = (*(v__ast__Type*)builtin__array_get(original.expr_types, idx));
		if (v__ast__Type_is_int(etype)) {
			if ((ncall.expr)._typ == 267 /* v.ast.CallExpr */) {
				(*ncall.expr._v__ast__CallExpr).name = _S("write_decimal");
			}
		}
		builtin__array_insert(&calls, (int)(1 + (int)(2 * idx)), &(v__ast__Stmt[]){v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&ncall, false)});
	}
	{ // Unsafe block
		*onode = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, (((v__ast__Block){.is_unsafe = 0,.pos = nexpr->pos,.scope = _const_v__ast__empty_scope,.stmts = calls,}))), false);
	}
	return true;
}
VV_LOC v__ast__AsmStmt v__parser__Parser_asm_stmt(v__parser__Parser* p, bool is_top_level) {
	p->inside_asm = true;
	p->inside_asm_template = true;
	p->n_asm = 0;
	if (is_top_level) {
		v__parser__Parser_top_level_statement_start(p);
	}
	v__ast__Scope* backup_scope = p->scope;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_asm);
	_result_v__pref__Arch _t1 = v__pref__arch_from_string(p->tok.lit);
	if (_t1.is_error) {
		*(v__pref__Arch*) _t1.data = v__pref__Arch___auto;
	}
	
 	v__pref__Arch arch = (*(v__pref__Arch*)_t1.data);
	if (is_top_level && arch == v__pref__Arch__wasm32) {
		v__parser__Parser_error(p, _S("wasm doesn't support toplevel assembly"));
	}
	bool is_volatile = false;
	bool is_goto = false;
	if (p->tok.kind == v__token__Kind__key_volatile) {
		_result_v__pref__Arch _t2 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t2.is_error) {
			*(v__pref__Arch*) _t2.data = v__pref__Arch___auto;
		}
		
 		arch = (*(v__pref__Arch*)_t2.data);
		is_volatile = true;
		v__parser__Parser_next(p);
	} else if (p->tok.kind == v__token__Kind__key_goto) {
		_result_v__pref__Arch _t3 = v__pref__arch_from_string(p->peek_tok.lit);
		if (_t3.is_error) {
			*(v__pref__Arch*) _t3.data = v__pref__Arch___auto;
		}
		
 		arch = (*(v__pref__Arch*)_t3.data);
		is_goto = true;
		v__parser__Parser_next(p);
	}
	if (arch == v__pref__Arch___auto && !p->pref->is_fmt) {
		if ((p->tok.lit).len == 0) {
			v__parser__Parser_error(p, _S("missing assembly architecture. Try i386, amd64, arm64, or wasm."));
		}
		v__parser__Parser_error(p, _S("unknown assembly architecture"));
	}
	if (p->tok.kind != v__token__Kind__name) {
		v__parser__Parser_error(p, _S("must specify assembly architecture"));
	} else {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check_for_impure_v(p, v__ast__pref_arch_to_table_language(arch), v__token__Token_pos(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	p->scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = v__ast__all_registers(p->table, arch),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = ((void*)0),.detached_from_parent = true,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope)));
	Array_string local_labels = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__AsmTemplate templates = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmTemplate), 0);
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__semicolon || p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__eof))) break;
		v__token__Pos template_pos = v__token__Token_pos(&p->tok);
		string name = _S("");
		Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (p->tok.kind == v__token__Kind__name && arch == v__pref__Arch__amd64 && (builtin__fast_string_eq(p->tok.lit, _S("rex")) || builtin__fast_string_eq(p->tok.lit, _S("vex")) || builtin__fast_string_eq(p->tok.lit, _S("xop")))) {
			name = builtin__string__plus(name, p->tok.lit);
			v__parser__Parser_next(p);
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__dot)) break;
				v__parser__Parser_next(p);
				name = builtin__string__plus(name, builtin__string__plus(_S("."), p->tok.lit));
				v__parser__Parser_check(p, v__token__Kind__name);
			}
			name = builtin__string__plus(name, _S(" "));
		}
		bool is_directive = p->tok.kind == v__token__Kind__dot;
		if (is_directive) {
			v__parser__Parser_next(p);
		}
		if (p->tok.kind == v__token__Kind__key_in || p->tok.kind == v__token__Kind__key_lock || p->tok.kind == v__token__Kind__key_orelse || p->tok.kind == v__token__Kind__key_select || p->tok.kind == v__token__Kind__key_return) {
			name = builtin__string__plus(name, v__token__Kind_str(p->tok.kind));
			if (p->tok.kind == v__token__Kind__key_lock && (arch == v__pref__Arch__i386 || arch == v__pref__Arch__amd64)) {
				v__parser__Parser_next(p);
				bool has_suffix = (builtin__string_at(p->tok.lit, (int)(p->tok.lit.len - 1)) == 'b' || builtin__string_at(p->tok.lit, (int)(p->tok.lit.len - 1)) == 'w' || builtin__string_at(p->tok.lit, (int)(p->tok.lit.len - 1)) == 'l' || builtin__string_at(p->tok.lit, (int)(p->tok.lit.len - 1)) == 'q');
				if (!((Array_string_contains(_const_v__parser__allowed_lock_prefix_ins, p->tok.lit)) || (has_suffix && (Array_string_contains(_const_v__parser__allowed_lock_prefix_ins, builtin__string_substr(p->tok.lit, 0, (int)(p->tok.lit.len - 1))))))) {
					v__parser__Parser_error(p, _S("The lock prefix cannot be used on this instruction"));
				}
				name = builtin__string__plus(name, _S(" "));
				name = builtin__string__plus(name, p->tok.lit);
			}
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind__number) {
			name = builtin__string__plus(name, p->tok.lit);
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind__comment) {
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comment)) break;
				builtin__array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
			}
		} else {
			name = builtin__string__plus(name, p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind__name);
		}
		if (arch == v__pref__Arch__rv32 || arch == v__pref__Arch__rv64 || arch == v__pref__Arch__wasm32 || arch == v__pref__Arch__arm64 || arch == v__pref__Arch__loongarch64) {
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__dot)) break;
				name = builtin__string__plus(name, _S("."));
				v__parser__Parser_next(p);
				if (arch == v__pref__Arch__wasm32 && p->tok.kind == v__token__Kind__key_const) {
					name = builtin__string__plus(name, _S("const"));
					v__parser__Parser_next(p);
				} else {
					name = builtin__string__plus(name, p->tok.lit);
					v__parser__Parser_check(p, v__token__Kind__name);
				}
			}
		}
		bool is_label = false;
		Array_v__ast__AsmArg args = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmArg), 0);
		if (p->tok.line_nr == p->prev_tok.line_nr) {
			args_loop:
			for (;;) {
				if (v__token__Token_pos(&p->prev_tok).line_nr < v__token__Token_pos(&p->tok).line_nr) {
					break;
				}
				string segment = _S("");
				if (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__colon) {
					segment = p->tok.lit;
					v__parser__Parser_next(p);
					v__parser__Parser_next(p);
				}

				if (p->tok.kind == (v__token__Kind__name)) {
					builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__parser__Parser_reg_or_alias(p) }));
				}
				else if (p->tok.kind == (v__token__Kind__string)) {
					builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ string_to_sumtype_v__ast__AsmArg(&p->tok.lit, false) }));
					v__parser__Parser_next(p);
				}
				else if (p->tok.kind == (v__token__Kind__number)) {
					v__ast__Expr number_lit = v__parser__Parser_parse_number_literal(p);
					if (number_lit._typ == 279 /* v.ast.FloatLiteral */) {
						builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__FloatLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = ((*number_lit._v__ast__FloatLiteral)).val,.pos = ((*number_lit._v__ast__FloatLiteral)).pos,}))), false) }));
					}
					else if (number_lit._typ == 286 /* v.ast.IntegerLiteral */) {
						if (is_directive) {
							builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = (*number_lit._v__ast__IntegerLiteral).val,.pos = (*number_lit._v__ast__IntegerLiteral).pos,}))), false) }));
						} else {
							builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__IntegerLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = ((*number_lit._v__ast__IntegerLiteral)).val,.pos = ((*number_lit._v__ast__IntegerLiteral)).pos,}))), false) }));
						}
					}
					
					else {
						v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("p.parse_number_literal() invalid output: `"), 0xfe10, {.d_s = v__ast__Expr_str(number_lit)}}, {_S("`"), 0, { .d_c = 0 }}})));
					}
					
				}
				else if (p->tok.kind == (v__token__Kind__chartoken)) {
					builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__CharLiteral_to_sumtype_v__ast__AsmArg(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false) }));
					v__parser__Parser_next(p);
				}
				else if (p->tok.kind == (v__token__Kind__colon)) {
					is_label = true;
					v__parser__Parser_next(p);
					builtin__array_push((array*)&local_labels, _MOV((string[]){ builtin__string_clone(name) }));
					break;
				}
				else if (p->tok.kind == (v__token__Kind__lsbr)) {
					if (arch == v__pref__Arch__wasm32) {
						v__parser__Parser_error(p, _S("wasm doesn't have addressing operands"));
					}
					v__ast__AsmAddressing addressing = v__parser__Parser_asm_addressing(p);
					addressing.segment = segment;
					builtin__array_push((array*)&args, _MOV((v__ast__AsmArg[]){ v__ast__AsmAddressing_to_sumtype_v__ast__AsmArg(&addressing, false) }));
				}
				else if (p->tok.kind == (v__token__Kind__rcbr)) {
					break;
				}
				else if (p->tok.kind == (v__token__Kind__semicolon)) {
					break;
				}
				else {
					v__parser__Parser_error(p, _S("invalid token in assembly block"));
				}
				if (p->tok.kind == v__token__Kind__comma) {
					v__parser__Parser_next(p);
				} else {
					break;
				}
				args_loop__continue: {}
			}
			args_loop__break: {}
		}
		for (;;) {
			if (!(p->tok.kind == v__token__Kind__comment)) break;
			builtin__array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		if (is_directive && (_SLIT_EQ(name.str, name.len, "globl") || _SLIT_EQ(name.str, name.len, "global"))) {
			for (int _t14 = 0; _t14 < args.len; ++_t14) {
				v__ast__AsmArg arg = ((v__ast__AsmArg*)args.data)[_t14];
				builtin__array_push((array*)&p->global_labels, _MOV((string[]){ builtin__string_clone((*(v__ast__AsmAlias*)builtin____as_cast((arg)._v__ast__AsmAlias,(arg)._typ, 430)).name) }));
			}
		}
		builtin__array_push((array*)&templates, _MOV((v__ast__AsmTemplate[]){ ((v__ast__AsmTemplate){
			.args = args,
			.comments = comments,
			.name = name,
			.pos = v__token__Pos_extend(template_pos, v__token__Token_pos(&p->tok)),
			.is_label = is_label,
			.is_directive = is_directive,
		}) }));
	}
	v__ast__Scope* scope = p->scope;
	p->scope = backup_scope;
	p->inside_asm_template = false;
	Array_v__ast__AsmIO output = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmIO input = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	Array_v__ast__AsmClobbered clobbered = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmClobbered), 0);
	Array_string global_labels = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (!is_top_level) {
		if (p->tok.kind == v__token__Kind__semicolon) {
			output = v__parser__Parser_asm_ios(p, true);
			if (p->tok.kind == v__token__Kind__semicolon) {
				input = v__parser__Parser_asm_ios(p, false);
			}
			if (p->tok.kind == v__token__Kind__semicolon) {
				backup_scope = p->scope;
				p->scope = scope;
				v__parser__Parser_next(p);
				for (;;) {
					if (!(p->tok.kind == v__token__Kind__name)) break;
					v__ast__AsmRegister reg = ((v__ast__AsmRegister){.name = p->tok.lit,.typ = 0,.size = -1,});
					v__parser__Parser_next(p);
					Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comment)) break;
						builtin__array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
					}
					builtin__array_push((array*)&clobbered, _MOV((v__ast__AsmClobbered[]){ ((v__ast__AsmClobbered){.reg = reg,.comments = comments,}) }));
					if (p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__semicolon) {
						break;
					}
				}
				if (is_goto && p->tok.kind == v__token__Kind__semicolon) {
					v__parser__Parser_next(p);
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__name)) break;
						builtin__array_push((array*)&global_labels, _MOV((string[]){ builtin__string_clone(p->tok.lit) }));
						v__parser__Parser_next(p);
					}
				}
			}
		}
	} else if (p->tok.kind == v__token__Kind__semicolon) {
		v__parser__Parser_error(p, _S("extended assembly is not allowed as a top level statement"));
	}
	p->scope = backup_scope;
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	scope->end_pos = p->prev_tok.pos;
	v__ast__AsmStmt _t20 = ((v__ast__AsmStmt){
		.local_labels = local_labels,
		.clobbered = clobbered,
		.templates = templates,
		.output = output,
		.input = input,
		.global_labels = global_labels,
		.scope = scope,
		.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
		.arch = arch,
		.is_basic = is_top_level || (int)((int)(output.len + input.len) + clobbered.len) == 0,
		.is_volatile = is_volatile,
		.is_goto = is_goto,
	});
		{ // defer begin
			p->inside_asm = false;
			p->inside_asm_template = false;
		} // defer end
	return _t20;
}
VV_LOC v__ast__AsmArg v__parser__Parser_reg_or_alias(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__name);
	bool _t1 = _IN_MAP(ADDR(string, p->prev_tok.lit), ADDR(map, p->scope->objects));
	bool _t4;
	if (!(_t1)) {
		bool _t5 = (p->prev_tok.len >= 2 && (builtin__string_at(p->prev_tok.lit, 0) == 'b' || builtin__string_at(p->prev_tok.lit, 0) == 'f'));
		bool _t6 = true;
		if (_t5) {
			Array_u8 _t6_orig = builtin__string_bytes(builtin__string_substr(p->prev_tok.lit, 1, 2147483647));
			int _t6_len = _t6_orig.len;
			for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
				u8 it = ((u8*) _t6_orig.data)[_t7];
				if (!(builtin__u8_is_digit(it))) {
					_t6 = false;
					break;
				}
			}
		}
		_t4 = _t5 &&_t6;
	}
		
	if (_t1) {
		v__ast__ScopeObject x = (*(v__ast__ScopeObject*)builtin__map_get(ADDR(map, p->scope->objects), &(string[]){p->prev_tok.lit}, &(v__ast__ScopeObject[]){ (v__ast__ScopeObject){._v__ast__EmptyScopeObject=HEAP(v__ast__EmptyScopeObject, ((v__ast__EmptyScopeObject){.name = (string){.str=(byteptr)"", .is_lit=1},.typ = 0,})),._typ=337} }));
		if ((x)._typ == 338 /* v.ast.AsmRegister */) {
			return v__ast__AsmRegister_to_sumtype_v__ast__AsmArg(&(*x._v__ast__AsmRegister), false);
		} else {
			v__parser__Parser_error(p, _S("non-register ast.ScopeObject found in scope"));
			return v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
		}
	} else if (_t4) {
		return v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = builtin__string__plus(builtin__string_substr(p->prev_tok.lit, 1, 2147483647), builtin__u8_ascii_str(builtin__string_at(p->prev_tok.lit, 0))),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
	} else {
		return v__ast__AsmAlias_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmAlias, (((v__ast__AsmAlias){.pos = v__token__Token_pos(&p->prev_tok),.name = p->prev_tok.lit,}))), false);
	}
	return (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429};
}
VV_LOC v__ast__AsmAddressing v__parser__Parser_asm_addressing(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	string unknown_addressing_mode = _S("unknown addressing mode. supported ones are [displacement],\011[base], [base + displacement], [index \342\210\227 scale + displacement], [base + index \342\210\227 scale + displacement], [base + index + displacement], [rip + displacement]");
	if (p->peek_tok.kind == v__token__Kind__rsbr) {
		if (p->tok.kind == v__token__Kind__name) {
			v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			return ((v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},.base = base,.index = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},});
		} else if (p->tok.kind == v__token__Kind__number) {
			v__ast__AsmArg _t2; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t2 = v__parser__Parser_reg_or_alias(p);
				goto _t3;
			};
			{
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
				v__parser__Parser_check(p, v__token__Kind__number);
				_t2 = x;
			}
	_t3: {};
						v__ast__AsmArg displacement = _t2;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			return ((v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__displacement,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},.index = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},});
		} else {
			v__parser__Parser_error(p, unknown_addressing_mode);
		}
	}
	if (p->peek_tok.kind == v__token__Kind__plus && p->tok.kind == v__token__Kind__name) {
		if (builtin__fast_string_eq(p->tok.lit, _S("rip"))) {
			v__ast__AsmArg rip = v__parser__Parser_reg_or_alias(p);
			v__parser__Parser_next(p);
			v__ast__AsmArg _t5; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t5 = v__parser__Parser_reg_or_alias(p);
				goto _t6;
			};
			{
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
				v__parser__Parser_check(p, v__token__Kind__number);
				_t5 = x;
			}
	_t6: {};
						v__ast__AsmArg displacement = _t5;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			return ((v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__rip_plus_displacement,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = rip,.index = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},});
		}
		v__ast__AsmArg base = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_next(p);
		if (p->peek_tok.kind == v__token__Kind__rsbr) {
			if (p->tok.kind == v__token__Kind__number) {
				v__ast__AsmArg _t8; /* if prepend */
				if (p->tok.kind == v__token__Kind__name) {
					_t8 = v__parser__Parser_reg_or_alias(p);
					goto _t9;
				};
				{
					v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
					v__parser__Parser_check(p, v__token__Kind__number);
					_t8 = x;
				}
	_t9: {};
								v__ast__AsmArg displacement = _t8;
				v__parser__Parser_check(p, v__token__Kind__rsbr);
				return ((v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base_plus_displacement,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = base,.index = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},});
			} else {
				v__parser__Parser_error(p, unknown_addressing_mode);
			}
		}
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		if (p->tok.kind == v__token__Kind__mul) {
			v__parser__Parser_next(p);
			int scale = builtin__string_int(p->tok.lit);
			v__parser__Parser_check(p, v__token__Kind__number);
			v__parser__Parser_check(p, v__token__Kind__plus);
			v__ast__AsmArg _t11; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t11 = v__parser__Parser_reg_or_alias(p);
				goto _t12;
			};
			{
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
				v__parser__Parser_check(p, v__token__Kind__number);
				_t11 = x;
			}
	_t12: {};
						v__ast__AsmArg displacement = _t11;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			return ((v__ast__AsmAddressing){
				.scale = scale,
				.mode = v__ast__AddressingMode__base_plus_index_times_scale_plus_displacement,
				.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
				.segment = (string){.str=(byteptr)"", .is_lit=1},
				.displacement = displacement,
				.base = base,
				.index = index,
			});
		} else if (p->tok.kind == v__token__Kind__plus) {
			v__parser__Parser_next(p);
			v__ast__AsmArg _t14; /* if prepend */
			if (p->tok.kind == v__token__Kind__name) {
				_t14 = v__parser__Parser_reg_or_alias(p);
				goto _t15;
			};
			{
				v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
				v__parser__Parser_check(p, v__token__Kind__number);
				_t14 = x;
			}
	_t15: {};
						v__ast__AsmArg displacement = _t14;
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			return ((v__ast__AsmAddressing){.scale = -1,.mode = v__ast__AddressingMode__base_plus_index_plus_displacement,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = base,.index = index,});
		}
	}
	if (p->peek_tok.kind == v__token__Kind__mul) {
		v__ast__AsmArg index = v__parser__Parser_reg_or_alias(p);
		v__parser__Parser_next(p);
		int scale = builtin__string_int(p->tok.lit);
		v__parser__Parser_check(p, v__token__Kind__number);
		v__parser__Parser_check(p, v__token__Kind__plus);
		v__ast__AsmArg _t17; /* if prepend */
		if (p->tok.kind == v__token__Kind__name) {
			_t17 = v__parser__Parser_reg_or_alias(p);
			goto _t18;
		};
		{
			v__ast__AsmArg x = v__ast__AsmDisp_to_sumtype_v__ast__AsmArg(ADDR(v__ast__AsmDisp, (((v__ast__AsmDisp){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
			v__parser__Parser_check(p, v__token__Kind__number);
			_t17 = x;
		}
	_t18: {};
				v__ast__AsmArg displacement = _t17;
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		return ((v__ast__AsmAddressing){.scale = scale,.mode = v__ast__AddressingMode__index_times_scale_plus_displacement,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = displacement,.base = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},.index = index,});
	}
	v__parser__Parser_error(p, unknown_addressing_mode);
	return ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},.base = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},.index = (v__ast__AsmArg){._v__ast__AsmAddressing=HEAP(v__ast__AsmAddressing, ((v__ast__AsmAddressing){.scale = -1,.mode = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.segment = (string){.str=(byteptr)"", .is_lit=1},.displacement = {0},.base = {0},.index = {0},})),._typ=429},});
}
VV_LOC Array_v__ast__AsmIO v__parser__Parser_asm_ios(v__parser__Parser* p, bool output) {
	Array_v__ast__AsmIO res = builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	v__parser__Parser_check(p, v__token__Kind__semicolon);
	if (p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__semicolon) {
		return builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_error(p, _S("reached eof in asm_ios"));
			return builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
		}
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		string constraint = _S("");
		if (p->tok.kind == v__token__Kind__lpar) {
			constraint = (output ? (_S("+r")) : (_S("r")));
		} else {
			if (output) {
				if (p->tok.kind == v__token__Kind__assign) {
					constraint = builtin__string__plus(constraint, _S("="));
				} else if (p->tok.kind == v__token__Kind__plus) {
					constraint = builtin__string__plus(constraint, _S("+"));
				} else {
					v__parser__Parser_error_with_pos(p, _S("Output constraint must starts with `=` or `+`"), pos);
					return builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
				}
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind__amp) {
					constraint = builtin__string__plus(constraint, _S("&"));
					v__parser__Parser_next(p);
				} else if (p->tok.kind == v__token__Kind__mul) {
					constraint = builtin__string__plus(constraint, _S("*"));
					v__parser__Parser_next(p);
				}
			} else {
				if (p->tok.kind == v__token__Kind__mod) {
					constraint = builtin__string__plus(constraint, _S("%"));
					v__parser__Parser_next(p);
				} else if (p->tok.kind == v__token__Kind__mul) {
					constraint = builtin__string__plus(constraint, _S("*"));
					v__parser__Parser_next(p);
				}
			}
			if (p->tok.kind == v__token__Kind__at) {
				constraint = builtin__string__plus(constraint, p->tok.lit);
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__number && !output) {
				if (builtin__string_int(p->tok.lit) >= 10) {
					v__parser__Parser_error_with_pos(p, _S("The digit must be between 0 and 9 only"), pos);
					return builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
				}
				constraint = builtin__string__plus(constraint, p->tok.lit);
				v__parser__Parser_check(p, v__token__Kind__number);
			} else {
				constraint = builtin__string__plus(constraint, p->tok.lit);
				v__parser__Parser_check(p, v__token__Kind__name);
			}
		}
		v__ast__Expr expr = v__parser__Parser_expr(p, 0);
		if ((expr)._typ == 297 /* v.ast.ParExpr */) {
			expr = (*expr._v__ast__ParExpr).expr;
		} else {
			v__parser__Parser_error(p, _S("asm in/output must be enclosed in brackets"));
			return builtin____new_array_with_default(0, 0, sizeof(v__ast__AsmIO), 0);
		}
		string alias = _S("");
		if (p->tok.kind == v__token__Kind__key_as) {
			v__parser__Parser_next(p);
			alias = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind__name);
		} else if ((expr)._typ == 281 /* v.ast.Ident */) {
			alias = (*expr._v__ast__Ident).name;
		}
		Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		for (;;) {
			if (!(p->tok.kind == v__token__Kind__comment)) break;
			builtin__array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		}
		builtin__array_push((array*)&res, _MOV((v__ast__AsmIO[]){ ((v__ast__AsmIO){.alias = alias,.constraint = constraint,.comments = comments,.typ = 0,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.expr = expr,}) }));
		p->n_asm++;
		if (p->tok.kind == v__token__Kind__semicolon || p->tok.kind == v__token__Kind__rcbr) {
			break;
		}
	}
	return res;
}
VV_LOC v__ast__Stmt v__parser__Parser_assign_stmt(v__parser__Parser* p) {
	Array_v__ast__Ident defer_vars = builtin__array_clone_to_depth(&p->defer_vars, 0);
	p->defer_vars = builtin____new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	Array_v__ast__Expr exprs = v__parser__Parser_expr_list(p, true);
	if (!(p->inside_defer && p->defer_mode == v__ast__DeferMode__function && p->tok.kind == v__token__Kind__decl_assign)) {
		_PUSH_MANY(&defer_vars, (p->defer_vars), _t1, Array_v__ast__Ident);
	}
	p->defer_vars = defer_vars;
	return v__parser__Parser_partial_assign_stmt(p, exprs);
}
VV_LOC _result_void v__parser__Parser_check_undefined_variables(v__parser__Parser* p, Array_string names, v__ast__Expr val) {
	p->expr_level++;
	_result_void _t1 = v__parser__Parser_check_expr_level(p);
	if (_t1.is_error) {
		{ // defer begin
			p->expr_level--;
		} // defer end
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	if (val._typ == 281 /* v.ast.Ident */) {
		for (int _t3 = 0; _t3 < names.len; ++_t3) {
			string name = ((string*)names.data)[_t3];
			if (builtin__string__eq(name, (*val._v__ast__Ident).name) && (*val._v__ast__Ident).kind != v__ast__IdentKind__blank_ident) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("undefined variable: `"), 0xfe10, {.d_s = (*val._v__ast__Ident).name}}, {_S("`"), 0, { .d_c = 0 }}})), (*val._v__ast__Ident).pos);
				_result_void _t4 = (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("undefined variable: `"), 0xfe10, {.d_s = (*val._v__ast__Ident).name}}, {_S("`"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t4;
			}
		}
	}
	else if (val._typ == 261 /* v.ast.ArrayInit */) {
		if ((*val._v__ast__ArrayInit).has_cap) {
			_result_void _t5 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__ArrayInit).cap_expr);
			if (_t5.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t6 = {0};
				_t6.is_error = true;
				_t6.err = _t5.err;
				return _t6;
			}
			
 ;
		}
		if ((*val._v__ast__ArrayInit).has_len) {
			_result_void _t7 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__ArrayInit).len_expr);
			if (_t7.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t8 = {0};
				_t8.is_error = true;
				_t8.err = _t7.err;
				return _t8;
			}
			
 ;
		}
		if ((*val._v__ast__ArrayInit).has_init) {
			_result_void _t9 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__ArrayInit).init_expr);
			if (_t9.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t10 = {0};
				_t10.is_error = true;
				_t10.err = _t9.err;
				return _t10;
			}
			
 ;
		}
		for (int _t11 = 0; _t11 < (*val._v__ast__ArrayInit).exprs.len; ++_t11) {
			v__ast__Expr expr = ((v__ast__Expr*)(*val._v__ast__ArrayInit).exprs.data)[_t11];
			_result_void _t12 = v__parser__Parser_check_undefined_variables(p, names, expr);
			if (_t12.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t13 = {0};
				_t13.is_error = true;
				_t13.err = _t12.err;
				return _t13;
			}
			
 ;
		}
	}
	else if (val._typ == 267 /* v.ast.CallExpr */) {
		_result_void _t14 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__CallExpr).left);
		if (_t14.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t15 = {0};
			_t15.is_error = true;
			_t15.err = _t14.err;
			return _t15;
		}
		
 ;
		if ((*val._v__ast__CallExpr).args.len == 1 && (builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("sort")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("sorted")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("map")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("filter")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("any")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("all")) || builtin__fast_string_eq((*val._v__ast__CallExpr).name, _S("count")))) {
				{ // defer begin
					p->expr_level--;
				} // defer end
			return (_result_void){0};
		}
		for (int _t16 = 0; _t16 < (*val._v__ast__CallExpr).args.len; ++_t16) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*val._v__ast__CallExpr).args.data)[_t16];
			_result_void _t17 = v__parser__Parser_check_undefined_variables(p, names, arg.expr);
			if (_t17.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t18 = {0};
				_t18.is_error = true;
				_t18.err = _t17.err;
				return _t18;
			}
			
 ;
		}
	}
	else if (val._typ == 268 /* v.ast.CastExpr */) {
		_result_void _t19 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__CastExpr).expr);
		if (_t19.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t20 = {0};
			_t20.is_error = true;
			_t20.err = _t19.err;
			return _t20;
		}
		
 ;
		_result_void _t21 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__CastExpr).arg);
		if (_t21.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t22 = {0};
			_t22.is_error = true;
			_t22.err = _t21.err;
			return _t22;
		}
		
 ;
	}
	else if (val._typ == 284 /* v.ast.IndexExpr */) {
		_result_void _t23 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__IndexExpr).left);
		if (_t23.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t24 = {0};
			_t24.is_error = true;
			_t24.err = _t23.err;
			return _t24;
		}
		
 ;
		_result_void _t25 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__IndexExpr).index);
		if (_t25.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t26 = {0};
			_t26.is_error = true;
			_t26.err = _t25.err;
			return _t26;
		}
		
 ;
	}
	else if (val._typ == 285 /* v.ast.InfixExpr */) {
		_result_void _t27 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__InfixExpr).left);
		if (_t27.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t28 = {0};
			_t28.is_error = true;
			_t28.err = _t27.err;
			return _t28;
		}
		
 ;
		_result_void _t29 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__InfixExpr).right);
		if (_t29.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t30 = {0};
			_t30.is_error = true;
			_t30.err = _t29.err;
			return _t30;
		}
		
 ;
	}
	else if (val._typ == 282 /* v.ast.IfExpr */) {
		_result_void _t31 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__IfExpr).left);
		if (_t31.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t32 = {0};
			_t32.is_error = true;
			_t32.err = _t31.err;
			return _t32;
		}
		
 ;
		for (int _t33 = 0; _t33 < (*val._v__ast__IfExpr).branches.len; ++_t33) {
			v__ast__IfBranch branch = ((v__ast__IfBranch*)(*val._v__ast__IfExpr).branches.data)[_t33];
			_result_void _t34 = v__parser__Parser_check_undefined_variables(p, names, branch.cond);
			if (_t34.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t35 = {0};
				_t35.is_error = true;
				_t35.err = _t34.err;
				return _t35;
			}
			
 ;
			for (int _t36 = 0; _t36 < branch.stmts.len; ++_t36) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t36];
				if ((stmt)._typ == 321 /* v.ast.ExprStmt */) {
					_result_void _t37 = v__parser__Parser_check_undefined_variables(p, names, (*stmt._v__ast__ExprStmt).expr);
					if (_t37.is_error) {
						{ // defer begin
							p->expr_level--;
						} // defer end
						_result_void _t38 = {0};
						_t38.is_error = true;
						_t38.err = _t37.err;
						return _t38;
					}
					
 ;
				}
			}
		}
	}
	else if (val._typ == 291 /* v.ast.MapInit */) {
		for (int _t39 = 0; _t39 < (*val._v__ast__MapInit).keys.len; ++_t39) {
			v__ast__Expr key = ((v__ast__Expr*)(*val._v__ast__MapInit).keys.data)[_t39];
			_result_void _t40 = v__parser__Parser_check_undefined_variables(p, names, key);
			if (_t40.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t41 = {0};
				_t41.is_error = true;
				_t41.err = _t40.err;
				return _t41;
			}
			
 ;
		}
		for (int _t42 = 0; _t42 < (*val._v__ast__MapInit).vals.len; ++_t42) {
			v__ast__Expr value = ((v__ast__Expr*)(*val._v__ast__MapInit).vals.data)[_t42];
			_result_void _t43 = v__parser__Parser_check_undefined_variables(p, names, value);
			if (_t43.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t44 = {0};
				_t44.is_error = true;
				_t44.err = _t43.err;
				return _t44;
			}
			
 ;
		}
	}
	else if (val._typ == 292 /* v.ast.MatchExpr */) {
		_result_void _t45 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__MatchExpr).cond);
		if (_t45.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t46 = {0};
			_t46.is_error = true;
			_t46.err = _t45.err;
			return _t46;
		}
		
 ;
		for (int _t47 = 0; _t47 < (*val._v__ast__MatchExpr).branches.len; ++_t47) {
			v__ast__MatchBranch branch = ((v__ast__MatchBranch*)(*val._v__ast__MatchExpr).branches.data)[_t47];
			for (int _t48 = 0; _t48 < branch.exprs.len; ++_t48) {
				v__ast__Expr expr = ((v__ast__Expr*)branch.exprs.data)[_t48];
				_result_void _t49 = v__parser__Parser_check_undefined_variables(p, names, expr);
				if (_t49.is_error) {
					{ // defer begin
						p->expr_level--;
					} // defer end
					_result_void _t50 = {0};
					_t50.is_error = true;
					_t50.err = _t49.err;
					return _t50;
				}
				
 ;
			}
			for (int _t51 = 0; _t51 < branch.stmts.len; ++_t51) {
				v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t51];
				if ((stmt)._typ == 321 /* v.ast.ExprStmt */) {
					_result_void _t52 = v__parser__Parser_check_undefined_variables(p, names, (*stmt._v__ast__ExprStmt).expr);
					if (_t52.is_error) {
						{ // defer begin
							p->expr_level--;
						} // defer end
						_result_void _t53 = {0};
						_t53.is_error = true;
						_t53.err = _t52.err;
						return _t53;
					}
					
 ;
				}
			}
		}
	}
	else if (val._typ == 297 /* v.ast.ParExpr */) {
		_result_void _t54 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__ParExpr).expr);
		if (_t54.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t55 = {0};
			_t55.is_error = true;
			_t55.err = _t54.err;
			return _t55;
		}
		
 ;
	}
	else if (val._typ == 298 /* v.ast.PostfixExpr */) {
		_result_void _t56 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__PostfixExpr).expr);
		if (_t56.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t57 = {0};
			_t57.is_error = true;
			_t57.err = _t56.err;
			return _t57;
		}
		
 ;
	}
	else if (val._typ == 299 /* v.ast.PrefixExpr */) {
		_result_void _t58 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__PrefixExpr).right);
		if (_t58.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t59 = {0};
			_t59.is_error = true;
			_t59.err = _t58.err;
			return _t59;
		}
		
 ;
	}
	else if (val._typ == 302 /* v.ast.SelectorExpr */) {
		_result_void _t60 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__SelectorExpr).expr);
		if (_t60.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t61 = {0};
			_t61.is_error = true;
			_t61.err = _t60.err;
			return _t61;
		}
		
 ;
	}
	else if (val._typ == 306 /* v.ast.StringInterLiteral */) {
		for (int _t62 = 0; _t62 < (*val._v__ast__StringInterLiteral).exprs.len; ++_t62) {
			v__ast__Expr expr_ = ((v__ast__Expr*)(*val._v__ast__StringInterLiteral).exprs.data)[_t62];
			_result_void _t63 = v__parser__Parser_check_undefined_variables(p, names, expr_);
			if (_t63.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t64 = {0};
				_t64.is_error = true;
				_t64.err = _t63.err;
				return _t64;
			}
			
 ;
		}
	}
	else if (val._typ == 236 /* v.ast.StructInit */) {
		for (int _t65 = 0; _t65 < (*val._v__ast__StructInit).init_fields.len; ++_t65) {
			v__ast__StructInitField init_field = ((v__ast__StructInitField*)(*val._v__ast__StructInit).init_fields.data)[_t65];
			_result_void _t66 = v__parser__Parser_check_undefined_variables(p, names, init_field.expr);
			if (_t66.is_error) {
				{ // defer begin
					p->expr_level--;
				} // defer end
				_result_void _t67 = {0};
				_t67.is_error = true;
				_t67.err = _t66.err;
				return _t67;
			}
			
 ;
		}
	}
	else if (val._typ == 309 /* v.ast.UnsafeExpr */) {
		_result_void _t68 = v__parser__Parser_check_undefined_variables(p, names, (*val._v__ast__UnsafeExpr).expr);
		if (_t68.is_error) {
			{ // defer begin
				p->expr_level--;
			} // defer end
			_result_void _t69 = {0};
			_t69.is_error = true;
			_t69.err = _t68.err;
			return _t69;
		}
		
 ;
	}
	
	else {
	}
	
		{ // defer begin
			p->expr_level--;
		} // defer end
	return (_result_void){0};
}
VV_LOC bool v__parser__Parser_check_cross_variables(v__parser__Parser* p, Array_v__ast__Expr exprs, v__ast__Expr val) {
	string val_str = v__ast__Expr_str(val);
	if (val._typ == 281 /* v.ast.Ident */) {
		for (int _t1 = 0; _t1 < exprs.len; ++_t1) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t1];
			if ((expr)._typ == 281 /* v.ast.Ident */) {
				if (builtin__string__eq((*expr._v__ast__Ident).name, (*val._v__ast__Ident).name)) {
					return true;
				}
			}
		}
	}
	else if (val._typ == 284 /* v.ast.IndexExpr */) {
		for (int _t3 = 0; _t3 < exprs.len; ++_t3) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t3];
			if (builtin__string__eq(v__ast__Expr_str(expr), val_str)) {
				return true;
			}
		}
	}
	else if (val._typ == 285 /* v.ast.InfixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__InfixExpr).left) || v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__InfixExpr).right);
	}
	else if (val._typ == 297 /* v.ast.ParExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__ParExpr).expr);
	}
	else if (val._typ == 267 /* v.ast.CallExpr */) {
		if (v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__CallExpr).left)) {
			return true;
		}
		for (int _t8 = 0; _t8 < (*val._v__ast__CallExpr).args.len; ++_t8) {
			v__ast__CallArg arg = ((v__ast__CallArg*)(*val._v__ast__CallExpr).args.data)[_t8];
			if (v__parser__Parser_check_cross_variables(p, exprs, arg.expr)) {
				return true;
			}
		}
	}
	else if (val._typ == 299 /* v.ast.PrefixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__PrefixExpr).right);
	}
	else if (val._typ == 298 /* v.ast.PostfixExpr */) {
		return v__parser__Parser_check_cross_variables(p, exprs, (*val._v__ast__PostfixExpr).expr);
	}
	else if (val._typ == 302 /* v.ast.SelectorExpr */) {
		for (int _t12 = 0; _t12 < exprs.len; ++_t12) {
			v__ast__Expr expr = ((v__ast__Expr*)exprs.data)[_t12];
			if (builtin__string__eq(v__ast__Expr_str(expr), val_str)) {
				return true;
			}
		}
	}
	
	else {
	}
	
	return false;
}
VV_LOC v__ast__Stmt v__parser__Parser_partial_assign_stmt(v__parser__Parser* p, Array_v__ast__Expr left) {
	p->is_stmt_ident = false;
	v__token__Kind op = p->tok.kind;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Expr right = builtin____new_array_with_default(0, left.len, sizeof(v__ast__Expr), 0);
	bool old_assign_rhs = p->inside_assign_rhs;
	p->inside_assign_rhs = true;
	right = v__parser__Parser_expr_list(p, true);
	p->inside_assign_rhs = old_assign_rhs;
	Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
	bool has_cross_var = false;
	bool is_static = false;
	bool is_volatile = false;
	for (int i = 0; i < left.len; ++i) {
		v__ast__Expr lx_ = ((v__ast__Expr*)left.data)[i];
		v__ast__Expr lx = lx_;
		if (lx._typ == 281 /* v.ast.Ident */) {
			if (op == v__token__Kind__decl_assign) {
				if (v__ast__Scope_known_var(p->scope, (*lx._v__ast__Ident).name)) {
					if (!(p->pref->translated_go && (builtin__fast_string_eq((*lx._v__ast__Ident).name, _S("err")) || builtin__fast_string_eq((*lx._v__ast__Ident).name, _S("ok"))))) {
						return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of `"), 0xfe10, {.d_s = (*lx._v__ast__Ident).name}}, {_S("`"), 0, { .d_c = 0 }}})), (*lx._v__ast__Ident).pos))), false);
					}
				}
				v__ast__ShareType share = ((v__ast__ShareType)(0));
				if (((*lx._v__ast__Ident).info)._typ == 408 /* v.ast.IdentVar */) {
					share = (*(*lx._v__ast__Ident).info._v__ast__IdentVar).share;
					if ((*(*lx._v__ast__Ident).info._v__ast__IdentVar).is_static) {
						if (!p->inside_unsafe && !p->pref->translated && !p->is_translated && !p->pref->is_fmt && !p->inside_unsafe_fn) {
							return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("static variables are supported only in -translated mode, `unsafe{}` blocks, or in `@[unsafe] fn`"), (*lx._v__ast__Ident).pos))), false);
						}
						is_static = true;
					}
					if ((*(*lx._v__ast__Ident).info._v__ast__IdentVar).is_volatile) {
						is_volatile = true;
					}
				}
				v__ast__Var v = ((v__ast__Var){
					.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.expr = (left.len == right.len ? ((*(v__ast__Expr*)builtin__array_get(right, i))) : (_const_v__ast__empty_expr)),
					.name = (*lx._v__ast__Ident).name,
					.pos = (*lx._v__ast__Ident).pos,
					.typ = 0,
					.orig_type = 0,
					.ct_type_var = 0,
					.share = share,
					.is_arg = 0,
					.is_auto_deref = 0,
					.is_unwrapped = 0,
					.is_index_var = 0,
					.is_volatile = is_volatile,
					.is_static = is_static,
					.is_special = 0,
					.is_mut = (*lx._v__ast__Ident).is_mut || p->inside_for,
					.is_used = 0,
					.is_changed = 0,
					.ct_type_unwrapped = 0,
					.is_or = 0,
					.is_tmp = 0,
					.is_auto_heap = 0,
					.is_stack_obj = p->inside_for,
					.is_inherited = 0,
					.is_autofree_tmp = 0,
					.has_inherited = 0,
				});
				if (p->prev_tok.kind == v__token__Kind__string) {
					v.typ = _const_v__ast__string_type_idx;
				} else if (p->prev_tok.kind == v__token__Kind__rsbr) {
					v.typ = _const_v__ast__array_type_idx;
				}
				if (p->pref->autofree && right.len > 0) {
					v__ast__Expr expr_for_or = ((v.expr)._typ != 277 /* v.ast.EmptyExpr */ ? (v.expr) : ((*(v__ast__Expr*)builtin__array_get(right, 0))));
					if (v__parser__expr_has_block_or(expr_for_or)) {
						v.is_or = true;
					}
				}
				v__ast__ScopeObject obj = v__ast__Var_to_sumtype_v__ast__ScopeObject(&v, false);
				(*lx._v__ast__Ident).obj = obj;
				v__ast__Scope_register(p->scope, obj);
			}
		}
		else if (lx._typ == 284 /* v.ast.IndexExpr */) {
			if (op == v__token__Kind__decl_assign) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("non-name `"), 0xfe10, {.d_s = v__ast__Expr_str((*lx._v__ast__IndexExpr).left)}}, {_S("["), 0xfe10, {.d_s = v__ast__Expr_str((*lx._v__ast__IndexExpr).index)}}, {_S("]` on left side of `:=`"), 0, { .d_c = 0 }}})), (*lx._v__ast__IndexExpr).pos))), false);
			}
			(*lx._v__ast__IndexExpr).is_setter = true;
		}
		else if (lx._typ == 297 /* v.ast.ParExpr */) {
		}
		else if (lx._typ == 299 /* v.ast.PrefixExpr */) {
		}
		else if (lx._typ == 302 /* v.ast.SelectorExpr */) {
			if (op == v__token__Kind__decl_assign) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("use assignment `=` instead of declaration `:=` when modifying struct fields"), pos))), false);
			}
		}
		
		else {
		}
		
	}
	if (op == v__token__Kind__decl_assign) {
		for (int _t5 = 0; _t5 < right.len; ++_t5) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t5];
			Array_string _t7 = {0};
			Array_v__ast__Expr _t7_orig = left;
			int _t7_len = _t7_orig.len;
			_t7 = builtin____new_array(0, _t7_len, sizeof(string));

			for (int _t9 = 0; _t9 < _t7_len; ++_t9) {
				v__ast__Expr it = ((v__ast__Expr*) _t7_orig.data)[_t9];
				string _t8 = v__ast__Expr_str(it);
				builtin__array_push((array*)&_t7, &_t8);
			}
			_result_void _t6 = v__parser__Parser_check_undefined_variables(p,_t7, r);
			if (_t6.is_error) {
				IError err = _t6.err;
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, IError_name_table[err._typ]._method_msg(err._object), pos))), false);
			}
			
 ;
		}
	} else if (left.len > 1) {
		for (int _t11 = 0; _t11 < right.len; ++_t11) {
			v__ast__Expr r = ((v__ast__Expr*)right.data)[_t11];
			has_cross_var = v__parser__Parser_check_cross_variables(p, left, r);
			if (!(op == v__token__Kind__assign || op == v__token__Kind__decl_assign)) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected_with_pos(p, pos, ((v__parser__ParamsForUnexpected){.got = v__token__Kind_str(op),.expecting = _S(":= or = or comma"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
			}
			if (has_cross_var) {
				break;
			}
		}
	}
	v__ast__Attr attr = ((v__ast__Attr){.name = (string){.str=(byteptr)"", .is_lit=1},.ct_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.arg = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.kind = 0,.ct_opt = 0,.has_at = 0,.has_arg = 0,.ct_evaled = 0,.ct_skip = 0,});
	if (p->tok.kind == v__token__Kind__at && p->tok.line_nr == p->prev_tok.line_nr) {
		v__parser__Parser_check(p, v__token__Kind__at);
		v__parser__Parser_check(p, v__token__Kind__lsbr);
		attr = v__parser__Parser_parse_attr(p, true);
		v__parser__Parser_check(p, v__token__Kind__rsbr);
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	p->expr_mod = _S("");
	return v__ast__AssignStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssignStmt, (((v__ast__AssignStmt){
		.attr = attr,
		.end_comments = end_comments,
		.right = right,
		.left = left,
		.left_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.right_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.pos = pos,
		.op = op,
		.is_static = is_static,
		.is_volatile = is_volatile,
		.is_simple = p->inside_for && p->tok.kind == v__token__Kind__lcbr,
		.has_cross_var = has_cross_var,
	}))), false);
}
VV_LOC bool v__parser__expr_has_block_or(v__ast__Expr expr) {
	return ((expr._typ == 267 /* v.ast.CallExpr */)? ((*expr._v__ast__CallExpr).or_block.kind == v__ast__OrKind__block && (*expr._v__ast__CallExpr).or_block.stmts.len > 0) : (expr._typ == 302 /* v.ast.SelectorExpr */)? ((*expr._v__ast__SelectorExpr).or_block.kind == v__ast__OrKind__block && (*expr._v__ast__SelectorExpr).or_block.stmts.len > 0) : (expr._typ == 299 /* v.ast.PrefixExpr */)? ((*expr._v__ast__PrefixExpr).or_block.kind == v__ast__OrKind__block && (*expr._v__ast__PrefixExpr).or_block.stmts.len > 0) : (expr._typ == 305 /* v.ast.SqlExpr */)? ((*expr._v__ast__SqlExpr).or_expr.kind == v__ast__OrKind__block && (*expr._v__ast__SqlExpr).or_expr.stmts.len > 0) : (expr._typ == 284 /* v.ast.IndexExpr */)? ((*expr._v__ast__IndexExpr).or_expr.kind == v__ast__OrKind__block && (*expr._v__ast__IndexExpr).or_expr.stmts.len > 0) : (expr._typ == 281 /* v.ast.Ident */)? ((*expr._v__ast__Ident).or_expr.kind == v__ast__OrKind__block && (*expr._v__ast__Ident).or_expr.stmts.len > 0) : (false));
}
VV_LOC v__ast__Attr v__parser__Parser_parse_attr(v__parser__Parser* p, bool is_at) {
	v__ast__AttrKind kind = v__ast__AttrKind__plain;
	p->inside_attr_decl = true;
	v__token__Pos apos = (is_at ? (v__token__Token_pos(ADDR(v__token__Token, v__parser__Parser_peek_token(p, -2)))) : (v__token__Token_pos(&p->prev_tok)));
	if (p->tok.kind == v__token__Kind__key_unsafe) {
		v__parser__Parser_next(p);
		v__ast__Attr _t1 = ((v__ast__Attr){.name = _S("unsafe"),.ct_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.arg = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(apos, v__token__Token_pos(&p->tok)),.kind = kind,.ct_opt = 0,.has_at = is_at,.has_arg = 0,.ct_evaled = 0,.ct_skip = 0,});
			{ // defer begin
				p->inside_attr_decl = false;
			} // defer end
		return _t1;
	}
	string name = _S("");
	bool has_arg = false;
	string arg = _S("");
	v__ast__Expr comptime_cond = _const_v__ast__empty_expr;
	bool comptime_cond_opt = false;
	if (p->tok.kind == v__token__Kind__key_if) {
		kind = v__ast__AttrKind__comptime_define;
		v__parser__Parser_next(p);
		p->comptime_if_cond = true;
		p->inside_if_expr = true;
		p->inside_ct_if_expr = true;
		comptime_cond = v__parser__Parser_expr(p, 0);
		p->comptime_if_cond = false;
		p->inside_if_expr = false;
		p->inside_ct_if_expr = false;
		if ((comptime_cond)._typ == 298 /* v.ast.PostfixExpr */) {
			comptime_cond_opt = true;
		}
		name = v__ast__Expr_str(comptime_cond);
	} else if (p->tok.kind == v__token__Kind__string) {
		name = p->tok.lit;
		kind = v__ast__AttrKind__string;
		v__parser__Parser_next(p);
	} else {
		name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind__dot) {
			v__parser__Parser_next(p);
			name = builtin__string__plus(name, _S("."));
			name = builtin__string__plus(name, v__parser__Parser_check_name(p));
		}
		if (p->tok.kind == v__token__Kind__colon) {
			has_arg = true;
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__name) {
				kind = v__ast__AttrKind__plain;
				arg = v__parser__Parser_check_name(p);
			} else if (p->tok.kind == v__token__Kind__number) {
				kind = v__ast__AttrKind__number;
				arg = p->tok.lit;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__string) {
				kind = v__ast__AttrKind__string;
				arg = p->tok.lit;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__key_true || p->tok.kind == v__token__Kind__key_false) {
				kind = v__ast__AttrKind__bool;
				arg = v__token__Kind_str(p->tok.kind);
				v__parser__Parser_next(p);
			} else if (v__token__is_key(p->tok.lit)) {
				kind = v__ast__AttrKind__plain;
				arg = v__parser__Parser_check_name(p);
			} else {
				v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = _S("an argument is expected after `:`"),}));
			}
		}
	}
	v__ast__Attr _t2 = ((v__ast__Attr){
		.name = name,
		.ct_expr = comptime_cond,
		.arg = arg,
		.pos = v__token__Pos_extend(apos, v__token__Token_pos(&p->tok)),
		.kind = kind,
		.ct_opt = comptime_cond_opt,
		.has_at = is_at,
		.has_arg = has_arg,
		.ct_evaled = 0,
		.ct_skip = 0,
	});
		{ // defer begin
			p->inside_attr_decl = false;
		} // defer end
	return _t2;
}
VV_LOC bool v__parser__Parser_is_attributes(v__parser__Parser* p) {
	if (p->tok.kind != v__token__Kind__lsbr) {
		return false;
	}
	int i = 0;
	for (;;) {
		v__token__Token tok = v__parser__Parser_peek_token(p, i);
		if (tok.kind == v__token__Kind__eof || tok.line_nr != p->tok.line_nr) {
			return false;
		}
		if (tok.kind == v__token__Kind__rsbr) {
			break;
		}
		i++;
	}
	v__token__Token peek_rsbr_tok = v__parser__Parser_peek_token(p, (int)(i + 1));
	if (peek_rsbr_tok.line_nr == p->tok.line_nr && peek_rsbr_tok.kind != v__token__Kind__rcbr) {
		return false;
	}
	return true;
}
VV_LOC void v__parser__Parser_attributes(v__parser__Parser* p) {
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	bool is_at = false;
	if (p->tok.kind == v__token__Kind__lsbr) {
		if (p->pref->is_fmt) {
		} else {
			v__parser__Parser_error(p, _S("`[attr]` has been deprecated, use `@[attr]` instead"));
		}
		v__parser__Parser_check(p, v__token__Kind__lsbr);
	} else if (p->tok.kind == v__token__Kind__at) {
		v__parser__Parser_check(p, v__token__Kind__at);
		v__parser__Parser_check(p, v__token__Kind__lsbr);
		is_at = true;
	}
	bool has_ctdefine = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rsbr)) break;
		v__token__Pos attr_start_pos = v__token__Token_pos(&p->tok);
		v__ast__Attr attr = v__parser__Parser_parse_attr(p, is_at);
		if (Array_v__ast__Attr_contains(p->attrs, attr.name) && !builtin__fast_string_eq(attr.name, _S("wasm_export"))) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicate attribute `"), 0xfe10, {.d_s = attr.name}}, {_S("`"), 0, { .d_c = 0 }}})), v__token__Pos_extend(attr_start_pos, v__token__Token_pos(&p->prev_tok)));
			return;
		}
		if (attr.kind == v__ast__AttrKind__comptime_define) {
			if (has_ctdefine) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("only one `[if flag]` may be applied at a time `"), 0xfe10, {.d_s = attr.name}}, {_S("`"), 0, { .d_c = 0 }}})), v__token__Pos_extend(attr_start_pos, v__token__Token_pos(&p->prev_tok)));
				return;
			} else {
				has_ctdefine = true;
			}
		}
		builtin__array_push((array*)&p->attrs, _MOV((v__ast__Attr[]){ attr }));
		if (p->tok.kind != v__token__Kind__semicolon) {
			if (p->tok.kind == v__token__Kind__rsbr) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("`;`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			return;
		}
		v__parser__Parser_next(p);
	}
	if (p->attrs.len == 0) {
		v__parser__Parser_error_with_pos(p, _S("attributes cannot be empty"), v__token__Pos_extend(start_pos, v__token__Token_pos(&p->tok)));
		return;
	} else {
		v__parser__Parser_check_deprecated_attributes(p);
	}
	if (p->inside_struct_attr_decl && p->tok.kind == v__token__Kind__lsbr) {
		v__parser__Parser_error_with_pos(p, _S("multiple attributes should be in the same [], with ; separators"), v__token__Pos_extend(v__token__Token_pos(&p->prev_tok), v__token__Token_pos(&p->tok)));
		return;
	} else if (p->inside_struct_attr_decl && p->tok.kind == v__token__Kind__at) {
		v__parser__Parser_error_with_pos(p, _S("multiple attributes should be in the same @[], with ; separators"), v__token__Pos_extend(v__token__Token_pos(&p->prev_tok), v__token__Token_pos(&p->tok)));
		return;
	}
}
VV_LOC void v__parser__Parser_check_deprecated_attributes(v__parser__Parser* p) {
	bool deprecated = false;
	bool deprecated_after = false;
	v__token__Pos deprecated_after_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	for (int _t1 = 0; _t1 < p->attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)p->attrs.data)[_t1];

		if (_SLIT_EQ(attr.name.str, attr.name.len, "deprecated")) {
			deprecated = true;
		}
		else if (_SLIT_EQ(attr.name.str, attr.name.len, "deprecated_after")) {
			deprecated_after = true;
			deprecated_after_pos = attr.pos;
		}
		else {
		}
	}
	if (deprecated_after && !deprecated) {
		v__parser__Parser_warn_with_pos(p, _S("@[deprecated_after] is only valid, in the presence of a `@[deprecated]` attribute"), deprecated_after_pos);
	}
}
VV_LOC bool v__parser__Parser_is_fn_type_decl(v__parser__Parser* p) {
	int n = 1;
	v__token__Token tok = p->tok;
	v__token__Token prev_tok = p->tok;
	int cur_ln = p->tok.line_nr;
	for (;;) {
		tok = v__scanner__Scanner_peek_token(p->scanner, n);
		if (tok.kind == v__token__Kind__eof) {
			break;
		}
		if (tok.kind == v__token__Kind__lpar || tok.kind == v__token__Kind__rpar) {
			n++;
			prev_tok = tok;
			continue;
		}
		if (tok.kind == v__token__Kind__pipe) {
			if ((int)(tok.pos - prev_tok.pos) > prev_tok.len) {
				return false;
			}
		}
		if (tok.line_nr > cur_ln) {
			break;
		}
		prev_tok = tok;
		n++;
	}
	return true;
}
VV_LOC bool v__parser__Parser_has_prev_newline(v__parser__Parser* p) {
	v__token__Token tok = p->tok;
	v__token__Token prev_tok = p->prev_tok;
	int idx = -1;
	for (;;) {
		if ((int)((int)(tok.line_nr - prev_tok.line_nr) - builtin__string_count(prev_tok.lit, _S("\n"))) > 1) {
			return true;
		}
		if (prev_tok.kind == v__token__Kind__comment) {
			idx--;
			tok = prev_tok;
			prev_tok = v__parser__Parser_peek_token(p, idx);
			continue;
		}
		break;
	}
	return false;
}
VV_LOC bool v__parser__Parser_has_prev_line_comment_or_label(v__parser__Parser* p) {
	return p->prev_tok.kind == v__token__Kind__colon || (p->prev_tok.kind == v__token__Kind__comment && (int)(p->tok.line_nr - p->prev_tok.line_nr) == 1 && (int)(p->prev_tok.line_nr - v__parser__Parser_peek_token(p, -2).line_nr) > 0);
}
VV_LOC bool v__parser__Parser_is_array_type(v__parser__Parser* p) {
	int i = 1;
	v__token__Token tok = p->tok;
	int line_nr = p->tok.line_nr;
	for (;;) {
		tok = v__parser__Parser_peek_token(p, i);
		if (tok.line_nr != line_nr) {
			return false;
		}
		if (tok.kind == v__token__Kind__name || tok.kind == v__token__Kind__amp) {
			return true;
		}
		if (tok.kind == v__token__Kind__eof || tok.kind == v__token__Kind__colon || tok.kind == v__token__Kind__dot) {
			break;
		}
		i++;
	}
	return false;
}
VV_LOC bool v__parser__Parser_is_following_concrete_types(v__parser__Parser* p) {
	if (!(p->tok.kind == v__token__Kind__lsbr && v__token__Token_is_next_to(p->tok, p->prev_tok))) {
		return false;
	}
	int i = 1;
	for (;;) {
		v__token__Token cur_tok = v__parser__Parser_peek_token(p, i);
		if (cur_tok.kind == v__token__Kind__eof) {
			return false;
		} else if (cur_tok.kind == v__token__Kind__rsbr) {
			break;
		} else if (cur_tok.kind == v__token__Kind__name) {
			if (v__parser__Parser_peek_token(p, (int)(i + 1)).kind == v__token__Kind__dot) {
				if (v__parser__Parser_is_typename(p, cur_tok)) {
					return false;
				}
				i++;
			} else if (!(v__parser__Parser_is_typename(p, cur_tok) && !(cur_tok.lit.len == 1 && !builtin__u8_is_capital(builtin__string_at(cur_tok.lit, 0))))) {
				return false;
			}
		} else if (cur_tok.kind != v__token__Kind__comma) {
			return false;
		}
		i++;
	}
	return true;
}
VV_LOC bool v__parser__Parser_is_generic_struct_init(v__parser__Parser* p) {
	bool lit0_is_capital = p->tok.kind != v__token__Kind__eof && p->tok.lit.len > 0 && builtin__u8_is_capital(p->tok.lit.str[ 0]);
	if (!lit0_is_capital || p->peek_tok.kind != v__token__Kind__lsbr) {
		return false;
	}
	int i = 2;
	int nested_sbr_count = 0;
	for (;;) {
		v__token__Token cur_tok = v__parser__Parser_peek_token(p, i);
		if (cur_tok.kind == v__token__Kind__eof || !(cur_tok.kind == v__token__Kind__amp || cur_tok.kind == v__token__Kind__dot || cur_tok.kind == v__token__Kind__comma || cur_tok.kind == v__token__Kind__name || cur_tok.kind == v__token__Kind__lpar || cur_tok.kind == v__token__Kind__rpar || cur_tok.kind == v__token__Kind__lsbr || cur_tok.kind == v__token__Kind__rsbr || cur_tok.kind == v__token__Kind__key_fn)) {
			break;
		}
		if (cur_tok.kind == v__token__Kind__lsbr) {
			nested_sbr_count++;
		} else if (cur_tok.kind == v__token__Kind__rsbr) {
			if (nested_sbr_count > 0) {
				nested_sbr_count--;
			} else {
				if (v__parser__Parser_peek_token(p, (int)(i + 1)).kind == v__token__Kind__lcbr) {
					return true;
				}
				break;
			}
		}
		i++;
	}
	return false;
}
inline VV_LOC bool v__parser__Parser_is_typename(v__parser__Parser* p, v__token__Token t) {
	return t.kind == v__token__Kind__name && (builtin__u8_is_capital(t.lit.str[ 0]) || v__ast__Table_known_type(p->table, t.lit));
}
VV_LOC bool v__parser__Parser_is_generic_call(v__parser__Parser* p) {
	bool lit0_is_capital = p->tok.kind != v__token__Kind__eof && p->tok.lit.len > 0 && builtin__u8_is_capital(p->tok.lit.str[ 0]);
	if (lit0_is_capital || p->peek_tok.kind != v__token__Kind__lsbr) {
		return false;
	}
	v__token__Token tok2 = v__parser__Parser_peek_token(p, 2);
	v__token__Token tok3 = v__parser__Parser_peek_token(p, 3);
	v__token__Token tok4 = v__parser__Parser_peek_token(p, 4);
	v__token__Token tok5 = v__parser__Parser_peek_token(p, 5);
	v__token__Kind kind2 = tok2.kind;
	v__token__Kind kind3 = tok3.kind;
	v__token__Kind kind4 = tok4.kind;
	v__token__Kind kind5 = tok5.kind;
	if (kind2 == v__token__Kind__amp) {
		tok2 = tok3;
		kind2 = kind3;
		tok3 = tok4;
		kind3 = kind4;
		tok4 = tok5;
		kind4 = kind5;
		tok5 = v__parser__Parser_peek_token(p, 6);
		kind5 = tok5.kind;
	}
	if (kind2 == v__token__Kind__lsbr) {
		return tok3.kind == v__token__Kind__rsbr || (tok4.kind == v__token__Kind__rsbr && v__parser__Parser_is_typename(p, tok5));
	}
	if (kind2 == v__token__Kind__name) {
		if (kind3 == v__token__Kind__lsbr && builtin__fast_string_eq(tok2.lit, _S("map"))) {
			return true;
		}
		if (p->peek_tok.kind == v__token__Kind__lsbr) {
			int i = 3;
			int nested_sbr_count = 0;
			for (;;) {
				v__token__Token cur_tok = v__parser__Parser_peek_token(p, i);
				if (cur_tok.kind == v__token__Kind__eof || !(cur_tok.kind == v__token__Kind__amp || cur_tok.kind == v__token__Kind__dot || cur_tok.kind == v__token__Kind__comma || cur_tok.kind == v__token__Kind__name || cur_tok.kind == v__token__Kind__lpar || cur_tok.kind == v__token__Kind__rpar || cur_tok.kind == v__token__Kind__lsbr || cur_tok.kind == v__token__Kind__rsbr || cur_tok.kind == v__token__Kind__key_fn)) {
					break;
				}
				if (cur_tok.kind == v__token__Kind__lsbr) {
					nested_sbr_count++;
				}
				if (cur_tok.kind == v__token__Kind__rsbr) {
					if (nested_sbr_count > 0) {
						nested_sbr_count--;
					} else {
						v__token__Token prev_tok = v__parser__Parser_peek_token(p, (int)(i - 1));
						if (!(v__parser__Parser_is_typename(p, prev_tok) || prev_tok.kind == v__token__Kind__rsbr)) {
							return false;
						}
						if (v__parser__Parser_peek_token(p, (int)(i + 1)).kind == v__token__Kind__lpar) {
							return true;
						}
						break;
					}
				}
				i++;
			}
		}
	}
	return false;
}
VV_LOC bool v__parser__Parser_is_generic_cast(v__parser__Parser* p) {
	if (!v__ast__type_can_start_with_token(&p->tok)) {
		return false;
	}
	int i = 0;
	int level = 0;
	int lt_count = 0;
	for (;;) {
		i++;
		v__token__Token tok = v__parser__Parser_peek_token(p, i);
		if (tok.kind == v__token__Kind__lsbr) {
			lt_count++;
			level++;
		} else if (tok.kind == v__token__Kind__rsbr) {
			level--;
		}
		if (lt_count > 0 && level == 0) {
			break;
		}
		if (i > 20 || !(Array_v__token__Kind_contains(_const_v__parser__valid_tokens_inside_types, tok.kind))) {
			return false;
		}
	}
	v__token__Token next_tok = v__parser__Parser_peek_token(p, (int)(i + 1));
	if (next_tok.kind == v__token__Kind__lpar) {
		return true;
	}
	return false;
}
inline VV_LOC bool v__parser__Parser_is_generic_name(v__parser__Parser* p) {
	return p->tok.kind == v__token__Kind__name && v__util__is_generic_type_name(p->tok.lit);
}
void v__parser__Parser_codegen(v__parser__Parser* p, string code) {
	p->codegen_text = builtin__string__plus(p->codegen_text, code);
}
VV_LOC void v__parser__Parser_handle_codegen_for_file(v__parser__Parser* p) {
	if (p->pref->is_fmt || (p->codegen_text).len == 0) {
		return;
	}
	string ptext = builtin__string__plus(builtin__string__plus(builtin__string__plus(_S("module "), builtin__string_all_after_last(p->mod, _S("."))), _S("\n")), p->codegen_text);
	builtin__array_push((array*)&codegen_files, _MOV((v__ast__File*[]){ v__parser__parse_text(ptext, p->file_path, p->table, p->scanner->comments_mode, p->pref) }));
}
VV_LOC void v__parser__handle_codegen_for_multiple_files(Array_v__ast__File_ptr* files) {
	if (codegen_files.len == 0) {
		return;
	}
	_PUSH_MANY(files, (codegen_files), _t1, Array_v__ast__File_ptr);
	builtin__array_clear(&codegen_files);
}
VV_LOC v__ast__ComptimeType v__parser__Parser_parse_comptime_type(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__dollar);
	string name = v__parser__Parser_check_name(p);
	if (!(Array_string_contains(_const_v__parser__comptime_types, name))) {
		v__parser__Parser_error(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("unsupported compile-time type `"), 0xfe10, {.d_s = name}}, {_S("`: only "), 0xfe10, {.d_s = Array_string_str(_const_v__parser__comptime_types)}}, {_S(" are supported"), 0, { .d_c = 0 }}})));
	}
	v__ast__ComptimeTypeKind kind = v__ast__ComptimeTypeKind__unknown;
	kind = ((_SLIT_EQ(name.str, name.len, "map"))? (v__ast__ComptimeTypeKind__map) : (_SLIT_EQ(name.str, name.len, "struct"))? (v__ast__ComptimeTypeKind__struct) : (_SLIT_EQ(name.str, name.len, "interface"))? (v__ast__ComptimeTypeKind__iface) : (_SLIT_EQ(name.str, name.len, "int"))? (v__ast__ComptimeTypeKind__int) : (_SLIT_EQ(name.str, name.len, "float"))? (v__ast__ComptimeTypeKind__float) : (_SLIT_EQ(name.str, name.len, "alias"))? (v__ast__ComptimeTypeKind__alias) : (_SLIT_EQ(name.str, name.len, "function"))? (v__ast__ComptimeTypeKind__function) : (_SLIT_EQ(name.str, name.len, "array"))? (v__ast__ComptimeTypeKind__array) : (_SLIT_EQ(name.str, name.len, "array_fixed"))? (v__ast__ComptimeTypeKind__array_fixed) : (_SLIT_EQ(name.str, name.len, "array_dynamic"))? (v__ast__ComptimeTypeKind__array_dynamic) : (_SLIT_EQ(name.str, name.len, "enum"))? (v__ast__ComptimeTypeKind__enum) : (_SLIT_EQ(name.str, name.len, "sumtype"))? (v__ast__ComptimeTypeKind__sum_type) : (_SLIT_EQ(name.str, name.len, "option"))? (v__ast__ComptimeTypeKind__option) : (_SLIT_EQ(name.str, name.len, "shared"))? (v__ast__ComptimeTypeKind__shared) : (_SLIT_EQ(name.str, name.len, "string"))? (v__ast__ComptimeTypeKind__string) : (_SLIT_EQ(name.str, name.len, "pointer"))? (v__ast__ComptimeTypeKind__pointer) : (_SLIT_EQ(name.str, name.len, "voidptr"))? (v__ast__ComptimeTypeKind__voidptr) : (v__ast__ComptimeTypeKind__unknown));
	return ((v__ast__ComptimeType){.kind = kind,.pos = pos,});
}
VV_LOC v__ast__HashStmt v__parser__Parser_hash(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	string val = p->tok.lit;
	string kind = builtin__string_all_before(val, _S(" "));
	Array_v__ast__Attr attrs = p->attrs;
	v__parser__Parser_next(p);
	string main_str = _S("");
	string msg = _S("");
	string content = builtin__string_all_before(builtin__string_all_after(val, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = kind}}, {_S(" "), 0, { .d_c = 0 }}}))), _S("//"));
	if (builtin__string_contains(content, _S(" #"))) {
		main_str = builtin__string_trim_space(builtin__string_all_before(content, _S(" #")));
		msg = builtin__string_trim_space(builtin__string_all_after(content, _S(" #")));
	} else {
		main_str = builtin__string_trim_space(content);
		msg = _S("");
	}
	bool is_use_once = false;
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr fna = ((v__ast__Attr*)attrs.data)[_t1];

		if (_SLIT_EQ(fna.name.str, fna.name.len, "use_once")) {
			is_use_once = true;
		}
		else {
		}
	}
	return ((v__ast__HashStmt){
		.mod = p->mod,
		.pos = pos,
		.source_file = p->file_path,
		.is_use_once = is_use_once,
		.val = val,
		.kind = kind,
		.main = main_str,
		.msg = msg,
		.ct_conds = builtin____new_array(0, 0, sizeof(v__ast__Expr)),
		.attrs = attrs,
	});
}
VV_LOC v__ast__ComptimeCall v__parser__Parser_comptime_call(v__parser__Parser* p) {
	v__ast__ComptimeCall *err_node = HEAP(v__ast__ComptimeCall, (((v__ast__ComptimeCall){.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),.method_name = (string){.str=(byteptr)"", .is_lit=1},.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.env_value = (string){.str=(byteptr)"", .is_lit=1},.args_var = (string){.str=(byteptr)"", .is_lit=1},.compile_value = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.result_type = 0,.left_type = 0,.kind = v__ast__ComptimeCallKind__unknown,.is_d_resolved = 0,.is_veb = 0,.is_vweb = 0,.has_parens = 0,})));
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__dollar);
	bool is_veb = false;
	if (p->peek_tok.kind == v__token__Kind__dot) {
		string name = v__parser__Parser_check_name(p);
		if (_SLIT_NE(name.str, name.len, "vweb") && _SLIT_NE(name.str, name.len, "veb")) {
			v__parser__Parser_error(p, _const_v__parser__error_msg);
			return (*(err_node));
		}
		Array_string _t2 = {0};
		Array_v__ast__Import _t2_orig = p->ast_imports;
		int _t2_len = _t2_orig.len;
		_t2 = builtin____new_array(0, _t2_len, sizeof(string));

		for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
			v__ast__Import it = ((v__ast__Import*) _t2_orig.data)[_t4];
			string _t3 = it.mod;
			builtin__array_push((array*)&_t2, &_t3);
		}
		Array_string import_mods =_t2;
		if (_SLIT_EQ(name.str, name.len, "vweb")) {
			if (!(Array_string_contains(import_mods, _S("vweb"))) && !(Array_string_contains(import_mods, _S("x.vweb")))) {
				v__parser__Parser_error_with_pos(p, _S("`$vweb` cannot be used without importing vweb"), v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)));
				return (*(err_node));
			}
			v__parser__Parser_register_used_import(p, _S("vweb"));
		} else if (_SLIT_EQ(name.str, name.len, "veb")) {
			if (!(Array_string_contains(import_mods, _S("veb")))) {
				v__parser__Parser_error_with_pos(p, _S("`$veb` cannot be used without importing veb"), v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)));
				return (*(err_node));
			}
			v__parser__Parser_register_used_import(p, _S("veb"));
			is_veb = true;
		}
		v__parser__Parser_check(p, v__token__Kind__dot);
	}
	string method_name = v__parser__Parser_check_name(p);
	if (!(Array_string_contains(_const_v__parser__supported_comptime_calls, method_name))) {
		v__parser__Parser_error(p, _const_v__parser__error_msg);
		return (*(err_node));
	}
	bool is_embed_file = _SLIT_EQ(method_name.str, method_name.len, "embed_file");
	bool is_html = _SLIT_EQ(method_name.str, method_name.len, "html");
	v__parser__Parser_check(p, v__token__Kind__lpar);
	v__token__Pos arg_pos = v__token__Token_pos(&p->tok);
	if (_SLIT_EQ(method_name.str, method_name.len, "env") || _SLIT_EQ(method_name.str, method_name.len, "pkgconfig")) {
		string s = p->tok.lit;
		v__parser__Parser_check(p, v__token__Kind__string);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		bool is_env = _SLIT_EQ(method_name.str, method_name.len, "env");
		return ((v__ast__ComptimeCall){
			.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
			.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
			.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
			.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),
			.method_name = method_name,
			.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args_var = s,
			.compile_value = (string){.str=(byteptr)"", .is_lit=1},
			.scope = ((void*)0),
			.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
			.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.env_pos = start_pos,
			.result_type = 0,
			.left_type = 0,
			.kind = (is_env ? (v__ast__ComptimeCallKind__env) : (v__ast__ComptimeCallKind__pkgconfig)),
			.is_d_resolved = 0,
			.is_veb = 0,
			.is_vweb = 0,
			.has_parens = 0,
		});
	} else if (_SLIT_EQ(method_name.str, method_name.len, "compile_error") || _SLIT_EQ(method_name.str, method_name.len, "compile_warn")) {
		string s = _S("");
		Array_v__ast__CallArg args = builtin____new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
		if (p->tok.kind == v__token__Kind__string && p->peek_tok.kind == v__token__Kind__rpar) {
			s = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind__string);
		} else {
			builtin__array_push((array*)&args, _MOV((v__ast__CallArg[]){ ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__parser__Parser_string_expr(p),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__string_type,.share = 0,.ct_expr = true,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,}) }));
		}
		v__parser__Parser_check(p, v__token__Kind__rpar);
		return ((v__ast__ComptimeCall){
			.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
			.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
			.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
			.args = args,
			.method_name = method_name,
			.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args_var = s,
			.compile_value = (string){.str=(byteptr)"", .is_lit=1},
			.scope = ((void*)0),
			.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
			.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.env_pos = start_pos,
			.result_type = 0,
			.left_type = 0,
			.kind = (_SLIT_EQ(method_name.str, method_name.len, "compile_error") ? (v__ast__ComptimeCallKind__compile_error) : (v__ast__ComptimeCallKind__compile_warn)),
			.is_d_resolved = 0,
			.is_veb = 0,
			.is_vweb = 0,
			.has_parens = 0,
		});
	} else if (_SLIT_EQ(method_name.str, method_name.len, "res")) {
		bool has_args = false;
		string type_index = _S("");
		if (p->tok.kind == v__token__Kind__number) {
			has_args = true;
			type_index = p->tok.lit;
			v__parser__Parser_check(p, v__token__Kind__number);
		}
		v__parser__Parser_check(p, v__token__Kind__rpar);
		if (has_args) {
			return ((v__ast__ComptimeCall){.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),.method_name = method_name,.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.env_value = (string){.str=(byteptr)"", .is_lit=1},.args_var = type_index,.compile_value = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.result_type = 0,.left_type = 0,.kind = v__ast__ComptimeCallKind__res,.is_d_resolved = 0,.is_veb = 0,.is_vweb = 0,.has_parens = 0,});
		}
		return ((v__ast__ComptimeCall){.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),.method_name = method_name,.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.env_value = (string){.str=(byteptr)"", .is_lit=1},.args_var = (string){.str=(byteptr)"", .is_lit=1},.compile_value = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.result_type = 0,.left_type = 0,.kind = v__ast__ComptimeCallKind__res,.is_d_resolved = 0,.is_veb = 0,.is_vweb = 0,.has_parens = 0,});
	} else if (_SLIT_EQ(method_name.str, method_name.len, "d")) {
		string const_string = p->tok.lit;
		v__parser__Parser_check(p, v__token__Kind__string);
		v__parser__Parser_check(p, v__token__Kind__comma);
		v__ast__Expr arg_expr = v__parser__Parser_expr(p, 0);
		Array_v__ast__CallArg args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = arg_expr,.pos = v__token__Token_pos(&p->tok),.typ = 0,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,})}));
		v__parser__Parser_check(p, v__token__Kind__rpar);
		return ((v__ast__ComptimeCall){
			.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
			.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
			.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
			.args = args,
			.method_name = method_name,
			.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args_var = const_string,
			.compile_value = (string){.str=(byteptr)"", .is_lit=1},
			.scope = ((void*)0),
			.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
			.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.result_type = 0,
			.left_type = 0,
			.kind = v__ast__ComptimeCallKind__d,
			.is_d_resolved = 0,
			.is_veb = 0,
			.is_vweb = 0,
			.has_parens = 0,
		});
	}
	bool has_string_arg = p->tok.kind == v__token__Kind__string;
	string literal_string_param = (is_html && !has_string_arg ? (_S("")) : (p->tok.lit));
	if (p->tok.kind == v__token__Kind__name) {
		_option_v__ast__Var_ptr _t14;
		_option_v__ast__ConstField_ptr _t15;
		if (_t14 = v__ast__Scope_find_var(p->scope, p->tok.lit), _t14.state == 0) {
			v__ast__Var* var = *(v__ast__Var**)_t14.data;
			if ((var->expr)._typ == 237 /* v.ast.StringLiteral */) {
				literal_string_param = (*var->expr._v__ast__StringLiteral).val;
			}
		} else if (_t15 = v__ast__Scope_find_const(p->table->global_scope, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit)), _t15.state == 0) {
			v__ast__ConstField* var = *(v__ast__ConstField**)_t15.data;
			if ((var->expr)._typ == 237 /* v.ast.StringLiteral */) {
				literal_string_param = (*var->expr._v__ast__StringLiteral).val;
			}
		}
	}
	string path_of_literal_string_param = builtin__string_replace(literal_string_param, _S("/"), _const_os__path_separator);
	v__ast__CallArg arg = ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,});
	if (is_html && !(has_string_arg || p->tok.kind == v__token__Kind__rpar)) {
		v__parser__Parser_error(p, _S("expecting `$vweb.html()` for a default template path or `$vweb.html(\"/path/to/template.html\")`"));
	}
	if (is_html && p->tok.kind != v__token__Kind__string) {
	} else {
		v__ast__Expr arg_expr = v__parser__Parser_expr(p, 0);
		arg = ((v__ast__CallArg){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = arg_expr,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.share = 0,.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = 0,});
	}
	string embed_compression_type = _S("none");
	if (is_embed_file) {
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
			embed_compression_type = v__parser__Parser_check_name(p);
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	if (is_embed_file) {
		v__parser__Parser_register_auto_import(p, _S("v.preludes.embed_file"));
		if (_SLIT_EQ(embed_compression_type.str, embed_compression_type.len, "zlib")) {
			v__parser__Parser_register_auto_import(p, _S("v.preludes.embed_file.zlib"));
		}
		return ((v__ast__ComptimeCall){
			.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
			.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = embed_compression_type,.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
			.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
			.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){arg})),
			.method_name = method_name,
			.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args_var = (string){.str=(byteptr)"", .is_lit=1},
			.compile_value = (string){.str=(byteptr)"", .is_lit=1},
			.scope = ((void*)0),
			.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
			.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.result_type = 0,
			.left_type = 0,
			.kind = v__ast__ComptimeCallKind__embed_file,
			.is_d_resolved = 0,
			.is_veb = 0,
			.is_vweb = 0,
			.has_parens = 0,
		});
	}
	Array_string fn_path = builtin__string_split(p->cur_fn_name, _S("_"));
	string fn_path_joined = Array_string_join(fn_path, _const_os__path_separator);
	string compiled_vfile_path = os__real_path(builtin__string_replace(p->scanner->file_path, _S("/"), _const_os__path_separator));
	string tmpl_path = (is_html && !has_string_arg ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = (*(string*)builtin__array_last(fn_path))}}, {_S(".html"), 0, { .d_c = 0 }}}))) : (path_of_literal_string_param));
	string dir = os__dir(compiled_vfile_path);
	string path = os__join_path_single(dir, fn_path_joined);
	path = builtin__string__plus(path, _S(".html"));
	path = os__real_path(path);
	if (!is_html || has_string_arg) {
		if (os__is_abs_path(tmpl_path)) {
			path = tmpl_path;
		} else {
			path = os__join_path_single(dir, tmpl_path);
		}
	}
	if (!os__exists(path)) {
		if (is_html) {
			path = os__join_path(dir, builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("templates"), fn_path_joined})));
			path = builtin__string__plus(path, _S(".html"));
		}
		if (!os__exists(path)) {
			if (p->pref->is_fmt) {
				return ((v__ast__ComptimeCall){
					.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
					.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
					.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
					.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){arg})),
					.method_name = method_name,
					.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
					.env_value = (string){.str=(byteptr)"", .is_lit=1},
					.args_var = literal_string_param,
					.compile_value = (string){.str=(byteptr)"", .is_lit=1},
					.scope = ((void*)0),
					.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
					.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
					.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
					.result_type = 0,
					.left_type = 0,
					.kind = (is_html ? (v__ast__ComptimeCallKind__html) : (v__ast__ComptimeCallKind__tmpl)),
					.is_d_resolved = 0,
					.is_veb = is_veb,
					.is_vweb = true,
					.has_parens = 0,
				});
			}
			if (is_html) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("veb HTML template \""), 0xfe10, {.d_s = tmpl_path}}, {_S("\" not found"), 0, { .d_c = 0 }}})), arg_pos);
			} else {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("template file \""), 0xfe10, {.d_s = tmpl_path}}, {_S("\" not found"), 0, { .d_c = 0 }}})), arg_pos);
			}
			return (*(err_node));
		}
	}
	string tmp_fn_name = builtin__string__plus(builtin__string_replace(p->cur_fn_name, _S("."), _S("__")), builtin__int_str(start_pos.pos));
	string v_code = v__parser__Parser_compile_template_file(p, path, tmp_fn_name);
	v__parser__Parser_open_scope(p);
	v__ast__File* file = v__parser__parse_comptime(tmpl_path, v_code, p->table, p->pref, p->scope);
	file->path = tmpl_path;
	file->call_stack = builtin__new_array_from_c_array(1, 1, sizeof(v__errors__CallStackItem), _MOV((v__errors__CallStackItem[1]){((v__errors__CallStackItem){.file_path = p->file_path,.pos = start_pos,})}));
	file->template_paths = p->template_paths;
	file->template_line_map = p->template_line_map;
	v__ast__ComptimeCall _t19 = ((v__ast__ComptimeCall){
		.veb_tmpl = *file,
		.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
		.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
		.args = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__CallArg), _MOV((v__ast__CallArg[1]){arg})),
		.method_name = method_name,
		.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.env_value = (string){.str=(byteptr)"", .is_lit=1},
		.args_var = literal_string_param,
		.compile_value = (string){.str=(byteptr)"", .is_lit=1},
		.scope = ((void*)0),
		.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
		.method_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.result_type = 0,
		.left_type = 0,
		.kind = (is_html ? (v__ast__ComptimeCallKind__html) : (v__ast__ComptimeCallKind__tmpl)),
		.is_d_resolved = 0,
		.is_veb = is_veb,
		.is_vweb = true,
		.has_parens = 0,
	});
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t19;
}
VV_LOC v__ast__ComptimeFor v__parser__Parser_comptime_for(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_check(p, v__token__Kind__key_for);
	v__token__Pos var_pos = v__token__Token_pos(&p->tok);
	string val_var = v__parser__Parser_check_name(p);
	v__parser__Parser_check(p, v__token__Kind__key_in);
	v__ast__Expr expr = _const_v__ast__empty_expr;
	v__token__Pos typ_pos = v__token__Token_pos(&p->tok);
	v__ast__Language lang = v__parser__Parser_parse_language(p);
	v__ast__Type typ = _const_v__ast__void_type;
	if (p->tok.lit.len == 0) {
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid expr, use `"), 0xfe10, {.d_s = p->peek_tok.lit}}, {_S("` instead"), 0, { .d_c = 0 }}})));
		return ((v__ast__ComptimeFor){.val_var = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.typ = 0,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},});
	}
	if (builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) || _IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
		typ = v__parser__Parser_parse_any_type(p, lang, false, true, false);
	} else {
		expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_ident(p, lang))), false);
		v__ast__Scope_mark_var_as_used(p->scope, (*(v__ast__Ident*)builtin____as_cast((expr)._v__ast__Ident,(expr)._typ, 281)).name);
	}
	typ_pos = v__token__Pos_extend(typ_pos, v__token__Token_pos(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__dot);
	string for_val = v__parser__Parser_check_name(p);
	v__ast__ComptimeForKind kind = v__ast__ComptimeForKind__methods;
	v__parser__Parser_open_scope(p);

	if (_SLIT_EQ(for_val.str, for_val.len, "params")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("FunctionParam")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		kind = v__ast__ComptimeForKind__params;
	}
	else if (_SLIT_EQ(for_val.str, for_val.len, "methods")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("FunctionData")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
	}
	else if (_SLIT_EQ(for_val.str, for_val.len, "values")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("EnumData")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		kind = v__ast__ComptimeForKind__values;
	}
	else if (_SLIT_EQ(for_val.str, for_val.len, "fields")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("FieldData")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		kind = v__ast__ComptimeForKind__fields;
	}
	else if (_SLIT_EQ(for_val.str, for_val.len, "variants")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("VariantData")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		kind = v__ast__ComptimeForKind__variants;
	}
	else if (_SLIT_EQ(for_val.str, for_val.len, "attributes")) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var,.pos = var_pos,.typ = v__ast__Table_find_type(p->table, _S("VAttribute")),.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		kind = v__ast__ComptimeForKind__attributes;
	}
	else {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown kind `"), 0xfe10, {.d_s = for_val}}, {_S("`, available are: `methods`, `fields`, `values`, `variants`, `attributes` or `params`"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->prev_tok));
		v__ast__ComptimeFor _t2 = ((v__ast__ComptimeFor){.val_var = (string){.str=(byteptr)"", .is_lit=1},.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.typ = 0,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},});
			{ // defer begin
				v__parser__Parser_close_scope(p);
			} // defer end
		return _t2;
	}
	v__token__Pos spos = v__token__Token_pos(&p->tok);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
	v__ast__ComptimeFor _t3 = ((v__ast__ComptimeFor){
		.val_var = val_var,
		.kind = kind,
		.pos = v__token__Pos_extend(spos, v__token__Token_pos(&p->tok)),
		.typ_pos = typ_pos,
		.scope = p->scope,
		.stmts = stmts,
		.typ = typ,
		.expr = expr,
	});
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t3;
}
VV_LOC v__ast__AtExpr v__parser__Parser_at(v__parser__Parser* p) {
	string name = p->tok.lit;
	v__token__AtKind kind = ((_SLIT_EQ(name.str, name.len, "@FN"))? (v__token__AtKind__fn_name) : (_SLIT_EQ(name.str, name.len, "@METHOD"))? (v__token__AtKind__method_name) : (_SLIT_EQ(name.str, name.len, "@MOD"))? (v__token__AtKind__mod_name) : (_SLIT_EQ(name.str, name.len, "@STRUCT"))? (v__token__AtKind__struct_name) : (_SLIT_EQ(name.str, name.len, "@FILE"))? (v__token__AtKind__file_path) : (_SLIT_EQ(name.str, name.len, "@DIR"))? (v__token__AtKind__file_dir) : (_SLIT_EQ(name.str, name.len, "@LINE"))? (v__token__AtKind__line_nr) : (_SLIT_EQ(name.str, name.len, "@FILE_LINE"))? (v__token__AtKind__file_path_line_nr) : (_SLIT_EQ(name.str, name.len, "@LOCATION"))? (v__token__AtKind__location) : (_SLIT_EQ(name.str, name.len, "@COLUMN"))? (v__token__AtKind__column_nr) : (_SLIT_EQ(name.str, name.len, "@VCURRENTHASH"))? (v__token__AtKind__v_current_hash) : (_SLIT_EQ(name.str, name.len, "@VHASH"))? (v__token__AtKind__vhash) : (_SLIT_EQ(name.str, name.len, "@VMOD_FILE"))? (v__token__AtKind__vmod_file) : (_SLIT_EQ(name.str, name.len, "@VEXE"))? (v__token__AtKind__vexe_path) : (_SLIT_EQ(name.str, name.len, "@VEXEROOT"))? (v__token__AtKind__vexeroot_path) : (_SLIT_EQ(name.str, name.len, "@VMODROOT"))? (v__token__AtKind__vmodroot_path) : (_SLIT_EQ(name.str, name.len, "@VMODHASH"))? (v__token__AtKind__vmod_hash) : (_SLIT_EQ(name.str, name.len, "@VROOT"))? (v__token__AtKind__vroot_path) : (_SLIT_EQ(name.str, name.len, "@BUILD_DATE"))? (v__token__AtKind__build_date) : (_SLIT_EQ(name.str, name.len, "@BUILD_TIME"))? (v__token__AtKind__build_time) : (_SLIT_EQ(name.str, name.len, "@BUILD_TIMESTAMP"))? (v__token__AtKind__build_timestamp) : (_SLIT_EQ(name.str, name.len, "@OS"))? (v__token__AtKind__os) : (_SLIT_EQ(name.str, name.len, "@CCOMPILER"))? (v__token__AtKind__ccompiler) : (_SLIT_EQ(name.str, name.len, "@BACKEND"))? (v__token__AtKind__backend) : (_SLIT_EQ(name.str, name.len, "@PLATFORM"))? (v__token__AtKind__platform) : (v__token__AtKind__unknown));
	v__ast__AtExpr expr = ((v__ast__AtExpr){.name = name,.pos = v__token__Token_pos(&p->tok),.kind = kind,.val = (string){.str=(byteptr)"", .is_lit=1},});
	v__parser__Parser_next(p);
	return expr;
}
VV_LOC v__ast__Expr v__parser__Parser_comptime_selector(v__parser__Parser* p, v__ast__Expr left) {
	v__parser__Parser_check(p, v__token__Kind__dollar);
	v__token__Pos start_pos = v__token__Token_pos(&p->prev_tok);
	if (p->peek_tok.kind == v__token__Kind__lpar) {
		v__token__Pos method_pos = v__token__Token_pos(&p->tok);
		string method_name = v__parser__Parser_check_name(p);
		v__ast__Scope_mark_var_as_used(p->scope, method_name);
		v__parser__Parser_check(p, v__token__Kind__lpar);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		v__ast__OrKind or_kind = v__ast__OrKind__absent;
		v__token__Pos or_pos = v__token__Token_pos(&p->tok);
		Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__ast__Scope* or_scope = _const_v__ast__empty_scope;
		if (p->tok.kind == v__token__Kind__key_orelse) {
			or_kind = v__ast__OrKind__block;
			multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_14449 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
			or_stmts = mr_14449.arg0;
			or_pos = mr_14449.arg1;
			or_scope = mr_14449.arg2;
		}
		return v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, (((v__ast__ComptimeCall){
			.veb_tmpl = ((v__ast__File){.nr_lines = 0,.nr_bytes = 0,.nr_tokens = 0,.mod = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,}),.global_scope = ((void*)0),.is_test = 0,.is_generated = 0,.is_translated = 0,.language = 0,.idx = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.path_base = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),.auto_imports = builtin____new_array(0, 0, sizeof(string)),.used_imports = builtin____new_array(0, 0, sizeof(string)),.implied_imports = builtin____new_array(0, 0, sizeof(string)),.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.template_paths = builtin____new_array(0, 0, sizeof(string)),.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},.is_parse_text = 0,.is_template_text = 0,}),
			.embed_file = ((v__ast__EmbeddedFile){.bytes = builtin____new_array(0, 0, sizeof(u8)),.compression_type = (string){.str=(byteptr)"", .is_lit=1},.rpath = (string){.str=(byteptr)"", .is_lit=1},.apath = (string){.str=(byteptr)"", .is_lit=1},.len = 0,.is_compressed = 0,}),
			.or_block = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),
			.args = args,
			.method_name = method_name,
			.left = left,
			.env_value = (string){.str=(byteptr)"", .is_lit=1},
			.args_var = _S(""),
			.compile_value = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
			.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
			.method_pos = method_pos,
			.env_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.result_type = 0,
			.left_type = 0,
			.kind = v__ast__ComptimeCallKind__method,
			.is_d_resolved = 0,
			.is_veb = 0,
			.is_vweb = 0,
			.has_parens = 0,
		}))), false);
	}
	bool has_parens = false;
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
		has_parens = true;
	} else {
		v__parser__Parser_warn_with_pos(p, _S("use brackets instead e.g. `s.$(field.name)` - run vfmt"), v__token__Token_pos(&p->tok));
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	if (has_parens) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	}
	return v__ast__ComptimeSelector_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeSelector, (((v__ast__ComptimeSelector){.or_block = ((v__ast__OrExpr){.kind = (p->tok.kind == v__token__Kind__question ? (v__ast__OrKind__propagate_option) : (v__ast__OrKind__absent)),.pos = v__token__Token_pos(&p->tok),.scope = p->scope,.err_used = 0,.stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0),}),.field_expr = expr,.left = left,.typ_key = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),.left_type = 0,.typ = 0,.is_name = 0,.has_parens = has_parens,}))), false);
}
VV_LOC v__ast__ArrayInit v__parser__Parser_array_init(v__parser__Parser* p, bool is_option, v__ast__Type alias_array_type) {
	v__token__Pos first_pos = v__token__Token_pos(&p->tok);
	v__token__Pos last_pos = v__token__Token_pos(&p->tok);
	v__ast__Type array_type = _const_v__ast__void_type;
	v__ast__Type elem_type = _const_v__ast__void_type;
	v__token__Pos elem_type_pos = first_pos;
	Array_v__ast__Expr exprs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment ecmnts = builtin____new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	Array_v__ast__Comment pre_cmnts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool is_fixed = false;
	bool has_val = false;
	bool has_type = false;
	bool has_init = false;
	bool has_index = false;
	v__ast__Expr init_expr = _const_v__ast__empty_expr;
	if (alias_array_type == _const_v__ast__void_type) {
		v__parser__Parser_check(p, v__token__Kind__lsbr);
		if (p->tok.kind == v__token__Kind__rsbr) {
			last_pos = v__token__Token_pos(&p->tok);
			int line_nr = p->tok.line_nr;
			v__parser__Parser_next(p);
			if ((p->tok.kind == v__token__Kind__name || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__key_shared || p->tok.kind == v__token__Kind__not) && p->tok.line_nr == line_nr) {
				elem_type_pos = v__token__Token_pos(&p->tok);
				elem_type = v__parser__Parser_parse_type(p);
				if (elem_type != 0) {
					if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__result)) {
						v__parser__Parser_error_with_pos(p, _S("arrays do not support storing Result values"), elem_type_pos);
					}
					int idx = v__ast__Table_find_or_register_array(p->table, elem_type);
					if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
						array_type = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
					} else {
						array_type = v__ast__new_type(idx);
					}
					if (is_option) {
						array_type = v__ast__Type_set_flag(array_type, v__ast__TypeFlag__option);
					}
					has_type = true;
				}
			}
			last_pos = v__token__Token_pos(&p->tok);
		} else {
			bool old_inside_array_lit = p->inside_array_lit;
			string old_last_enum_name = p->last_enum_name;
			string old_last_enum_mod = p->last_enum_mod;
			p->inside_array_lit = true;
			p->last_enum_name = _S("");
			p->last_enum_mod = _S("");
			pre_cmnts = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			for (int i = 0; !(p->tok.kind == v__token__Kind__rsbr || p->tok.kind == v__token__Kind__eof); i++) {
				builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
				builtin__array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
				if (p->tok.kind == v__token__Kind__comma) {
					v__parser__Parser_next(p);
				}
				_PUSH_MANY(&(*(Array_v__ast__Comment*)builtin__array_last(ecmnts)), (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t3, Array_v__ast__Comment);
			}
			p->inside_array_lit = old_inside_array_lit;
			p->last_enum_name = old_last_enum_name;
			p->last_enum_mod = old_last_enum_mod;
			int line_nr = p->tok.line_nr;
			last_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rsbr);
			if (exprs.len == 1 && p->tok.line_nr == line_nr && ((p->tok.kind == v__token__Kind__name || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__key_shared) || (p->tok.kind == v__token__Kind__lsbr && v__parser__Parser_is_array_type(p)))) {
				elem_type = v__parser__Parser_parse_type(p);
				if (elem_type != 0) {
					v__ast__TypeSymbol* s = v__ast__Table_sym(p->table, elem_type);
					if (builtin__fast_string_eq(s->name, _S("byte"))) {
						v__parser__Parser_error(p, _S("`byte` has been deprecated in favor of `u8`: use `[10]u8{}` instead of `[10]byte{}`"));
					}
				}
				last_pos = v__token__Token_pos(&p->tok);
				is_fixed = true;
				if (p->tok.kind == v__token__Kind__lcbr) {
					v__parser__Parser_next(p);
					if (p->tok.kind != v__token__Kind__rcbr) {
						v__token__Pos pos = v__token__Token_pos(&p->tok);
						string n = v__parser__Parser_check_name(p);
						if (_SLIT_NE(n.str, n.len, "init")) {
							if (is_fixed) {
								v__parser__Parser_error_with_pos(p, _S("`len` and `cap` are invalid attributes for fixed array dimension"), pos);
							} else {
								v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected `init:`, not `"), 0xfe10, {.d_s = n}}, {_S("`"), 0, { .d_c = 0 }}})), pos);
							}
							return ((v__ast__ArrayInit){.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.ecmnts = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),.expr_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.cap_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.init_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.elem_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.init_type = 0,.elem_type = 0,.alias_type = 0,.has_callexpr = 0,.is_fixed = 0,.is_option = 0,.has_val = 0,.has_len = 0,.has_cap = 0,.has_init = 0,.has_index = 0,});
						}
						v__parser__Parser_check(p, v__token__Kind__colon);
						has_init = true;
						has_index = v__parser__Parser_handle_index_variable(p, &init_expr);
					}
					last_pos = v__token__Token_pos(&p->tok);
					v__parser__Parser_check(p, v__token__Kind__rcbr);
				} else {
					string modifier = (is_option ? (_S("?")) : (_S("")));
					v__parser__Parser_warn_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("use e.g. `x := "), 0xfe10, {.d_s = modifier}}, {_S("[1]Type{}` instead of `x := "), 0xfe10, {.d_s = modifier}}, {_S("[1]Type`"), 0, { .d_c = 0 }}})), v__token__Pos_extend(first_pos, last_pos));
				}
			} else {
				if (p->tok.kind == v__token__Kind__not) {
					last_pos = v__token__Token_pos(&p->tok);
					is_fixed = true;
					has_val = true;
					if (exprs.len == 1 && p->tok.line_nr == line_nr && v__parser__Parser_is_array_type(p)) {
						v__parser__Parser_error(p, _S("fixed arrays do not support storing Result values"));
					} else {
						v__parser__Parser_next(p);
					}
				}
				if (p->tok.kind == v__token__Kind__not && p->tok.line_nr == p->prev_tok.line_nr) {
					last_pos = v__token__Token_pos(&p->tok);
					v__parser__Parser_error_with_pos(p, _S("use e.g. `[1, 2, 3]!` instead of `[1, 2, 3]!!`"), last_pos);
					v__parser__Parser_next(p);
				}
			}
		}
		if (exprs.len == 0 && p->tok.kind != v__token__Kind__lcbr && has_type) {
			if (!p->pref->is_fmt) {
				string modifier = (is_option ? (_S("?")) : (_S("")));
				v__parser__Parser_warn_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("use `x := "), 0xfe10, {.d_s = modifier}}, {_S("[]Type{}` instead of `x := "), 0xfe10, {.d_s = modifier}}, {_S("[]Type`"), 0, { .d_c = 0 }}})), v__token__Pos_extend(first_pos, last_pos));
			}
		}
	} else {
		array_type = (({ v__ast__TypeInfo _t5 = v__ast__Table_sym(p->table, alias_array_type)->info; *(v__ast__Alias*)builtin____as_cast(_t5._v__ast__Alias,_t5._typ, 482); })).parent_type;
		elem_type = v__ast__TypeSymbol_array_info(v__ast__Table_sym(p->table, array_type)).elem_type;
		v__parser__Parser_next(p);
	}
	bool has_len = false;
	bool has_cap = false;
	v__ast__Expr len_expr = _const_v__ast__empty_expr;
	v__ast__Expr cap_expr = _const_v__ast__empty_expr;
	v__token__Pos attr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	if (p->tok.kind == v__token__Kind__lcbr && exprs.len == 0 && array_type != _const_v__ast__void_type) {
		v__parser__Parser_next(p);
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rcbr)) break;
			attr_pos = v__token__Token_pos(&p->tok);
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__colon);
			if (is_option) {
				v__parser__Parser_error(p, _S("Option array cannot have initializers"));
			}

			if (_SLIT_EQ(key.str, key.len, "len")) {
				has_len = true;
				len_expr = v__parser__Parser_expr(p, 0);
			}
			else if (_SLIT_EQ(key.str, key.len, "cap")) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (_SLIT_EQ(key.str, key.len, "init")) {
				has_init = true;
				has_index = v__parser__Parser_handle_index_variable(p, &init_expr);
			}
			else {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("wrong field `"), 0xfe10, {.d_s = key}}, {_S("`, expecting `len`, `cap`, or `init`"), 0, { .d_c = 0 }}})), attr_pos);
				return ((v__ast__ArrayInit){.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.ecmnts = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),.expr_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.cap_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.init_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.mod = (string){.str=(byteptr)"", .is_lit=1},.len_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.elem_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.init_type = 0,.elem_type = 0,.alias_type = 0,.has_callexpr = 0,.is_fixed = 0,.is_option = 0,.has_val = 0,.has_len = 0,.has_cap = 0,.has_init = 0,.has_index = 0,});
			}
			if (p->tok.kind != v__token__Kind__rcbr) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			}
		}
		v__parser__Parser_check(p, v__token__Kind__rcbr);
		if (has_init && !has_len) {
			v__parser__Parser_error_with_pos(p, _S("cannot use `init` attribute unless `len` attribute is also provided"), attr_pos);
		}
	}
	v__token__Pos pos = v__token__Pos_extend_with_last_line(first_pos, last_pos, p->prev_tok.line_nr);
	return ((v__ast__ArrayInit){
		.pre_cmnts = pre_cmnts,
		.ecmnts = ecmnts,
		.expr_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.exprs = exprs,
		.cap_expr = cap_expr,
		.init_expr = init_expr,
		.mod = p->mod,
		.len_expr = len_expr,
		.elem_type_pos = elem_type_pos,
		.pos = pos,
		.typ = array_type,
		.init_type = 0,
		.elem_type = elem_type,
		.alias_type = alias_array_type,
		.has_callexpr = 0,
		.is_fixed = is_fixed,
		.is_option = is_option,
		.has_val = has_val,
		.has_len = has_len,
		.has_cap = has_cap,
		.has_init = has_init,
		.has_index = has_index,
	});
}
VV_LOC v__ast__MapInit v__parser__Parser_map_init(v__parser__Parser* p) {
	bool old_inside_map_init = p->inside_map_init;
	p->inside_map_init = true;
	v__token__Pos first_pos = v__token__Token_pos(&p->prev_tok);
	Array_v__ast__Expr keys = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_v__ast__Expr vals = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
	bool has_update_expr = false;
	v__ast__Expr update_expr = _const_v__ast__empty_expr;
	Array_v__ast__Comment update_expr_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	v__token__Pos update_expr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	Array_v__ast__Comment pre_cmnts = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	if (p->tok.kind == v__token__Kind__ellipsis) {
		has_update_expr = true;
		v__parser__Parser_check(p, v__token__Kind__ellipsis);
		update_expr = v__parser__Parser_expr(p, 0);
		update_expr_pos = v__ast__Expr_pos(update_expr);
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		_PUSH_MANY(&update_expr_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t1, Array_v__ast__Comment);
	}
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__eof))) break;
		if (p->tok.kind == v__token__Kind__name && (builtin__fast_string_eq(p->tok.lit, _S("r")) || builtin__fast_string_eq(p->tok.lit, _S("c")) || builtin__fast_string_eq(p->tok.lit, _S("js")))) {
			v__ast__Expr key = v__parser__Parser_string_expr(p);
			builtin__array_push((array*)&keys, _MOV((v__ast__Expr[]){ key }));
		} else {
			v__ast__Expr key = v__parser__Parser_expr(p, 0);
			builtin__array_push((array*)&keys, _MOV((v__ast__Expr[]){ key }));
		}
		v__parser__Parser_check(p, v__token__Kind__colon);
		v__ast__Expr val = v__parser__Parser_expr(p, 0);
		builtin__array_push((array*)&vals, _MOV((v__ast__Expr[]){ val }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		builtin__array_push((array*)&comments, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
	}
	v__ast__MapInit _t6 = ((v__ast__MapInit){
		.comments = comments,
		.pre_cmnts = pre_cmnts,
		.keys = keys,
		.vals = vals,
		.val_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.update_expr_comments = update_expr_comments,
		.update_expr = update_expr,
		.pos = v__token__Pos_extend_with_last_line(first_pos, v__token__Token_pos(&p->tok), p->tok.line_nr),
		.update_expr_pos = update_expr_pos,
		.key_type = 0,
		.typ = 0,
		.value_type = 0,
		.has_update_expr = has_update_expr,
	});
		{ // defer begin
			p->inside_map_init = old_inside_map_init;
		} // defer end
	return _t6;
}
VV_LOC void v__parser__Parser_scope_register_index(v__parser__Parser* p) {
	builtin__map_set(&p->scope->objects, &(string[]){_S("index")}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
		.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.name = _S("index"),
		.pos = v__token__Token_pos(&p->tok),
		.typ = _const_v__ast__int_type,
		.orig_type = 0,
		.ct_type_var = 0,
		.share = 0,
		.is_arg = 0,
		.is_auto_deref = 0,
		.is_unwrapped = 0,
		.is_index_var = true,
		.is_volatile = 0,
		.is_static = 0,
		.is_special = 0,
		.is_mut = false,
		.is_used = false,
		.is_changed = 0,
		.ct_type_unwrapped = 0,
		.is_or = 0,
		.is_tmp = 0,
		.is_auto_heap = 0,
		.is_stack_obj = 0,
		.is_inherited = 0,
		.is_autofree_tmp = 0,
		.has_inherited = 0,
	}))), false) });
	builtin__map_set(&p->scope->objects, &(string[]){_S("it")}, &(v__ast__ScopeObject[]) { v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = _S("it"),.pos = v__token__Token_pos(&p->tok),.typ = _const_v__ast__int_type,.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = false,.is_used = false,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false) });
}
VV_LOC bool v__parser__Parser_handle_index_variable(v__parser__Parser* p, v__ast__Expr* default_expr) {
	bool has_index = false;
	v__parser__Parser_open_scope(p);
	v__parser__Parser_scope_register_index(p);
	*default_expr = v__parser__Parser_expr(p, 0);
	_option_v__ast__Var_ptr _t1;
	if (_t1 = v__ast__Scope_find_var(p->scope, _S("index")), _t1.state == 0) {
		v__ast__Var* var = *(v__ast__Var**)_t1.data;
		v__ast__Var* variable = var;
		bool is_used = variable->is_used;
		variable->is_used = true;
		has_index = is_used;
	}
	_option_v__ast__Var_ptr _t2;
	if (_t2 = v__ast__Scope_find_var(p->scope, _S("it")), _t2.state == 0) {
		v__ast__Var* var = *(v__ast__Var**)_t2.data;
		v__ast__Var* variable = var;
		bool is_used = variable->is_used;
		if (is_used) {
			v__parser__Parser_warn(p, _S("variable `it` in array initialization will soon be replaced with `index`"));
		}
		variable->is_used = true;
		if (!has_index) {
			has_index = is_used;
		}
	}
	bool _t3 = has_index;
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t3;
}
VV_LOC v__ast__EnumVal v__parser__Parser_enum_val_expr(v__parser__Parser* p, string mod) {
	string enum_name = v__parser__Parser_check_name(p);
	v__token__Pos enum_name_pos = v__token__Token_pos(&p->prev_tok);
	if ((mod).len != 0) {
		enum_name = builtin__string__plus(builtin__string__plus(mod, _S(".")), enum_name);
	} else {
		string* _t2 = (string*)(builtin__map_get_check(ADDR(map, p->imported_symbols), &(string[]){enum_name}));
		_option_string _t1 = {0};
		if (_t2) {
			*((string*)&_t1.data) = *((string*)_t2);
		} else {
			_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
		}
		;
		if (_t1.state != 0) {
			*(string*) _t1.data = v__parser__Parser_prepend_mod(p, enum_name);
		}
		
		enum_name = (*(string*)_t1.data);
	}
	v__parser__Parser_check(p, v__token__Kind__dot);
	string val = v__parser__Parser_check_name(p);
	p->expr_mod = _S("");
	p->last_enum_name = enum_name;
	p->last_enum_mod = mod;
	return ((v__ast__EnumVal){.enum_name = enum_name,.val = val,.mod = mod,.pos = v__token__Pos_extend(enum_name_pos, v__token__Token_pos(&p->prev_tok)),.typ = 0,});
}
VV_LOC v__ast__EnumVal v__parser__Parser_enum_val(v__parser__Parser* p) {
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__dot);
	string val = v__parser__Parser_check_name(p);
	return ((v__ast__EnumVal){.enum_name = (string){.str=(byteptr)"", .is_lit=1},.val = val,.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),.typ = 0,});
}
VV_LOC v__ast__EnumDecl v__parser__Parser_enum_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_enum);
	v__token__Pos end_pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Comment _t1; /* if prepend */
	if (p->pref->is_vls) {
		_t1 = builtin__array_clone_to_depth(&p->cur_comments, 0);
		goto _t2;
	};
	{
		_t1 = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	_t2: {};
		Array_v__ast__Comment comments_before_key_enum = _t1;
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
	}
	string enum_name = v__parser__Parser_check_name(p);
	if (enum_name.len == 0) {
		v__parser__Parser_error_with_pos(p, _S("enum names can not be empty"), end_pos);
		return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
	}
	if (enum_name.len == 1) {
		v__parser__Parser_error_with_pos(p, _S("single letter capital names are reserved for generic template types."), end_pos);
		return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
	}
	if (v__parser__Parser_is_imported_symbol(p, enum_name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register enum `"), 0xfe10, {.d_s = enum_name}}, {_S("`, this type was already imported"), 0, { .d_c = 0 }}})), end_pos);
		return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
	}
	string name = v__parser__Parser_prepend_mod(p, enum_name);
	bool _t7; /* if prepend */
	v__ast__EnumDecl* _t10 = (v__ast__EnumDecl*)(builtin__map_get_check(ADDR(map, p->table->enum_decls), &(string[]){name}));
	_option_v__ast__EnumDecl _t9 = {0};
	if (_t10) {
		*((v__ast__EnumDecl*)&_t9.data) = *((v__ast__EnumDecl*)_t10);
	} else {
		_t9.state = 2; _t9.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t9.state == 0) {
		v__ast__EnumDecl _dummy_9 = (*(v__ast__EnumDecl*)_t9.data);
		_t7 = true;
		goto _t8;
	};
	{
		_t7 = false;
	}
	_t8: {};
		bool already_exists = _t7;
	v__ast__Type enum_type = _const_v__ast__int_type;
	v__token__Pos typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	if (p->tok.kind == v__token__Kind__key_as) {
		v__parser__Parser_next(p);
		typ_pos = v__token__Token_pos(&p->tok);
		enum_type = v__parser__Parser_parse_type(p);
	}
	Array_v__ast__Comment enum_decl_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	_PUSH_MANY(&enum_decl_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t11, Array_v__ast__Comment);
	string senum_type = v__ast__Table_get_type_name(p->table, enum_type);
	Array_string vals = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__EnumField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__EnumField), 0);
	bool uses_exprs = false;
	Map_string_Array_v__ast__Attr enum_attrs = builtin__new_map(sizeof(string), sizeof(Array_v__ast__Attr), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof && p->tok.kind != v__token__Kind__rcbr)) break;
		Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		bool has_prev_newline = v__parser__Parser_has_prev_newline(p);
		bool has_break_line = has_prev_newline || v__parser__Parser_has_prev_line_comment_or_label(p);
		string val = v__parser__Parser_check_name(p);
		builtin__array_push((array*)&vals, _MOV((string[]){ builtin__string_clone(val) }));
		v__ast__Expr expr = _const_v__ast__empty_expr;
		bool has_expr = false;
		if (p->tok.kind == v__token__Kind__assign) {
			v__parser__Parser_next(p);
			bool old_assign_rhs = p->inside_assign_rhs;
			p->inside_assign_rhs = true;
			expr = v__parser__Parser_expr(p, 0);
			p->inside_assign_rhs = old_assign_rhs;
			has_expr = true;
			uses_exprs = true;
		}
		Array_v__ast__Attr attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		if (p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__at) {
			v__parser__Parser_attributes(p);
			_PUSH_MANY(&attrs, (p->attrs), _t13, Array_v__ast__Attr);
			(*(Array_v__ast__Attr*)builtin__map_get_and_set((map*)&enum_attrs, &(string[]){val}, &(Array_v__ast__Attr[]){ builtin____new_array(0, 0, sizeof(v__ast__Attr)) })) = attrs;
			p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
		Array_v__ast__Comment next_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}));
		builtin__array_push((array*)&fields, _MOV((v__ast__EnumField[]){ ((v__ast__EnumField){
			.name = val,
			.source_name = v__parser__source_name(val),
			.pos = pos,
			.pre_comments = pre_comments,
			.comments = comments,
			.next_comments = next_comments,
			.has_expr = has_expr,
			.has_prev_newline = has_prev_newline,
			.has_break_line = has_break_line,
			.attrs = attrs,
			.expr = expr,
		}) }));
	}
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	bool is_flag = Array_v__ast__Attr_contains(p->attrs, _S("flag"));
	bool is_multi_allowed = Array_v__ast__Attr_contains(p->attrs, _S("_allow_multiple_values"));
	string pubfn = (builtin__fast_string_eq(p->mod, _S("main")) ? (_S("@[flag_enum_fn] fn")) : (_S("@[flag_enum_fn] pub fn")));
	if (is_flag) {
		if (fields.len > 64) {
			v__parser__Parser_error(p, _S("when an enum is used as bit field, it must have a max of 64 fields"));
			return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
		}
		for (int _t16 = 0; _t16 < fields.len; ++_t16) {
			v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[_t16];
			if (f.has_expr) {
				v__parser__Parser_error_with_pos(p, _S("when an enum is used as a bit field, you can not assign custom values"), f.pos);
				return ((v__ast__EnumDecl){.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__EnumField)),.name = (string){.str=(byteptr)"", .is_lit=1},.typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.enum_typ = 0,.is_multi_allowed = 0,.is_flag = 0,.is_pub = 0,});
			}
		}
		if (!already_exists) {
			string all_bits_set_value = builtin__string__plus(_S("0b"), builtin__string_repeat(_S("1"), fields.len));
			v__parser__Parser_codegen(p, builtin__str_intp(40, _MOV((StrIntpData[]){{_S("\n//\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_S(") is_empty() bool           { return  "), 0xfe10, {.d_s = senum_type}}, {_S("(*e) == 0 }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_S(") has(flag_ "), 0xfe10, {.d_s = enum_name}}, {_S(") bool { return  ("), 0xfe10, {.d_s = senum_type}}, {_S("(*e) &  ("), 0xfe10, {.d_s = senum_type}}, {_S("(flag_))) != 0 }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (    e &"), 0xfe10, {.d_s = enum_name}}, {_S(") all(flag_ "), 0xfe10, {.d_s = enum_name}}, {_S(") bool { return  ("), 0xfe10, {.d_s = senum_type}}, {_S("(*e) &  ("), 0xfe10, {.d_s = senum_type}}, {_S("(flag_))) == "), 0xfe10, {.d_s = senum_type}}, {_S("(flag_) }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_S(") set(flag_ "), 0xfe10, {.d_s = enum_name}}, {_S(")      { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_S("("), 0xfe10, {.d_s = senum_type}}, {_S("(*e) |  ("), 0xfe10, {.d_s = senum_type}}, {_S("(flag_))) } }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_S(") set_all()                   { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_S("("), 0xfe10, {.d_s = all_bits_set_value}}, {_S(") } }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_S(") clear(flag_ "), 0xfe10, {.d_s = enum_name}}, {_S(")    { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_S("("), 0xfe10, {.d_s = senum_type}}, {_S("(*e) & ~("), 0xfe10, {.d_s = senum_type}}, {_S("(flag_))) } }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_S(") clear_all()                 { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_S("(0) } }\n@[inline] "), 0xfe10, {.d_s = pubfn}}, {_S(" (mut e  "), 0xfe10, {.d_s = enum_name}}, {_S(") toggle(flag_ "), 0xfe10, {.d_s = enum_name}}, {_S(")   { unsafe{ *e = "), 0xfe10, {.d_s = enum_name}}, {_S("("), 0xfe10, {.d_s = senum_type}}, {_S("(*e) ^  ("), 0xfe10, {.d_s = senum_type}}, {_S("(flag_))) } }\n//\n"), 0, { .d_c = 0 }}})));
		}
	}
	strings__Builder isb = strings__new_builder(1024);
	strings__Builder_write_string(&isb, _S("\n"));
	if (is_flag) {
		{
			strings__Builder_write_string(&isb, _S("@[inline] "));
			strings__Builder_write_string(&isb, pubfn);
			strings__Builder_write_string(&isb, _S(" "));
			strings__Builder_write_string(&isb, enum_name);
			strings__Builder_write_string(&isb, _S(".zero() "));
			strings__Builder_write_string(&isb, enum_name);
			strings__Builder_write_string(&isb, _S(" {\n"));
		}
		{
			strings__Builder_write_string(&isb, _S("\011\011return unsafe{ "));
			strings__Builder_write_string(&isb, enum_name);
			strings__Builder_write_string(&isb, _S("(0) }\n"));
		}
		strings__Builder_write_string(&isb, _S("}\n"));
	}
	{
		strings__Builder_write_string(&isb, pubfn);
		strings__Builder_write_string(&isb, _S(" "));
		strings__Builder_write_string(&isb, enum_name);
		strings__Builder_write_string(&isb, _S(".from[W](input W) !"));
		strings__Builder_write_string(&isb, enum_name);
		strings__Builder_write_string(&isb, _S(" {\n"));
	}
	strings__Builder_write_string(&isb, _S("\011$if input is $int {\n"));
	{
		strings__Builder_write_string(&isb, _S("\011\011val := unsafe{ "));
		strings__Builder_write_string(&isb, enum_name);
		strings__Builder_write_string(&isb, _S("(input) }\n"));
	}
	if (is_flag) {
		strings__Builder_write_string(&isb, _S("\011\011if input == 0 { return val }\n"));
		string all_bits_set_value = builtin__string__plus(_S("0b"), builtin__string_repeat(_S("1"), fields.len));
		{
			strings__Builder_write_string(&isb, _S("\011\011if input & ~"));
			strings__Builder_write_string(&isb, all_bits_set_value);
			strings__Builder_write_string(&isb, _S(" == 0 { return val }\n"));
		}
	} else {
		strings__Builder_write_string(&isb, _S("\011\011match val {\n"));
		for (int _t18 = 0; _t18 < fields.len; ++_t18) {
			v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[_t18];
			{
				strings__Builder_write_string(&isb, _S("\011\011\011."));
				strings__Builder_write_string(&isb, f.source_name);
				strings__Builder_write_string(&isb, _S(" { return "));
				strings__Builder_write_string(&isb, enum_name);
				strings__Builder_write_string(&isb, _S("."));
				strings__Builder_write_string(&isb, f.source_name);
				strings__Builder_write_string(&isb, _S(" }\n"));
			}
		}
		if (is_flag) {
			strings__Builder_write_string(&isb, _S("\011\011\011else{}\n"));
		}
		strings__Builder_write_string(&isb, _S("\011\011}\n"));
	}
	strings__Builder_write_string(&isb, _S("\011}\n"));
	strings__Builder_write_string(&isb, _S("\011$if input is $string {\n"));
	strings__Builder_write_string(&isb, _S("\011\011val := input.str()\n"));
	if (is_flag) {
		{
			strings__Builder_write_string(&isb, _S("\011\011if val == \'\' { return unsafe{ "));
			strings__Builder_write_string(&isb, enum_name);
			strings__Builder_write_string(&isb, _S("(0) } }\n"));
		}
	}
	strings__Builder_write_string(&isb, _S("\011\011match val {\n"));
	for (int _t19 = 0; _t19 < fields.len; ++_t19) {
		v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[_t19];
		{
			strings__Builder_write_string(&isb, _S("\011\011\011\'"));
			strings__Builder_write_string(&isb, f.name);
			strings__Builder_write_string(&isb, _S("\' { return "));
			strings__Builder_write_string(&isb, enum_name);
			strings__Builder_write_string(&isb, _S("."));
			strings__Builder_write_string(&isb, f.source_name);
			strings__Builder_write_string(&isb, _S(" }\n"));
		}
	}
	strings__Builder_write_string(&isb, _S("\011\011\011else{}\n"));
	strings__Builder_write_string(&isb, _S("\011\011}\n"));
	strings__Builder_write_string(&isb, _S("\011}\n"));
	strings__Builder_write_string(&isb, _S("\011return error('invalid value')\n"));
	strings__Builder_write_string(&isb, _S("}\n"));
	strings__Builder_write_string(&isb, _S("\n"));
	string code_for_from_fn = strings__Builder_str(&isb);
	if (builtin__u8_is_capital(builtin__string_at(enum_name, 0)) && fields.len > 0) {
		v__parser__Parser_codegen(p, code_for_from_fn);
	}
	int idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.name = name,
		.cname = v__util__no_dots(name),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = v__ast__Enum_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Enum, (((v__ast__Enum){
			.vals = vals,
			.is_flag = is_flag,
			.is_multi_allowed = is_multi_allowed,
			.uses_exprs = uses_exprs,
			.typ = enum_type,
			.attrs = enum_attrs,
			.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__enum,
		.language = 0,
		.is_pub = is_pub,
		.is_builtin = 0,
	}));
	if ((idx == _const_v__ast__string_type_idx || idx == _const_v__ast__rune_type_idx || idx == _const_v__ast__array_type_idx || idx == _const_v__ast__map_type_idx) && !p->pref->is_fmt) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register enum `"), 0xfe10, {.d_s = name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}})), end_pos);
	}
	if (idx == -1) {
		enum_type = idx;
	}
	v__ast__EnumDecl enum_decl = ((v__ast__EnumDecl){
		.comments = enum_decl_comments,
		.attrs = p->attrs,
		.fields = fields,
		.name = name,
		.typ_pos = typ_pos,
		.pos = v__token__Pos_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
		.typ = enum_type,
		.enum_typ = 0,
		.is_multi_allowed = is_multi_allowed,
		.is_flag = is_flag,
		.is_pub = is_pub,
	});
	if (!already_exists) {
		v__ast__Table_register_enum_decl(p->table, enum_decl);
		if (p->pref->is_vls) {
			string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("enum_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			bool has_decl_end_comment = false;
			if (enum_decl.comments.len > 0 && (*(v__ast__Comment*)builtin__array_get(enum_decl.comments, 0)).pos.line_nr == enum_decl.pos.line_nr) {
				builtin__array_push((array*)&comments_before_key_enum, _MOV((v__ast__Comment[]){ (*(v__ast__Comment*)builtin__array_get(enum_decl.comments, 0)) }));
				has_decl_end_comment = true;
			}
			v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = typ_pos,.doc = v__parser__Parser_keyword_comments_to_string(p, enum_name, comments_before_key_enum),});
			v__ast__Table_register_vls_info(p->table, key, val);
			for (int i = 0; i < fields.len; ++i) {
				v__ast__EnumField f = ((v__ast__EnumField*)fields.data)[i];
				string f_key = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("enum_"), 0xfe10, {.d_s = name}}, {_S("."), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__ast__VlsInfo _t21; /* if prepend */
				if (i == 0) {
					Array_v__ast__Comment _t23; /* if prepend */
					if (has_decl_end_comment) {
						_t23 = builtin__array_clone_static_to_depth(builtin__array_slice(enum_decl.comments, 1, 2147483647), 0);
						goto _t24;
					};
					{
						_t23 = enum_decl.comments;
					}
	_t24: {};
										Array_v__ast__Comment first_field_pre_comment = _t23;
					_t21 = ((v__ast__VlsInfo){.pos = f.pos,.doc = builtin__string__plus(v__parser__Parser_comments_to_string(p, first_field_pre_comment), v__parser__Parser_comments_to_string(p, f.comments)),});
					goto _t22;
				};
				{
					_t21 = ((v__ast__VlsInfo){.pos = f.pos,.doc = builtin__string__plus(v__parser__Parser_comments_to_string(p, (*(v__ast__EnumField*)builtin__array_get(fields, (int)(i - 1))).next_comments), v__parser__Parser_comments_to_string(p, f.comments)),});
				}
	_t22: {};
								v__ast__VlsInfo f_val = _t21;
				v__ast__Table_register_vls_info(p->table, f_key, f_val);
			}
		}
	}
	return enum_decl;
}
inline VV_LOC _result_void v__parser__Parser_check_expr_level(v__parser__Parser* p) {
	if (p->expr_level > 100) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expr level > "), 0xfe07, {.d_i32 = _const_v__parser__max_expr_level}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	return (_result_void){0};
}
VV_LOC v__ast__Expr v__parser__Parser_expr_no_value(v__parser__Parser* p, int precedence) {
	bool old_expecting_value = p->expecting_value;
	p->expecting_value = false;
	_result_v__ast__Expr _t2 = v__parser__Parser_check_expr(p, precedence);
	if (_t2.is_error) {
		if (v__token__is_decl(p->tok.kind) && v__parser__Parser_disallow_declarations_in_script_mode(p)) {
			v__ast__Expr _t3 = _const_v__ast__empty_expr;
				{ // defer begin
					p->expecting_value = old_expecting_value;
				} // defer end
			return _t3;
		}
		*(v__ast__Expr*) _t2.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = _S("invalid expression:"),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
	}
	
 	v__ast__Expr _t1 = (*(v__ast__Expr*)_t2.data);
		{ // defer begin
			p->expecting_value = old_expecting_value;
		} // defer end
	return _t1;
}
VV_LOC v__ast__Expr v__parser__Parser_expr(v__parser__Parser* p, int precedence) {
	bool old_expecting_value = p->expecting_value;
	p->expecting_value = true;
	_result_v__ast__Expr _t2 = v__parser__Parser_check_expr(p, precedence);
	if (_t2.is_error) {
		if (v__token__is_decl(p->tok.kind) && v__parser__Parser_disallow_declarations_in_script_mode(p)) {
			v__ast__Expr _t3 = _const_v__ast__empty_expr;
				{ // defer begin
					p->expecting_value = old_expecting_value;
				} // defer end
			return _t3;
		}
		*(v__ast__Expr*) _t2.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = _S("invalid expression:"),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
	}
	
 	v__ast__Expr _t1 = (*(v__ast__Expr*)_t2.data);
		{ // defer begin
			p->expecting_value = old_expecting_value;
		} // defer end
	return _t1;
}
VV_LOC _result_v__ast__Expr v__parser__Parser_check_expr(v__parser__Parser* p, int precedence) {
	;
	p->expr_level++;
	_result_void _t1 = v__parser__Parser_check_expr_level(p);
	if (_t1.is_error) {
		{ // defer begin
			p->expr_level--;
		} // defer end
		_result_v__ast__Expr _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	v__ast__Expr node = _const_v__ast__empty_expr;
	bool is_stmt_ident = p->is_stmt_ident;
	p->is_stmt_ident = false;
	if (!p->pref->is_fmt) {
		v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	}
	if (p->inside_if_cond) {
		_PUSH_MANY(&p->if_cond_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t3, Array_v__ast__Comment);
	}
	switch (p->tok.kind) {
		case v__token__Kind__key_mut: case v__token__Kind__key_shared: case v__token__Kind__key_atomic: case v__token__Kind__key_static: case v__token__Kind__key_volatile: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				v__ast__Ident ident = v__parser__Parser_ident(p, v__ast__Language__v);
				node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident, false);
				if (p->peek_tok.kind != v__token__Kind__assign && (p->inside_if_cond || p->inside_match)) {
					v__ast__Scope_mark_var_as_used(p->scope, ident.name);
				}
				v__parser__Parser_add_defer_var(p, ident);
				p->is_stmt_ident = is_stmt_ident;
			}
			break;
		}
		case v__token__Kind__name: case v__token__Kind__question: {
			if (p->peek_tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("sql"))) {
				node = v__parser__Parser_sql_expr(p);
			} else if (p->peek_tok.kind == v__token__Kind__lcbr && builtin__fast_string_eq(p->tok.lit, _S("map")) && !(p->builtin_mod && (builtin__fast_string_eq(p->file_base, _S("map.v")) || builtin__fast_string_eq(p->file_base, _S("map_d_gcboehm_opt.v"))))) {
				v__parser__Parser_error_with_pos(p, _S("deprecated map syntax, use syntax like `{'age': 20}`"), v__token__Token_pos(&p->tok));
			} else if (p->tok.kind == v__token__Kind__question && p->peek_tok.kind == v__token__Kind__amp) {
				node = v__parser__Parser_prefix_expr(p);
			} else if (p->inside_for_expr && p->tok.kind == v__token__Kind__name && ((builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) && p->peek_tok.kind == v__token__Kind__lcbr && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rcbr || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name)) || (p->inside_array_lit && p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name && builtin__u8_is_capital(builtin__string_at(v__parser__Parser_peek_token(p, 2).lit, 0)) && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__lcbr && (v__parser__Parser_peek_token(p, 4).kind == v__token__Kind__rcbr || v__parser__Parser_peek_token(p, 4).kind == v__token__Kind__name)))) {
				node = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit), v__ast__StructInitKind__normal, false))), false);
			} else if (v__parser__Parser_is_generic_name(p) && p->peek_tok.kind == v__token__Kind__lcbr && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rcbr && v__parser__Parser_peek_token(p, 2).line_nr == p->tok.line_nr) {
				node = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit), v__ast__StructInitKind__normal, false))), false);
			} else {
				if (p->inside_comptime_if && v__parser__Parser_is_generic_name(p) && p->peek_tok.kind != v__token__Kind__dot) {
					p->expecting_type = true;
				}
				node = v__parser__Parser_name_expr(p);
				p->is_stmt_ident = is_stmt_ident;
			}
			break;
		}
		case v__token__Kind__string: {
			node = v__parser__Parser_string_expr(p);
			break;
		}
		case v__token__Kind__comment: {
			node = v__ast__Comment_to_sumtype_v__ast__Expr(ADDR(v__ast__Comment, (v__parser__Parser_comment(p))), false);
			_result_v__ast__Expr _t4;
			builtin___result_ok(&(v__ast__Expr[]) { node }, (_result*)(&_t4), sizeof(v__ast__Expr));
			 
				{ // defer begin
					p->expr_level--;
				} // defer end
			return _t4;
		}
		case v__token__Kind__dot: {
			node = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (v__parser__Parser_enum_val(p))), false);
			break;
		}
		case v__token__Kind__at: {
			node = v__ast__AtExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__AtExpr, (v__parser__Parser_at(p))), false);
			break;
		}
		case v__token__Kind__dollar: {

			if (p->peek_tok.kind == (v__token__Kind__name) || p->peek_tok.kind == (v__token__Kind__key_struct) || p->peek_tok.kind == (v__token__Kind__key_enum) || p->peek_tok.kind == (v__token__Kind__key_interface) || p->peek_tok.kind == (v__token__Kind__key_shared)) {
				if ((Array_string_contains(_const_v__parser__comptime_types, p->peek_tok.lit))) {
					node = v__ast__ComptimeType_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeType, (v__parser__Parser_parse_comptime_type(p))), false);
				} else {
					node = v__ast__ComptimeCall_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeCall, (v__parser__Parser_comptime_call(p))), false);
				}
				p->is_stmt_ident = is_stmt_ident;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_if)) {
				bool is_expr = false;
				if (v__token__Kind_is_assign(p->prev_tok.kind)) {
					is_expr = true;
				}
				_result_v__ast__Expr _t5;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, true, is_expr))), false) }, (_result*)(&_t5), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t5;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_match)) {
				_result_v__ast__Expr _t6;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__MatchExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__MatchExpr, (v__parser__Parser_match_expr(p, true, v__token__Kind_is_assign(p->prev_tok.kind)))), false) }, (_result*)(&_t6), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t6;
			}
			else {
				_result_v__ast__Expr _t7;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected_with_pos(p, v__token__Token_pos(&p->peek_tok), ((v__parser__ParamsForUnexpected){.got = _S("`$`"),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false) }, (_result*)(&_t7), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t7;
			}
			break;
		}
		case v__token__Kind__chartoken: {
			node = v__ast__CharLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__CharLiteral, (((v__ast__CharLiteral){.val = p->tok.lit,.pos = v__token__Token_pos(&p->tok),}))), false);
			v__parser__Parser_next(p);
			break;
		}
		case v__token__Kind__amp: case v__token__Kind__mul: case v__token__Kind__not: case v__token__Kind__bit_not: case v__token__Kind__arrow: {
			node = v__parser__Parser_prefix_expr(p);
			break;
		}
		case v__token__Kind__minus: {
			if (p->peek_tok.kind == v__token__Kind__number) {
				node = v__parser__Parser_parse_number_literal(p);
			} else {
				node = v__parser__Parser_prefix_expr(p);
			}
			break;
		}
		case v__token__Kind__key_go: case v__token__Kind__key_spawn: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				if ((p->pref->use_coroutines || p->pref->is_fmt) && p->tok.kind == v__token__Kind__key_go) {
					v__ast__GoExpr go_expr = v__parser__Parser_go_expr(p);
					go_expr.is_expr = true;
					node = v__ast__GoExpr_to_sumtype_v__ast__Expr(&go_expr, false);
				} else {
					v__ast__SpawnExpr spawn_expr = v__parser__Parser_spawn_expr(p);
					spawn_expr.is_expr = true;
					node = v__ast__SpawnExpr_to_sumtype_v__ast__Expr(&spawn_expr, false);
				}
			}
			break;
		}
		case v__token__Kind__key_true: case v__token__Kind__key_false: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				node = v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = p->tok.kind == v__token__Kind__key_true,.pos = v__token__Token_pos(&p->tok),}))), false);
				v__parser__Parser_next(p);
			}
			break;
		}
		case v__token__Kind__key_match: {
			node = ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok) ? (v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false)) : (v__ast__MatchExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__MatchExpr, (v__parser__Parser_match_expr(p, false, false))), false)));
			break;
		}
		case v__token__Kind__key_select: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				node = v__ast__SelectExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectExpr, (v__parser__Parser_select_expr(p))), false);
			}
			break;
		}
		case v__token__Kind__key_nil: {
			node = v__ast__Nil_to_sumtype_v__ast__Expr(ADDR(v__ast__Nil, (((v__ast__Nil){.pos = v__token__Token_pos(&p->tok),}))), false);
			v__parser__Parser_next(p);
			break;
		}
		case v__token__Kind__number: {
			node = v__parser__Parser_parse_number_literal(p);
			break;
		}
		case v__token__Kind__lpar: {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__lpar);
			Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			node = v__parser__Parser_expr(p, 0);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t8, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			node = v__ast__ParExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ParExpr, (((v__ast__ParExpr){.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.expr = node,.comments = comments,}))), false);
			break;
		}
		case v__token__Kind__key_if: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				bool is_expr = false;
				if (v__token__Kind_is_assign(p->prev_tok.kind)) {
					is_expr = true;
				}
				node = v__ast__IfExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfExpr, (v__parser__Parser_if_expr(p, false, is_expr))), false);
			}
			break;
		}
		case v__token__Kind__key_unsafe: {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
			if (p->inside_unsafe) {
				_result_v__ast__Expr _t9;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("already inside `unsafe` block"), pos))), false) }, (_result*)(&_t9), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t9;
			}
			p->inside_unsafe = true;
			v__parser__Parser_check(p, v__token__Kind__lcbr);
			v__ast__Expr e = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind__rcbr);
			v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
			node = v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__UnsafeExpr, (((v__ast__UnsafeExpr){.pos = pos,.expr = e,}))), false);
			p->inside_unsafe = false;
			break;
		}
		case v__token__Kind__pipe: case v__token__Kind__logical_or: {
			_option_v__ast__LambdaExpr _t10;
			if (_t10 = v__parser__Parser_lambda_expr(p), _t10.state == 0) {
				v__ast__LambdaExpr nnn = *(v__ast__LambdaExpr*)_t10.data;
				node = v__ast__LambdaExpr_to_sumtype_v__ast__Expr(&nnn, false);
			} else {
				_result_v__ast__Expr _t11 = (_result_v__ast__Expr){ .is_error=true, .err=builtin___v_error(_S("unexpected lambda expression")), .data={E_STRUCT} };
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t11;
			}
			break;
		}
		case v__token__Kind__key_lock: case v__token__Kind__key_rlock: {
			if ((p->peek_tok.kind == v__token__Kind__lpar || p->peek_tok.kind == v__token__Kind__lsbr) && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, p->language, p->mod))), false);
			} else {
				node = v__ast__LockExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__LockExpr, (v__parser__Parser_lock_expr(p))), false);
			}
			break;
		}
		case v__token__Kind__lsbr: {
			if (p->expecting_type) {
				node = v__parser__Parser_name_expr(p);
			} else {
				int line_nr = p->tok.line_nr;
				int n = 1;
				v__token__Token prev_n_tok = p->tok;
				v__token__Token peek_n_tok = v__parser__Parser_peek_token(p, n);
				int sbr_level = 1;
				for (;;) {
					if (!((peek_n_tok.kind == v__token__Kind__name || peek_n_tok.kind == v__token__Kind__dot || peek_n_tok.kind == v__token__Kind__lsbr || peek_n_tok.kind == v__token__Kind__rsbr || peek_n_tok.kind == v__token__Kind__number))) break;
					if (peek_n_tok.kind == v__token__Kind__rsbr) {
						sbr_level--;
					} else if (peek_n_tok.kind == v__token__Kind__lsbr) {
						sbr_level++;
					}
					if (peek_n_tok.kind == v__token__Kind__dot && prev_n_tok.kind != v__token__Kind__name) {
						break;
					}
					n++;
					prev_n_tok = peek_n_tok;
					peek_n_tok = v__parser__Parser_peek_token(p, n);
				}
				if (peek_n_tok.kind == v__token__Kind__lpar && sbr_level == 0 && peek_n_tok.line_nr == line_nr) {
					v__token__Pos pos = v__token__Token_pos(&p->tok);
					v__ast__Type typ = v__parser__Parser_parse_type(p);
					string typname = v__ast__Table_sym(p->table, typ)->name;
					v__parser__Parser_check(p, v__token__Kind__lpar);
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					v__parser__Parser_check(p, v__token__Kind__rpar);
					node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, (((v__ast__CastExpr){.arg = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.expr = expr,.typname = typname,.pos = pos,.typ = typ,.expr_type = 0,.has_arg = 0,}))), false);
				} else {
					node = v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (v__parser__Parser_array_init(p, false, _const_v__ast__void_type))), false);
				}
			}
			break;
		}
		case v__token__Kind__key_none: {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
			node = v__ast__None_to_sumtype_v__ast__Expr(ADDR(v__ast__None, (((v__ast__None){.pos = pos,}))), false);
			break;
		}
		case v__token__Kind__key_typeof: {
			v__token__Pos spos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__lsbr) {
				v__parser__Parser_check(p, v__token__Kind__lsbr);
				v__token__Pos type_pos = v__token__Token_pos(&p->tok);
				v__ast__Type typ = v__parser__Parser_parse_type(p);
				v__parser__Parser_check(p, v__token__Kind__rsbr);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				node = v__ast__TypeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeOf, (((v__ast__TypeOf){.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->tok)),.typ = typ,.is_type = true,}))), false);
			} else {
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				if (p->tok.kind != v__token__Kind__dot && p->tok.line_nr == p->prev_tok.line_nr) {
					if (!p->inside_unsafe) {
						v__parser__Parser_warn_with_pos(p, _S("use e.g. `typeof(expr).name` or `sum_type_instance.type_name()` instead"), spos);
					}
				}
				node = v__ast__TypeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeOf, (((v__ast__TypeOf){.expr = expr,.pos = v__token__Pos_extend(spos, v__token__Token_pos(&p->tok)),.typ = 0,.is_type = false,}))), false);
			}
			break;
		}
		case v__token__Kind__key_sizeof: case v__token__Kind__key_isreftype: {
			bool is_reftype = p->tok.kind == v__token__Kind__key_isreftype;
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__lsbr) {
				v__parser__Parser_check(p, v__token__Kind__lsbr);
				v__token__Pos type_pos = v__token__Token_pos(&p->tok);
				v__ast__Type typ = v__parser__Parser_parse_type(p);
				type_pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->tok));
				v__parser__Parser_check(p, v__token__Kind__rsbr);
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				if (is_reftype) {
					node = v__ast__IsRefType_to_sumtype_v__ast__Expr(ADDR(v__ast__IsRefType, (((v__ast__IsRefType){.guessed_type = 0,.is_type = true,.pos = type_pos,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.typ = typ,}))), false);
				} else {
					node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, (((v__ast__SizeOf){.guessed_type = 0,.is_type = true,.pos = type_pos,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.typ = typ,}))), false);
				}
			} else {
				v__parser__Parser_check(p, v__token__Kind__lpar);
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				bool is_known_var = v__ast__Scope_mark_var_as_used(p->scope, p->tok.lit) || v__ast__Scope_known_const(p->table->global_scope, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit));
				bool is_type = v__parser__Parser_known_import(p, p->tok.lit) || v__token__Kind_is_start_of_type(p->tok.kind) || (p->tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)));
				if (p->peek_tok.kind == v__token__Kind__string && (builtin__fast_string_eq(p->tok.lit, _S("c")) || builtin__fast_string_eq(p->tok.lit, _S("r")))) {
					is_known_var = false;
					is_type = false;
				}
				if (is_known_var || !is_type) {
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					if (is_reftype) {
						node = v__ast__IsRefType_to_sumtype_v__ast__Expr(ADDR(v__ast__IsRefType, (((v__ast__IsRefType){.guessed_type = 0,.is_type = false,.pos = pos,.expr = expr,.typ = 0,}))), false);
					} else {
						node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, (((v__ast__SizeOf){.guessed_type = 0,.is_type = false,.pos = pos,.expr = expr,.typ = 0,}))), false);
					}
				} else {
					if (p->tok.kind == v__token__Kind__name) {
						v__parser__Parser_register_used_import(p, p->tok.lit);
					}
					string save_expr_mod = p->expr_mod;
					p->expr_mod = _S("");
					v__ast__Type arg_type = v__parser__Parser_parse_type(p);
					p->expr_mod = save_expr_mod;
					if (is_reftype) {
						node = v__ast__IsRefType_to_sumtype_v__ast__Expr(ADDR(v__ast__IsRefType, (((v__ast__IsRefType){.guessed_type = true,.is_type = true,.pos = pos,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.typ = arg_type,}))), false);
					} else {
						node = v__ast__SizeOf_to_sumtype_v__ast__Expr(ADDR(v__ast__SizeOf, (((v__ast__SizeOf){.guessed_type = true,.is_type = true,.pos = pos,.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.typ = arg_type,}))), false);
					}
				}
				v__parser__Parser_check(p, v__token__Kind__rpar);
			}
			break;
		}
		case v__token__Kind__key_dump: {
			v__token__Pos spos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind__comma && p->peek_tok.kind == v__token__Kind__rpar) {
				v__parser__Parser_next(p);
			}
			v__parser__Parser_check(p, v__token__Kind__rpar);
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
			node = v__ast__DumpExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__DumpExpr, (((v__ast__DumpExpr){.expr = expr,.cname = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(spos, pos),.expr_type = 0,}))), false);
			break;
		}
		case v__token__Kind__key_offsetof: {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Type st = v__parser__Parser_parse_type(p);
			v__parser__Parser_check(p, v__token__Kind__comma);
			if (p->tok.kind != v__token__Kind__name) {
				_result_v__ast__Expr _t12;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`"), 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = _S("expecting struct field"),})))), false) }, (_result*)(&_t12), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t12;
			}
			string field = p->tok.lit;
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			node = v__ast__OffsetOf_to_sumtype_v__ast__Expr(ADDR(v__ast__OffsetOf, (((v__ast__OffsetOf){.field = field,.pos = pos,.struct_type = st,}))), false);
			break;
		}
		case v__token__Kind__key_likely: case v__token__Kind__key_unlikely: {
			bool is_likely = p->tok.kind == v__token__Kind__key_likely;
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__token__Pos lpos = v__token__Token_pos(&p->tok);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			node = v__ast__Likely_to_sumtype_v__ast__Expr(ADDR(v__ast__Likely, (((v__ast__Likely){.pos = lpos,.is_likely = is_likely,.expr = expr,}))), false);
			break;
		}
		case v__token__Kind__lcbr: {
			v__parser__Parser_next(p);
			node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (v__parser__Parser_map_init(p))), false);
			v__parser__Parser_check(p, v__token__Kind__rcbr);
			break;
		}
		case v__token__Kind__key_fn: {
			if (p->expecting_type) {
				v__token__Pos start_pos = v__token__Token_pos(&p->tok);
				_result_v__ast__Expr _t13;
				builtin___result_ok(&(v__ast__Expr[]) { v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, (((v__ast__TypeNode){.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),.typ = v__parser__Parser_parse_type(p),.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}))), false) }, (_result*)(&_t13), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t13;
			} else {
				node = v__ast__AnonFn_to_sumtype_v__ast__Expr(ADDR(v__ast__AnonFn, (v__parser__Parser_anon_fn(p))), false);
				if (p->file_backend_mode == v__ast__Language__v || p->file_backend_mode == v__ast__Language__c) {
					v__parser__Parser_register_auto_import(p, _S("builtin.closure"));
				}
				if (p->tok.kind == v__token__Kind__lpar) {
					v__parser__Parser_next(p);
					v__token__Pos pos = v__token__Token_pos(&p->tok);
					Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
					v__parser__Parser_check(p, v__token__Kind__rpar);
					v__ast__OrExpr or_block = v__parser__Parser_gen_or_block(p);
					node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){
						.or_block = or_block,
						.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.args = args,
						.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
						.name = _S("anon"),
						.const_name = (string){.str=(byteptr)"", .is_lit=1},
						.left = node,
						.mod = (string){.str=(byteptr)"", .is_lit=1},
						.scope = p->scope,
						.pos = pos,
						.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
						.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
						.receiver_type = 0,
						.return_type = 0,
						.return_type_generic = 0,
						.nr_ret_values = -1,
						.fn_var_type = 0,
						.left_type = 0,
						.receiver_concrete_type = 0,
						.kind = 0,
						.language = 0,
						.is_unwrapped_fn_selector = 0,
						.is_method = 0,
						.is_field = 0,
						.is_fn_var = 0,
						.is_fn_a_const = 0,
						.is_keep_alive = 0,
						.is_noreturn = 0,
						.is_ctor_new = 0,
						.is_file_translated = 0,
						.is_static_method = 0,
						.is_variadic = 0,
						.is_c_variadic = 0,
						.comptime_ret_val = 0,
						.should_be_skipped = 0,
						.free_receiver = 0,
						.is_return_used = p->expecting_value,
						.is_expand_simple_interpolation = 0,
					}))), false);
				}
				_result_v__ast__Expr _t14;
				builtin___result_ok(&(v__ast__Expr[]) { node }, (_result*)(&_t14), sizeof(v__ast__Expr));
				 
					{ // defer begin
						p->expr_level--;
					} // defer end
				return _t14;
			}
			break;
		}
		case v__token__Kind__inc: case v__token__Kind__dec: {
			bool same_line_with_next = p->tok.line_nr == p->peek_tok.line_nr;
			bool next_tok_name = p->peek_tok.kind == v__token__Kind__name;
			if (next_tok_name && same_line_with_next) {
				v__parser__Parser_prefix_inc_dec_error(p);
			}
			break;
		}
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__str_inter:
		case v__token__Kind__plus:
		case v__token__Kind__div:
		case v__token__Kind__mod:
		case v__token__Kind__xor:
		case v__token__Kind__and:
		case v__token__Kind__comma:
		case v__token__Kind__semicolon:
		case v__token__Kind__colon:
		case v__token__Kind__hash:
		case v__token__Kind__str_dollar:
		case v__token__Kind__left_shift:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__not_in:
		case v__token__Kind__not_is:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__boolean_and_assign:
		case v__token__Kind__boolean_or_assign:
		case v__token__Kind__rcbr:
		case v__token__Kind__rpar:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__eq:
		case v__token__Kind__ne:
		case v__token__Kind__gt:
		case v__token__Kind__lt:
		case v__token__Kind__ge:
		case v__token__Kind__le:
		case v__token__Kind__nl:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_asm:
		case v__token__Kind__key_assert:
		case v__token__Kind__key_break:
		case v__token__Kind__key_const:
		case v__token__Kind__key_continue:
		case v__token__Kind__key_defer:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_for:
		case v__token__Kind__key_global:
		case v__token__Kind__key_goto:
		case v__token__Kind__key_import:
		case v__token__Kind__key_in:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_is:
		case v__token__Kind__key_module:
		case v__token__Kind__key_return:
		case v__token__Kind__key_like:
		case v__token__Kind__key_ilike:
		case v__token__Kind__key_struct:
		case v__token__Kind__key_type:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_union:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_implements:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default: {
			{
				if (p->tok.kind == v__token__Kind__key_struct && p->peek_tok.kind == v__token__Kind__lcbr) {
					if (p->expecting_type && p->inside_call_args) {
						v__token__Pos tok_pos = v__token__Token_pos(&p->tok);
						_result_v__ast__Expr _t15;
						builtin___result_ok(&(v__ast__Expr[]) { v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, (((v__ast__TypeNode){.pos = tok_pos,.typ = _const_v__ast__void_type,.stmt = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p, true))), false),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}))), false) }, (_result*)(&_t15), sizeof(v__ast__Expr));
						 
							{ // defer begin
								p->expr_level--;
							} // defer end
						return _t15;
					} else {
						v__parser__Parser_next(p);
						_result_v__ast__Expr _t16;
						builtin___result_ok(&(v__ast__Expr[]) { v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, _S(""), v__ast__StructInitKind__anon, false))), false) }, (_result*)(&_t16), sizeof(v__ast__Expr));
						 
							{ // defer begin
								p->expr_level--;
							} // defer end
						return _t16;
					}
				} else if (p->tok.kind == v__token__Kind__key_type) {
					v__ast__Ident ident = v__parser__Parser_ident(p, v__ast__Language__v);
					node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident, false);
					v__ast__Scope_mark_var_as_used(p->scope, ident.name);
					v__parser__Parser_add_defer_var(p, ident);
					p->is_stmt_ident = is_stmt_ident;
				} else if (p->tok.kind != v__token__Kind__eof && !(p->tok.kind == v__token__Kind__rsbr && p->inside_asm)) {
					_result_v__ast__Expr _t17 = (_result_v__ast__Expr){ .is_error=true, .err=builtin___v_error(_S("none")), .data={E_STRUCT} };
						{ // defer begin
							p->expr_level--;
						} // defer end
					return _t17;
				}
				break;
			}
		}
	}
	
	if (p->inside_array_lit) {
		if ((p->tok.kind == v__token__Kind__minus || p->tok.kind == v__token__Kind__mul || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__arrow) && (int)(p->tok.pos + 1) == p->peek_tok.pos && (int)((int)(p->prev_tok.pos + p->prev_tok.len) + 1) != p->peek_tok.pos) {
			_result_v__ast__Expr _t18;
			builtin___result_ok(&(v__ast__Expr[]) { node }, (_result*)(&_t18), sizeof(v__ast__Expr));
			 
				{ // defer begin
					p->expr_level--;
				} // defer end
			return _t18;
		}
	}
	if (p->inside_if_cond) {
		_PUSH_MANY(&p->if_cond_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t19, Array_v__ast__Comment);
	}
	if (p->pref->is_fmt && p->tok.kind == v__token__Kind__comment && v__token__Kind_is_infix(p->peek_tok.kind) && !p->inside_map_init && !(p->peek_tok.kind == v__token__Kind__mul && v__token__Token_pos(&p->peek_tok).line_nr != v__token__Token_pos(&p->tok).line_nr)) {
		p->left_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	}
	_result_v__ast__Expr _t20;
	builtin___result_ok(&(v__ast__Expr[]) { v__parser__Parser_expr_with_left(p, node, precedence, is_stmt_ident) }, (_result*)(&_t20), sizeof(v__ast__Expr));
	 
		{ // defer begin
			p->expr_level--;
		} // defer end
	return _t20;
}
VV_LOC v__ast__Expr v__parser__Parser_expr_with_left(v__parser__Parser* p, v__ast__Expr left, int precedence, bool is_stmt_ident) {
	v__ast__Expr node = left;
	if (p->inside_asm && v__token__Token_pos(&p->prev_tok).line_nr < v__token__Token_pos(&p->tok).line_nr) {
		return node;
	}
	v__parser__Parser_process_custom_orm_operators(p);
	for (;;) {
		if (!(precedence < v__token__Kind_precedence(p->tok.kind))) break;
		if (p->tok.kind == v__token__Kind__dot) {
			if ((p->inside_map_init || p->inside_array_lit) && (int)(p->tok.pos - p->prev_tok.pos) > p->prev_tok.len) {
				return node;
			}
			node = v__parser__Parser_dot_expr(p, node);
			if (p->name_error) {
				return node;
			}
			p->is_stmt_ident = is_stmt_ident;
		} else if ((left)._typ != 286 /* v.ast.IntegerLiteral */ && (p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__nilsbr) && (p->tok.line_nr == p->prev_tok.line_nr || (p->prev_tok.kind == v__token__Kind__string && p->tok.line_nr == (int)(p->prev_tok.line_nr + builtin__string_count(p->prev_tok.lit, _S("\n")))))) {
			if (p->peek_tok.kind == v__token__Kind__question && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name) {
				v__parser__Parser_next(p);
				v__parser__Parser_error_with_pos(p, _S("cannot use Option type name as concrete type"), v__token__Token_pos(&p->tok));
			} else if (p->tok.kind == v__token__Kind__nilsbr) {
				node = v__ast__IndexExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IndexExpr, (v__parser__Parser_index_expr(p, node, true))), false);
			} else {
				node = v__ast__IndexExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IndexExpr, (v__parser__Parser_index_expr(p, node, false))), false);
			}
			p->is_stmt_ident = is_stmt_ident;
			if (p->tok.kind == v__token__Kind__lpar && p->tok.line_nr == p->prev_tok.line_nr && (node)._typ == 284 /* v.ast.IndexExpr */) {
				v__parser__Parser_next(p);
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				v__ast__OrExpr or_block = v__parser__Parser_gen_or_block(p);
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){
					.or_block = or_block,
					.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.args = args,
					.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
					.name = (string){.str=(byteptr)"", .is_lit=1},
					.const_name = (string){.str=(byteptr)"", .is_lit=1},
					.left = node,
					.mod = (string){.str=(byteptr)"", .is_lit=1},
					.scope = p->scope,
					.pos = pos,
					.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
					.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
					.receiver_type = 0,
					.return_type = 0,
					.return_type_generic = 0,
					.nr_ret_values = -1,
					.fn_var_type = 0,
					.left_type = 0,
					.receiver_concrete_type = 0,
					.kind = 0,
					.language = 0,
					.is_unwrapped_fn_selector = 0,
					.is_method = 0,
					.is_field = 0,
					.is_fn_var = 0,
					.is_fn_a_const = 0,
					.is_keep_alive = 0,
					.is_noreturn = 0,
					.is_ctor_new = 0,
					.is_file_translated = 0,
					.is_static_method = 0,
					.is_variadic = 0,
					.is_c_variadic = 0,
					.comptime_ret_val = 0,
					.should_be_skipped = 0,
					.free_receiver = 0,
					.is_return_used = p->expecting_value,
					.is_expand_simple_interpolation = 0,
				}))), false);
				p->is_stmt_ident = is_stmt_ident;
				if (p->tok.kind == v__token__Kind__lpar && p->prev_tok.line_nr == p->tok.line_nr) {
					v__parser__Parser_next(p);
					v__token__Pos pos2 = v__token__Token_pos(&p->tok);
					Array_v__ast__CallArg args2 = v__parser__Parser_call_args(p);
					v__parser__Parser_check(p, v__token__Kind__rpar);
					v__ast__OrExpr or_block2 = v__parser__Parser_gen_or_block(p);
					node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){.or_block = or_block2,.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.args = args2,.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.const_name = (string){.str=(byteptr)"", .is_lit=1},.left = node,.mod = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,.pos = pos2,.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.return_type = 0,.return_type_generic = 0,.nr_ret_values = -1,.fn_var_type = 0,.left_type = 0,.receiver_concrete_type = 0,.kind = 0,.language = 0,.is_unwrapped_fn_selector = 0,.is_method = 0,.is_field = 0,.is_fn_var = 0,.is_fn_a_const = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.is_file_translated = 0,.is_static_method = 0,.is_variadic = 0,.is_c_variadic = 0,.comptime_ret_val = 0,.should_be_skipped = 0,.free_receiver = 0,.is_return_used = 0,.is_expand_simple_interpolation = 0,}))), false);
				}
			}
		} else if (p->tok.kind == v__token__Kind__key_as && p->tok.line_nr == p->prev_tok.line_nr) {
			if (!p->inside_asm) {
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				v__parser__Parser_next(p);
				v__ast__Type typ = v__parser__Parser_parse_type(p);
				node = v__ast__AsCast_to_sumtype_v__ast__Expr(ADDR(v__ast__AsCast, (((v__ast__AsCast){.typ = typ,.pos = pos,.expr = node,.expr_type = 0,}))), false);
			} else {
				return node;
			}
		} else if ((node)._typ != 268 /* v.ast.CastExpr */ && p->tok.kind == v__token__Kind__left_shift && p->is_stmt_ident) {
			v__token__Token tok = p->tok;
			v__token__Pos pos = v__token__Token_pos(&tok);
			v__parser__Parser_next(p);
			bool old_assign_rhs = p->inside_assign_rhs;
			p->inside_assign_rhs = true;
			v__ast__Expr right = v__parser__Parser_expr(p, (int)(precedence - 1));
			p->inside_assign_rhs = old_assign_rhs;
			v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
			if ((node)._typ == 284 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_arraymap_set_is_setter(&(*node._v__ast__IndexExpr));
			}
			node = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, (((v__ast__InfixExpr){.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.after_op_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.before_op_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.right = right,.ct_right_value = _const_v__ast__empty_comptime_const_value,.ct_left_value = _const_v__ast__empty_comptime_const_value,.left = node,.auto_locked = (string){.str=(byteptr)"", .is_lit=1},.pos = pos,.left_type = 0,.promoted_type = _const_v__ast__void_type,.right_type = 0,.op = tok.kind,.is_stmt = true,.ct_left_value_evaled = 0,.left_ct_expr = 0,.ct_right_value_evaled = 0,.right_ct_expr = 0,}))), false);
		} else if (v__token__Kind_is_infix(p->tok.kind) && !((p->tok.kind == v__token__Kind__minus || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__mul || p->tok.kind == v__token__Kind__key_as || p->tok.kind == v__token__Kind__key_in || p->tok.kind == v__token__Kind__key_is) && p->tok.line_nr != p->prev_tok.line_nr)) {
			node = v__parser__Parser_infix_expr(p, node);
			if (p->tok.kind == v__token__Kind__key_as && p->inside_if) {
				return node;
			}
		} else if ((p->tok.kind == v__token__Kind__inc || p->tok.kind == v__token__Kind__dec) || (p->tok.kind == v__token__Kind__question && p->inside_ct_if_expr)) {
			if (p->peek_tok.kind == v__token__Kind__rpar || p->peek_tok.kind == v__token__Kind__rsbr) {
				if (!p->inside_ct_if_expr) {
					if (!p->pref->translated && !p->is_translated) {
						v__parser__Parser_warn_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_S("` operator can only be used as a statement"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
					}
				}
			}
			bool inc_dec_tok = (p->tok.kind == v__token__Kind__inc || p->tok.kind == v__token__Kind__dec);
			bool same_line_with_prev = p->tok.line_nr == p->prev_tok.line_nr;
			bool same_line_with_next = p->tok.line_nr == p->peek_tok.line_nr;
			bool next_tok_name = p->peek_tok.kind == v__token__Kind__name;
			if (inc_dec_tok && !same_line_with_prev && !next_tok_name) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_S(" must be on the same line as the previous token"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
			}
			bool prev_name_or_rsbr = (p->prev_tok.kind == v__token__Kind__name || p->prev_tok.kind == v__token__Kind__rsbr);
			if (inc_dec_tok && same_line_with_next && next_tok_name && (!prev_name_or_rsbr || !same_line_with_prev)) {
				v__parser__Parser_prefix_inc_dec_error(p);
			}
			if ((node)._typ == 284 /* v.ast.IndexExpr */) {
				v__ast__IndexExpr_recursive_mapset_is_setter(&(*node._v__ast__IndexExpr), true);
			}
			bool is_c2v_prefix = p->peek_tok.kind == v__token__Kind__dollar && v__token__Token_is_next_to(p->peek_tok, p->tok);
			node = v__ast__PostfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PostfixExpr, (((v__ast__PostfixExpr){.op = p->tok.kind,.pos = v__token__Token_pos(&p->tok),.is_c2v_prefix = is_c2v_prefix,.expr = node,.typ = 0,.auto_locked = (string){.str=(byteptr)"", .is_lit=1},}))), false);
			if (is_c2v_prefix) {
				v__parser__Parser_next(p);
			}
			v__parser__Parser_next(p);
		} else {
			return node;
		}
	}
	return node;
}
VV_LOC v__ast__OrExpr v__parser__Parser_gen_or_block(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind__key_orelse) {
		multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_19423 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
		Array_v__ast__Stmt or_stmts = mr_19423.arg0;
		v__token__Pos or_pos = mr_19423.arg1;
		v__ast__Scope* or_scope = mr_19423.arg2;
		return ((v__ast__OrExpr){.kind = v__ast__OrKind__block,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,});
	} else if (p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__not) {
		v__token__Pos or_pos = v__token__Token_pos(&p->tok);
		bool is_not = p->tok.kind == v__token__Kind__not;
		v__parser__Parser_next(p);
		if (p->inside_defer) {
			v__parser__Parser_error_with_pos(p, _S("error propagation not allowed inside `defer` blocks"), v__token__Token_pos(&p->prev_tok));
		}
		return ((v__ast__OrExpr){.kind = (is_not ? (v__ast__OrKind__propagate_result) : (v__ast__OrKind__propagate_option)),.pos = or_pos,.scope = p->scope,.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),});
	} else {
		return ((v__ast__OrExpr){.kind = v__ast__OrKind__absent,.pos = v__token__Token_pos(&p->tok),.scope = _const_v__ast__empty_scope,.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),});
	}
	return (v__ast__OrExpr){.kind = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),};
}
VV_LOC v__ast__Expr v__parser__Parser_infix_expr(v__parser__Parser* p, v__ast__Expr left) {
	bool prev_inside_infix = p->inside_infix;
	p->inside_infix = true;
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind__arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _S("sync"));
	}
	int precedence = v__token__Kind_precedence(p->tok.kind);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	if (p->inside_if_cond) {
		_PUSH_MANY(&p->if_cond_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t1, Array_v__ast__Comment);
	}
	Array_v__ast__Comment before_op_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (p->pref->is_fmt && p->left_comments.len > 0) {
		before_op_comments = builtin__array_clone_to_depth(&p->left_comments, 0);
		p->left_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	p->left_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_v__ast__Comment after_op_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	v__ast__Expr right = _const_v__ast__empty_expr;
	bool prev_expecting_type = p->expecting_type;
	if (op == v__token__Kind__key_is || op == v__token__Kind__not_is) {
		p->expecting_type = true;
	}
	bool is_key_in = (op == v__token__Kind__key_in || op == v__token__Kind__not_in);
	if (is_key_in) {
		p->inside_in_array = true;
	}
	v__token__Pos right_op_pos = v__token__Token_pos(&p->tok);
	bool old_assign_rhs = p->inside_assign_rhs;
	if (op == v__token__Kind__decl_assign || op == v__token__Kind__assign) {
		p->inside_assign_rhs = true;
	}
	right = v__parser__Parser_expr(p, precedence);
	p->inside_assign_rhs = old_assign_rhs;
	if ((op == v__token__Kind__plus || op == v__token__Kind__minus || op == v__token__Kind__mul || op == v__token__Kind__div || op == v__token__Kind__mod || op == v__token__Kind__lt || op == v__token__Kind__eq) && (right)._typ == 299 /* v.ast.PrefixExpr */) {
		v__ast__Expr right_expr = (*right._v__ast__PrefixExpr).right;
		right_expr = v__ast__Expr_remove_par(&right_expr);
		if (((*right._v__ast__PrefixExpr).op == v__token__Kind__plus || (*right._v__ast__PrefixExpr).op == v__token__Kind__minus || (*right._v__ast__PrefixExpr).op == v__token__Kind__mul || (*right._v__ast__PrefixExpr).op == v__token__Kind__div || (*right._v__ast__PrefixExpr).op == v__token__Kind__mod || (*right._v__ast__PrefixExpr).op == v__token__Kind__lt || (*right._v__ast__PrefixExpr).op == v__token__Kind__eq) && v__ast__Expr_is_pure_literal(right_expr)) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid expression: unexpected token `"), 0xfe10, {.d_s = v__token__Kind_str(op)}}, {_S("`"), 0, { .d_c = 0 }}})), right_op_pos);
		}
	}
	if (is_key_in) {
		if (p->tok.kind == v__token__Kind__dotdot) {
			v__parser__Parser_check(p, v__token__Kind__dotdot);
			v__token__Pos pos_high = v__token__Token_pos(&p->tok);
			right = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){
				.low = right,
				.high = v__parser__Parser_expr(p, ((int)(v__token__Precedence__in_as))),
				.pos = pos_high,
				.typ = 0,
				.has_high = true,
				.has_low = true,
				.is_gated = false,
			}))), false);
		}
		p->inside_in_array = false;
	}
	p->expecting_type = prev_expecting_type;
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	v__token__Pos or_pos = v__token__Token_pos(&p->tok);
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (op == v__token__Kind__arrow) {
		if ((right)._typ == 302 /* v.ast.SelectorExpr */) {
			or_kind = (*right._v__ast__SelectorExpr).or_block.kind;
			or_stmts = builtin__array_clone_to_depth(&(*right._v__ast__SelectorExpr).or_block.stmts, 0);
			(*right._v__ast__SelectorExpr).or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),});
		}
		if ((right)._typ == 267 /* v.ast.CallExpr */) {
			or_kind = (*right._v__ast__CallExpr).or_block.kind;
			or_stmts = builtin__array_clone_to_depth(&(*right._v__ast__CallExpr).or_block.stmts, 0);
			or_scope = (*right._v__ast__CallExpr).or_block.scope;
			(*right._v__ast__CallExpr).or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),});
		}
		if (p->tok.kind == v__token__Kind__key_orelse) {
			or_kind = v__ast__OrKind__block;
			multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_22417 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
			or_stmts = mr_22417.arg0;
			or_pos = mr_22417.arg1;
			or_scope = mr_22417.arg2;
		}
		if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind__propagate_option;
			or_scope = p->scope;
		}
		p->or_is_handled = false;
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__Expr _t2 = v__ast__InfixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__InfixExpr, (((v__ast__InfixExpr){
		.or_block = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),
		.after_op_comments = after_op_comments,
		.before_op_comments = before_op_comments,
		.right = right,
		.ct_right_value = _const_v__ast__empty_comptime_const_value,
		.ct_left_value = _const_v__ast__empty_comptime_const_value,
		.left = left,
		.auto_locked = (string){.str=(byteptr)"", .is_lit=1},
		.pos = pos,
		.left_type = 0,
		.promoted_type = _const_v__ast__void_type,
		.right_type = 0,
		.op = op,
		.is_stmt = p->is_stmt_ident,
		.ct_left_value_evaled = 0,
		.left_ct_expr = 0,
		.ct_right_value_evaled = 0,
		.right_ct_expr = 0,
	}))), false);
		{ // defer begin
			p->inside_infix = prev_inside_infix;
		} // defer end
	return _t2;
}
VV_LOC v__ast__Expr v__parser__Parser_prefix_expr(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	bool is_option = p->tok.kind == v__token__Kind__question;
	if (is_option) {
		v__parser__Parser_next(p);
	}
	v__token__Kind op = p->tok.kind;
	if (op == v__token__Kind__amp) {
		p->is_amp = true;
	}
	if (op == v__token__Kind__arrow) {
		p->or_is_handled = true;
		v__parser__Parser_register_auto_import(p, _S("sync"));
	}
	v__parser__Parser_next(p);
	v__ast__Expr right = v__parser__Parser_expr(p, ((int)(v__token__Precedence__prefix)));
	p->is_amp = false;
	if (op == v__token__Kind__amp) {
		if ((right)._typ == 268 /* v.ast.CastExpr */) {
			v__parser__Parser_recast_as_pointer(p, &/*mut*/(*right._v__ast__CastExpr), pos);
			if (is_option) {
				(*right._v__ast__CastExpr).typ = v__ast__Type_set_flag((*right._v__ast__CastExpr).typ, v__ast__TypeFlag__option);
			}
			return v__ast__CastExpr_to_sumtype_v__ast__Expr(&(*right._v__ast__CastExpr), false);
		}
		if ((right)._typ == 302 /* v.ast.SelectorExpr */) {
			if (((*right._v__ast__SelectorExpr).expr)._typ == 268 /* v.ast.CastExpr */) {
				v__parser__Parser_recast_as_pointer(p, (voidptr)&(*(*right._v__ast__SelectorExpr).expr._v__ast__CastExpr), pos);
				return v__ast__SelectorExpr_to_sumtype_v__ast__Expr(&(*right._v__ast__SelectorExpr), false);
			}
		}
		if ((right)._typ == 284 /* v.ast.IndexExpr */) {
			if (((*right._v__ast__IndexExpr).left)._typ == 268 /* v.ast.CastExpr */) {
				v__parser__Parser_recast_as_pointer(p, (voidptr)&(*(*right._v__ast__IndexExpr).left._v__ast__CastExpr), pos);
				return v__ast__IndexExpr_to_sumtype_v__ast__Expr(&(*right._v__ast__IndexExpr), false);
			}
		}
		if ((right)._typ == 297 /* v.ast.ParExpr */) {
			if (((*right._v__ast__ParExpr).expr)._typ == 236 /* v.ast.StructInit */) {
				v__parser__Parser_note_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("unnecessary `()`, use `&"), 0xfe10, {.d_s = v__ast__Expr_str((*right._v__ast__ParExpr).expr)}}, {_S("` instead of `&("), 0xfe10, {.d_s = v__ast__Expr_str((*right._v__ast__ParExpr).expr)}}, {_S(")`"), 0, { .d_c = 0 }}})), (*right._v__ast__ParExpr).pos);
				right = (*right._v__ast__ParExpr).expr;
			}
		}
		if ((right)._typ == 307 /* v.ast.TypeNode */) {
			(*right._v__ast__TypeNode).typ = v__ast__Type_ref((*right._v__ast__TypeNode).typ);
			return v__ast__TypeNode_to_sumtype_v__ast__Expr(&(*right._v__ast__TypeNode), false);
		}
	}
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	v__token__Pos or_pos = v__token__Token_pos(&p->tok);
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (op == v__token__Kind__arrow) {
		if ((right)._typ == 302 /* v.ast.SelectorExpr */) {
			or_kind = (*right._v__ast__SelectorExpr).or_block.kind;
			or_stmts = builtin__array_clone_to_depth(&(*right._v__ast__SelectorExpr).or_block.stmts, 0);
			(*right._v__ast__SelectorExpr).or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),});
		} else if (p->tok.kind == v__token__Kind__key_orelse) {
			or_kind = v__ast__OrKind__block;
			multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_24780 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
			or_stmts = mr_24780.arg0;
			or_pos = mr_24780.arg1;
			or_scope = mr_24780.arg2;
		} else if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			or_kind = v__ast__OrKind__propagate_option;
			or_scope = p->scope;
		}
		p->or_is_handled = false;
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	return v__ast__PrefixExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__PrefixExpr, (((v__ast__PrefixExpr){.or_block = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),.right = right,.pos = pos,.right_type = 0,.op = op,.is_option = 0,}))), false);
}
VV_LOC void v__parser__Parser_recast_as_pointer(v__parser__Parser* p, v__ast__CastExpr* cast_expr, v__token__Pos pos) {
	cast_expr->typ = v__ast__Type_ref(cast_expr->typ);
	cast_expr->typname = (cast_expr->typ == 0 ? (v__ast__Table_sym(p->table, cast_expr->typ)->name) : (_S("unknown type name")));
	cast_expr->pos = v__token__Pos_extend(pos, cast_expr->pos);
}
VV_LOC void v__parser__Parser_prefix_inc_dec_error(v__parser__Parser* p) {
	string op = (p->tok.kind == v__token__Kind__inc ? (_S("++")) : (_S("--")));
	v__token__Pos op_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	v__token__Pos full_expr_pos = v__token__Pos_extend(op_pos, v__ast__Expr_pos(expr));
	v__parser__Parser_error_with_pos(p, builtin__str_intp(5, _MOV((StrIntpData[]){{_S("prefix `"), 0xfe10, {.d_s = op}}, {_SLIT0, 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_S("` is unsupported, use suffix form `"), 0xfe10, {.d_s = v__ast__Expr_str(expr)}}, {_SLIT0, 0xfe10, {.d_s = op}}, {_S("`"), 0, { .d_c = 0 }}})), full_expr_pos);
}
inline VV_LOC void v__parser__Parser_process_custom_orm_operators(v__parser__Parser* p) {
	if (!p->inside_orm) {
		return;
	}
	bool is_like_operator = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("like"));
	bool is_ilike_operator = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("ilike"));
	if (is_like_operator) {
		p->tok = ((v__token__Token){.lit = (p->tok).lit,.pos = (p->tok).pos,.len = (p->tok).len,.line_nr = (p->tok).line_nr,.tidx = (p->tok).tidx,.file_idx = (p->tok).file_idx,.col = (p->tok).col,.kind = v__token__Kind__key_like,});
	} else if (is_ilike_operator) {
		p->tok = ((v__token__Token){.lit = (p->tok).lit,.pos = (p->tok).pos,.len = (p->tok).len,.line_nr = (p->tok).line_nr,.tidx = (p->tok).tidx,.file_idx = (p->tok).file_idx,.col = (p->tok).col,.kind = v__token__Kind__key_ilike,});
	}
}
VV_LOC _option_v__ast__LambdaExpr v__parser__Parser_lambda_expr(v__parser__Parser* p) {
	if (!(p->tok.kind == v__token__Kind__logical_or || (v__parser__Parser_peek_token(p, 1).kind == v__token__Kind__key_mut && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name) || (v__parser__Parser_peek_token(p, 1).kind == v__token__Kind__name && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__pipe) || (v__parser__Parser_peek_token(p, 1).kind == v__token__Kind__name && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma))) {
		return (_option_v__ast__LambdaExpr){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	v__parser__Parser_open_scope(p);
	p->scope->detached_from_parent = true;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Ident params = builtin____new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	if (p->tok.kind == v__token__Kind__logical_or) {
		v__parser__Parser_check(p, v__token__Kind__logical_or);
	} else {
		v__parser__Parser_check(p, v__token__Kind__pipe);
		for (;;) {
			if (p->tok.kind == v__token__Kind__eof) {
				break;
			}
			v__ast__Ident ident = v__parser__Parser_ident(p, v__ast__Language__v);
			if (v__ast__Scope_known_var(p->scope, ident.name)) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of parameter `"), 0xfe10, {.d_s = ident.name}}, {_S("`"), 0, { .d_c = 0 }}})), ident.pos);
			}
			builtin__array_push((array*)&params, _MOV((v__ast__Ident[]){ ident }));
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
				.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
				.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
				.name = ident.name,
				.pos = ident.pos,
				.typ = 0,
				.orig_type = 0,
				.ct_type_var = 0,
				.share = 0,
				.is_arg = true,
				.is_auto_deref = 0,
				.is_unwrapped = 0,
				.is_index_var = 0,
				.is_volatile = 0,
				.is_static = 0,
				.is_special = 0,
				.is_mut = ident.is_mut,
				.is_used = true,
				.is_changed = 0,
				.ct_type_unwrapped = 0,
				.is_or = 0,
				.is_tmp = 0,
				.is_auto_heap = 0,
				.is_stack_obj = true,
				.is_inherited = 0,
				.is_autofree_tmp = 0,
				.has_inherited = 0,
			}))), false));
			if (p->tok.kind == v__token__Kind__pipe) {
				v__parser__Parser_next(p);
				break;
			}
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
	}
	v__token__Pos pos_expr = v__token__Token_pos(&p->tok);
	v__ast__Expr e = v__parser__Parser_expr(p, 0);
	v__token__Pos pos_end = v__token__Token_pos(&p->tok);
	_option_v__ast__LambdaExpr _t3;
	builtin___option_ok(&(v__ast__LambdaExpr[]) { ((v__ast__LambdaExpr){
		.pos = v__token__Pos_extend(pos, v__ast__Expr_pos(e)),
		.params = params,
		.pos_expr = pos_expr,
		.expr = e,
		.pos_end = pos_end,
		.scope = p->scope,
		.func = ((void*)0),
		.is_checked = 0,
		.typ = 0,
		.call_ctx = ((void*)0),
	}) }, (_option*)(&_t3), sizeof(v__ast__LambdaExpr));
	 
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t3;
}
VV_LOC v__ast__CallExpr v__parser__Parser_call_expr(v__parser__Parser* p, v__ast__Language language, string mod) {
	v__token__Pos first_pos = v__token__Token_pos(&p->tok);
	string name = (language == v__ast__Language__js ? (v__parser__Parser_check_js_name(p)) : (v__parser__Parser_check_name(p)));
	bool is_static_type_method = language == v__ast__Language__v && (name).len != 0 && builtin__u8_is_capital(builtin__string_at(name, 0)) && p->tok.kind == v__token__Kind__dot;
	if (is_static_type_method) {
		v__parser__Parser_check(p, v__token__Kind__dot);
		name = builtin__string__plus(builtin__string__plus(name, _S("__static__")), v__parser__Parser_check_name(p));
	}
	string fn_name = (language == v__ast__Language__c ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : language == v__ast__Language__js ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : language == v__ast__Language__wasm ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("WASM."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (mod).len != 0 ? (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_S("."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (name));
	if (language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, language, first_pos);
	}
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	if (_SLIT_EQ(fn_name.str, fn_name.len, "json.decode") || _SLIT_EQ(fn_name.str, fn_name.len, "C.va_arg")) {
		p->expecting_type = true;
	}
	string old_expr_mod = p->expr_mod;
	p->expr_mod = _S("");
	Array_v__ast__Type concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Pos concrete_list_pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__lsbr) {
		p->expr_mod = _S("");
		concrete_types = v__parser__Parser_parse_concrete_types(p);
		concrete_list_pos = v__token__Pos_extend(concrete_list_pos, v__token__Token_pos(&p->prev_tok));
	}
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
	if (p->tok.kind != v__token__Kind__rpar && !p->pref->is_vls) {
		v__ast__Fn* _t2 = (v__ast__Fn*)(builtin__map_get_check(ADDR(map, p->table->fns), &(string[]){fn_name}));
		_option_v__ast__Fn _t1 = {0};
		if (_t2) {
			*((v__ast__Fn*)&_t1.data) = *((v__ast__Fn*)_t2);
		} else {
			_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
		}
		;
		if (_t1.state != 0) {
			*(v__ast__Fn*) _t1.data = (*(v__ast__Fn*)builtin__map_get(ADDR(map, p->table->fns), &(string[]){builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->mod}}, {_S("."), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}}))}, &(v__ast__Fn[]){ (v__ast__Fn){.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.dep_names = builtin____new_array(0, 0, sizeof(string)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.file = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.name_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.return_type_pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.receiver_type = 0,.usages = 0,.return_type = 0,.from_embedded_type = 0,.ctdefine_idx = 0,.file_mode = 0,.language = 0,.is_expand_simple_interpolation = 0,.is_c_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_must_use = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = 0,.is_static_type_method = 0,.no_body = 0,.is_file_translated = 0,.is_conditional = 0,.is_variadic = 0,} }));
		}
		
		Array_v__ast__Param params = (*(v__ast__Fn*)_t1.data).params;
		if (args.len < params.len && p->prev_tok.kind != v__token__Kind__comma) {
			v__token__Pos pos = (p->tok.kind == v__token__Kind__eof ? (v__token__Token_pos(&p->prev_tok)) : (v__token__Token_pos(&p->tok)));
			v__parser__Parser_unexpected_with_pos(p, pos, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("`,`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
		} else if (args.len > params.len) {
			v__ast__CallArg* _t4 = (v__ast__CallArg*)(builtin__array_get_with_check(args, (int)(params.len - 1)));
			_option_v__ast__CallArg _t3 = {0};
			if (_t4) {
				*((v__ast__CallArg*)&_t3.data) = *((v__ast__CallArg*)_t4);
			} else {
				_t3.state = 2; _t3.err = builtin___v_error(_S("array index out of range"));
			}
			;
			if (_t3.state != 0) {
				*(v__ast__CallArg*) _t3.data = (*(v__ast__CallArg*)builtin__array_get(args, 0));
			}
			
			v__token__Pos ok_arg_pos = ((*(v__ast__CallArg*)_t3.data)).pos;
			v__token__Pos pos = ((v__token__Pos){.len = (ok_arg_pos).len,.line_nr = (ok_arg_pos).line_nr,.pos = (ok_arg_pos).pos,.col = ((u16)((int)(ok_arg_pos.col + ok_arg_pos.len))),.file_idx = (ok_arg_pos).file_idx,.last_line = (ok_arg_pos).last_line,});
			v__parser__Parser_unexpected_with_pos(p, v__token__Pos_extend(pos, v__token__Token_pos(&p->tok)), ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("`)`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
		} else {
			v__token__Pos pos = (p->tok.kind == v__token__Kind__eof ? (v__token__Token_pos(&p->prev_tok)) : (v__token__Token_pos(&p->tok)));
			v__parser__Parser_unexpected_with_pos(p, pos, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("`)`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
		}
	}
	v__token__Pos last_pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__rpar) {
		v__parser__Parser_next(p);
	}
	v__token__Pos pos = v__token__Pos_extend(first_pos, last_pos);
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Pos or_pos = v__token__Token_pos(&p->tok);
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (p->tok.kind == v__token__Kind__key_orelse) {
		or_kind = v__ast__OrKind__block;
		multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_2524 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
		or_stmts = mr_2524.arg0;
		or_pos = mr_2524.arg1;
		or_scope = mr_2524.arg2;
	}
	if (p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__not) {
		bool is_not = p->tok.kind == v__token__Kind__not;
		v__parser__Parser_next(p);
		if (p->inside_defer) {
			v__parser__Parser_error_with_pos(p, _S("error propagation not allowed inside `defer` blocks"), v__token__Token_pos(&p->prev_tok));
		}
		or_kind = (is_not ? (v__ast__OrKind__propagate_result) : (v__ast__OrKind__propagate_option));
		or_scope = p->scope;
	}
	if (v__parser__Parser_is_imported_symbol(p, fn_name)) {
		bool check = !(*(bool*)builtin__map_get(ADDR(map, p->imported_symbols_used), &(string[]){fn_name}, &(bool[]){ 0 }));
		fn_name = (*(string*)builtin__map_get(ADDR(map, p->imported_symbols), &(string[]){fn_name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		if (check) {
			v__parser__Parser_register_used_import_for_symbol_name(p, fn_name);
		}
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__CallExpr _t5 = ((v__ast__CallExpr){
		.or_block = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),
		.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.args = args,
		.concrete_types = concrete_types,
		.raw_concrete_types = concrete_types,
		.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.comments = comments,
		.name = fn_name,
		.const_name = (string){.str=(byteptr)"", .is_lit=1},
		.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.mod = p->mod,
		.scope = p->scope,
		.pos = pos,
		.concrete_list_pos = concrete_list_pos,
		.name_pos = first_pos,
		.receiver_type = 0,
		.return_type = 0,
		.return_type_generic = 0,
		.nr_ret_values = -1,
		.fn_var_type = 0,
		.left_type = 0,
		.receiver_concrete_type = 0,
		.kind = v__parser__Parser_call_kind(p, fn_name),
		.language = language,
		.is_unwrapped_fn_selector = 0,
		.is_method = 0,
		.is_field = 0,
		.is_fn_var = 0,
		.is_fn_a_const = 0,
		.is_keep_alive = 0,
		.is_noreturn = 0,
		.is_ctor_new = 0,
		.is_file_translated = 0,
		.is_static_method = is_static_type_method,
		.is_variadic = 0,
		.is_c_variadic = 0,
		.comptime_ret_val = 0,
		.should_be_skipped = 0,
		.free_receiver = 0,
		.is_return_used = p->expecting_value,
		.is_expand_simple_interpolation = 0,
	});
		{ // defer begin
			p->expr_mod = old_expr_mod;
		} // defer end
	return _t5;
}
VV_LOC v__ast__CallKind v__parser__Parser_call_kind(v__parser__Parser* p, string fn_name) {
	if (fn_name.len < 3 || fn_name.len > 20) {
		return v__ast__CallKind__unknown;
	}
	v__ast__CallKind _t3 = 0;
	
	if (fn_name.len == (3)) {
		_t3 = ((_SLIT_EQ(fn_name.str, fn_name.len, "str"))? (v__ast__CallKind__str) : (_SLIT_EQ(fn_name.str, fn_name.len, "map"))? (v__ast__CallKind__map) : (_SLIT_EQ(fn_name.str, fn_name.len, "any"))? (v__ast__CallKind__any) : (_SLIT_EQ(fn_name.str, fn_name.len, "all"))? (v__ast__CallKind__all) : (_SLIT_EQ(fn_name.str, fn_name.len, "pop"))? (v__ast__CallKind__pop) : (v__ast__CallKind__unknown))
		;
	}
	else if (fn_name.len == (4)) {
		_t3 = ((_SLIT_EQ(fn_name.str, fn_name.len, "wait"))? (v__ast__CallKind__wait) : (_SLIT_EQ(fn_name.str, fn_name.len, "free"))? (v__ast__CallKind__free) : (_SLIT_EQ(fn_name.str, fn_name.len, "keys"))? (v__ast__CallKind__keys) : (_SLIT_EQ(fn_name.str, fn_name.len, "sort"))? (v__ast__CallKind__sort) : (_SLIT_EQ(fn_name.str, fn_name.len, "trim"))? (v__ast__CallKind__trim) : (_SLIT_EQ(fn_name.str, fn_name.len, "last"))? (v__ast__CallKind__last) : (_SLIT_EQ(fn_name.str, fn_name.len, "drop"))? (v__ast__CallKind__drop) : (_SLIT_EQ(fn_name.str, fn_name.len, "main"))? (v__ast__CallKind__main) : (_SLIT_EQ(fn_name.str, fn_name.len, "move"))? (v__ast__CallKind__move) : (v__ast__CallKind__unknown))
		;
	}
	else if (fn_name.len == (5)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "count"))? (v__ast__CallKind__count) : (_SLIT_EQ(fn_name.str, fn_name.len, "print"))? (v__ast__CallKind__print) : (_SLIT_EQ(fn_name.str, fn_name.len, "close"))? (v__ast__CallKind__close) : (_SLIT_EQ(fn_name.str, fn_name.len, "slice"))? (v__ast__CallKind__slice) : (_SLIT_EQ(fn_name.str, fn_name.len, "clone"))? (v__ast__CallKind__clone) : (_SLIT_EQ(fn_name.str, fn_name.len, "index"))? (v__ast__CallKind__index) : (_SLIT_EQ(fn_name.str, fn_name.len, "first"))? (v__ast__CallKind__first) : (_SLIT_EQ(fn_name.str, fn_name.len, "panic"))? (v__ast__CallKind__panic) : (_SLIT_EQ(fn_name.str, fn_name.len, "clear"))? (v__ast__CallKind__clear) : (_SLIT_EQ(fn_name.str, fn_name.len, "error"))? (v__ast__CallKind__error) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (6)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "values"))? (v__ast__CallKind__values) : (_SLIT_EQ(fn_name.str, fn_name.len, "eprint"))? (v__ast__CallKind__eprint) : (_SLIT_EQ(fn_name.str, fn_name.len, "sorted"))? (v__ast__CallKind__sorted) : (_SLIT_EQ(fn_name.str, fn_name.len, "filter"))? (v__ast__CallKind__filter) : (_SLIT_EQ(fn_name.str, fn_name.len, "insert"))? (v__ast__CallKind__insert) : (_SLIT_EQ(fn_name.str, fn_name.len, "delete"))? (v__ast__CallKind__delete) : (_SLIT_EQ(fn_name.str, fn_name.len, "repeat"))? (v__ast__CallKind__repeat) : (_SLIT_EQ(fn_name.str, fn_name.len, "__addr"))? (v__ast__CallKind__addr) : (_SLIT_EQ(fn_name.str, fn_name.len, "malloc"))? (v__ast__CallKind__malloc) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (7)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "prepend"))? (v__ast__CallKind__prepend) : (_SLIT_EQ(fn_name.str, fn_name.len, "writeln"))? (v__ast__CallKind__writeln) : (_SLIT_EQ(fn_name.str, fn_name.len, "println"))? (v__ast__CallKind__println) : (_SLIT_EQ(fn_name.str, fn_name.len, "try_pop"))? (v__ast__CallKind__try_pop) : (_SLIT_EQ(fn_name.str, fn_name.len, "reverse"))? (v__ast__CallKind__reverse) : (_SLIT_EQ(fn_name.str, fn_name.len, "reserve"))? (v__ast__CallKind__reserve) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (8)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "try_push"))? (v__ast__CallKind__try_push) : (_SLIT_EQ(fn_name.str, fn_name.len, "eprintln"))? (v__ast__CallKind__eprintln) : (_SLIT_EQ(fn_name.str, fn_name.len, "pointers"))? (v__ast__CallKind__pointers) : (_SLIT_EQ(fn_name.str, fn_name.len, "contains"))? (v__ast__CallKind__contains) : (_SLIT_EQ(fn_name.str, fn_name.len, "pop_left"))? (v__ast__CallKind__pop_left) : (_SLIT_EQ(fn_name.str, fn_name.len, "type_idx"))? (v__ast__CallKind__type_idx) : (_SLIT_EQ(fn_name.str, fn_name.len, "C.va_arg"))? (v__ast__CallKind__va_arg) : (_SLIT_EQ(fn_name.str, fn_name.len, "JS.await"))? (v__ast__CallKind__jsawait) : (_SLIT_EQ(fn_name.str, fn_name.len, "grow_len"))? (v__ast__CallKind__grow_len) : (_SLIT_EQ(fn_name.str, fn_name.len, "grow_cap"))? (v__ast__CallKind__grow_cap) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (9)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "type_name"))? (v__ast__CallKind__type_name) : (_SLIT_EQ(fn_name.str, fn_name.len, "main.main"))? (v__ast__CallKind__main_main) : (_SLIT_EQ(fn_name.str, fn_name.len, "push_many"))? (v__ast__CallKind__push_many) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (10)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "last_index"))? (v__ast__CallKind__last_index) : (v__ast__CallKind__unknown));
	}
	else if (fn_name.len == (11)) {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "delete_many"))? (v__ast__CallKind__delete_many) : (_SLIT_EQ(fn_name.str, fn_name.len, "delete_last"))? (v__ast__CallKind__delete_last) : (_SLIT_EQ(fn_name.str, fn_name.len, "json.decode"))? (v__ast__CallKind__json_decode) : (_SLIT_EQ(fn_name.str, fn_name.len, "json.encode"))? (v__ast__CallKind__json_encode) : (v__ast__CallKind__unknown));
	}
	else {
		return ((_SLIT_EQ(fn_name.str, fn_name.len, "sort_with_compare"))? (v__ast__CallKind__sort_with_compare) : (_SLIT_EQ(fn_name.str, fn_name.len, "sorted_with_compare"))? (v__ast__CallKind__sorted_with_compare) : (_SLIT_EQ(fn_name.str, fn_name.len, "reverse_in_place"))? (v__ast__CallKind__reverse_in_place) : (_SLIT_EQ(fn_name.str, fn_name.len, "json.encode_pretty"))? (v__ast__CallKind__json_encode_pretty) : (_SLIT_EQ(fn_name.str, fn_name.len, "clone_to_depth"))? (v__ast__CallKind__clone_to_depth) : (v__ast__CallKind__unknown));
	}return _t3;
}
VV_LOC Array_v__ast__CallArg v__parser__Parser_call_args(v__parser__Parser* p) {
	bool prev_inside_call_args = p->inside_call_args;
	p->inside_call_args = true;
	Array_v__ast__CallArg args = builtin____new_array_with_default(0, 0, sizeof(v__ast__CallArg), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rpar)) break;
		if (p->tok.kind == v__token__Kind__eof) {
			Array_v__ast__CallArg _t1 = args;
				{ // defer begin
					p->inside_call_args = prev_inside_call_args;
				} // defer end
			return _t1;
		}
		bool is_shared = p->tok.kind == v__token__Kind__key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		v__token__Pos arg_start_pos = v__token__Token_pos(&p->tok);
		bool array_decompose = false;
		if (p->tok.kind == v__token__Kind__ellipsis) {
			v__parser__Parser_next(p);
			array_decompose = true;
		}
		v__ast__Expr expr = _const_v__ast__empty_expr;
		if (p->peek_tok.kind == v__token__Kind__colon) {
			expr = v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, _S("void_type"), v__ast__StructInitKind__short_syntax, false))), false);
		} else {
			expr = v__parser__Parser_expr(p, 0);
			if ((expr)._typ == 281 /* v.ast.Ident */) {
				if (v__parser__Parser_is_imported_symbol(p, (*expr._v__ast__Ident).name) && !(*(bool*)builtin__map_get(ADDR(map, p->imported_symbols_used), &(string[]){(*expr._v__ast__Ident).name}, &(bool[]){ 0 }))) {
					v__parser__Parser_register_used_import_for_symbol_name(p, (*(string*)builtin__map_get(ADDR(map, p->imported_symbols), &(string[]){(*expr._v__ast__Ident).name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
				}
			}
		}
		if (array_decompose) {
			expr = v__ast__ArrayDecompose_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayDecompose, (((v__ast__ArrayDecompose){.pos = v__token__Token_pos(&p->tok),.expr = expr,.expr_type = 0,.arg_type = 0,}))), false);
		}
		if ((expr)._typ == 236 /* v.ast.StructInit */) {
			_PUSH_MANY(&(*expr._v__ast__StructInit).pre_comments, (comments), _t2, Array_v__ast__Comment);
			comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		}
		v__token__Pos pos = v__token__Pos_extend(arg_start_pos, v__token__Token_pos(&p->prev_tok));
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t3, Array_v__ast__Comment);
		builtin__array_push((array*)&args, _MOV((v__ast__CallArg[]){ ((v__ast__CallArg){.comments = comments,.expr = expr,.pos = pos,.typ = 0,.share = v__ast__sharetype_from_flags(is_shared, is_atomic),.ct_expr = 0,.is_tmp_autofree = 0,.should_be_ptr = 0,.is_mut = is_mut,}) }));
		if (p->tok.kind != v__token__Kind__comma) {
			break;
		}
		v__parser__Parser_next(p);
	}
	Array_v__ast__CallArg _t5 = args;
		{ // defer begin
			p->inside_call_args = prev_inside_call_args;
		} // defer end
	return _t5;
}
VV_LOC v__ast__FnDecl v__parser__Parser_fn_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	bool is_manualfree = p->is_manualfree;
	bool is_deprecated = false;
	bool is_direct_arr = false;
	bool is_keep_alive = false;
	bool is_exported = false;
	bool is_unsafe = false;
	bool is_must_use = false;
	bool is_trusted = false;
	bool is_noreturn = false;
	bool is_ctor_new = false;
	bool is_c2v_variadic = false;
	bool is_c_extern = false;
	bool is_markused = false;
	bool is_ignore_overflow = false;
	bool is_weak = false;
	bool is_expand_simple_interpolation = false;
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_v__ast__Attr fn_attrs = p->attrs;
	p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	for (int _t1 = 0; _t1 < fn_attrs.len; ++_t1) {
		v__ast__Attr fna = ((v__ast__Attr*)fn_attrs.data)[_t1];

		if (_SLIT_EQ(fna.name.str, fna.name.len, "noreturn")) {
			is_noreturn = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "manualfree")) {
			is_manualfree = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "deprecated")) {
			is_deprecated = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "direct_array_access")) {
			if (!p->pref->force_bounds_checking) {
				is_direct_arr = true;
			}
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "keep_args_alive")) {
			is_keep_alive = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "export")) {
			is_exported = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "wasm_export")) {
			is_exported = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "unsafe")) {
			is_unsafe = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "must_use")) {
			is_must_use = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "trusted")) {
			is_trusted = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "c2v_variadic")) {
			is_c2v_variadic = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "weak")) {
			is_weak = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "use_new")) {
			is_ctor_new = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "markused")) {
			is_markused = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "ignore_overflow")) {
			is_ignore_overflow = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "c_extern")) {
			is_c_extern = true;
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "windows_stdcall")) {
			v__parser__Parser_note_with_pos(p, _S("the tag [windows_stdcall] has been deprecated, it will be an error after 2022-06-01, use `[callconv: stdcall]` instead"), v__token__Token_pos(&p->tok));
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "_fastcall")) {
			v__parser__Parser_note_with_pos(p, _S("the tag [_fastcall] has been deprecated, it will be an error after 2022-06-01, use `[callconv: fastcall]` instead"), v__token__Token_pos(&p->tok));
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "callconv")) {
			if (!fna.has_arg) {
				v__parser__Parser_error_with_pos(p, _S("callconv attribute is present but its value is missing"), v__token__Token_pos(&p->prev_tok));
			}
			if (!(builtin__fast_string_eq(fna.arg, _S("stdcall")) || builtin__fast_string_eq(fna.arg, _S("fastcall")) || builtin__fast_string_eq(fna.arg, _S("cdecl")))) {
				v__parser__Parser_error_with_pos(p, _S("unsupported calling convention, supported are stdcall, fastcall and cdecl"), v__token__Token_pos(&p->prev_tok));
			}
		}
		else if (_SLIT_EQ(fna.name.str, fna.name.len, "expand_simple_interpolation")) {
			is_expand_simple_interpolation = true;
		}
		else {
		}
	}
	_option_int _t2 = Array_v__ast__Attr_find_comptime_define(fn_attrs);
	if (_t2.state != 0) {
		*(int*) _t2.data = -1;
	}
	
 	int conditional_ctdefine_idx = (*(int*)_t2.data);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	Array_v__ast__Comment _t3; /* if prepend */
	if (p->pref->is_vls) {
		_t3 = builtin__array_clone_to_depth(&p->cur_comments, 0);
		goto _t4;
	};
	{
		_t3 = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	_t4: {};
		Array_v__ast__Comment comments_before_key_fn = _t3;
	_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t5, Array_v__ast__Comment);
	v__parser__Parser_open_scope(p);
	v__token__Pos language_tok_pos = v__token__Token_pos(&p->tok);
	v__ast__Language language = v__parser__Parser_parse_language(p);
	p->fn_language = language;
	if (language != v__ast__Language__v) {
		for (int _t6 = 0; _t6 < fn_attrs.len; ++_t6) {
			v__ast__Attr fna = ((v__ast__Attr*)fn_attrs.data)[_t6];
			if (builtin__fast_string_eq(fna.name, _S("export"))) {
				v__parser__Parser_error_with_pos(p, _S("interop function cannot be exported"), fna.pos);
				break;
			}
		}
	}
	if (is_keep_alive && language != v__ast__Language__c) {
		v__parser__Parser_error_with_pos(p, _S("attribute [keep_args_alive] is only supported for C functions"), language_tok_pos);
	}
	if (language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, language, language_tok_pos);
		if (language == v__ast__Language__c) {
			is_unsafe = !is_trusted;
		}
	}
	v__parser__ReceiverParsingInfo rec = ((v__parser__ReceiverParsingInfo){.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = _const_v__ast__void_type,.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_mut = 0,.language = language,});
	bool is_method = false;
	bool is_static_type_method = false;
	Array_v__ast__Param params = builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	if (p->tok.kind == v__token__Kind__lpar) {
		is_method = true;
		_result_void _t7 = v__parser__Parser_fn_receiver(p, &params, (voidptr)&rec);
		if (_t7.is_error) {
			v__ast__FnDecl _t8 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
				{ // defer begin
					v__parser__Parser_close_scope(p);
				} // defer end
			return _t8;
		}
		
 ;
		language = rec.language;
		p->fn_language = language;
	}
	string name = _S("");
	v__ast__TypeSymbol* type_sym = v__ast__Table_sym(p->table, rec.typ);
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	v__token__Pos static_type_pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__name || v__parser__is_ident_name(p->tok.lit)) {
		string check_name = _S("");
		is_static_type_method = p->tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) && p->peek_tok.kind == v__token__Kind__dot && language == v__ast__Language__v;
		if (is_static_type_method) {
			string type_name = p->tok.lit;
			static_type_pos = v__token__Token_pos(&p->tok);
			rec.typ = v__parser__Parser_parse_type(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
			check_name = v__parser__Parser_check_name(p);
			name = builtin__string__plus(builtin__string__plus(type_name, _S("__static__")), check_name);
			name_pos = v__token__Pos_extend(name_pos, v__token__Token_pos(&p->prev_tok));
		} else {
			check_name = (language == v__ast__Language__js ? (v__parser__Parser_check_js_name(p)) : (v__parser__Parser_check_name(p)));
			name = check_name;
		}
		if (language == v__ast__Language__v && !p->pref->translated && !p->is_translated && !p->builtin_mod && v__util__contains_capital(check_name)) {
			v__parser__Parser_error_with_pos(p, _S("function names cannot contain uppercase letters, use snake_case instead"), name_pos);
			v__ast__FnDecl _t9 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
				{ // defer begin
					v__parser__Parser_close_scope(p);
				} // defer end
			return _t9;
		}
		if (is_method) {
			bool is_duplicate = v__ast__TypeSymbol_has_method(type_sym, name);
			if (type_sym->kind == v__ast__Kind__interface && is_duplicate) {
				if ((type_sym->info)._typ == 485 /* v.ast.Interface */) {
					is_duplicate = !v__ast__Interface_has_method(&(*type_sym->info._v__ast__Interface), name);
				}
			}
			if (is_duplicate && !p->pref->is_fmt) {
				if (type_sym->kind == v__ast__Kind__enum && (_SLIT_EQ(name.str, name.len, "is_empty") || _SLIT_EQ(name.str, name.len, "has") || _SLIT_EQ(name.str, name.len, "all") || _SLIT_EQ(name.str, name.len, "set") || _SLIT_EQ(name.str, name.len, "set_all") || _SLIT_EQ(name.str, name.len, "clear") || _SLIT_EQ(name.str, name.len, "clear_all") || _SLIT_EQ(name.str, name.len, "toggle") || _SLIT_EQ(name.str, name.len, "zero") || _SLIT_EQ(name.str, name.len, "from"))) {
					_option_v__ast__Fn _t10;
					if (_t10 = v__ast__TypeSymbol_find_method(type_sym, name), _t10.state == 0) {
						v__ast__Fn enum_fn = *(v__ast__Fn*)_t10.data;
						name_pos = enum_fn.name_pos;
					}
					v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("duplicate method `"), 0xfe10, {.d_s = name}}, {_S("`, `"), 0xfe10, {.d_s = name}}, {_S("` is an enum type built-in method"), 0, { .d_c = 0 }}})), name_pos);
				} else {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicate method `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), name_pos);
				}
				v__ast__FnDecl _t11 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
					{ // defer begin
						v__parser__Parser_close_scope(p);
					} // defer end
				return _t11;
			}
		}
		if (!p->pref->is_fmt) {
			if (v__parser__Parser_is_imported_symbol(p, name)) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot redefine imported function `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), name_pos);
				v__ast__FnDecl _t12 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
					{ // defer begin
						v__parser__Parser_close_scope(p);
					} // defer end
				return _t12;
			}
		}
	} else if ((p->tok.kind == v__token__Kind__plus || p->tok.kind == v__token__Kind__minus || p->tok.kind == v__token__Kind__mul || p->tok.kind == v__token__Kind__div || p->tok.kind == v__token__Kind__mod || p->tok.kind == v__token__Kind__lt || p->tok.kind == v__token__Kind__eq) && p->peek_tok.kind == v__token__Kind__lpar) {
		name = v__token__Kind_str(p->tok.kind);
		if (rec.typ == _const_v__ast__void_type) {
			v__parser__Parser_error_with_pos(p, _S("cannot use operator overloading with normal functions"), v__token__Token_pos(&p->tok));
		}
		if (v__ast__TypeSymbol_has_method(type_sym, name)) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot duplicate operator overload `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
		}
		v__parser__Parser_next(p);
	} else if ((p->tok.kind == v__token__Kind__ne || p->tok.kind == v__token__Kind__gt || p->tok.kind == v__token__Kind__ge || p->tok.kind == v__token__Kind__le) && p->peek_tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_error_with_pos(p, _S("cannot overload `!=`, `>`, `<=` and `>=` as they are auto generated from `==` and`<`"), v__token__Token_pos(&p->tok));
	} else if (p->tok.kind == v__token__Kind__plus_assign || p->tok.kind == v__token__Kind__minus_assign || p->tok.kind == v__token__Kind__div_assign || p->tok.kind == v__token__Kind__mult_assign || p->tok.kind == v__token__Kind__mod_assign) {
		string _t13 = (string){.str=(byteptr)"", .is_lit=1};
		switch (p->tok.kind) {
			case v__token__Kind__plus_assign: {
				_t13 = _S("+");
				break;
			}
			case v__token__Kind__minus_assign: {
				_t13 = _S("-");
				break;
			}
			case v__token__Kind__div_assign: {
				_t13 = _S("/");
				break;
			}
			case v__token__Kind__mod_assign: {
				_t13 = _S("%");
				break;
			}
			case v__token__Kind__mult_assign: {
				_t13 = _S("*");
				break;
			}
			case v__token__Kind__unknown:
			case v__token__Kind__eof:
			case v__token__Kind__name:
			case v__token__Kind__number:
			case v__token__Kind__string:
			case v__token__Kind__str_inter:
			case v__token__Kind__chartoken:
			case v__token__Kind__plus:
			case v__token__Kind__minus:
			case v__token__Kind__mul:
			case v__token__Kind__div:
			case v__token__Kind__mod:
			case v__token__Kind__xor:
			case v__token__Kind__pipe:
			case v__token__Kind__inc:
			case v__token__Kind__dec:
			case v__token__Kind__and:
			case v__token__Kind__logical_or:
			case v__token__Kind__not:
			case v__token__Kind__bit_not:
			case v__token__Kind__question:
			case v__token__Kind__comma:
			case v__token__Kind__semicolon:
			case v__token__Kind__colon:
			case v__token__Kind__arrow:
			case v__token__Kind__amp:
			case v__token__Kind__hash:
			case v__token__Kind__dollar:
			case v__token__Kind__at:
			case v__token__Kind__str_dollar:
			case v__token__Kind__left_shift:
			case v__token__Kind__right_shift:
			case v__token__Kind__unsigned_right_shift:
			case v__token__Kind__not_in:
			case v__token__Kind__not_is:
			case v__token__Kind__assign:
			case v__token__Kind__decl_assign:
			case v__token__Kind__xor_assign:
			case v__token__Kind__or_assign:
			case v__token__Kind__and_assign:
			case v__token__Kind__right_shift_assign:
			case v__token__Kind__left_shift_assign:
			case v__token__Kind__unsigned_right_shift_assign:
			case v__token__Kind__boolean_and_assign:
			case v__token__Kind__boolean_or_assign:
			case v__token__Kind__lcbr:
			case v__token__Kind__rcbr:
			case v__token__Kind__lpar:
			case v__token__Kind__rpar:
			case v__token__Kind__lsbr:
			case v__token__Kind__nilsbr:
			case v__token__Kind__rsbr:
			case v__token__Kind__eq:
			case v__token__Kind__ne:
			case v__token__Kind__gt:
			case v__token__Kind__lt:
			case v__token__Kind__ge:
			case v__token__Kind__le:
			case v__token__Kind__comment:
			case v__token__Kind__nl:
			case v__token__Kind__dot:
			case v__token__Kind__dotdot:
			case v__token__Kind__ellipsis:
			case v__token__Kind__keyword_beg:
			case v__token__Kind__key_as:
			case v__token__Kind__key_asm:
			case v__token__Kind__key_assert:
			case v__token__Kind__key_atomic:
			case v__token__Kind__key_break:
			case v__token__Kind__key_const:
			case v__token__Kind__key_continue:
			case v__token__Kind__key_defer:
			case v__token__Kind__key_else:
			case v__token__Kind__key_enum:
			case v__token__Kind__key_false:
			case v__token__Kind__key_for:
			case v__token__Kind__key_fn:
			case v__token__Kind__key_global:
			case v__token__Kind__key_go:
			case v__token__Kind__key_goto:
			case v__token__Kind__key_if:
			case v__token__Kind__key_import:
			case v__token__Kind__key_in:
			case v__token__Kind__key_interface:
			case v__token__Kind__key_is:
			case v__token__Kind__key_match:
			case v__token__Kind__key_module:
			case v__token__Kind__key_mut:
			case v__token__Kind__key_nil:
			case v__token__Kind__key_shared:
			case v__token__Kind__key_lock:
			case v__token__Kind__key_rlock:
			case v__token__Kind__key_none:
			case v__token__Kind__key_return:
			case v__token__Kind__key_select:
			case v__token__Kind__key_like:
			case v__token__Kind__key_ilike:
			case v__token__Kind__key_sizeof:
			case v__token__Kind__key_isreftype:
			case v__token__Kind__key_likely:
			case v__token__Kind__key_unlikely:
			case v__token__Kind__key_offsetof:
			case v__token__Kind__key_struct:
			case v__token__Kind__key_true:
			case v__token__Kind__key_type:
			case v__token__Kind__key_typeof:
			case v__token__Kind__key_dump:
			case v__token__Kind__key_orelse:
			case v__token__Kind__key_union:
			case v__token__Kind__key_pub:
			case v__token__Kind__key_static:
			case v__token__Kind__key_volatile:
			case v__token__Kind__key_unsafe:
			case v__token__Kind__key_spawn:
			case v__token__Kind__key_implements:
			case v__token__Kind__keyword_end:
			case v__token__Kind___end_:
			default: {
				{
					_t13 = _S("unknown op");
					break;
				}
			}
		}
		string extracted_op = _t13;
		if (v__ast__TypeSymbol_has_method(type_sym, extracted_op)) {
			v__parser__Parser_error(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("cannot overload `"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_S("`, operator is implicitly overloaded because the `"), 0xfe10, {.d_s = extracted_op}}, {_S("` operator is overloaded"), 0, { .d_c = 0 }}})));
		}
		v__parser__Parser_error(p, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("cannot overload `"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_S("`, overload `"), 0xfe10, {.d_s = extracted_op}}, {_S("` and `"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_S("` will be automatically generated"), 0, { .d_c = 0 }}})));
	} else {
		v__parser__Parser_error_with_pos(p, _S("expecting method name"), v__token__Token_pos(&p->tok));
		v__ast__FnDecl _t14 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
			{ // defer begin
				v__parser__Parser_close_scope(p);
			} // defer end
		return _t14;
	}
	multi_return_Array_v__ast__Type_Array_string mr_15880 = v__parser__Parser_parse_generic_types(p);
	Array_string generic_names = mr_15880.arg1;
	if (is_method && v__ast__Type_has_flag(rec.typ, v__ast__TypeFlag__generic)) {
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, rec.typ);
		if ((sym->info)._typ == 457 /* v.ast.Struct */) {
			_result_Array_string _t15 = v__parser__Parser_types_to_names(p, (*sym->info._v__ast__Struct).generic_types, v__token__Token_pos(&p->tok), _S("sym.info.generic_types"));
			if (_t15.is_error) {
				v__ast__FnDecl _t16 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
					{ // defer begin
						v__parser__Parser_close_scope(p);
					} // defer end
				return _t16;
			}
			
 			Array_string decl_generic_names = (*(Array_string*)_t15.data);
			Array_string fn_generic_names = builtin__array_clone_to_depth(&generic_names, 1);
			generic_names = v__ast__Table_generic_type_names(p->table, rec.typ);
			if (decl_generic_names.len != generic_names.len) {
				string plural = (decl_generic_names.len == 1 ? (_S("")) : (_S("s")));
				v__parser__Parser_error_with_pos(p, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("expected "), 0xfe07, {.d_i32 = decl_generic_names.len}}, {_S(" generic parameter"), 0xfe10, {.d_s = plural}}, {_S(", got "), 0xfe07, {.d_i32 = generic_names.len}}, {_SLIT0, 0, { .d_c = 0 }}})), rec.type_pos);
			}
			for (int _t17 = 0; _t17 < fn_generic_names.len; ++_t17) {
				string gname = ((string*)fn_generic_names.data)[_t17];
				if (!(Array_string_contains(generic_names, gname))) {
					builtin__array_push((array*)&generic_names, _MOV((string[]){ builtin__string_clone(gname) }));
				}
			}
		}
	}
	if (generic_names.len > 0) {
		for (int _t19 = 0; _t19 < fn_attrs.len; ++_t19) {
			v__ast__Attr fna = ((v__ast__Attr*)fn_attrs.data)[_t19];
			if (builtin__fast_string_eq(fna.name, _S("export"))) {
				v__parser__Parser_error_with_pos(p, _S("generic functions cannot be exported"), fna.pos);
				break;
			}
		}
	}
	multi_return_Array_v__ast__Param_bool_bool_bool mr_16959 = v__parser__Parser_fn_params(p);
	Array_v__ast__Param params_t = mr_16959.arg0;
	bool are_params_type_only = mr_16959.arg1;
	bool is_variadic = mr_16959.arg2;
	bool is_c_variadic = mr_16959.arg3;
	if (is_c2v_variadic) {
		is_variadic = true;
		is_c_variadic = true;
	}
	_PUSH_MANY(&params, (params_t), _t20, Array_v__ast__Param);
	v__token__Pos return_type_pos = v__token__Token_pos(&p->tok);
	v__ast__Type return_type = _const_v__ast__void_type;
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if ((v__token__Kind_is_start_of_type(p->tok.kind) && (same_line || p->tok.kind != v__token__Kind__lsbr)) || (same_line && p->tok.kind == v__token__Kind__key_fn)) {
		if (p->tok.kind == v__token__Kind__lsbr && p->peek_tok.kind == v__token__Kind__name && p->peek_tok.lit.len == 1 && builtin__u8_is_capital(builtin__string_at(p->peek_tok.lit, 0))) {
			return_type_pos = v__token__Pos_extend(v__token__Pos_extend(return_type_pos, v__token__Token_pos(&p->peek_tok)), v__token__Token_pos(ADDR(v__token__Token, v__parser__Parser_peek_token(p, 2))));
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid generic return, use `"), 0xfe10, {.d_s = p->peek_tok.lit}}, {_S("` instead"), 0, { .d_c = 0 }}})), return_type_pos);
		}
		p->inside_fn_return = true;
		return_type = v__parser__Parser_parse_type(p);
		p->inside_fn_return = false;
		return_type_pos = v__token__Pos_extend(return_type_pos, v__token__Token_pos(&p->prev_tok));
		if (p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__not) {
			v__ast__TypeSymbol* ret_type_sym = v__ast__Table_sym(p->table, return_type);
			v__parser__Parser_error_with_pos(p, builtin__str_intp(5, _MOV((StrIntpData[]){{_S("wrong syntax, it must be "), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_SLIT0, 0xfe10, {.d_s = ret_type_sym->name}}, {_S(", not "), 0xfe10, {.d_s = ret_type_sym->name}}, {_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_SLIT0, 0, { .d_c = 0 }}})), return_type_pos);
		}
	}
	if (p->tok.kind == v__token__Kind__comma) {
		v__token__Pos mr_pos = v__token__Pos_extend(return_type_pos, v__token__Token_pos(&p->peek_tok));
		v__parser__Parser_error_with_pos(p, _S("multiple return types in function declaration must use parentheses, e.g. (int, string)"), mr_pos);
	}
	int type_sym_method_idx = 0;
	bool no_body = p->tok.kind != v__token__Kind__lcbr;
	v__token__Pos end_pos = v__token__Token_pos(&p->prev_tok);
	string short_fn_name = name;
	bool is_main = _SLIT_EQ(short_fn_name.str, short_fn_name.len, "main") && builtin__fast_string_eq(p->mod, _S("main"));
	if (is_main) {
		p->main_already_defined = true;
	}
	bool is_test = (!is_method && params.len == 0) && p->inside_test_file && (builtin__string_starts_with(short_fn_name, _S("test_")) || builtin__string_starts_with(short_fn_name, _S("testsuite_")));
	v__ast__Language file_mode = p->file_backend_mode;
	if (is_main) {
		_option_v__ast__Fn _t21;
		if (_t21 = v__ast__Table_find_fn(p->table, _S("main.main")), _t21.state == 0) {
			if ((Array_string_contains(_const_os__args, _S(".")))) {
				v__parser__Parser_error_with_pos(p, _S("multiple `main` functions detected, and you ran `v .`\nperhaps there are multiple V programs in this directory, and you need to\nrun them via `v file.v` instead"), name_pos);
			}
		}
	}
	if (is_method && is_static_type_method) {
		v__parser__Parser_error_with_pos(p, _S("cannot declare a static function as a receiver method"), name_pos);
	}
	if (!are_params_type_only) {
		for (int k = 0; k < params.len; ++k) {
			v__ast__Param param = ((v__ast__Param*)params.data)[k];
			if (v__ast__Scope_known_var(p->scope, param.name)) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of parameter `"), 0xfe10, {.d_s = param.name}}, {_S("`"), 0, { .d_c = 0 }}})), param.pos);
				v__ast__FnDecl _t22 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
					{ // defer begin
						v__parser__Parser_close_scope(p);
					} // defer end
				return _t22;
			}
			bool is_stack_obj = !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__shared_f) && (param.is_mut || v__ast__Type_is_ptr(param.typ));
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
				.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
				.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
				.name = param.name,
				.pos = param.pos,
				.typ = param.typ,
				.orig_type = 0,
				.ct_type_var = ((!is_method || k >= 0) && v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic) && !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__variadic) ? (v__ast__ComptimeVarKind__generic_param) : (v__ast__ComptimeVarKind__no_comptime)),
				.share = 0,
				.is_arg = true,
				.is_auto_deref = param.is_mut,
				.is_unwrapped = 0,
				.is_index_var = 0,
				.is_volatile = 0,
				.is_static = 0,
				.is_special = 0,
				.is_mut = param.is_mut,
				.is_used = is_pub || no_body || (is_method && k == 0) || p->builtin_mod,
				.is_changed = 0,
				.ct_type_unwrapped = 0,
				.is_or = 0,
				.is_tmp = 0,
				.is_auto_heap = 0,
				.is_stack_obj = is_stack_obj,
				.is_inherited = 0,
				.is_autofree_tmp = 0,
				.has_inherited = 0,
			}))), false));
		}
	}
	if (is_method) {
		bool is_non_local = type_sym->mod.len > 0 && !builtin__string__eq(type_sym->mod, p->mod) && type_sym->language == v__ast__Language__v;
		if (!is_non_local && !(p->builtin_mod && p->pref->is_fmt) && (type_sym->kind == v__ast__Kind__array || type_sym->kind == v__ast__Kind__map)) {
			v__ast__TypeSymbol* elem_type_sym = v__ast__Table_sym(p->table, v__ast__Table_value_type(p->table, rec.typ));
			is_non_local = elem_type_sym->mod.len > 0 && !builtin__string__eq(elem_type_sym->mod, p->mod) && elem_type_sym->language == v__ast__Language__v;
		}
		if (is_non_local && !(p->file_backend_mode == v__ast__Language__js && builtin__string_starts_with(type_sym->mod, _S("Promise")))) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("cannot define new methods on non-local type "), 0xfe10, {.d_s = type_sym->name}}, {_S(". Define an alias and use that instead like `type AliasName = "), 0xfe10, {.d_s = type_sym->name}}, {_S("` "), 0, { .d_c = 0 }}})), rec.type_pos);
			v__ast__FnDecl _t23 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
				{ // defer begin
					v__parser__Parser_close_scope(p);
				} // defer end
			return _t23;
		}
		type_sym_method_idx = v__ast__TypeSymbol_register_method(type_sym, ((v__ast__Fn){
			.params = params,
			.attrs = fn_attrs,
			.dep_names = builtin____new_array(0, 0, sizeof(string)),
			.generic_names = generic_names,
			.file = p->file_path,
			.name = name,
			.mod = p->mod,
			.source_fn = 0,
			.name_pos = name_pos,
			.pos = start_pos,
			.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.receiver_type = rec.typ,
			.usages = 0,
			.return_type = return_type,
			.from_embedded_type = 0,
			.ctdefine_idx = conditional_ctdefine_idx,
			.file_mode = file_mode,
			.language = language,
			.is_expand_simple_interpolation = is_expand_simple_interpolation,
			.is_c_variadic = 0,
			.is_pub = is_pub,
			.is_ctor_new = 0,
			.is_deprecated = is_deprecated,
			.is_noreturn = is_noreturn,
			.is_unsafe = is_unsafe,
			.is_must_use = is_must_use,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_keep_alive = is_keep_alive,
			.is_method = true,
			.is_static_type_method = 0,
			.no_body = no_body,
			.is_file_translated = 0,
			.is_conditional = conditional_ctdefine_idx != -1,
			.is_variadic = is_variadic,
		}));
	} else {
		name = ((language == (v__ast__Language__c))? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (language == (v__ast__Language__js))? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (language == (v__ast__Language__wasm))? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("WASM."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (v__parser__Parser_prepend_mod(p, name)));
		if (language == v__ast__Language__v) {
			v__ast__Fn* _t25 = (v__ast__Fn*)(builtin__map_get_check(ADDR(map, p->table->fns), &(string[]){name}));
			_option_v__ast__Fn _t24 = {0};
			if (_t25) {
				*((v__ast__Fn*)&_t24.data) = *((v__ast__Fn*)_t25);
			} else {
				_t24.state = 2; _t24.err = builtin___v_error(_S("map key does not exist"));
			}
			
			if (_t24.state == 0) {
				v__ast__Fn existing = (*(v__ast__Fn*)_t24.data);
				if ((existing.name).len != 0) {
					if (file_mode == v__ast__Language__v && existing.file_mode != v__ast__Language__v) {
						if (!p->pref->is_fmt) {
							name = v__parser__Parser_prepend_mod(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("pure_v_but_overridden_by_"), 0xfe10, {.d_s = v__ast__Language_str(existing.file_mode)}}, {_S("_"), 0xfe10, {.d_s = short_fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
						}
					} else if (!p->pref->translated) {
						builtin__array_push((array*)&p->table->redefined_fns, _MOV((string[]){ builtin__string_clone(name) }));
					}
				}
			}
		}
		v__ast__Table_register_fn(p->table, ((v__ast__Fn){
			.params = params,
			.attrs = fn_attrs,
			.dep_names = builtin____new_array(0, 0, sizeof(string)),
			.generic_names = generic_names,
			.file = p->file_path,
			.name = name,
			.mod = p->mod,
			.source_fn = 0,
			.name_pos = name_pos,
			.pos = start_pos,
			.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.receiver_type = (is_static_type_method ? (rec.typ) : (0)),
			.usages = 0,
			.return_type = return_type,
			.from_embedded_type = 0,
			.ctdefine_idx = conditional_ctdefine_idx,
			.file_mode = file_mode,
			.language = language,
			.is_expand_simple_interpolation = is_expand_simple_interpolation,
			.is_c_variadic = is_c_variadic,
			.is_pub = is_pub,
			.is_ctor_new = is_ctor_new,
			.is_deprecated = is_deprecated,
			.is_noreturn = is_noreturn,
			.is_unsafe = is_unsafe,
			.is_must_use = is_must_use,
			.is_placeholder = 0,
			.is_main = is_main,
			.is_test = is_test,
			.is_keep_alive = is_keep_alive,
			.is_method = false,
			.is_static_type_method = is_static_type_method,
			.no_body = no_body,
			.is_file_translated = p->is_translated,
			.is_conditional = conditional_ctdefine_idx != -1,
			.is_variadic = is_variadic,
		}));
	}
	string keep_fn_name = p->cur_fn_name;
	p->cur_fn_name = name;
	Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Pos body_start_pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__lcbr) {
		if (language != v__ast__Language__v && !(language == v__ast__Language__js && (type_sym->info)._typ == 485 /* v.ast.Interface */)) {
			v__parser__Parser_error_with_pos(p, _S("interop functions cannot have a body"), body_start_pos);
		}
		v__ast__Scope* last_fn_scope = p->scope;
		p->inside_fn = true;
		p->inside_unsafe_fn = is_unsafe;
		p->cur_fn_scope = p->scope;
		if (p->is_vls_skip_file) {
			v__parser__Parser_skip_scope(p);
		} else {
			stmts = v__parser__Parser_parse_block_no_scope(p, true);
		}
		p->cur_fn_scope = last_fn_scope;
		p->inside_unsafe_fn = false;
		p->inside_fn = false;
	}
	p->cur_fn_name = keep_fn_name;
	if (!no_body && are_params_type_only) {
		v__parser__Parser_error_with_pos(p, _S("functions with type only params can not have bodies"), body_start_pos);
		v__ast__FnDecl _t27 = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,});
			{ // defer begin
				v__parser__Parser_close_scope(p);
			} // defer end
		return _t27;
	}
	v__ast__FnDecl fn_decl = ((v__ast__FnDecl){
		.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = rec.name,.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = rec.pos,.type_pos = rec.type_pos,.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = rec.typ,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),
		.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.comments = comments,
		.label_names = p->label_names,
		.end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,})),
		.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.stmts = stmts,
		.params = params,
		.attrs = fn_attrs,
		.generic_names = generic_names,
		.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.name = name,
		.file = p->file_path,
		.mod = p->mod,
		.short_name = short_fn_name,
		.scope = p->scope,
		.source_file = ((void*)0),
		.receiver_pos = rec.pos,
		.static_type_pos = static_type_pos,
		.method_type_pos = rec.type_pos,
		.name_pos = name_pos,
		.body_pos = body_start_pos,
		.return_type_pos = return_type_pos,
		.pos = v__token__Pos_extend_with_last_line(start_pos, end_pos, p->prev_tok.line_nr),
		.end_pos = v__token__Token_pos(&p->tok),
		.ninstances = 0,
		.return_type = return_type,
		.idx = 0,
		.ctdefine_idx = conditional_ctdefine_idx,
		.method_idx = type_sym_method_idx,
		.kind = v__parser__Parser_call_kind(p, name),
		.language = language,
		.file_mode = 0,
		.rec_share = 0,
		.is_exported = is_exported,
		.is_keep_alive = is_keep_alive,
		.no_body = no_body,
		.is_builtin = p->builtin_mod || (Array_string_contains(_const_v__util__builtin_module_parts, p->mod)),
		.is_deprecated = is_deprecated,
		.rec_mut = rec.is_mut,
		.is_conditional = conditional_ctdefine_idx != -1,
		.is_test = is_test,
		.is_direct_arr = is_direct_arr,
		.is_main = is_main,
		.is_pub = is_pub,
		.is_c_variadic = is_c_variadic,
		.is_manualfree = is_manualfree,
		.is_noreturn = is_noreturn,
		.is_weak = is_weak,
		.is_anon = 0,
		.is_static_type_method = is_static_type_method,
		.is_expand_simple_interpolation = is_expand_simple_interpolation,
		.has_return = 0,
		.should_be_skipped = 0,
		.is_method = is_method,
		.has_await = 0,
		.is_variadic = is_variadic,
		.is_c_extern = is_c_extern,
		.is_unsafe = is_unsafe,
		.is_must_use = is_must_use,
		.is_markused = is_markused,
		.is_ignore_overflow = is_ignore_overflow,
		.is_file_translated = p->is_translated,
		.is_closure = 0,
		.has_break_line = 0,
		.has_prev_newline = 0,
	});
	if (generic_names.len > 0) {
		v__ast__Table_register_fn_generic_types(p->table, v__ast__FnDecl_fkey(&fn_decl));
	}
	p->label_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (p->pref->is_vls) {
		string type_str = ((is_method || is_static_type_method) && rec.typ != _const_v__ast__no_type ? (builtin__string_all_after_last(v__ast__Table_sym(p->table, v__ast__Type_idx_type(rec.typ))->name, _S("."))) : (_S("")));
		string key = builtin__str_intp(4, _MOV((StrIntpData[]){{_S("fn_"), 0xfe10, {.d_s = p->mod}}, {_S("["), 0xfe10, {.d_s = type_str}}, {_S("]"), 0xfe10, {.d_s = short_fn_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = fn_decl.pos,.doc = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, short_fn_name, comments_before_key_fn), v__parser__Parser_comments_to_string(p, fn_decl.end_comments)),});
		v__ast__Table_register_vls_info(p->table, key, val);
	}
	v__ast__FnDecl _t28 = fn_decl;
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t28;
}
VV_LOC _result_void v__parser__Parser_fn_receiver(v__parser__Parser* p, Array_v__ast__Param* params, v__parser__ReceiverParsingInfo* rec) {
	p->inside_receiver_param = true;
	v__token__Pos lpar_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	rec->is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
	if (rec->is_mut) {
		v__parser__Parser_next(p);
	}
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _S("sync"));
	}
	v__token__Pos rec_start_pos = v__token__Token_pos(&p->tok);
	rec->name = v__parser__Parser_check_name(p);
	if (!rec->is_mut) {
		rec->is_mut = p->tok.kind == v__token__Kind__key_mut;
		if (rec->is_mut) {
			v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
			v__parser__Parser_warn_with_pos(p, _S("use `(mut f Foo)` instead of `(f mut Foo)`"), v__token__Pos_extend(lpar_pos, v__token__Token_pos(&ptoken2)));
		}
	}
	if (p->tok.kind == v__token__Kind__key_shared) {
		v__token__Token ptoken2 = v__parser__Parser_peek_token(p, 2);
		v__parser__Parser_error_with_pos(p, _S("use `(shared f Foo)` instead of `(f shared Foo)`"), v__token__Pos_extend(lpar_pos, v__token__Token_pos(&ptoken2)));
	}
	rec->pos = v__token__Pos_extend(rec_start_pos, v__token__Token_pos(&p->tok));
	bool is_amp = p->tok.kind == v__token__Kind__amp;
	if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("JS"))) {
		rec->language = v__ast__Language__js;
	}
	rec->type_pos = v__token__Token_pos(&p->tok);
	rec->typ = v__parser__Parser_parse_type_with_mut(p, rec->is_mut);
	if (v__ast__Type_idx(rec->typ) == 0) {
		_result_void _t1 = (_result_void){ .is_error=true, .err=builtin___v_error(_S("void receiver type")), .data={E_STRUCT} };
			{ // defer begin
				p->inside_receiver_param = false;
			} // defer end
		return _t1;
	}
	rec->type_pos = v__token__Pos_extend(rec->type_pos, v__token__Token_pos(&p->prev_tok));
	if (is_amp && rec->is_mut) {
		v__parser__Parser_error_with_pos(p, _S("use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`"), v__token__Pos_extend(lpar_pos, v__token__Token_pos(&p->tok)));
		_result_void _t2 = (_result_void){ .is_error=true, .err=builtin___v_error(_S("invalid `mut f &Foo`")), .data={E_STRUCT} };
			{ // defer begin
				p->inside_receiver_param = false;
			} // defer end
		return _t2;
	}
	if (is_shared) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag__shared_f);
	}
	if (is_atomic) {
		rec->typ = v__ast__Type_set_flag(rec->typ, v__ast__TypeFlag__atomic_f);
	}
	if (rec->language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, rec->language, rec->type_pos);
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	builtin__array_push((array*)params, _MOV((v__ast__Param[]){ ((v__ast__Param){
		.name = rec->name,
		.type_pos = rec->type_pos,
		.pos = rec_start_pos,
		.typ = rec->typ,
		.is_atomic = is_atomic,
		.is_shared = is_shared,
		.is_hidden = 0,
		.on_newline = 0,
		.is_mut = rec->is_mut,
	}) }));
		{ // defer begin
			p->inside_receiver_param = false;
		} // defer end
	return (_result_void){0};
}
VV_LOC v__ast__AnonFn v__parser__Parser_anon_fn(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	if (p->tok.kind == v__token__Kind__name) {
		if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
			return ((v__ast__AnonFn){.decl = ((v__ast__FnDecl){.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.label_names = builtin____new_array(0, 0, sizeof(string)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.file = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.scope = ((void*)0),.source_file = ((void*)0),.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.ninstances = 0,.return_type = 0,.idx = 0,.ctdefine_idx = -1,.method_idx = 0,.kind = 0,.language = 0,.file_mode = 0,.rec_share = 0,.is_exported = 0,.is_keep_alive = 0,.no_body = 0,.is_builtin = 0,.is_deprecated = 0,.rec_mut = 0,.is_conditional = 0,.is_test = 0,.is_direct_arr = 0,.is_main = 0,.is_pub = 0,.is_c_variadic = 0,.is_manualfree = 0,.is_noreturn = 0,.is_weak = 0,.is_anon = 0,.is_static_type_method = 0,.is_expand_simple_interpolation = 0,.has_return = 0,.should_be_skipped = 0,.is_method = 0,.has_await = 0,.is_variadic = 0,.is_c_extern = 0,.is_unsafe = 0,.is_must_use = 0,.is_markused = 0,.is_ignore_overflow = 0,.is_file_translated = 0,.is_closure = 0,.has_break_line = 0,.has_prev_newline = 0,}),.inherited_vars = builtin____new_array(0, 0, sizeof(v__ast__Param)),.has_ct_var = 0,.typ = 0,.has_gen = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
		}
	}
	bool old_inside_defer = p->inside_defer;
	p->inside_defer = false;
	v__parser__Parser_open_scope(p);
	p->scope->detached_from_parent = true;
	Array_v__ast__Param inherited_vars = (p->tok.kind == v__token__Kind__lsbr && !(p->peek_tok.kind == v__token__Kind__name && p->peek_tok.lit.len == 1 && builtin__u8_is_capital(builtin__string_at(p->peek_tok.lit, 0))) ? (v__parser__Parser_closure_vars(p)) : (builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0)));
	Array_string _t2 = {0};
	Array_v__ast__Param _t2_orig = inherited_vars;
	int _t2_len = _t2_orig.len;
	_t2 = builtin____new_array(0, _t2_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
		v__ast__Param it = ((v__ast__Param*) _t2_orig.data)[_t4];
		string _t3 = it.name;
		builtin__array_push((array*)&_t2, &_t3);
	}
	Array_string inherited_vars_name =_t2;
	multi_return_Array_v__ast__Type_Array_string mr_30223 = v__parser__Parser_parse_generic_types(p);
	Array_string generic_names = mr_30223.arg1;
	multi_return_Array_v__ast__Param_bool_bool_bool mr_30277 = v__parser__Parser_fn_params(p);
	Array_v__ast__Param params = mr_30277.arg0;
	bool is_variadic = mr_30277.arg2;
	for (int _t5 = 0; _t5 < params.len; ++_t5) {
		v__ast__Param param = ((v__ast__Param*)params.data)[_t5];
		if ((param.name).len == 0 && v__ast__Table_sym(p->table, param.typ)->kind != v__ast__Kind__placeholder) {
			v__parser__Parser_error_with_pos(p, _S("use `_` to name an unused parameter"), param.pos);
		}
		if ((Array_string_contains(inherited_vars_name, param.name))) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the parameter name `"), 0xfe10, {.d_s = param.name}}, {_S("` conflicts with the captured value name"), 0, { .d_c = 0 }}})), param.pos);
		} else if (v__ast__Scope_known_var(p->scope, param.name)) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of parameter `"), 0xfe10, {.d_s = param.name}}, {_S("`"), 0, { .d_c = 0 }}})), param.pos);
		}
		bool is_stack_obj = !v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__shared_f) && (param.is_mut || v__ast__Type_is_ptr(param.typ));
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
			.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.name = param.name,
			.pos = param.pos,
			.typ = param.typ,
			.orig_type = 0,
			.ct_type_var = 0,
			.share = 0,
			.is_arg = true,
			.is_auto_deref = param.is_mut,
			.is_unwrapped = 0,
			.is_index_var = 0,
			.is_volatile = 0,
			.is_static = 0,
			.is_special = 0,
			.is_mut = param.is_mut,
			.is_used = true,
			.is_changed = 0,
			.ct_type_unwrapped = 0,
			.is_or = 0,
			.is_tmp = 0,
			.is_auto_heap = 0,
			.is_stack_obj = is_stack_obj,
			.is_inherited = 0,
			.is_autofree_tmp = 0,
			.has_inherited = 0,
		}))), false));
	}
	bool same_line = p->tok.line_nr == p->prev_tok.line_nr;
	v__ast__Type return_type = _const_v__ast__void_type;
	v__token__Pos return_type_pos = v__token__Token_pos(&p->tok);
	if (same_line) {
		if ((v__token__Kind_is_start_of_type(p->tok.kind) && (same_line || p->tok.kind != v__token__Kind__lsbr)) || (same_line && p->tok.kind == v__token__Kind__key_fn)) {
			p->inside_fn_return = true;
			return_type = v__parser__Parser_parse_type(p);
			p->inside_fn_return = false;
			return_type_pos = v__token__Pos_extend(return_type_pos, v__token__Token_pos(&p->tok));
		} else if (p->tok.kind != v__token__Kind__lcbr) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected return type, not "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_S(" for anonymous function"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
		}
	}
	Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	bool no_body = p->tok.kind != v__token__Kind__lcbr;
	same_line = p->tok.line_nr == p->prev_tok.line_nr;
	if (no_body && same_line) {
		v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_S(" after anonymous function signature"), 0, { .d_c = 0 }}})),.expecting = _S("`{`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
	}
	Array_string label_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	v__ast__Fn func = ((v__ast__Fn){.params = params,.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.dep_names = builtin____new_array(0, 0, sizeof(string)),.generic_names = builtin____new_array(0, 0, sizeof(string)),.file = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.source_fn = 0,.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.usages = 0,.return_type = return_type,.from_embedded_type = 0,.ctdefine_idx = 0,.file_mode = 0,.language = 0,.is_expand_simple_interpolation = 0,.is_c_variadic = 0,.is_pub = 0,.is_ctor_new = 0,.is_deprecated = 0,.is_noreturn = 0,.is_unsafe = 0,.is_must_use = 0,.is_placeholder = 0,.is_main = 0,.is_test = 0,.is_keep_alive = 0,.is_method = false,.is_static_type_method = 0,.no_body = 0,.is_file_translated = 0,.is_conditional = 0,.is_variadic = is_variadic,});
	string name = v__ast__Table_get_anon_fn_name(p->table, p->unique_prefix, (voidptr)&func, v__token__Token_pos(&p->tok));
	string keep_fn_name = p->cur_fn_name;
	p->cur_fn_name = name;
	if (p->tok.kind == v__token__Kind__lcbr) {
		Array_string tmp = p->label_names;
		p->label_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
		bool old_assign_rhs = p->inside_assign_rhs;
		p->inside_assign_rhs = false;
		stmts = v__parser__Parser_parse_block_no_scope(p, false);
		p->inside_assign_rhs = old_assign_rhs;
		label_names = builtin__array_clone_to_depth(&p->label_names, 1);
		p->label_names = tmp;
	}
	p->cur_fn_name = keep_fn_name;
	func.name = name;
	int idx = v__ast__Table_find_or_register_fn_type(p->table, func, true, false);
	v__ast__Type typ = (generic_names.len > 0 ? (v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic)) : (v__ast__new_type(idx)));
	p->inside_defer = old_inside_defer;
	v__ast__AnonFn _t6 = ((v__ast__AnonFn){.decl = ((v__ast__FnDecl){
		.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),
		.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.label_names = label_names,
		.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),
		.stmts = stmts,
		.params = params,
		.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
		.generic_names = generic_names,
		.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.name = name,
		.file = p->file_path,
		.mod = p->mod,
		.short_name = _S(""),
		.scope = p->scope,
		.source_file = ((void*)0),
		.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.return_type_pos = return_type_pos,
		.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
		.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.ninstances = 0,
		.return_type = return_type,
		.idx = 0,
		.ctdefine_idx = -1,
		.method_idx = 0,
		.kind = 0,
		.language = 0,
		.file_mode = 0,
		.rec_share = 0,
		.is_exported = 0,
		.is_keep_alive = 0,
		.no_body = no_body,
		.is_builtin = 0,
		.is_deprecated = 0,
		.rec_mut = 0,
		.is_conditional = 0,
		.is_test = 0,
		.is_direct_arr = 0,
		.is_main = 0,
		.is_pub = 0,
		.is_c_variadic = 0,
		.is_manualfree = 0,
		.is_noreturn = 0,
		.is_weak = 0,
		.is_anon = true,
		.is_static_type_method = 0,
		.is_expand_simple_interpolation = 0,
		.has_return = 0,
		.should_be_skipped = 0,
		.is_method = false,
		.has_await = 0,
		.is_variadic = is_variadic,
		.is_c_extern = 0,
		.is_unsafe = 0,
		.is_must_use = 0,
		.is_markused = 0,
		.is_ignore_overflow = 0,
		.is_file_translated = 0,
		.is_closure = inherited_vars.len > 0,
		.has_break_line = 0,
		.has_prev_newline = 0,
	}),.inherited_vars = inherited_vars,.has_ct_var = 0,.typ = typ,.has_gen = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t6;
}
VV_LOC multi_return_Array_v__ast__Param_bool_bool_bool v__parser__Parser_fn_params(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__Param params = builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
	bool is_variadic = false;
	bool is_c_variadic = false;
	string param_name = (p->tok.kind == v__token__Kind__name && p->tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) ? (v__parser__Parser_prepend_mod(p, p->tok.lit)) : (p->tok.lit));
	bool is_generic_type = p->tok.kind == v__token__Kind__name && p->tok.lit.len == 1 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0));
	bool types_only = (p->tok.kind == v__token__Kind__question || p->tok.kind == v__token__Kind__not || p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__ellipsis || p->tok.kind == v__token__Kind__key_fn || p->tok.kind == v__token__Kind__lsbr) || (p->peek_tok.kind == v__token__Kind__comma && (v__ast__Table_known_type(p->table, param_name) || is_generic_type)) || p->peek_tok.kind == v__token__Kind__dot || p->peek_tok.kind == v__token__Kind__rpar || p->fn_language == v__ast__Language__c || (p->tok.kind == v__token__Kind__key_mut && ((p->peek_tok.kind == v__token__Kind__amp || p->peek_tok.kind == v__token__Kind__ellipsis || p->peek_tok.kind == v__token__Kind__key_fn || p->peek_tok.kind == v__token__Kind__lsbr) || (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma && (p->tok.kind != v__token__Kind__key_mut || builtin__u8_is_capital(builtin__string_at(p->peek_tok.lit, 0)))) || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rpar || (p->peek_tok.kind == v__token__Kind__name && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__dot)));
	int prev_param_newline = v__token__Token_pos(&p->tok).line_nr;
	if (types_only) {
		int param_no = 1;
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rpar)) break;
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _S("expecting `)`"), v__token__Token_pos(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind__key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
			string name = _S("");
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->fn_language == v__ast__Language__c && p->tok.kind == v__token__Kind__name && !(p->peek_tok.kind == v__token__Kind__comma || p->peek_tok.kind == v__token__Kind__rpar || p->peek_tok.kind == v__token__Kind__dot)) {
				name = p->tok.lit;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
				is_c_variadic = p->tok.kind == v__token__Kind__rpar;
				if (is_c_variadic) {
					v__parser__Parser_check(p, v__token__Kind__rpar);
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=params, .arg1=types_only, .arg2=is_variadic, .arg3=is_c_variadic};
				}
			}
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__ast__Type param_type = v__parser__Parser_parse_type(p);
			v__token__Pos type_pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok));
			if (param_type == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (param_type == _const_v__ast__chan_type) {
				v__parser__Parser_chan_type_error(p);
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(param_type, v__ast__TypeFlag__generic)) {
					if (is_variadic) {
						v__parser__Parser_error_with_pos(p, _S("variadic arguments cannot be `mut`, `shared` or `atomic`"), pos);
					}
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, param_type, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, param_type, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, param_type, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _S("generic object cannot be `atomic`or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
				}
				if (v__ast__Type_is_ptr(param_type) && v__ast__Table_sym(p->table, param_type)->kind == v__ast__Kind__struct) {
					param_type = v__ast__Type_ref(param_type);
				} else {
					param_type = v__ast__Type_set_nr_muls(param_type, 1);
				}
				if (v__ast__Type_has_flag(param_type, v__ast__TypeFlag__option)) {
					param_type = v__ast__Type_set_flag(param_type, v__ast__TypeFlag__option_mut_param_t);
				}
				if (is_shared) {
					param_type = v__ast__Type_set_flag(param_type, v__ast__TypeFlag__shared_f);
				}
				if (is_atomic) {
					param_type = v__ast__Type_set_flag(param_type, v__ast__TypeFlag__atomic_f);
				}
			}
			if (is_variadic) {
				param_type = v__ast__Type_set_flag(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, param_type)), v__ast__TypeFlag__variadic);
			}
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _S("expecting `)`"), v__token__Token_pos(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (p->tok.kind == v__token__Kind__comma) {
				if (is_variadic) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot use ...(variadic) with non-final parameter no "), 0xfe07, {.d_i32 = param_no}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
				}
				v__parser__Parser_next(p);
			}
			v__ast__Language alanguage = v__ast__Table_sym(p->table, param_type)->language;
			if (alanguage != v__ast__Language__v) {
				v__parser__Parser_check_for_impure_v(p, alanguage, pos);
			}
			builtin__array_push((array*)&params, _MOV((v__ast__Param[]){ ((v__ast__Param){
				.name = name,
				.type_pos = type_pos,
				.pos = pos,
				.typ = param_type,
				.is_atomic = 0,
				.is_shared = 0,
				.is_hidden = 0,
				.on_newline = prev_param_newline != pos.line_nr,
				.is_mut = is_mut,
			}) }));
			prev_param_newline = pos.line_nr;
			param_no++;
			if (param_no > 1024) {
				v__parser__Parser_error_with_pos(p, _S("too many parameters"), pos);
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
		}
	} else {
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rpar)) break;
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _S("expecting `)`"), v__token__Token_pos(&p->tok));
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			bool is_shared = p->tok.kind == v__token__Kind__key_shared;
			bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
			bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
			if (is_mut) {
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__ellipsis && p->peek_tok.kind == v__token__Kind__rpar) {
				v__parser__Parser_check(p, v__token__Kind__ellipsis);
				v__parser__Parser_check(p, v__token__Kind__rpar);
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=params, .arg1=types_only, .arg2=true, .arg3=true};
			}
			Array_v__token__Pos param_pos = builtin__new_array_from_c_array(1, 1, sizeof(v__token__Pos), _MOV((v__token__Pos[1]){v__token__Token_pos(&p->tok)}));
			string name = v__parser__Parser_check_name(p);
			Array_string param_names = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone(name)}));
			if ((name).len != 0 && p->fn_language == v__ast__Language__v && builtin__u8_is_capital(builtin__string_at(name, 0))) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parameter name must not begin with upper case letter (`"), 0xfe10, {.d_s = (*(string*)builtin__array_get(param_names, 0))}}, {_S("`)"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->prev_tok));
			}
			Array_v__token__Pos type_pos = builtin__new_array_from_c_array(1, 1, sizeof(v__token__Pos), _MOV((v__token__Pos[1]){v__token__Token_pos(&p->tok)}));
			for (;;) {
				if (!(p->tok.kind == v__token__Kind__comma)) break;
				if (!p->pref->is_fmt) {
					v__parser__Parser_error(p, builtin__string__plus(_S("`fn f(x, y Type)` syntax has been deprecated. "), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Use `fn f(x Type, y Type)` instead. You can run `v fmt -w \""), 0xfe10, {.d_s = p->scanner->file_path}}, {_S("\"` to automatically fix your code."), 0, { .d_c = 0 }}}))));
				}
				v__parser__Parser_next(p);
				builtin__array_push((array*)&param_pos, _MOV((v__token__Pos[]){ v__token__Token_pos(&p->tok) }));
				builtin__array_push((array*)&param_names, _MOV((string[]){ v__parser__Parser_check_name(p) }));
				builtin__array_push((array*)&type_pos, _MOV((v__token__Pos[]){ v__token__Token_pos(&p->tok) }));
			}
			if (p->tok.kind == v__token__Kind__key_mut) {
				if (!p->pref->is_fmt) {
					v__parser__Parser_warn_with_pos(p, _S("use `mut f Foo` instead of `f mut Foo`"), v__token__Token_pos(&p->tok));
				}
				is_mut = true;
			}
			if (p->tok.kind == v__token__Kind__key_shared) {
				v__parser__Parser_error_with_pos(p, _S("use `shared f Foo` instead of `f shared Foo`"), v__token__Token_pos(&p->tok));
			}
			if (p->tok.kind == v__token__Kind__ellipsis) {
				v__parser__Parser_next(p);
				is_variadic = true;
				is_c_variadic = p->tok.kind == v__token__Kind__rpar;
				if (is_c_variadic) {
					v__parser__Parser_check(p, v__token__Kind__rpar);
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=params, .arg1=types_only, .arg2=is_variadic, .arg3=is_c_variadic};
				}
			}
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			builtin__array_set(&type_pos, 0, &(v__token__Pos[]) { v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)) });
			if (typ == 0) {
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (typ == _const_v__ast__chan_type) {
				v__parser__Parser_chan_type_error(p);
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (is_mut) {
				if (!v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic)) {
					if (is_variadic) {
						v__parser__Parser_error_with_pos(p, _S("variadic arguments cannot be `mut`, `shared` or `atomic`"), pos);
					}
					if (is_shared) {
						v__parser__Parser_check_fn_shared_arguments(p, typ, pos);
					} else if (is_atomic) {
						v__parser__Parser_check_fn_atomic_arguments(p, typ, pos);
					} else {
						v__parser__Parser_check_fn_mutable_arguments(p, typ, pos);
					}
				} else if (is_shared || is_atomic) {
					v__parser__Parser_error_with_pos(p, _S("generic object cannot be `atomic` or `shared`"), pos);
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
				}
				if (v__ast__Type_is_ptr(typ) && v__ast__Table_sym(p->table, typ)->kind == v__ast__Kind__struct) {
					typ = v__ast__Type_ref(typ);
				} else {
					typ = v__ast__Type_set_nr_muls(typ, 1);
				}
				if (v__ast__Type_has_flag(typ, v__ast__TypeFlag__option)) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__option_mut_param_t);
				}
				if (is_shared) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__shared_f);
				}
				if (is_atomic) {
					typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__atomic_f);
				}
			}
			if (is_variadic) {
				typ = v__ast__Type_set_flag(v__ast__Type_set_nr_muls(v__ast__Type_derive(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, typ)), typ), 0), v__ast__TypeFlag__variadic);
			}
			for (int i = 0; i < param_names.len; ++i) {
				string para_name = ((string*)param_names.data)[i];
				v__ast__Language alanguage = v__ast__Table_sym(p->table, typ)->language;
				if (alanguage != v__ast__Language__v) {
					v__parser__Parser_check_for_impure_v(p, alanguage, (*(v__token__Pos*)builtin__array_get(type_pos, i)));
				}
				builtin__array_push((array*)&params, _MOV((v__ast__Param[]){ ((v__ast__Param){
					.name = para_name,
					.type_pos = (*(v__token__Pos*)builtin__array_get(type_pos, i)),
					.pos = (*(v__token__Pos*)builtin__array_get(param_pos, i)),
					.typ = typ,
					.is_atomic = is_atomic,
					.is_shared = is_shared,
					.is_hidden = 0,
					.on_newline = prev_param_newline != (*(v__token__Pos*)builtin__array_get(param_pos, i)).line_nr,
					.is_mut = is_mut,
				}) }));
				prev_param_newline = (*(v__token__Pos*)builtin__array_get(param_pos, i)).line_nr;
				if (is_variadic && p->tok.kind == v__token__Kind__comma && p->peek_tok.kind != v__token__Kind__rpar) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot use ...(variadic) with non-final parameter "), 0xfe10, {.d_s = para_name}}, {_SLIT0, 0, { .d_c = 0 }}})), (*(v__token__Pos*)builtin__array_get(param_pos, i)));
					return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
				}
			}
			if (p->tok.kind == v__token__Kind__eof) {
				v__parser__Parser_error_with_pos(p, _S("expecting `)`"), v__token__Token_pos(&p->prev_tok));
				return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0), .arg1=false, .arg2=false, .arg3=false};
			}
			if (p->tok.kind != v__token__Kind__rpar) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			}
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	return (multi_return_Array_v__ast__Param_bool_bool_bool){.arg0=params, .arg1=types_only, .arg2=is_variadic, .arg3=is_c_variadic};
}
VV_LOC v__ast__SpawnExpr v__parser__Parser_spawn_expr(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__token__Pos spos = v__token__Token_pos(&p->tok);
	bool old_inside_assign_rhs = p->inside_assign_rhs;
	p->inside_assign_rhs = false;
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	p->inside_assign_rhs = old_inside_assign_rhs;
	v__ast__CallExpr _t1; /* if prepend */
	if ((expr)._typ == 267 /* v.ast.CallExpr */) {
		_t1 = (*expr._v__ast__CallExpr);
		goto _t2;
	};
	{
		v__parser__Parser_error_with_pos(p, _S("expression in `spawn` must be a function call"), v__ast__Expr_pos(expr));
		_t1 = ((v__ast__CallExpr){.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.const_name = (string){.str=(byteptr)"", .is_lit=1},.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.mod = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.return_type = 0,.return_type_generic = 0,.nr_ret_values = -1,.fn_var_type = 0,.left_type = 0,.receiver_concrete_type = 0,.kind = 0,.language = 0,.is_unwrapped_fn_selector = 0,.is_method = 0,.is_field = 0,.is_fn_var = 0,.is_fn_a_const = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.is_file_translated = 0,.is_static_method = 0,.is_variadic = 0,.is_c_variadic = 0,.comptime_ret_val = 0,.should_be_skipped = 0,.free_receiver = 0,.is_return_used = 0,.is_expand_simple_interpolation = 0,});
	}
	_t2: {};
		v__ast__CallExpr call_expr = _t1;
	call_expr.is_return_used = true;
	v__token__Pos pos = v__token__Pos_extend(spos, v__token__Token_pos(&p->prev_tok));
	v__parser__Parser_register_auto_import(p, _S("sync.threads"));
	p->table->gostmts++;
	return ((v__ast__SpawnExpr){.call_expr = call_expr,.pos = pos,.is_expr = 0,});
}
VV_LOC v__ast__GoExpr v__parser__Parser_go_expr(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__token__Pos spos = v__token__Token_pos(&p->tok);
	bool old_inside_assign_rhs = p->inside_assign_rhs;
	p->inside_assign_rhs = false;
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	p->inside_assign_rhs = old_inside_assign_rhs;
	v__ast__CallExpr _t1; /* if prepend */
	if ((expr)._typ == 267 /* v.ast.CallExpr */) {
		_t1 = (*expr._v__ast__CallExpr);
		goto _t2;
	};
	{
		v__parser__Parser_error_with_pos(p, _S("expression in `go` must be a function call"), v__ast__Expr_pos(expr));
		_t1 = ((v__ast__CallExpr){.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.args = builtin____new_array(0, 0, sizeof(v__ast__CallArg)),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.name = (string){.str=(byteptr)"", .is_lit=1},.const_name = (string){.str=(byteptr)"", .is_lit=1},.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.mod = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.receiver_type = 0,.return_type = 0,.return_type_generic = 0,.nr_ret_values = -1,.fn_var_type = 0,.left_type = 0,.receiver_concrete_type = 0,.kind = 0,.language = 0,.is_unwrapped_fn_selector = 0,.is_method = 0,.is_field = 0,.is_fn_var = 0,.is_fn_a_const = 0,.is_keep_alive = 0,.is_noreturn = 0,.is_ctor_new = 0,.is_file_translated = 0,.is_static_method = 0,.is_variadic = 0,.is_c_variadic = 0,.comptime_ret_val = 0,.should_be_skipped = 0,.free_receiver = 0,.is_return_used = 0,.is_expand_simple_interpolation = 0,});
	}
	_t2: {};
		v__ast__CallExpr call_expr = _t1;
	call_expr.is_return_used = true;
	v__token__Pos pos = v__token__Pos_extend(spos, v__token__Token_pos(&p->prev_tok));
	p->table->gostmts++;
	return ((v__ast__GoExpr){.call_expr = call_expr,.pos = pos,.is_expr = 0,});
}
VV_LOC Array_v__ast__Param v__parser__Parser_closure_vars(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	Array_v__ast__Param vars = builtin____new_array_with_default(0, 5, sizeof(v__ast__Param), 0);
	for (;;) {
		bool is_shared = p->tok.kind == v__token__Kind__key_shared;
		bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
		bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
		if (is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Pos var_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_check(p, v__token__Kind__name);
		string var_name = p->prev_tok.lit;
		_option_v__ast__Var_ptr _t1 = v__ast__Scope_find_var(p->scope->parent, var_name);
		if (_t1.state != 0) {
			if (v__ast__Scope_known_global(p->table->global_scope, var_name)) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("no need to capture global variable `"), 0xfe10, {.d_s = var_name}}, {_S("` in closure"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->prev_tok));
				return builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
			}
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("undefined ident: `"), 0xfe10, {.d_s = var_name}}, {_S("`"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->prev_tok));
			return builtin____new_array_with_default(0, 0, sizeof(v__ast__Param), 0);
		}
		
 		v__ast__Var* var = (*(v__ast__Var**)_t1.data);
		var->is_used = true;
		if (is_mut) {
			var->is_changed = true;
		}
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
			.smartcasts = ((*var)).smartcasts,
			.expr = ((*var)).expr,
			.name = ((*var)).name,
			.pos = var_pos,
			.typ = ((*var)).typ,
			.orig_type = ((*var)).orig_type,
			.ct_type_var = ((*var)).ct_type_var,
			.share = ((*var)).share,
			.is_arg = ((*var)).is_arg,
			.is_auto_deref = ((*var)).is_auto_deref,
			.is_unwrapped = ((*var)).is_unwrapped,
			.is_index_var = ((*var)).is_index_var,
			.is_volatile = ((*var)).is_volatile,
			.is_static = ((*var)).is_static,
			.is_special = ((*var)).is_special,
			.is_mut = is_mut,
			.is_used = false,
			.is_changed = false,
			.ct_type_unwrapped = ((*var)).ct_type_unwrapped,
			.is_or = ((*var)).is_or,
			.is_tmp = ((*var)).is_tmp,
			.is_auto_heap = ((*var)).is_auto_heap,
			.is_stack_obj = ((*var)).is_stack_obj,
			.is_inherited = true,
			.is_autofree_tmp = ((*var)).is_autofree_tmp,
			.has_inherited = var->is_inherited,
		}))), false));
		builtin__array_push((array*)&vars, _MOV((v__ast__Param[]){ ((v__ast__Param){.name = var_name,.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = var_pos,.typ = 0,.is_atomic = is_atomic,.is_shared = is_shared,.is_hidden = 0,.on_newline = 0,.is_mut = is_mut,}) }));
		if (p->tok.kind != v__token__Kind__comma) {
			break;
		}
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	return vars;
}
VV_LOC void v__parser__Parser_check_fn_mutable_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__array_fixed || sym->kind == v__ast__Kind__interface || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__placeholder || sym->kind == v__ast__Kind__struct || sym->kind == v__ast__Kind__generic_inst || sym->kind == v__ast__Kind__sum_type) {
		return;
	}
	if (v__ast__Type_is_any_kind_of_pointer(typ)) {
		return;
	}
	if (sym->kind == v__ast__Kind__alias) {
		v__ast__Type atyp = (*(v__ast__Alias*)builtin____as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 482)).parent_type;
		v__parser__Parser_check_fn_mutable_arguments(p, atyp, pos);
		return;
	}
	if (p->fn_language == v__ast__Language__c) {
		return;
	}
	v__parser__Parser_error_with_pos(p, builtin__string__plus(_S("mutable arguments are only allowed for arrays, interfaces, maps, pointers, structs or their aliases\n"), builtin__str_intp(4, _MOV((StrIntpData[]){{_S("return values instead: `fn foo(mut n "), 0xfe10, {.d_s = sym->name}}, {_S(") {` => `fn foo(n "), 0xfe10, {.d_s = sym->name}}, {_S(") "), 0xfe10, {.d_s = sym->name}}, {_S(" {`"), 0, { .d_c = 0 }}}))), pos);
}
VV_LOC void v__parser__Parser_check_fn_shared_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (sym->kind == v__ast__Kind__generic_inst) {
		sym = (*(v__ast__TypeSymbol**)builtin__array_get(p->table->type_symbols, (*(v__ast__GenericInst*)builtin____as_cast((sym->info)._v__ast__GenericInst,(sym->info)._typ, 496)).parent_idx));
	}
	if (!(sym->kind == v__ast__Kind__array || sym->kind == v__ast__Kind__struct || sym->kind == v__ast__Kind__map || sym->kind == v__ast__Kind__placeholder) && !v__ast__Type_is_ptr(typ)) {
		v__parser__Parser_error_with_pos(p, _S("shared arguments are only allowed for arrays, maps, and structs\n"), pos);
	}
}
VV_LOC void v__parser__Parser_check_fn_atomic_arguments(v__parser__Parser* p, v__ast__Type typ, v__token__Pos pos) {
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	if (!(sym->kind == v__ast__Kind__u32 || sym->kind == v__ast__Kind__int || sym->kind == v__ast__Kind__u64)) {
		v__parser__Parser_error_with_pos(p, builtin__string__plus(_S("atomic arguments are only allowed for 32/64 bit integers\n"), builtin__str_intp(3, _MOV((StrIntpData[]){{_S("use shared arguments instead: `fn foo(atomic n "), 0xfe10, {.d_s = sym->name}}, {_S(") {` => `fn foo(shared n "), 0xfe10, {.d_s = sym->name}}, {_S(") {`"), 0, { .d_c = 0 }}}))), pos);
	}
}
VV_LOC v__ast__Stmt v__parser__Parser_for_stmt(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__key_for);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_open_scope(p);
	p->inside_for = true;
	if (p->tok.kind == v__token__Kind__key_match) {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("cannot use `match` in `for` loop")))), false);
	}
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t2, Array_v__ast__Comment);
	if (p->tok.kind == v__token__Kind__lcbr) {
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForStmt for_stmt = ((v__ast__ForStmt){.is_inf = true,.pos = pos,.comments = comments,.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.stmts = stmts,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,});
		v__parser__Parser_close_scope(p);
		return v__ast__ForStmt_to_sumtype_v__ast__Stmt(&for_stmt, false);
	} else if (p->peek_tok.kind == v__token__Kind__semicolon || ((p->peek_tok.kind == v__token__Kind__inc || p->peek_tok.kind == v__token__Kind__dec) && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__semicolon || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma)) || v__token__Kind_is_assign(p->peek_tok.kind) || p->tok.kind == v__token__Kind__semicolon || (p->peek_tok.kind == v__token__Kind__comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__key_in)) {
		if (p->tok.kind == v__token__Kind__key_mut) {
			return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("`mut` is not needed in `for ;;` loops: use `for i := 0; i < n; i ++ {`")))), false);
		}
		v__ast__Stmt init = _const_v__ast__empty_stmt;
		v__ast__Expr cond = v__parser__Parser_new_true_expr(p);
		v__ast__Stmt inc = _const_v__ast__empty_stmt;
		bool has_init = false;
		bool has_cond = false;
		bool has_inc = false;
		bool is_multi = p->peek_tok.kind == v__token__Kind__comma && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__key_mut && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__key_in;
		if (v__token__Kind_is_assign(p->peek_tok.kind) || is_multi) {
			init = v__parser__Parser_assign_stmt(p);
			has_init = true;
		} else if (p->peek_tok.kind == v__token__Kind__inc || p->peek_tok.kind == v__token__Kind__dec) {
			init = v__parser__Parser_stmt(p, false);
			has_init = true;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t5, Array_v__ast__Comment);
		v__parser__Parser_check(p, v__token__Kind__semicolon);
		if (p->tok.kind != v__token__Kind__semicolon) {
			if (p->tok.kind == v__token__Kind__name && (p->peek_tok.kind == v__token__Kind__inc || p->peek_tok.kind == v__token__Kind__dec)) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("cannot use "), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT0, 0xfe10, {.d_s = v__token__Kind_str(p->peek_tok.kind)}}, {_S(" as value"), 0, { .d_c = 0 }}}))))), false);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t7, Array_v__ast__Comment);
			cond = v__parser__Parser_expr(p, 0);
			has_cond = true;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t8, Array_v__ast__Comment);
		v__parser__Parser_check(p, v__token__Kind__semicolon);
		if (!is_multi) {
			is_multi = p->peek_tok.kind == v__token__Kind__comma;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t9, Array_v__ast__Comment);
		if (p->tok.kind != v__token__Kind__lcbr) {
			inc = v__parser__Parser_stmt(p, false);
			has_inc = true;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t10, Array_v__ast__Comment);
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForCStmt for_c_stmt = ((v__ast__ForCStmt){
			.has_init = has_init,
			.has_cond = has_cond,
			.has_inc = has_inc,
			.is_multi = is_multi,
			.pos = pos,
			.comments = comments,
			.init = init,
			.cond = cond,
			.inc = inc,
			.stmts = stmts,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
		});
		v__parser__Parser_close_scope(p);
		return v__ast__ForCStmt_to_sumtype_v__ast__Stmt(&for_c_stmt, false);
	} else if ((p->peek_tok.kind == v__token__Kind__key_in || p->peek_tok.kind == v__token__Kind__comma) || (p->tok.kind == v__token__Kind__key_mut && (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__key_in || v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__comma))) {
		bool val_is_mut = p->tok.kind == v__token__Kind__key_mut;
		v__token__Pos mut_pos = v__token__Token_pos(&p->tok);
		if (val_is_mut) {
			v__parser__Parser_next(p);
		}
		v__token__Pos key_var_pos = v__token__Token_pos(&p->tok);
		v__token__Pos val_var_pos = v__token__Token_pos(&p->tok);
		string key_var_name = _S("");
		string val_var_name = v__parser__Parser_check_name(p);
		if (p->tok.kind == v__token__Kind__comma) {
			if (val_is_mut) {
				v__parser__Parser_error_with_pos(p, _S("index of array or key of map cannot be mutated"), mut_pos);
			}
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__key_mut) {
				v__parser__Parser_next(p);
				val_is_mut = true;
			}
			key_var_name = val_var_name;
			val_var_pos = v__token__Token_pos(&p->tok);
			val_var_name = v__parser__Parser_check_name(p);
			if (builtin__string__eq(key_var_name, val_var_name) && _SLIT_NE(key_var_name.str, key_var_name.len, "_")) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("key and value in a for loop cannot be the same"), val_var_pos))), false);
			}
			if (v__ast__Scope_known_var(p->scope, key_var_name)) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of key iteration variable `"), 0xfe10, {.d_s = key_var_name}}, {_S("`"), 0, { .d_c = 0 }}})), key_var_pos))), false);
			}
			if (v__ast__Scope_known_var(p->scope, val_var_name)) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of value iteration variable `"), 0xfe10, {.d_s = val_var_name}}, {_S("`"), 0, { .d_c = 0 }}})), val_var_pos))), false);
			}
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = key_var_name,.pos = key_var_pos,.typ = _const_v__ast__int_type,.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = true,.is_auto_heap = 0,.is_stack_obj = true,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
		} else if (v__ast__Scope_known_var(p->scope, val_var_name)) {
			return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("redefinition of value iteration variable `"), 0xfe10, {.d_s = val_var_name}}, {_S("`, use `for ("), 0xfe10, {.d_s = val_var_name}}, {_S(" in array) {` if you want to check for a condition instead"), 0, { .d_c = 0 }}})), val_var_pos))), false);
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t16, Array_v__ast__Comment);
		v__parser__Parser_check(p, v__token__Kind__key_in);
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t17, Array_v__ast__Comment);
		p->inside_for_expr = true;
		v__ast__Expr cond = v__parser__Parser_expr(p, 0);
		p->inside_for_expr = false;
		v__ast__Expr high_expr = _const_v__ast__empty_expr;
		bool is_range = false;
		if (p->tok.kind == v__token__Kind__ellipsis) {
			v__parser__Parser_error_with_pos(p, _S("for loop only supports exclusive (`..`) ranges, not inclusive (`...`)"), v__token__Token_pos(&p->tok));
		} else if (p->tok.kind == v__token__Kind__dotdot) {
			is_range = true;
			v__parser__Parser_next(p);
			high_expr = v__parser__Parser_expr(p, 0);
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.name = val_var_name,.pos = val_var_pos,.typ = _const_v__ast__int_type,.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = 0,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = true,.is_auto_heap = 0,.is_stack_obj = true,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
			if ((key_var_name).len != 0) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("cannot declare index variable with range `for`"), key_var_pos))), false);
			}
			if (val_is_mut) {
				return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("variable in range `for` cannot be mut"), mut_pos))), false);
			}
		} else {
			v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
				.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
				.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
				.name = val_var_name,
				.pos = val_var_pos,
				.typ = 0,
				.orig_type = 0,
				.ct_type_var = 0,
				.share = 0,
				.is_arg = 0,
				.is_auto_deref = val_is_mut,
				.is_unwrapped = 0,
				.is_index_var = 0,
				.is_volatile = 0,
				.is_static = 0,
				.is_special = 0,
				.is_mut = val_is_mut,
				.is_used = 0,
				.is_changed = 0,
				.ct_type_unwrapped = 0,
				.is_or = 0,
				.is_tmp = true,
				.is_auto_heap = 0,
				.is_stack_obj = true,
				.is_inherited = 0,
				.is_autofree_tmp = 0,
				.has_inherited = 0,
			}))), false));
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t20, Array_v__ast__Comment);
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
		v__ast__ForInStmt for_in_stmt = ((v__ast__ForInStmt){
			.stmts = stmts,
			.comments = comments,
			.cond = cond,
			.val_var = val_var_name,
			.key_var = key_var_name,
			.high = high_expr,
			.label = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
			.pos = pos,
			.kv_pos = key_var_pos,
			.vv_pos = val_var_pos,
			.val_type = 0,
			.cond_type = 0,
			.high_type = 0,
			.key_type = 0,
			.kind = 0,
			.val_is_mut = val_is_mut,
			.val_is_ref = 0,
			.is_range = is_range,
		});
		v__parser__Parser_close_scope(p);
		return v__ast__ForInStmt_to_sumtype_v__ast__Stmt(&for_in_stmt, false);
	}
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	p->inside_for = false;
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__ForStmt for_stmt = ((v__ast__ForStmt){.is_inf = 0,.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.cond = cond,.stmts = stmts,.label = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,});
	v__parser__Parser_close_scope(p);
	v__parser__Parser_close_scope(p);
	return v__ast__ForStmt_to_sumtype_v__ast__Stmt(&for_stmt, false);
}
VV_LOC v__ast__IfExpr v__parser__Parser_if_expr(v__parser__Parser* p, bool is_comptime, bool is_expr) {
	bool was_inside_if_expr = p->inside_if_expr;
	bool was_inside_ct_if_expr = p->inside_ct_if_expr;
	p->inside_if_expr = true;
	bool is_expr_ = p->prev_tok.kind == v__token__Kind__key_return || is_expr;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	if (is_comptime) {
		p->inside_ct_if_expr = true;
		v__parser__Parser_next(p);
		pos = v__token__Pos_extend(v__token__Token_pos(&p->prev_tok), v__token__Token_pos(&p->tok));
	}
	Array_v__ast__IfBranch branches = builtin____new_array_with_default(0, 0, sizeof(v__ast__IfBranch), 0);
	bool has_else = false;
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool prev_guard = false;
	bool comptime_skip_curr_stmts = false;
	bool comptime_has_true_branch = false;
	for (;;) {
		if (!((p->tok.kind == v__token__Kind__key_if || p->tok.kind == v__token__Kind__key_else))) break;
		p->inside_if = true;
		if (is_comptime) {
			p->inside_comptime_if = true;
		}
		v__token__Pos start_pos = (is_comptime ? (v__token__Pos_extend(v__token__Token_pos(&p->prev_tok), v__token__Token_pos(&p->tok))) : (v__token__Token_pos(&p->tok)));
		if (p->tok.kind == v__token__Kind__key_else) {
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t1, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind__key_else);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t2, Array_v__ast__Comment);
			if (p->tok.kind == v__token__Kind__key_match) {
				v__parser__Parser_error(p, _S("cannot use `match` with `if` statements"));
				v__ast__IfExpr _t3 = ((v__ast__IfExpr){.post_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.branches = builtin____new_array(0, 0, sizeof(v__ast__IfBranch)),.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.tok_kind = 0,.has_else = 0,.is_expr = 0,.is_comptime = 0,});
					{ // defer begin
						p->inside_if_expr = was_inside_if_expr;
						p->inside_ct_if_expr = was_inside_ct_if_expr;
					} // defer end
				return _t3;
			}
			if (p->tok.kind == v__token__Kind__lcbr) {
				has_else = true;
				p->inside_if = false;
				p->inside_comptime_if = false;
				v__token__Pos end_pos = v__token__Token_pos(&p->prev_tok);
				v__token__Pos body_pos = v__token__Token_pos(&p->tok);
				v__parser__Parser_open_scope(p);
				if (prev_guard) {
					v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
						.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
						.name = _S("err"),
						.pos = v__token__Token_pos(&p->tok),
						.typ = _const_v__ast__error_type,
						.orig_type = 0,
						.ct_type_var = 0,
						.share = 0,
						.is_arg = 0,
						.is_auto_deref = 0,
						.is_unwrapped = 0,
						.is_index_var = 0,
						.is_volatile = 0,
						.is_static = 0,
						.is_special = true,
						.is_mut = 0,
						.is_used = false,
						.is_changed = 0,
						.ct_type_unwrapped = 0,
						.is_or = 0,
						.is_tmp = 0,
						.is_auto_heap = 0,
						.is_stack_obj = true,
						.is_inherited = 0,
						.is_autofree_tmp = 0,
						.has_inherited = 0,
					}))), false));
				}
				if (is_comptime && comptime_has_true_branch && !p->pref->is_fmt && !p->pref->output_cross_c) {
					v__parser__Parser_skip_scope(p);
					builtin__array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ ((v__ast__IfBranch){.pos = v__token__Pos_extend(start_pos, end_pos),.body_pos = v__token__Pos_extend(body_pos, v__token__Token_pos(&p->tok)),.comments = comments,.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.scope = p->scope,.id = 0,}) }));
				} else {
					builtin__array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ ((v__ast__IfBranch){.pos = v__token__Pos_extend(start_pos, end_pos),.body_pos = v__token__Pos_extend(body_pos, v__token__Token_pos(&p->tok)),.comments = comments,.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.stmts = v__parser__Parser_parse_block_no_scope(p, false),.scope = p->scope,.id = 0,}) }));
				}
				v__parser__Parser_close_scope(p);
				comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
				break;
			}
			if (is_comptime) {
				v__parser__Parser_check(p, v__token__Kind__dollar);
			}
		}
		v__token__Pos if_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_check(p, v__token__Kind__key_if);
		if (p->tok.kind == v__token__Kind__key_match) {
			v__parser__Parser_error(p, _S("cannot use `match` with `if` statements"));
			v__ast__IfExpr _t6 = ((v__ast__IfExpr){.post_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.branches = builtin____new_array(0, 0, sizeof(v__ast__IfBranch)),.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.tok_kind = 0,.has_else = 0,.is_expr = 0,.is_comptime = 0,});
				{ // defer begin
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				} // defer end
			return _t6;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t7, Array_v__ast__Comment);
		v__ast__Expr cond = _const_v__ast__empty_expr;
		bool is_guard = false;
		if (!is_comptime && v__parser__Parser_peek_token_after_var_list(p).kind == v__token__Kind__decl_assign) {
			v__parser__Parser_open_scope(p);
			is_guard = true;
			Array_v__ast__IfGuardVar vars = builtin____new_array_with_default(0, 0, sizeof(v__ast__IfGuardVar), 0);
			Array_string var_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
			for (;;) {
				v__ast__IfGuardVar var = ((v__ast__IfGuardVar){.name = (string){.str=(byteptr)"", .is_lit=1},.is_mut = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),});
				bool is_mut = false;
				if (p->tok.kind == v__token__Kind__key_mut) {
					is_mut = true;
					v__parser__Parser_next(p);
				}
				var.is_mut = is_mut;
				var.pos = v__token__Token_pos(&p->tok);
				var.name = v__parser__Parser_check_name(p);
				builtin__array_push((array*)&var_names, _MOV((string[]){ builtin__string_clone(var.name) }));
				if (v__ast__Scope_known_var(p->scope, var.name)) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("redefinition of `"), 0xfe10, {.d_s = var.name}}, {_S("`"), 0, { .d_c = 0 }}})), var.pos);
				}
				builtin__array_push((array*)&vars, _MOV((v__ast__IfGuardVar[]){ var }));
				if (p->tok.kind != v__token__Kind__comma) {
					break;
				}
				v__parser__Parser_next(p);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t10, Array_v__ast__Comment);
			v__parser__Parser_check(p, v__token__Kind__decl_assign);
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t11, Array_v__ast__Comment);
			bool old_assign_rhs = p->inside_assign_rhs;
			p->inside_assign_rhs = true;
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			p->inside_assign_rhs = old_assign_rhs;
			if (!((expr)._typ == 267 /* v.ast.CallExpr */ || (expr)._typ == 284 /* v.ast.IndexExpr */ || (expr)._typ == 299 /* v.ast.PrefixExpr */ || (expr)._typ == 302 /* v.ast.SelectorExpr */ || (expr)._typ == 281 /* v.ast.Ident */)) {
				v__parser__Parser_error_with_pos(p, _S("if guard condition expression is illegal, it should return an Option"), v__ast__Expr_pos(expr));
			}
			_result_void _t12 = v__parser__Parser_check_undefined_variables(p, var_names, expr);
			if (_t12.is_error) {
				IError err = _t12.err;
				v__parser__Parser_error_with_pos(p, IError_name_table[err._typ]._method_msg(err._object), pos);
				break;
			}
			
 ;
			cond = v__ast__IfGuardExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__IfGuardExpr, (((v__ast__IfGuardExpr){.vars = vars,.expr = expr,.expr_type = 0,}))), false);
			for (int _t13 = 0; _t13 < vars.len; ++_t13) {
				v__ast__IfGuardVar var = ((v__ast__IfGuardVar*)vars.data)[_t13];
				v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = cond,.name = var.name,.pos = var.pos,.typ = 0,.orig_type = 0,.ct_type_var = 0,.share = 0,.is_arg = 0,.is_auto_deref = 0,.is_unwrapped = 0,.is_index_var = 0,.is_volatile = 0,.is_static = 0,.is_special = 0,.is_mut = var.is_mut,.is_used = 0,.is_changed = 0,.ct_type_unwrapped = 0,.is_or = 0,.is_tmp = 0,.is_auto_heap = 0,.is_stack_obj = 0,.is_inherited = 0,.is_autofree_tmp = 0,.has_inherited = 0,}))), false));
			}
			prev_guard = true;
		} else {
			prev_guard = false;
			p->comptime_if_cond = true;
			p->inside_if_cond = true;
			cond = v__parser__Parser_expr(p, 0);
			if (is_comptime && v__parser__Parser_is_in_top_level_comptime(p, p->inside_assign_rhs)) {
				comptime_skip_curr_stmts = !v__parser__Parser_comptime_if_cond(p, &cond);
				if (!comptime_skip_curr_stmts) {
					comptime_has_true_branch = true;
				}
			}
			if ((cond)._typ == 285 /* v.ast.InfixExpr */ && !is_comptime) {
				if ((*cond._v__ast__InfixExpr).op == v__token__Kind__key_is || (*cond._v__ast__InfixExpr).op == v__token__Kind__not_is) {
					if (((*cond._v__ast__InfixExpr).left)._typ == 281 /* v.ast.Ident */) {
						if ((*(*cond._v__ast__InfixExpr).left._v__ast__Ident).name.len == 1 && builtin__string_is_capital((*(*cond._v__ast__InfixExpr).left._v__ast__Ident).name) && ((*cond._v__ast__InfixExpr).right)._typ == 307 /* v.ast.TypeNode */) {
							v__parser__Parser_error_with_pos(p, _S("use `$if` instead of `if`"), if_pos);
							v__ast__IfExpr _t14 = ((v__ast__IfExpr){.post_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.branches = builtin____new_array(0, 0, sizeof(v__ast__IfBranch)),.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.tok_kind = 0,.has_else = 0,.is_expr = 0,.is_comptime = 0,});
								{ // defer begin
									p->inside_if_expr = was_inside_if_expr;
									p->inside_ct_if_expr = was_inside_ct_if_expr;
								} // defer end
							return _t14;
						}
					}
				}
			}
			p->inside_if_cond = false;
			if (p->if_cond_comments.len > 0) {
				_PUSH_MANY(&comments, (p->if_cond_comments), _t15, Array_v__ast__Comment);
				p->if_cond_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			}
			p->comptime_if_cond = false;
		}
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t16, Array_v__ast__Comment);
		v__token__Pos end_pos = v__token__Token_pos(&p->prev_tok);
		v__token__Pos body_pos = v__token__Token_pos(&p->tok);
		p->inside_if = false;
		p->inside_comptime_if = false;
		if (p->opened_scopes > p->max_opened_scopes) {
			p->should_abort = true;
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("too many nested conditionals, scopes: "), 0xfe07, {.d_i32 = p->opened_scopes}}, {_SLIT0, 0, { .d_c = 0 }}})));
			v__ast__IfExpr _t17 = ((v__ast__IfExpr){.post_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.branches = builtin____new_array(0, 0, sizeof(v__ast__IfBranch)),.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.tok_kind = 0,.has_else = 0,.is_expr = 0,.is_comptime = 0,});
				{ // defer begin
					p->inside_if_expr = was_inside_if_expr;
					p->inside_ct_if_expr = was_inside_ct_if_expr;
				} // defer end
			return _t17;
		}
		v__parser__Parser_open_scope(p);
		if (is_comptime && comptime_skip_curr_stmts && v__parser__Parser_is_in_top_level_comptime(p, p->inside_assign_rhs) && !p->pref->is_fmt && !p->pref->output_cross_c) {
			v__parser__Parser_skip_scope(p);
			builtin__array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ ((v__ast__IfBranch){.pos = v__token__Pos_extend(start_pos, end_pos),.body_pos = v__token__Pos_extend(body_pos, v__token__Token_pos(&p->prev_tok)),.comments = comments,.cond = cond,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),.scope = p->scope,.id = 0,}) }));
		} else {
			Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
			builtin__array_push((array*)&branches, _MOV((v__ast__IfBranch[]){ ((v__ast__IfBranch){
				.pos = v__token__Pos_extend(start_pos, end_pos),
				.body_pos = v__token__Pos_extend(body_pos, v__token__Token_pos(&p->prev_tok)),
				.comments = comments,
				.cond = cond,
				.stmts = stmts,
				.scope = p->scope,
				.id = 0,
			}) }));
		}
		v__parser__Parser_close_scope(p);
		if (is_guard) {
			v__parser__Parser_close_scope(p);
		}
		comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		if (is_comptime) {
			if (p->tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_error(p, _S("use `$else` instead of `else` in compile-time `if` branches"));
				v__ast__IfExpr _t20 = ((v__ast__IfExpr){.post_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.branches = builtin____new_array(0, 0, sizeof(v__ast__IfBranch)),.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.tok_kind = 0,.has_else = 0,.is_expr = 0,.is_comptime = 0,});
					{ // defer begin
						p->inside_if_expr = was_inside_if_expr;
						p->inside_ct_if_expr = was_inside_ct_if_expr;
					} // defer end
				return _t20;
			}
			if (p->tok.kind != v__token__Kind__rcbr && p->peek_tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_check(p, v__token__Kind__dollar);
			}
		}
		if (p->tok.kind != v__token__Kind__key_else) {
			break;
		}
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	if (comments.len > 0) {
		pos.last_line = (*(v__ast__Comment*)builtin__array_last(comments)).pos.last_line;
	}
	v__ast__IfExpr _t21 = ((v__ast__IfExpr){
		.post_comments = comments,
		.branches = branches,
		.left = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
		.pos = pos,
		.typ = 0,
		.tok_kind = 0,
		.has_else = has_else,
		.is_expr = is_expr_,
		.is_comptime = is_comptime,
	});
		{ // defer begin
			p->inside_if_expr = was_inside_if_expr;
			p->inside_ct_if_expr = was_inside_ct_if_expr;
		} // defer end
	return _t21;
}
VV_LOC bool v__parser__Parser_is_only_array_type(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind__lsbr) {
		for (int i = 1; i < 20; ++i) {
			if (v__parser__Parser_peek_token(p, i).kind == v__token__Kind__rsbr) {
				v__token__Kind next_kind = v__parser__Parser_peek_token(p, (int_literal)(i + 1)).kind;
				if (next_kind == v__token__Kind__name) {
					return true;
				} else if (next_kind == v__token__Kind__question && v__parser__Parser_peek_token(p, (int_literal)(i + 2)).kind == v__token__Kind__name) {
					return true;
				} else if (next_kind == v__token__Kind__lsbr) {
					continue;
				} else {
					return false;
				}
			}
		}
	}
	return false;
}
VV_LOC bool v__parser__Parser_is_match_sumtype_type(v__parser__Parser* p) {
	bool is_option = p->tok.kind == v__token__Kind__question;
	v__token__Token name_tok = (is_option ? (p->peek_tok) : (p->tok));
	v__token__Kind next_tok_kind = (is_option ? (v__parser__Parser_peek_token(p, 2).kind) : (p->peek_tok.kind));
	int next_next_idx = (is_option ? (3) : (2));
	v__token__Token next_next_tok = v__parser__Parser_peek_token(p, next_next_idx);
	return name_tok.kind == v__token__Kind__name && !(builtin__fast_string_eq(name_tok.lit, _S("C")) && next_tok_kind == v__token__Kind__dot) && (((v__token__KeywordsMatcherTrie_matches(&_const_v__ast__builtin_type_names_matcher, name_tok.lit) || builtin__u8_is_capital(builtin__string_at(name_tok.lit, 0))) && next_tok_kind != v__token__Kind__lpar && !(next_tok_kind == v__token__Kind__dot && next_next_tok.kind == v__token__Kind__name && v__parser__Parser_peek_token(p, (int)(next_next_idx + 1)).kind == v__token__Kind__lpar)) || (next_tok_kind == v__token__Kind__dot && next_next_tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(next_next_tok.lit, 0))));
}
VV_LOC _result_string v__parser__Parser_resolve_at_expr(v__parser__Parser* p, v__ast__AtExpr expr) {
	switch (expr.kind) {
		case v__token__AtKind__mod_name: {
			_result_string _t1;
			builtin___result_ok(&(string[]) { p->mod }, (_result*)(&_t1), sizeof(string));
			 
			return _t1;
		}
		case v__token__AtKind__os: {
			_result_string _t2;
			builtin___result_ok(&(string[]) { v__pref__OS_lower(v__pref__get_host_os()) }, (_result*)(&_t2), sizeof(string));
			 
			return _t2;
		}
		case v__token__AtKind__ccompiler: {
			_result_string _t3;
			builtin___result_ok(&(string[]) { v__pref__CompilerType_str(p->pref->ccompiler_type) }, (_result*)(&_t3), sizeof(string));
			 
			return _t3;
		}
		case v__token__AtKind__backend: {
			_result_string _t4;
			builtin___result_ok(&(string[]) { v__pref__Backend_str(p->pref->backend) }, (_result*)(&_t4), sizeof(string));
			 
			return _t4;
		}
		case v__token__AtKind__platform: {
			_result_string _t5;
			builtin___result_ok(&(string[]) { v__pref__Arch_str(p->pref->arch) }, (_result*)(&_t5), sizeof(string));
			 
			return _t5;
		}
		case v__token__AtKind__unknown:
		case v__token__AtKind__fn_name:
		case v__token__AtKind__method_name:
		case v__token__AtKind__struct_name:
		case v__token__AtKind__vexe_path:
		case v__token__AtKind__file_path:
		case v__token__AtKind__file_dir:
		case v__token__AtKind__line_nr:
		case v__token__AtKind__column_nr:
		case v__token__AtKind__vhash:
		case v__token__AtKind__v_current_hash:
		case v__token__AtKind__vmod_file:
		case v__token__AtKind__vmodroot_path:
		case v__token__AtKind__vmod_hash:
		case v__token__AtKind__vroot_path:
		case v__token__AtKind__vexeroot_path:
		case v__token__AtKind__file_path_line_nr:
		case v__token__AtKind__location:
		case v__token__AtKind__build_date:
		case v__token__AtKind__build_time:
		case v__token__AtKind__build_timestamp:
		default: {
			{
				return (_result_string){ .is_error=true, .err=builtin___v_error(_S("top level comptime only support `@MOD` `@OS` `@CCOMPILER` `@BACKEND` or `@PLATFORM`")), .data={E_STRUCT} };
			}
		}
	}
	
	_result_string _t7;
	builtin___result_ok(&(string[]) { _S("") }, (_result*)(&_t7), sizeof(string));
	 
	return _t7;
}
VV_LOC v__ast__MatchExpr v__parser__Parser_match_expr(v__parser__Parser* p, bool is_comptime, bool is_expr) {
	v__token__Pos match_first_pos = v__token__Token_pos(&p->tok);
	bool old_inside_ct_match = p->inside_ct_match;
	bool is_expr_ = p->prev_tok.kind == v__token__Kind__key_return || is_expr;
	if (is_comptime) {
		v__parser__Parser_next(p);
		match_first_pos = v__token__Pos_extend(v__token__Token_pos(&p->prev_tok), v__token__Token_pos(&p->tok));
		p->inside_ct_match = true;
	}
	bool old_inside_match = p->inside_match;
	p->inside_match = true;
	v__parser__Parser_check(p, v__token__Kind__key_match);
	bool is_sum_type = false;
	v__ast__Expr cond = v__parser__Parser_expr(p, 0);
	string cond_str = _S("");
	if (is_comptime && (cond)._typ == 264 /* v.ast.AtExpr */ && v__parser__Parser_is_in_top_level_comptime(p, p->inside_assign_rhs)) {
		_result_string _t1 = v__parser__Parser_resolve_at_expr(p, (*cond._v__ast__AtExpr));
		if (_t1.is_error) {
			IError err = _t1.err;
			v__parser__Parser_error(p, IError_name_table[err._typ]._method_msg(err._object));
			return ((v__ast__MatchExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__MatchBranch)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type = 0,.expected_type = 0,.cond_type = 0,.tok_kind = 0,.is_sum_type = 0,.is_expr = 0,.is_comptime = 0,});
		}
		
 		cond_str = (*(string*)_t1.data);
	}
	p->inside_match = old_inside_match;
	p->inside_ct_match = old_inside_ct_match;
	bool no_lcbr = p->tok.kind != v__token__Kind__lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	Array_v__ast__MatchBranch branches = builtin____new_array_with_default(0, 0, sizeof(v__ast__MatchBranch), 0);
	bool comptime_skip_curr_stmts = false;
	bool comptime_has_true_branch = false;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__token__Pos branch_first_pos = v__token__Token_pos(&p->tok);
		Array_v__ast__Expr exprs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
		Array_Array_v__ast__Comment ecmnts = builtin____new_array_with_default(0, 0, sizeof(Array_v__ast__Comment), 0);
		bool is_else = false;
		if (is_comptime) {
			if (p->tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_error(p, _S("use `$else` instead of `else` in compile-time `match` branches"));
				return ((v__ast__MatchExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__MatchBranch)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type = 0,.expected_type = 0,.cond_type = 0,.tok_kind = 0,.is_sum_type = 0,.is_expr = 0,.is_comptime = 0,});
			}
			if (p->tok.kind != v__token__Kind__rcbr && p->peek_tok.kind == v__token__Kind__key_else) {
				v__parser__Parser_check(p, v__token__Kind__dollar);
			}
		}
		if (p->tok.kind == v__token__Kind__key_else) {
			is_else = true;
			v__parser__Parser_next(p);
		} else if (v__parser__Parser_is_match_sumtype_type(p) || v__parser__Parser_is_only_array_type(p) || p->tok.kind == v__token__Kind__key_fn || (p->tok.kind == v__token__Kind__lsbr && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__amp)) {
			Array_v__ast__Type types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
			for (;;) {
				v__ast__Type parsed_type = v__parser__Parser_parse_type(p);
				builtin__array_push((array*)&types, _MOV((v__ast__Type[]){ parsed_type }));
				builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, (((v__ast__TypeNode){.pos = v__token__Token_pos(&p->prev_tok),.typ = parsed_type,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}))), false) }));
				if (p->tok.kind != v__token__Kind__comma) {
					builtin__array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
					break;
				}
				v__parser__Parser_check(p, v__token__Kind__comma);
				if (p->pref->is_fmt) {
					if (p->tok.kind == v__token__Kind__lcbr) {
						break;
					}
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comma)) break;
						v__parser__Parser_next(p);
					}
					builtin__array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
				}
			}
			is_sum_type = true;
		} else {
			if (p->tok.kind == v__token__Kind__rcbr) {
				v__parser__Parser_next(p);
				return ((v__ast__MatchExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__MatchBranch)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = match_first_pos,.return_type = 0,.expected_type = 0,.cond_type = 0,.tok_kind = 0,.is_sum_type = 0,.is_expr = 0,.is_comptime = 0,});
			}
			for (;;) {
				if (is_comptime) {
					p->inside_ct_match_case = true;
				}
				p->inside_match_case = true;
				v__token__Pos range_pos = v__token__Token_pos(&p->tok);
				string case_str = _S("");
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				p->inside_match_case = false;
				p->inside_ct_match_case = false;
				if (expr._typ == 237 /* v.ast.StringLiteral */) {
					case_str = (*expr._v__ast__StringLiteral).val;
				}
				else if (expr._typ == 286 /* v.ast.IntegerLiteral */) {
					case_str = builtin__string_str((*expr._v__ast__IntegerLiteral).val);
				}
				else if (expr._typ == 265 /* v.ast.BoolLiteral */) {
					case_str = builtin__bool_str((*expr._v__ast__BoolLiteral).val);
				}
				
				else {
				}
				
				comptime_skip_curr_stmts = !builtin__string__eq(cond_str, case_str);
				if (!comptime_skip_curr_stmts) {
					comptime_has_true_branch = true;
				}
				if (p->tok.kind == v__token__Kind__dotdot) {
					v__parser__Parser_error_with_pos(p, _S("match only supports inclusive (`...`) ranges, not exclusive (`..`)"), v__token__Token_pos(&p->tok));
					return ((v__ast__MatchExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__MatchBranch)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.cond = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.return_type = 0,.expected_type = 0,.cond_type = 0,.tok_kind = 0,.is_sum_type = 0,.is_expr = 0,.is_comptime = 0,});
				} else if (p->tok.kind == v__token__Kind__ellipsis) {
					v__parser__Parser_next(p);
					if (is_comptime) {
						p->inside_ct_match_case = true;
					}
					p->inside_match_case = true;
					v__ast__Expr expr2 = v__parser__Parser_expr(p, 0);
					p->inside_match_case = false;
					p->inside_ct_match_case = false;
					builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){.low = expr,.high = expr2,.pos = v__token__Pos_extend(range_pos, v__token__Token_pos(&p->prev_tok)),.typ = 0,.has_high = true,.has_low = true,.is_gated = 0,}))), false) }));
				} else {
					builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ expr }));
				}
				if (p->tok.kind != v__token__Kind__comma) {
					builtin__array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
					break;
				}
				v__parser__Parser_check(p, v__token__Kind__comma);
				if (p->pref->is_fmt) {
					if (p->tok.kind == v__token__Kind__lcbr) {
						break;
					}
					for (;;) {
						if (!(p->tok.kind == v__token__Kind__comma)) break;
						v__parser__Parser_next(p);
					}
					builtin__array_push((array*)&ecmnts, _MOV((Array_v__ast__Comment[]){ v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,})) }));
				}
			}
		}
		v__token__Pos branch_last_pos = v__token__Token_pos(&p->prev_tok);
		if (is_comptime) {
			p->inside_ct_match_body = true;
		}
		p->inside_match_body = true;
		v__parser__Parser_open_scope(p);
		Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		if (is_comptime && ((!is_else && comptime_skip_curr_stmts) || (is_else && comptime_has_true_branch)) && v__parser__Parser_is_in_top_level_comptime(p, p->inside_assign_rhs) && !p->pref->is_fmt && !p->pref->output_cross_c) {
			v__parser__Parser_skip_scope(p);
		} else {
			stmts = v__parser__Parser_parse_block_no_scope(p, false);
		}
		v__ast__Scope* branch_scope = p->scope;
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		p->inside_ct_match_body = false;
		v__token__Pos pos = v__token__Pos_extend_with_last_line(branch_first_pos, branch_last_pos, p->prev_tok.line_nr);
		v__token__Pos branch_pos = v__token__Pos_extend_with_last_line(branch_first_pos, v__token__Token_pos(&p->tok), p->tok.line_nr);
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		builtin__array_push((array*)&branches, _MOV((v__ast__MatchBranch[]){ ((v__ast__MatchBranch){
			.ecmnts = ecmnts,
			.pos = pos,
			.is_else = is_else,
			.post_comments = post_comments,
			.branch_pos = branch_pos,
			.stmts = stmts,
			.exprs = exprs,
			.scope = branch_scope,
			.id = 0,
			.is_comptime_err = 0,
		}) }));
		if (p->tok.kind == v__token__Kind__rcbr || (is_else && no_lcbr)) {
			break;
		}
	}
	v__token__Pos match_last_pos = v__token__Token_pos(&p->tok);
	v__token__Pos pos = ((v__token__Pos){.len = (int)((int)(match_last_pos.pos - match_first_pos.pos) + match_last_pos.len),.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.file_idx = -1,.last_line = 0,});
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	return ((v__ast__MatchExpr){
		.branches = branches,
		.comments = comments,
		.cond = cond,
		.pos = pos,
		.return_type = 0,
		.expected_type = 0,
		.cond_type = 0,
		.tok_kind = 0,
		.is_sum_type = is_sum_type,
		.is_expr = is_expr_,
		.is_comptime = is_comptime,
	});
}
VV_LOC v__ast__SelectExpr v__parser__Parser_select_expr(v__parser__Parser* p) {
	v__token__Pos match_first_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_select);
	bool no_lcbr = p->tok.kind != v__token__Kind__lcbr;
	if (!no_lcbr) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__SelectBranch branches = builtin____new_array_with_default(0, 0, sizeof(v__ast__SelectBranch), 0);
	bool has_else = false;
	bool has_timeout = false;
	for (;;) {
		v__token__Pos branch_first_pos = v__token__Token_pos(&p->tok);
		v__ast__Comment comment = v__parser__Parser_check_comment(p);
		v__parser__Parser_open_scope(p);
		bool is_else = false;
		bool is_timeout = false;
		v__ast__Stmt stmt = _const_v__ast__empty_stmt;
		if (p->tok.kind == v__token__Kind__key_else) {
			if (has_timeout) {
				v__parser__Parser_error_with_pos(p, _S("timeout `> t` and `else` are mutually exclusive `select` keys"), v__token__Token_pos(&p->tok));
				return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
			}
			if (has_else) {
				v__parser__Parser_error_with_pos(p, _S("at most one `else` branch allowed in `select` block"), v__token__Token_pos(&p->tok));
				return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
			}
			is_else = true;
			has_else = true;
			v__parser__Parser_next(p);
		} else {
			bool is_gt = false;
			if (p->tok.kind == v__token__Kind__gt) {
				is_gt = true;
				v__parser__Parser_note_with_pos(p, _S("`>` is deprecated and will soon be forbidden - just state the timeout in nanoseconds"), v__token__Token_pos(&p->tok));
				v__parser__Parser_next(p);
			}
			p->inside_match = true;
			p->inside_select = true;
			Array_v__ast__Expr exprs = v__parser__Parser_expr_list(p, true);
			if (exprs.len != 1) {
				v__parser__Parser_error(p, _S("only one expression allowed as `select` key"));
				return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
			}
			if (p->tok.kind == v__token__Kind__assign || p->tok.kind == v__token__Kind__decl_assign) {
				stmt = v__parser__Parser_partial_assign_stmt(p, exprs);
			} else {
				stmt = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = v__ast__Expr_pos((*(v__ast__Expr*)builtin__array_get(exprs, 0))),.comments = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){comment})),.expr = (*(v__ast__Expr*)builtin__array_get(exprs, 0)),.is_expr = true,.typ = 0,}))), false);
			}
			p->inside_match = false;
			p->inside_select = false;
			if (stmt._typ == 321 /* v.ast.ExprStmt */) {
				bool check_timeout = false;
				if (!(*stmt._v__ast__ExprStmt).is_expr) {
					v__parser__Parser_error_with_pos(p, _S("select: invalid expression"), (*stmt._v__ast__ExprStmt).pos);
					return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
				} else {
					if ((*stmt._v__ast__ExprStmt).expr._typ == 285 /* v.ast.InfixExpr */) {
						if ((*(*stmt._v__ast__ExprStmt).expr._v__ast__InfixExpr).op != v__token__Kind__arrow) {
							check_timeout = true;
						} else if (is_gt) {
							v__parser__Parser_error_with_pos(p, _S("send expression cannot be used as timeout"), (*stmt._v__ast__ExprStmt).pos);
						}
					}
					
					else {
						check_timeout = true;
					}
					
				}
				if (check_timeout) {
					if (has_else) {
						v__parser__Parser_error_with_pos(p, _S("`else` and timeout value are mutually exclusive `select` keys"), (*stmt._v__ast__ExprStmt).pos);
						return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
					}
					if (has_timeout) {
						v__parser__Parser_error_with_pos(p, _S("at most one timeout branch allowed in `select` block"), (*stmt._v__ast__ExprStmt).pos);
						return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
					}
					is_timeout = true;
					has_timeout = true;
				}
			}
			else if (stmt._typ == 313 /* v.ast.AssignStmt */) {
				v__ast__Expr expr = (*(v__ast__Expr*)builtin__array_get((*stmt._v__ast__AssignStmt).right, 0));
				if (expr._typ == 299 /* v.ast.PrefixExpr */) {
					if ((*expr._v__ast__PrefixExpr).op != v__token__Kind__arrow) {
						v__parser__Parser_error_with_pos(p, _S("select key: `<-` operator expected"), (*expr._v__ast__PrefixExpr).pos);
						return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
					}
				}
				
				else {
					v__parser__Parser_error_with_pos(p, _S("select key: receive expression expected"), v__ast__Expr_pos((*(v__ast__Expr*)builtin__array_get((*stmt._v__ast__AssignStmt).right, 0))));
					return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
				}
				
			}
			
			else {
				v__parser__Parser_error_with_pos(p, _S("select: transmission statement, timeout (in ns) or `else` expected"), (*(stmt.pos)));
				return ((v__ast__SelectExpr){.branches = builtin____new_array(0, 0, sizeof(v__ast__SelectBranch)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.has_exception = 0,.is_expr = 0,.expected_type = 0,});
			}
			
		}
		v__token__Pos branch_last_pos = v__token__Token_pos(&p->tok);
		p->inside_match_body = true;
		p->inside_for = false;
		Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
		v__ast__Scope* branch_scope = p->scope;
		v__parser__Parser_close_scope(p);
		p->inside_match_body = false;
		v__token__Pos pos = ((v__token__Pos){.len = (int)((int)(branch_last_pos.pos - branch_first_pos.pos) + branch_last_pos.len),.line_nr = branch_first_pos.line_nr,.pos = branch_first_pos.pos,.col = branch_first_pos.col,.file_idx = -1,.last_line = 0,});
		Array_v__ast__Comment post_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
		if (post_comments.len > 0) {
			pos.last_line = (*(v__ast__Comment*)builtin__array_last(post_comments)).pos.last_line;
		}
		builtin__array_push((array*)&branches, _MOV((v__ast__SelectBranch[]){ ((v__ast__SelectBranch){
			.comment = comment,
			.stmts = stmts,
			.post_comments = post_comments,
			.stmt = stmt,
			.scope = branch_scope,
			.pos = pos,
			.is_timeout = is_timeout,
			.is_else = is_else,
		}) }));
		if (p->tok.kind == v__token__Kind__rcbr || ((is_else || is_timeout) && no_lcbr)) {
			break;
		}
	}
	v__token__Pos match_last_pos = v__token__Token_pos(&p->tok);
	v__token__Pos pos = ((v__token__Pos){.len = (int)((int)(match_last_pos.pos - match_first_pos.pos) + match_last_pos.len),.line_nr = match_first_pos.line_nr,.pos = match_first_pos.pos,.col = match_first_pos.col,.file_idx = -1,.last_line = 0,});
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	v__parser__Parser_register_auto_import(p, _S("sync"));
	return ((v__ast__SelectExpr){.branches = branches,.pos = v__token__Pos_extend_with_last_line(pos, v__token__Token_pos(&p->prev_tok), p->prev_tok.line_nr),.has_exception = has_else || has_timeout,.is_expr = 0,.expected_type = 0,});
}
VV_LOC bool v__parser__Parser_comptime_if_cond(v__parser__Parser* p, v__ast__Expr* cond) {
	bool is_true = false;
	if (cond->_typ == 265 /* v.ast.BoolLiteral */) {
		return (*cond->_v__ast__BoolLiteral).val;
	}
	else if (cond->_typ == 297 /* v.ast.ParExpr */) {
		return v__parser__Parser_comptime_if_cond(p, &(*cond->_v__ast__ParExpr).expr);
	}
	else if (cond->_typ == 299 /* v.ast.PrefixExpr */) {
		if ((*cond->_v__ast__PrefixExpr).op != v__token__Kind__not) {
			v__parser__Parser_error(p, _S("invalid $if prefix operator, only allow `!`."));
			return false;
		}
		return !v__parser__Parser_comptime_if_cond(p, &(*cond->_v__ast__PrefixExpr).right);
	}
	else if (cond->_typ == 298 /* v.ast.PostfixExpr */) {
		if ((*cond->_v__ast__PostfixExpr).op != v__token__Kind__question) {
			v__parser__Parser_error(p, _S("invalid $if postfix operator, only allow `?`."));
			return false;
		}
		if (((*cond->_v__ast__PostfixExpr).expr)._typ != 281 /* v.ast.Ident */) {
			v__parser__Parser_error(p, _S("invalid $if postfix condition, only allow `Indent`."));
			return false;
		}
		string cname = (*(v__ast__Ident*)builtin____as_cast(((*cond->_v__ast__PostfixExpr).expr)._v__ast__Ident,((*cond->_v__ast__PostfixExpr).expr)._typ, 281)).name;
		return (Array_string_contains(p->pref->compile_defines, cname));
	}
	else if (cond->_typ == 285 /* v.ast.InfixExpr */) {

		if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__and) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__logical_or)) {
			bool l = v__parser__Parser_comptime_if_cond(p, &(*cond->_v__ast__InfixExpr).left);
			bool r = v__parser__Parser_comptime_if_cond(p, &(*cond->_v__ast__InfixExpr).right);
			return ((*cond->_v__ast__InfixExpr).op == v__token__Kind__and ? (l && r) : (l || r));
		}
		else if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__eq) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__ne) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__gt) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__lt) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__ge) || (*cond->_v__ast__InfixExpr).op == (v__token__Kind__le)) {
			if ((*cond->_v__ast__InfixExpr).left._typ == 264 /* v.ast.AtExpr */) {
				_result_string _t9 = v__parser__Parser_resolve_at_expr(p, (*(*cond->_v__ast__InfixExpr).left._v__ast__AtExpr));
				if (_t9.is_error) {
					IError err = _t9.err;
					v__parser__Parser_error(p, IError_name_table[err._typ]._method_msg(err._object));
					return false;
				}
				
 				string left_str = (*(string*)_t9.data);
				if (((*cond->_v__ast__InfixExpr).right)._typ != 237 /* v.ast.StringLiteral */) {
					v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = v__ast__AtExpr_str((*(*cond->_v__ast__InfixExpr).left._v__ast__AtExpr))}}, {_S(" can only compare with string type"), 0, { .d_c = 0 }}})));
					return false;
				}
				string right_str = (*(v__ast__StringLiteral*)builtin____as_cast(((*cond->_v__ast__InfixExpr).right)._v__ast__StringLiteral,((*cond->_v__ast__InfixExpr).right)._typ, 237)).val;
				if ((*cond->_v__ast__InfixExpr).op == v__token__Kind__eq) {
					is_true = builtin__string__eq(left_str, right_str);
				} else if ((*cond->_v__ast__InfixExpr).op == v__token__Kind__ne) {
					is_true = !builtin__string__eq(left_str, right_str);
				} else {
					v__parser__Parser_error(p, _S("string type only support `==` and `!=` operator"));
					return false;
				}
				return is_true;
			}
			else if ((*cond->_v__ast__InfixExpr).left._typ == 281 /* v.ast.Ident */) {
				if ((*cond->_v__ast__InfixExpr).right._typ == 237 /* v.ast.StringLiteral */) {

					if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__eq)) {
						is_true = builtin__string__eq(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident)), v__ast__StringLiteral_str((*(*cond->_v__ast__InfixExpr).right._v__ast__StringLiteral)));
					}
					else if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__ne)) {
						is_true = !builtin__string__eq(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident)), v__ast__StringLiteral_str((*(*cond->_v__ast__InfixExpr).right._v__ast__StringLiteral)));
					}
					else {
						v__parser__Parser_error(p, _S("string type only support `==` and `!=` operator"));
						return false;
					}
				}
				else if ((*cond->_v__ast__InfixExpr).right._typ == 286 /* v.ast.IntegerLiteral */) {
					switch ((*cond->_v__ast__InfixExpr).op) {
						case v__token__Kind__eq: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) == builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__ne: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) != builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__gt: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) > builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__lt: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) < builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__ge: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) >= builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__le: {
							is_true = builtin__string_i64(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) <= builtin__string_i64((*(*cond->_v__ast__InfixExpr).right._v__ast__IntegerLiteral).val);
							break;
						}
						case v__token__Kind__unknown:
						case v__token__Kind__eof:
						case v__token__Kind__name:
						case v__token__Kind__number:
						case v__token__Kind__string:
						case v__token__Kind__str_inter:
						case v__token__Kind__chartoken:
						case v__token__Kind__plus:
						case v__token__Kind__minus:
						case v__token__Kind__mul:
						case v__token__Kind__div:
						case v__token__Kind__mod:
						case v__token__Kind__xor:
						case v__token__Kind__pipe:
						case v__token__Kind__inc:
						case v__token__Kind__dec:
						case v__token__Kind__and:
						case v__token__Kind__logical_or:
						case v__token__Kind__not:
						case v__token__Kind__bit_not:
						case v__token__Kind__question:
						case v__token__Kind__comma:
						case v__token__Kind__semicolon:
						case v__token__Kind__colon:
						case v__token__Kind__arrow:
						case v__token__Kind__amp:
						case v__token__Kind__hash:
						case v__token__Kind__dollar:
						case v__token__Kind__at:
						case v__token__Kind__str_dollar:
						case v__token__Kind__left_shift:
						case v__token__Kind__right_shift:
						case v__token__Kind__unsigned_right_shift:
						case v__token__Kind__not_in:
						case v__token__Kind__not_is:
						case v__token__Kind__assign:
						case v__token__Kind__decl_assign:
						case v__token__Kind__plus_assign:
						case v__token__Kind__minus_assign:
						case v__token__Kind__div_assign:
						case v__token__Kind__mult_assign:
						case v__token__Kind__xor_assign:
						case v__token__Kind__mod_assign:
						case v__token__Kind__or_assign:
						case v__token__Kind__and_assign:
						case v__token__Kind__right_shift_assign:
						case v__token__Kind__left_shift_assign:
						case v__token__Kind__unsigned_right_shift_assign:
						case v__token__Kind__boolean_and_assign:
						case v__token__Kind__boolean_or_assign:
						case v__token__Kind__lcbr:
						case v__token__Kind__rcbr:
						case v__token__Kind__lpar:
						case v__token__Kind__rpar:
						case v__token__Kind__lsbr:
						case v__token__Kind__nilsbr:
						case v__token__Kind__rsbr:
						case v__token__Kind__comment:
						case v__token__Kind__nl:
						case v__token__Kind__dot:
						case v__token__Kind__dotdot:
						case v__token__Kind__ellipsis:
						case v__token__Kind__keyword_beg:
						case v__token__Kind__key_as:
						case v__token__Kind__key_asm:
						case v__token__Kind__key_assert:
						case v__token__Kind__key_atomic:
						case v__token__Kind__key_break:
						case v__token__Kind__key_const:
						case v__token__Kind__key_continue:
						case v__token__Kind__key_defer:
						case v__token__Kind__key_else:
						case v__token__Kind__key_enum:
						case v__token__Kind__key_false:
						case v__token__Kind__key_for:
						case v__token__Kind__key_fn:
						case v__token__Kind__key_global:
						case v__token__Kind__key_go:
						case v__token__Kind__key_goto:
						case v__token__Kind__key_if:
						case v__token__Kind__key_import:
						case v__token__Kind__key_in:
						case v__token__Kind__key_interface:
						case v__token__Kind__key_is:
						case v__token__Kind__key_match:
						case v__token__Kind__key_module:
						case v__token__Kind__key_mut:
						case v__token__Kind__key_nil:
						case v__token__Kind__key_shared:
						case v__token__Kind__key_lock:
						case v__token__Kind__key_rlock:
						case v__token__Kind__key_none:
						case v__token__Kind__key_return:
						case v__token__Kind__key_select:
						case v__token__Kind__key_like:
						case v__token__Kind__key_ilike:
						case v__token__Kind__key_sizeof:
						case v__token__Kind__key_isreftype:
						case v__token__Kind__key_likely:
						case v__token__Kind__key_unlikely:
						case v__token__Kind__key_offsetof:
						case v__token__Kind__key_struct:
						case v__token__Kind__key_true:
						case v__token__Kind__key_type:
						case v__token__Kind__key_typeof:
						case v__token__Kind__key_dump:
						case v__token__Kind__key_orelse:
						case v__token__Kind__key_union:
						case v__token__Kind__key_pub:
						case v__token__Kind__key_static:
						case v__token__Kind__key_volatile:
						case v__token__Kind__key_unsafe:
						case v__token__Kind__key_spawn:
						case v__token__Kind__key_implements:
						case v__token__Kind__keyword_end:
						case v__token__Kind___end_:
						default: {
							{
								v__parser__Parser_error(p, _S("int type only support `==` `!=` `>` `<` `>=` and `<=` operator"));
								return false;
							}
						}
					}
					
				}
				else if ((*cond->_v__ast__InfixExpr).right._typ == 265 /* v.ast.BoolLiteral */) {

					if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__eq)) {
						is_true = builtin__string_bool(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) == (*(*cond->_v__ast__InfixExpr).right._v__ast__BoolLiteral).val;
					}
					else if ((*cond->_v__ast__InfixExpr).op == (v__token__Kind__ne)) {
						is_true = builtin__string_bool(v__ast__Ident_str((*(*cond->_v__ast__InfixExpr).left._v__ast__Ident))) != (*(*cond->_v__ast__InfixExpr).right._v__ast__BoolLiteral).val;
					}
					else {
						v__parser__Parser_error(p, _S("bool type only support `==` and `!=` operator"));
						return false;
					}
				}
				
				else {
					v__parser__Parser_error(p, _S("compare only support string int and bool type"));
					return false;
				}
				
				return is_true;
			}
			
			else {
				v__parser__Parser_error(p, _S("invalid $if condition"));
				return false;
			}
			
			v__parser__Parser_error(p, _S("invalid $if condition"));
			return false;
		}
		else {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if operator: "), 0xfe10, {.d_s = v__token__Kind_str((*cond->_v__ast__InfixExpr).op)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return false;
		}
	}
	else if (cond->_typ == 281 /* v.ast.Ident */) {
		string cname = (*cond->_v__ast__Ident).name;
		if ((Array_string_contains(_const_v__ast__valid_comptime_not_user_defined, cname))) {
			if (_SLIT_EQ(cname.str, cname.len, "threads")) {
				is_true = p->table->gostmts > 0;
			} else {
				_result_bool _t22 = v__ast__eval_comptime_not_user_defined_ident(cname, p->pref);
				if (_t22.is_error) {
					IError err = _t22.err;
					v__parser__Parser_error(p, IError_name_table[err._typ]._method_msg(err._object));
					return false;
				}
				
 				is_true = (*(bool*)_t22.data);
			}
		} else {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition: unknown indent `"), 0xfe10, {.d_s = cname}}, {_S("`"), 0, { .d_c = 0 }}})));
			return false;
		}
		return is_true;
	}
	else if (cond->_typ == 272 /* v.ast.ComptimeCall */) {
		if ((*cond->_v__ast__ComptimeCall).kind == v__ast__ComptimeCallKind__pkgconfig) {
			_result_v__pkgconfig__Main_ptr _t26;
			if (_t26 = v__pkgconfig__main(builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone((*cond->_v__ast__ComptimeCall).args_var)}))), !_t26.is_error) {
				v__pkgconfig__Main* m = *(v__pkgconfig__Main**)_t26.data;
				_result_string _t27;
				if (_t27 = v__pkgconfig__Main_run(m), !_t27.is_error) {
					is_true = true;
				} else {
					is_true = false;
				}
			} else {
				IError err = _t26.err;
				v__parser__Parser_error(p, IError_name_table[err._typ]._method_msg(err._object));
				is_true = false;
			}
			return is_true;
		}
		if ((*cond->_v__ast__ComptimeCall).kind == v__ast__ComptimeCallKind__d) {
			is_true = builtin__string_bool((*cond->_v__ast__ComptimeCall).compile_value);
			return is_true;
		}
		v__parser__Parser_error(p, _S("invalid $if condition: unknown ComptimeCall"));
		return false;
	}
	
	else {
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid $if condition "), 0xfe10, {.d_s = v__ast__Expr_str(*cond)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return false;
	}
	
	return is_true;
}
VV_LOC v__ast__LockExpr v__parser__Parser_lock_expr(v__parser__Parser* p) {
	v__parser__Parser_register_auto_import(p, _S("sync"));
	v__parser__Parser_open_scope(p);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Expr lockeds = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_bool is_rlocked = builtin____new_array_with_default(0, 0, sizeof(bool), 0);
	for (;;) {
		bool is_rlock = p->tok.kind == v__token__Kind__key_rlock;
		if (!is_rlock && p->tok.kind != v__token__Kind__key_lock) {
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("one or more shared variable names"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
		}
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind__lcbr) {
			break;
		}
		if (p->tok.kind == v__token__Kind__name) {
			p->inside_lock_exprs = true;
			Array_v__ast__Expr exprs = v__parser__Parser_expr_list(p, true);
			p->inside_lock_exprs = false;
			for (int _t1 = 0; _t1 < exprs.len; ++_t1) {
				v__ast__Expr e = ((v__ast__Expr*)exprs.data)[_t1];
				if (!v__ast__Expr_is_lockable(&e)) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = v__ast__Expr_str(e)}}, {_S("` cannot be locked - only `x`, `x.y` or `x.$(y)` are supported"), 0, { .d_c = 0 }}})), v__ast__Expr_pos(e));
				}
				builtin__array_push((array*)&lockeds, _MOV((v__ast__Expr[]){ e }));
				builtin__array_push((array*)&is_rlocked, _MOV((bool[]){ is_rlock }));
			}
		}
		if (p->tok.kind == v__token__Kind__lcbr) {
			break;
		}
		if (p->tok.kind == v__token__Kind__semicolon) {
			v__parser__Parser_next(p);
		}
	}
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__ast__Scope* scope = p->scope;
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	v__ast__LockExpr _t4 = ((v__ast__LockExpr){.is_rlock = is_rlocked,.pos = pos,.stmts = stmts,.lockeds = lockeds,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.is_expr = 0,.typ = 0,.scope = scope,});
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t4;
}
VV_LOC void v__parser__Parser_language_not_allowed_error(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos) {
	string upcase_language = builtin__string_to_upper_ascii(v__ast__Language_str(language));
	v__parser__Parser_error_with_pos(p, builtin__str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = upcase_language}}, {_S(" code is not allowed in ."), 0xfe10, {.d_s = v__ast__Language_str(p->file_backend_mode)}}, {_S(".v files, please move it to a ."), 0xfe10, {.d_s = v__ast__Language_str(language)}}, {_S(".v file"), 0, { .d_c = 0 }}})), pos);
}
VV_LOC void v__parser__Parser_language_not_allowed_warning(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos) {
	string upcase_language = builtin__string_to_upper_ascii(v__ast__Language_str(language));
	v__parser__Parser_warn_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = upcase_language}}, {_S(" code will not be allowed in pure .v files, please move it to a ."), 0xfe10, {.d_s = v__ast__Language_str(language)}}, {_S(".v file instead"), 0, { .d_c = 0 }}})), pos);
}
VV_LOC void v__parser__Parser_check_for_impure_v(v__parser__Parser* p, v__ast__Language language, v__token__Pos pos) {
	if (language == v__ast__Language__v) {
		return;
	} else {

		if (p->file_backend_mode == (v__ast__Language__c)) {
			if (language != v__ast__Language__c) {
				v__parser__Parser_language_not_allowed_error(p, language, pos);
				return;
			}
		}
		else if (p->file_backend_mode == (v__ast__Language__js)) {
			if (language != v__ast__Language__js) {
				v__parser__Parser_language_not_allowed_error(p, language, pos);
				return;
			}
		}
		else {
		}
	}
	if (!p->pref->warn_impure_v) {
		return;
	}
	if (p->file_backend_mode != language) {
		if (p->file_backend_mode == v__ast__Language__v) {
			if (p->pref->is_bare) {
				return;
			}
			v__parser__Parser_language_not_allowed_warning(p, language, pos);
			return;
		}
	}
}
VV_LOC v__ast__NodeError v__parser__Parser_error(v__parser__Parser* p, string s) {
	return v__parser__Parser_error_with_pos(p, s, v__token__Token_pos(&p->tok));
}
VV_LOC void v__parser__Parser_warn(v__parser__Parser* p, string s) {
	v__parser__Parser_warn_with_pos(p, s, v__token__Token_pos(&p->tok));
}
VV_LOC v__ast__NodeError v__parser__Parser_error_with_pos(v__parser__Parser* p, string s, v__token__Pos pos) {
	string kind = _S("error:");
	string file_path = (pos.file_idx < 0 ? (p->file_path) : ((*(string*)builtin__array_get(p->table->filelist, pos.file_idx))));
	if (p->pref->fatal_errors) {
		v__util__show_compiler_message(kind, ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
		builtin___v_exit(1);
		VUNREACHABLE();
	}
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only && !p->is_vls) {
		if (p->pref->is_verbose) {
			builtin__print_backtrace();
			kind = _S("parser error:");
		}
		v__util__show_compiler_message(kind, ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
		builtin___v_exit(1);
		VUNREACHABLE();
	} else {
		builtin__array_push((array*)&p->errors, _MOV((v__errors__Error[]){ ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
		if (p->pref->check_only || p->pref->only_check_syntax) {
			if (p->tok.kind != v__token__Kind__eof) {
				v__parser__Parser_next(p);
			}
		}
	}
	if (p->pref->output_mode == v__pref__OutputMode__silent && p->tok.kind != v__token__Kind__eof) {
		v__parser__Parser_next(p);
	}
	return ((v__ast__NodeError){.idx = (int)(p->errors.len - 1),.pos = pos,});
}
VV_LOC void v__parser__Parser_error_with_error(v__parser__Parser* p, v__errors__Error __v_error) {
	string kind = _S("error:");
	if (p->pref->fatal_errors) {
		v__util__show_compiler_message(kind, __v_error.CompilerMessage);
		builtin___v_exit(1);
		VUNREACHABLE();
	}
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		if (p->pref->is_verbose) {
			builtin__print_backtrace();
			kind = _S("parser error:");
		}
		v__util__show_compiler_message(kind, __v_error.CompilerMessage);
		builtin___v_exit(1);
		VUNREACHABLE();
	} else {
		if (p->pref->message_limit >= 0 && p->errors.len >= p->pref->message_limit) {
			p->should_abort = true;
			return;
		}
		builtin__array_push((array*)&p->errors, _MOV((v__errors__Error[]){ __v_error }));
	}
	if (p->pref->output_mode == v__pref__OutputMode__silent) {
		v__parser__Parser_next(p);
	}
}
VV_LOC void v__parser__Parser_warn_with_pos(v__parser__Parser* p, string s, v__token__Pos pos) {
	if (p->pref->warns_are_errors) {
		v__parser__Parser_error_with_pos(p, s, pos);
		return;
	}
	if (p->pref->skip_warnings) {
		return;
	}
	string file_path = (pos.file_idx < 0 ? (p->file_path) : ((*(string*)builtin__array_get(p->table->filelist, pos.file_idx))));
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		v__util__show_compiler_message(_S("warning:"), ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
	} else {
		if (p->pref->message_limit >= 0 && p->warnings.len >= p->pref->message_limit) {
			p->should_abort = true;
			return;
		}
		builtin__array_push((array*)&p->warnings, _MOV((v__errors__Warning[]){ ((v__errors__Warning){.CompilerMessage = ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
	}
}
VV_LOC void v__parser__Parser_note_with_pos(v__parser__Parser* p, string s, v__token__Pos pos) {
	if (p->pref->skip_warnings) {
		return;
	}
	if (p->pref->skip_notes) {
		return;
	}
	if (p->is_generated) {
		return;
	}
	if (p->pref->notes_are_errors) {
		v__parser__Parser_error_with_pos(p, s, pos);
		return;
	}
	string file_path = (pos.file_idx < 0 ? (p->file_path) : ((*(string*)builtin__array_get(p->table->filelist, pos.file_idx))));
	if (p->pref->output_mode == v__pref__OutputMode__stdout && !p->pref->check_only) {
		v__util__show_compiler_message(_S("notice:"), ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = 0,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}));
	} else {
		builtin__array_push((array*)&p->notices, _MOV((v__errors__Notice[]){ ((v__errors__Notice){.CompilerMessage = ((v__errors__CompilerMessage){.message = s,.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = file_path,.pos = pos,.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}) }));
	}
}
VV_LOC v__ast__NodeError v__parser__Parser_unexpected(v__parser__Parser* p, v__parser__ParamsForUnexpected params) {
	return v__parser__Parser_unexpected_with_pos(p, v__token__Token_pos(&p->tok), params);
}
VV_LOC v__ast__NodeError v__parser__Parser_unexpected_with_pos(v__parser__Parser* p, v__token__Pos pos, v__parser__ParamsForUnexpected params) {
	string msg = ((params.got).len != 0 ? (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unexpected "), 0xfe10, {.d_s = params.got}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unexpected "), 0xfe10, {.d_s = v__token__Token_str(p->tok)}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	if ((params.expecting).len != 0) {
		msg = builtin__string__plus(msg, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(", expecting "), 0xfe10, {.d_s = params.expecting}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	if ((params.prepend_msg).len != 0) {
		msg = builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = params.prepend_msg}}, {_S(" "), 0, { .d_c = 0 }}})), msg);
	}
	if ((params.additional_msg).len != 0) {
		msg = builtin__string__plus(msg, builtin__str_intp(2, _MOV((StrIntpData[]){{_S(", "), 0xfe10, {.d_s = params.additional_msg}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	return v__parser__Parser_error_with_pos(p, msg, pos);
}
VV_LOC void v__parser__Parser_chan_type_error(v__parser__Parser* p) {
	v__parser__Parser_error_with_pos(p, _S("`chan` has no type specified. Use `chan Type` instead of `chan`"), v__token__Token_pos(&p->prev_tok));
}
VV_LOC bool v__parser__Parser_known_import(v__parser__Parser* p, string mod) {
	return _IN_MAP(ADDR(string, mod), ADDR(map, p->imports));
}
VV_LOC string v__parser__Parser_prepend_mod(v__parser__Parser* p, string name) {
	if ((p->expr_mod).len != 0) {
		return builtin__string__plus(builtin__string__plus(p->expr_mod, _S(".")), name);
	}
	if (p->builtin_mod) {
		return name;
	}
	return builtin__string__plus(builtin__string__plus(p->mod, _S(".")), name);
}
VV_LOC bool v__parser__Parser_is_used_import(v__parser__Parser* p, string alias) {
	return (Array_string_contains(p->used_imports, alias));
}
VV_LOC void v__parser__Parser_register_used_import(v__parser__Parser* p, string alias) {
	if (!v__parser__Parser_is_used_import(p, alias)) {
		builtin__array_push((array*)&p->used_imports, _MOV((string[]){ builtin__string_clone(alias) }));
	}
}
VV_LOC void v__parser__Parser_register_used_import_for_symbol_name(v__parser__Parser* p, string sym_name) {
	string short_import_name = builtin__string_all_after_last(builtin__string_all_before_last(sym_name, _S(".")), _S("."));
	string short_symbol_name = builtin__string_all_after_last(sym_name, _S("."));
	if (v__parser__Parser_is_imported_symbol(p, short_symbol_name)) {
		builtin__map_set(&p->imported_symbols_used, &(string[]){short_symbol_name}, &(bool[]) { true });
	}
	Map_string_string _t1 = p->imports;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!builtin__DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string alias = *(string*)builtin__DenseArray_key(&_t1.key_values, _t2);
		alias = builtin__string_clone(alias);
		string mod = (*(string*)builtin__DenseArray_value(&_t1.key_values, _t2));
		if (builtin__string__eq(mod, short_import_name)) {
			v__parser__Parser_register_used_import(p, alias);
			return;
		}
	}
	v__parser__Parser_register_used_import(p, short_import_name);
}
VV_LOC void v__parser__Parser_register_auto_import(v__parser__Parser* p, string alias) {
	if (builtin__string__eq(p->mod, alias)) {
		return;
	}
	if (!_IN_MAP(ADDR(string, alias), ADDR(map, p->imports))) {
		builtin__map_set(&p->imports, &(string[]){alias}, &(string[]) { alias });
		builtin__array_push((array*)&p->table->imports, _MOV((string[]){ builtin__string_clone(alias) }));
		v__ast__Import node = ((v__ast__Import){.source_name = alias,.mod = alias,.alias = alias,.pos = v__token__Token_pos(&p->tok),.mod_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.alias_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		builtin__array_push((array*)&p->ast_imports, _MOV((v__ast__Import[]){ node }));
	}
	if (!(Array_string_contains(p->auto_imports, alias))) {
		builtin__array_push((array*)&p->auto_imports, _MOV((string[]){ builtin__string_clone(alias) }));
	}
}
VV_LOC void v__parser__Parser_register_implied_import(v__parser__Parser* p, string alias) {
	if (!(Array_string_contains(p->implied_imports, alias))) {
		builtin__array_push((array*)&p->implied_imports, _MOV((string[]){ builtin__string_clone(alias) }));
	}
}
VV_LOC void v__parser__Parser_check_unused_imports(v__parser__Parser* p) {
	if (p->pref->is_repl || p->pref->is_fmt) {
		return;
	}
	for (int _t1 = 0; _t1 < p->ast_imports.len; ++_t1) {
		v__ast__Import import_m = ((v__ast__Import*)p->ast_imports.data)[_t1];
		string alias = import_m.alias;
		string mod = import_m.mod;
		if (!(alias.len == 1 && builtin__string_at(alias, 0) == '_') && !v__parser__Parser_is_used_import(p, alias) && !(Array_string_contains(p->auto_imports, alias))) {
			string mod_alias = (builtin__string__eq(alias, mod) ? (alias) : (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = alias}}, {_S(" ("), 0xfe10, {.d_s = mod}}, {_S(")"), 0, { .d_c = 0 }}}))));
			v__parser__Parser_warn_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("module '"), 0xfe10, {.d_s = mod_alias}}, {_S("' is imported but never used. Use `import "), 0xfe10, {.d_s = mod_alias}}, {_S(" as _`, to silence this warning, or just remove the unused import line"), 0, { .d_c = 0 }}})), import_m.mod_pos);
		}
	}
}
VV_LOC v__ast__Module v__parser__Parser_module_decl(v__parser__Parser* p) {
	Array_v__ast__Attr module_attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__token__Pos attrs_pos = v__token__Token_pos(&p->tok);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__lsbr || p->tok.kind == v__token__Kind__at)) break;
		v__parser__Parser_attributes(p);
	}
	_PUSH_MANY(&module_attrs, (p->attrs), _t1, Array_v__ast__Attr);
	string name = _S("main");
	v__token__Pos module_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	v__token__Pos name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	v__ast__Module mod_node = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,});
	bool is_skipped = p->tok.kind != v__token__Kind__key_module;
	if (is_skipped) {
		module_attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	} else {
		p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		module_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_next(p);
		name_pos = v__token__Token_pos(&p->tok);
		name = v__parser__Parser_check_name(p);
		mod_node = ((v__ast__Module){.name = (string){.str=(byteptr)"", .is_lit=1},.short_name = (string){.str=(byteptr)"", .is_lit=1},.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pos = module_pos,.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_skipped = 0,});
		if (module_pos.line_nr != name_pos.line_nr) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`module` and `"), 0xfe10, {.d_s = name}}, {_S("` must be at same line"), 0, { .d_c = 0 }}})), name_pos);
			return mod_node;
		}
		v__token__Pos n_pos = v__token__Token_pos(&p->tok);
		if (module_pos.line_nr == n_pos.line_nr && !(p->tok.kind == v__token__Kind__comment || p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__semicolon)) {
			if (p->tok.kind == v__token__Kind__name) {
				v__parser__Parser_unexpected_with_pos(p, n_pos, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`"), 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`module "), 0xfe10, {.d_s = name}}, {_S("`, you can only declare one module,"), 0, { .d_c = 0 }}})),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
				return mod_node;
			} else {
				v__parser__Parser_unexpected_with_pos(p, n_pos, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = v__token__Kind_str(p->tok.kind)}}, {_S("` after module name"), 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`module "), 0xfe10, {.d_s = name}}, {_S("`,"), 0, { .d_c = 0 }}})),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
				return mod_node;
			}
		}
		module_pos = v__token__Pos_extend(attrs_pos, name_pos);
	}
	string full_name = v__util__qualify_module(p->pref, name, p->file_path);
	p->mod = full_name;
	p->builtin_mod = builtin__fast_string_eq(p->mod, _S("builtin"));
	mod_node = ((v__ast__Module){
		.name = full_name,
		.short_name = name,
		.attrs = module_attrs,
		.pos = module_pos,
		.name_pos = name_pos,
		.is_skipped = is_skipped,
	});
	if (p->tok.kind == v__token__Kind__semicolon) {
		v__parser__Parser_check(p, v__token__Kind__semicolon);
	}
	if (!is_skipped) {
		(*(Array_v__ast__Attr*)builtin__map_get_and_set((map*)&p->table->module_attrs, &(string[]){p->mod}, &(Array_v__ast__Attr[]){ builtin____new_array(0, 0, sizeof(v__ast__Attr)) })) = module_attrs;
		for (int _t5 = 0; _t5 < module_attrs.len; ++_t5) {
			v__ast__Attr ma = ((v__ast__Attr*)module_attrs.data)[_t5];

			if (_SLIT_EQ(ma.name.str, ma.name.len, "deprecated") || _SLIT_EQ(ma.name.str, ma.name.len, "deprecated_after")) {
				builtin__map_set(&p->table->module_deprecated, &(string[]){p->mod}, &(bool[]) { true });
			}
			else if (_SLIT_EQ(ma.name.str, ma.name.len, "manualfree")) {
				p->is_manualfree = true;
			}
			else if (_SLIT_EQ(ma.name.str, ma.name.len, "generated")) {
				p->is_generated = true;
			}
			else if (_SLIT_EQ(ma.name.str, ma.name.len, "has_globals")) {
				p->has_globals = true;
			}
			else if (_SLIT_EQ(ma.name.str, ma.name.len, "translated")) {
				p->is_translated = true;
			}
			else if (_SLIT_EQ(ma.name.str, ma.name.len, "wasm_import_namespace")) {
				if (!p->pref->is_fmt && p->pref->backend != v__pref__Backend__wasm) {
					v__parser__Parser_note_with_pos(p, _S("@[wasm_import_namespace] is only supported by the wasm backend"), ma.pos);
				}
			}
			else {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown module attribute `["), 0xfe10, {.d_s = ma.name}}, {_S("]`"), 0, { .d_c = 0 }}})), ma.pos);
				return mod_node;
			}
		}
	}
	return mod_node;
}
VV_LOC v__ast__Import v__parser__Parser_import_stmt(v__parser__Parser* p) {
	v__token__Pos import_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_import);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__ast__Import import_node = ((v__ast__Import){.source_name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(import_pos, pos),.mod_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.alias_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_error_with_pos(p, _S("`import()` has been deprecated, use `import x` instead"), pos);
		return import_node;
	}
	string source_name = v__parser__Parser_check_name(p);
	if ((source_name).len == 0) {
		v__parser__Parser_error_with_pos(p, _S("import name can not be empty"), pos);
		return import_node;
	}
	Array_string mod_name_arr = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__array_push((array*)&mod_name_arr, _MOV((string[]){ builtin__string_clone(source_name) }));
	if (import_pos.line_nr != pos.line_nr) {
		v__parser__Parser_error_with_pos(p, _S("`import` statements must be a single line"), pos);
		return import_node;
	}
	string mod_alias = (*(string*)builtin__array_get(mod_name_arr, 0));
	import_node = ((v__ast__Import){.source_name = source_name,.mod = (string){.str=(byteptr)"", .is_lit=1},.alias = (string){.str=(byteptr)"", .is_lit=1},.pos = v__token__Pos_extend(import_pos, pos),.mod_pos = pos,.alias_pos = pos,.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__dot)) break;
		v__parser__Parser_next(p);
		v__token__Pos submod_pos = v__token__Token_pos(&p->tok);
		if (p->tok.kind != v__token__Kind__name) {
			v__parser__Parser_error_with_pos(p, _S("module syntax error, please use `x.y.z`"), submod_pos);
			return import_node;
		}
		if (import_pos.line_nr != submod_pos.line_nr) {
			v__parser__Parser_error_with_pos(p, _S("`import` and `submodule` must be at same line"), submod_pos);
			return import_node;
		}
		string submod_name = v__parser__Parser_check_name(p);
		builtin__array_push((array*)&mod_name_arr, _MOV((string[]){ builtin__string_clone(submod_name) }));
		mod_alias = submod_name;
		pos = v__token__Pos_extend(pos, submod_pos);
		source_name = Array_string_join(mod_name_arr, _S("."));
		import_node = ((v__ast__Import){
			.source_name = source_name,
			.mod = v__util__qualify_import(p->pref, source_name, p->file_path),
			.alias = mod_alias,
			.pos = v__token__Pos_extend(import_pos, pos),
			.mod_pos = pos,
			.alias_pos = submod_pos,
			.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),
			.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		});
	}
	if (mod_name_arr.len == 1) {
		import_node = ((v__ast__Import){
			.source_name = source_name,
			.mod = v__util__qualify_import(p->pref, (*(string*)builtin__array_get(mod_name_arr, 0)), p->file_path),
			.alias = mod_alias,
			.pos = import_node.pos,
			.mod_pos = import_node.mod_pos,
			.alias_pos = import_node.alias_pos,
			.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),
			.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		});
	}
	string mod_name = import_node.mod;
	if (p->tok.kind == v__token__Kind__key_as) {
		v__parser__Parser_next(p);
		v__token__Pos alias_pos = v__token__Token_pos(&p->tok);
		mod_alias = v__parser__Parser_check_name(p);
		if (builtin__string__eq(mod_alias, (*(string*)builtin__array_last(mod_name_arr)))) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("import alias `"), 0xfe10, {.d_s = mod_name}}, {_S(" as "), 0xfe10, {.d_s = mod_alias}}, {_S("` is redundant"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->prev_tok));
			return import_node;
		}
		import_node = ((v__ast__Import){
			.source_name = source_name,
			.mod = import_node.mod,
			.alias = mod_alias,
			.pos = v__token__Pos_extend(import_node.pos, alias_pos),
			.mod_pos = import_node.mod_pos,
			.alias_pos = alias_pos,
			.syms_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.syms = builtin____new_array(0, 0, sizeof(v__ast__ImportSymbol)),
			.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		});
	}
	if (p->tok.kind == v__token__Kind__lcbr) {
		v__token__Pos initial_syms_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_import_syms(p, (voidptr)&import_node);
		initial_syms_pos = v__token__Pos_extend(initial_syms_pos, v__token__Token_pos(&p->tok));
		import_node = ((v__ast__Import){.source_name = source_name,.mod = (import_node).mod,.alias = (import_node).alias,.pos = v__token__Pos_extend(import_node.pos, initial_syms_pos),.mod_pos = (import_node).mod_pos,.alias_pos = (import_node).alias_pos,.syms_pos = initial_syms_pos,.syms = (import_node).syms,.comments = (import_node).comments,.next_comments = (import_node).next_comments,});
	}
	v__token__Pos pos_t = v__token__Token_pos(&p->tok);
	if (import_pos.line_nr == pos_t.line_nr) {
		if (!(p->tok.kind == v__token__Kind__lcbr || p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__comment || p->tok.kind == v__token__Kind__semicolon || p->tok.kind == v__token__Kind__key_import)) {
			v__parser__Parser_error_with_pos(p, _S("cannot import multiple modules at a time"), pos_t);
			return import_node;
		}
	}
	import_node.comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
	import_node.next_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}));
	builtin__map_set(&p->imports, &(string[]){mod_alias}, &(string[]) { mod_name });
	if (p->tok.kind == v__token__Kind__semicolon) {
		v__parser__Parser_check(p, v__token__Kind__semicolon);
	}
	builtin__array_push((array*)&p->table->imports, _MOV((string[]){ builtin__string_clone(mod_name) }));
	builtin__array_push((array*)&p->ast_imports, _MOV((v__ast__Import[]){ import_node }));
	return import_node;
}
VV_LOC void v__parser__Parser_import_syms(v__parser__Parser* p, v__ast__Import* parent) {
	v__parser__Parser_next(p);
	v__token__Pos pos_t = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("empty `"), 0xfe10, {.d_s = parent->mod}}, {_S("` import set, remove `{}`"), 0, { .d_c = 0 }}})), pos_t);
		return;
	}
	if (p->tok.kind != v__token__Kind__name) {
		v__parser__Parser_error_with_pos(p, _S("import syntax error, please specify a valid fn or type name"), pos_t);
		return;
	}
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__name)) break;
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		string alias = v__parser__Parser_check_name(p);
		if (v__parser__Parser_is_imported_symbol(p, alias)) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register symbol `"), 0xfe10, {.d_s = alias}}, {_S("`, it was already imported"), 0, { .d_c = 0 }}})), pos);
			return;
		}
		builtin__map_set(&p->imported_symbols, &(string[]){alias}, &(string[]) { builtin__string__plus(builtin__string__plus(parent->mod, _S(".")), alias) });
		v__parser__Parser_rebuild_imported_symbols_matcher(p, alias);
		builtin__array_push((array*)&parent->syms, _MOV((v__ast__ImportSymbol[]){ ((v__ast__ImportSymbol){.pos = pos,.name = alias,}) }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
			continue;
		}
		if (p->tok.kind == v__token__Kind__rcbr) {
			break;
		}
	}
	if (p->tok.kind != v__token__Kind__rcbr) {
		v__parser__Parser_error_with_pos(p, _S("import syntax error, no closing `}`"), v__token__Token_pos(&p->tok));
		return;
	}
	v__parser__Parser_next(p);
}
VV_LOC void v__parser__Parser_rebuild_imported_symbols_matcher(v__parser__Parser* p, string name) {
	p->imported_symbols_trie = v__token__new_keywords_matcher_from_array_trie(builtin__map_keys(&p->imported_symbols));
}
inline VV_LOC bool v__parser__Parser_is_imported_symbol(v__parser__Parser* p, string name) {
	return v__token__KeywordsMatcherTrie_matches(&p->imported_symbols_trie, name);
}
VV_LOC v__ast__Expr v__parser__Parser_sql_expr(v__parser__Parser* p) {
	bool tmp_inside_match = p->inside_match;
	p->inside_orm = true;
	p->inside_match = true;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check_name(p);
	_result_v__ast__Expr _t1 = v__parser__Parser_check_expr(p, 0);
	if (_t1.is_error) {
		*(v__ast__Expr*) _t1.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("database"),.prepend_msg = _S("invalid expression:"),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
	}
	
 	v__ast__Expr db_expr = (*(v__ast__Expr*)_t1.data);
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	bool is_select = p->tok.kind == v__token__Kind__key_select;
	bool is_insert = builtin__fast_string_eq(p->tok.lit, _S("insert"));
	if (!is_select && !is_insert) {
		v__parser__Parser_error(p, _S("expected \"select\" or \"insert\" in an ORM expression"));
	}
	v__parser__Parser_next(p);
	string inserted_var = _S("");
	bool is_count = false;
	bool has_distinct = false;
	if (is_insert) {
		inserted_var = v__parser__Parser_check_name(p);
		v__ast__Scope_mark_var_as_used(p->scope, inserted_var);
		string into = v__parser__Parser_check_name(p);
		if (_SLIT_NE(into.str, into.len, "into")) {
			v__parser__Parser_error(p, _S("expecting `into`"));
		}
	} else if (is_select) {
		string n = v__parser__Parser_check_name(p);
		if (_SLIT_EQ(n.str, n.len, "distinct")) {
			has_distinct = true;
			string n2 = v__parser__Parser_check_name(p);
			is_count = _SLIT_EQ(n2.str, n2.len, "count");
		} else {
			is_count = _SLIT_EQ(n.str, n.len, "count");
		}
	}
	v__ast__Type typ = _const_v__ast__void_type;
	if (is_count) {
		string n = v__parser__Parser_check_name(p);
		if (_SLIT_NE(n.str, n.len, "from")) {
			v__parser__Parser_error(p, _S("expecting \"from\" in a \"select count\" ORM statement"));
		}
	}
	v__token__Pos table_pos = v__token__Token_pos(&p->tok);
	v__ast__Type table_type = v__parser__Parser_parse_type(p);
	Array_v__ast__JoinClause joins = builtin____new_array_with_default(0, 0, sizeof(v__ast__JoinClause), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__name && (builtin__fast_string_eq(p->tok.lit, _S("join")) || builtin__fast_string_eq(p->tok.lit, _S("left")) || builtin__fast_string_eq(p->tok.lit, _S("right")) || builtin__fast_string_eq(p->tok.lit, _S("full")) || builtin__fast_string_eq(p->tok.lit, _S("inner"))))) break;
		v__ast__JoinClause join_clause = v__parser__Parser_parse_sql_join_clause(p);
		if (join_clause.table_expr.typ != _const_v__ast__void_type) {
			builtin__array_push((array*)&joins, _MOV((v__ast__JoinClause[]){ join_clause }));
		}
	}
	v__ast__Expr where_expr = _const_v__ast__empty_expr;
	bool has_where = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("where"));
	if (has_where) {
		v__parser__Parser_next(p);
		where_expr = v__parser__Parser_expr(p, 0);
		v__ast__Expr where_check_result = v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &where_expr, builtin____new_array_with_default(0, 0, sizeof(string), 0));
		if ((where_check_result)._typ == 258 /* v.ast.NodeError */) {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(&(*where_check_result._v__ast__NodeError), false);
		}
	}
	bool has_limit = false;
	v__ast__Expr limit_expr = _const_v__ast__empty_expr;
	bool has_offset = false;
	v__ast__Expr offset_expr = _const_v__ast__empty_expr;
	bool has_order = false;
	v__ast__Expr order_expr = _const_v__ast__empty_expr;
	bool has_desc = false;
	if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("order"))) {
		v__parser__Parser_check_name(p);
		v__token__Pos order_pos = v__token__Token_pos(&p->tok);
		if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("by"))) {
			v__parser__Parser_check_name(p);
		} else {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("use `order by` in ORM queries"), order_pos))), false);
		}
		has_order = true;
		order_expr = v__parser__Parser_expr(p, 0);
		if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("desc"))) {
			v__parser__Parser_check_name(p);
			has_desc = true;
		}
	}
	if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("limit"))) {
		v__parser__Parser_check_name(p);
		has_limit = true;
		limit_expr = v__parser__Parser_expr(p, 0);
	}
	if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("offset"))) {
		v__parser__Parser_check_name(p);
		has_offset = true;
		offset_expr = v__parser__Parser_expr(p, 0);
	}
	if (is_count) {
		typ = _const_v__ast__int_type;
	} else if (v__ast__Type_has_flag(table_type, v__ast__TypeFlag__generic)) {
		typ = v__ast__Type_set_flag(v__ast__new_type(v__ast__Table_find_or_register_array(p->table, table_type)), v__ast__TypeFlag__generic);
	} else {
		typ = v__ast__new_type(v__ast__Table_find_or_register_array(p->table, table_type));
	}
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	p->inside_match = false;
	p->inside_orm = false;
	v__ast__OrExpr or_expr = v__parser__Parser_parse_sql_or_block(p);
	p->inside_match = tmp_inside_match;
	return v__ast__SqlExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SqlExpr, (((v__ast__SqlExpr){
		.is_count = is_count,
		.is_insert = is_insert,
		.inserted_var = inserted_var,
		.has_where = has_where,
		.has_order = has_order,
		.has_limit = has_limit,
		.has_offset = has_offset,
		.has_desc = has_desc,
		.has_distinct = has_distinct,
		.is_array = (is_count ? (false) : (true)),
		.is_generated = false,
		.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
		.typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__result),
		.db_expr = db_expr,
		.where_expr = where_expr,
		.order_expr = order_expr,
		.limit_expr = limit_expr,
		.offset_expr = offset_expr,
		.table_expr = ((v__ast__TypeNode){.pos = table_pos,.typ = table_type,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),
		.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),
		.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlExpr), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),
		.or_expr = or_expr,
		.joins = joins,
	}))), false);
}
VV_LOC v__ast__JoinClause v__parser__Parser_parse_sql_join_clause(v__parser__Parser* p) {
	v__ast__JoinKind kind = v__ast__JoinKind__inner;
	v__token__Pos join_pos = v__token__Token_pos(&p->tok);
	if (builtin__fast_string_eq(p->tok.lit, _S("left"))) {
		kind = v__ast__JoinKind__left;
		v__parser__Parser_next(p);
	} else if (builtin__fast_string_eq(p->tok.lit, _S("right"))) {
		kind = v__ast__JoinKind__right;
		v__parser__Parser_next(p);
	} else if (builtin__fast_string_eq(p->tok.lit, _S("full"))) {
		kind = v__ast__JoinKind__full_outer;
		v__parser__Parser_next(p);
		if (p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("outer"))) {
			v__parser__Parser_next(p);
		}
	} else if (builtin__fast_string_eq(p->tok.lit, _S("inner"))) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind != v__token__Kind__name || !builtin__fast_string_eq(p->tok.lit, _S("join"))) {
		v__parser__Parser_error(p, _S("expected `join` keyword after join type"));
		return ((v__ast__JoinClause){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.on_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},});
	}
	v__parser__Parser_next(p);
	v__token__Pos table_pos = v__token__Token_pos(&p->tok);
	v__ast__Type table_type = v__parser__Parser_parse_type(p);
	if (p->tok.kind != v__token__Kind__name || !builtin__fast_string_eq(p->tok.lit, _S("on"))) {
		v__parser__Parser_error(p, _S("expected `on` keyword after table name in JOIN clause"));
		return ((v__ast__JoinClause){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.on_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},});
	}
	v__parser__Parser_next(p);
	v__ast__Expr on_expr = v__parser__Parser_expr(p, 0);
	return ((v__ast__JoinClause){.kind = kind,.pos = join_pos,.table_expr = ((v__ast__TypeNode){.pos = table_pos,.typ = table_type,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.on_expr = on_expr,});
}
VV_LOC v__ast__SqlStmt v__parser__Parser_sql_stmt(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	p->inside_orm = true;
	p->inside_match = true;
	v__parser__Parser_check_name(p);
	_result_v__ast__Expr _t1 = v__parser__Parser_check_expr(p, 0);
	if (_t1.is_error) {
		*(v__ast__Expr*) _t1.data = v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = _S("database"),.prepend_msg = _S("invalid expression:"),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
	}
	
 	v__ast__Expr db_expr = (*(v__ast__Expr*)_t1.data);
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__SqlStmtLine lines = builtin____new_array_with_default(0, 0, sizeof(v__ast__SqlStmtLine), 0);
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr)) break;
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_unexpected_with_pos(p, pos, ((v__parser__ParamsForUnexpected){.got = _S("eof, while parsing an SQL statement"),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			v__ast__SqlStmt _t2 = ((v__ast__SqlStmt){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.lines = builtin____new_array(0, 0, sizeof(v__ast__SqlStmtLine)),.db_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.db_expr_type = 0,});
				{ // defer begin
					p->inside_orm = false;
					p->inside_match = false;
				} // defer end
			return _t2;
		}
		builtin__array_push((array*)&lines, _MOV((v__ast__SqlStmtLine[]){ v__parser__Parser_parse_sql_stmt_line(p) }));
	}
	v__parser__Parser_next(p);
	v__ast__OrExpr or_expr = v__parser__Parser_parse_sql_or_block(p);
	pos.last_line = p->prev_tok.line_nr;
	v__ast__SqlStmt _t4 = ((v__ast__SqlStmt){.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),.lines = lines,.db_expr = db_expr,.or_expr = or_expr,.db_expr_type = 0,});
		{ // defer begin
			p->inside_orm = false;
			p->inside_match = false;
		} // defer end
	return _t4;
}
VV_LOC v__ast__OrExpr v__parser__Parser_parse_sql_or_block(v__parser__Parser* p) {
	Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__ast__OrKind kind = v__ast__OrKind__absent;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (p->tok.kind == v__token__Kind__key_orelse) {
		kind = v__ast__OrKind__block;
		multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_6665 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
		stmts = mr_6665.arg0;
		pos = mr_6665.arg1;
		or_scope = mr_6665.arg2;
	} else if (p->tok.kind == v__token__Kind__not) {
		kind = v__ast__OrKind__propagate_result;
		or_scope = p->scope;
		v__parser__Parser_next(p);
	}
	return ((v__ast__OrExpr){.kind = kind,.pos = pos,.scope = or_scope,.err_used = 0,.stmts = stmts,});
}
VV_LOC v__ast__SqlStmtLine v__parser__Parser_parse_sql_stmt_line(v__parser__Parser* p) {
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	string n = v__parser__Parser_check_name(p);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__ast__SqlStmtKind kind = v__ast__SqlStmtKind__insert;
	if (_SLIT_EQ(n.str, n.len, "delete")) {
		kind = v__ast__SqlStmtKind__delete;
	} else if (_SLIT_EQ(n.str, n.len, "update")) {
		kind = v__ast__SqlStmtKind__update;
	} else if (_SLIT_EQ(n.str, n.len, "create")) {
		kind = v__ast__SqlStmtKind__create;
		string table = v__parser__Parser_check_name(p);
		if (_SLIT_NE(table.str, table.len, "table")) {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected `table` got `"), 0xfe10, {.d_s = table}}, {_S("`"), 0, { .d_c = 0 }}})));
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Pos typ_pos = v__token__Token_pos(&p->tok);
		Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		return ((v__ast__SqlStmtLine){
			.kind = kind,
			.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
			.is_generated = false,
			.scope = p->scope,
			.object_var = (string){.str=(byteptr)"", .is_lit=1},
			.updated_columns = builtin____new_array(0, 0, sizeof(string)),
			.table_expr = ((v__ast__TypeNode){.pos = typ_pos,.typ = typ,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),
			.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),
			.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),
			.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),
			.pre_comments = pre_comments,
			.end_comments = end_comments,
		});
	} else if (_SLIT_EQ(n.str, n.len, "drop")) {
		kind = v__ast__SqlStmtKind__drop;
		string table = v__parser__Parser_check_name(p);
		if (_SLIT_NE(table.str, table.len, "table")) {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("expected `table` got `"), 0xfe10, {.d_s = table}}, {_S("`"), 0, { .d_c = 0 }}})));
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		v__token__Pos typ_pos = v__token__Token_pos(&p->tok);
		Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		return ((v__ast__SqlStmtLine){
			.kind = kind,
			.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok)),
			.is_generated = false,
			.scope = p->scope,
			.object_var = (string){.str=(byteptr)"", .is_lit=1},
			.updated_columns = builtin____new_array(0, 0, sizeof(string)),
			.table_expr = ((v__ast__TypeNode){.pos = typ_pos,.typ = typ,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),
			.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),
			.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),
			.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),
			.pre_comments = pre_comments,
			.end_comments = end_comments,
		});
	}
	string inserted_var = _S("");
	v__ast__Type table_type = _const_v__ast__no_type;
	if (kind != v__ast__SqlStmtKind__delete) {
		if (kind == v__ast__SqlStmtKind__update) {
			table_type = v__parser__Parser_parse_type(p);
		} else if (kind == v__ast__SqlStmtKind__insert) {
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			if ((expr)._typ == 281 /* v.ast.Ident */) {
				inserted_var = (*expr._v__ast__Ident).name;
			} else {
				v__parser__Parser_error(p, _S("can only insert variables"));
				return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
			}
		}
	}
	n = v__parser__Parser_check_name(p);
	Array_string updated_columns = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_v__ast__Expr update_exprs = builtin____new_array_with_default(0, 5, sizeof(v__ast__Expr), 0);
	if (kind == v__ast__SqlStmtKind__insert && _SLIT_NE(n.str, n.len, "into")) {
		v__parser__Parser_error(p, _S("expecting `into`"));
		return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
	} else if (kind == v__ast__SqlStmtKind__update) {
		if (_SLIT_NE(n.str, n.len, "set")) {
			v__parser__Parser_error(p, _S("expecting `set`"));
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		for (;;) {
			string column = v__parser__Parser_check_name(p);
			builtin__array_push((array*)&updated_columns, _MOV((string[]){ builtin__string_clone(column) }));
			v__parser__Parser_check(p, v__token__Kind__assign);
			builtin__array_push((array*)&update_exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
			if (p->tok.kind == v__token__Kind__comma) {
				v__parser__Parser_check(p, v__token__Kind__comma);
			} else {
				break;
			}
		}
	} else if (kind == v__ast__SqlStmtKind__delete && _SLIT_NE(n.str, n.len, "from")) {
		v__parser__Parser_error(p, _S("expecting `from`"));
		return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
	}
	v__token__Pos table_pos = v__token__Token_pos(&p->tok);
	v__ast__Expr where_expr = _const_v__ast__empty_expr;
	if (kind == v__ast__SqlStmtKind__insert) {
		table_pos = v__token__Token_pos(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
	} else if (kind == v__ast__SqlStmtKind__update) {
		_option_bool _t11 = v__parser__Parser_check_sql_keyword(p, _S("where"));
		if (_t11.state != 0) {
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		
 ;
		where_expr = v__parser__Parser_expr(p, 0);
		v__ast__Expr where_expr_result = v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &where_expr, builtin____new_array_with_default(0, 0, sizeof(string), 0));
		if ((where_expr_result)._typ == 258 /* v.ast.NodeError */) {
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
	} else if (kind == v__ast__SqlStmtKind__delete) {
		table_pos = v__token__Token_pos(&p->tok);
		table_type = v__parser__Parser_parse_type(p);
		_option_bool _t14 = v__parser__Parser_check_sql_keyword(p, _S("where"));
		if (_t14.state != 0) {
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		
 ;
		where_expr = v__parser__Parser_expr(p, 0);
		v__ast__Expr where_expr_result = v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &where_expr, builtin____new_array_with_default(0, 0, sizeof(string), 0));
		if ((where_expr_result)._typ == 258 /* v.ast.NodeError */) {
			return ((v__ast__SqlStmtLine){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_generated = 0,.scope = ((void*)0),.object_var = (string){.str=(byteptr)"", .is_lit=1},.updated_columns = builtin____new_array(0, 0, sizeof(string)),.table_expr = ((v__ast__TypeNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),.where_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.update_exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
	}
	Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	return ((v__ast__SqlStmtLine){
		.kind = kind,
		.pos = pos,
		.is_generated = false,
		.scope = p->scope,
		.object_var = inserted_var,
		.updated_columns = updated_columns,
		.table_expr = ((v__ast__TypeNode){.pos = table_pos,.typ = table_type,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}),
		.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),
		.sub_structs = builtin__new_map(sizeof(int), sizeof(v__ast__SqlStmtLine), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop),
		.where_expr = where_expr,
		.update_exprs = update_exprs,
		.pre_comments = pre_comments,
		.end_comments = end_comments,
	});
}
VV_LOC _option_bool v__parser__Parser_check_sql_keyword(v__parser__Parser* p, string name) {
	if (!builtin__string__eq(v__parser__Parser_check_name(p), name)) {
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ORM: expecting `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})));
		return (_option_bool){ .state=2, .err=_const_none__, .data={E_STRUCT} };
	}
	_option_bool _t2;
	builtin___option_ok(&(bool[]) { true }, (_option*)(&_t2), sizeof(bool));
	 
	return _t2;
}
VV_LOC v__ast__Expr v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(v__parser__Parser* p, v__ast__Expr* expr, Array_string unacceptable_variable_names) {
	if ((expr)->_typ == 281 /* v.ast.Ident */) {
		if (!v__ast__Scope_known_var(p->scope, (*expr->_v__ast__Ident).name)) {
			_result_void _t1 = v__parser__Parser_check_undefined_variables(p, unacceptable_variable_names, v__ast__Ident_to_sumtype_v__ast__Expr(&(*expr->_v__ast__Ident), false));
			if (_t1.is_error) {
				IError err = _t1.err;
				return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, IError_name_table[err._typ]._method_msg(err._object), (*expr->_v__ast__Ident).pos))), false);
			}
			
 ;
		}
	} else if ((expr)->_typ == 285 /* v.ast.InfixExpr */) {
		if (((*expr->_v__ast__InfixExpr).left)._typ == 281 /* v.ast.Ident */) {
			if (((*expr->_v__ast__InfixExpr).right)._typ == 281 /* v.ast.Ident */) {
				return v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, HEAP(v__ast__Expr, v__ast__Ident_to_sumtype_v__ast__Expr(&(*(*expr->_v__ast__InfixExpr).right._v__ast__Ident), true)), builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__string_clone((*(*expr->_v__ast__InfixExpr).left._v__ast__Ident).name)})));
			}
		}
		v__ast__Expr left_check_result = v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &(*expr->_v__ast__InfixExpr).left, builtin____new_array_with_default(0, 0, sizeof(string), 0));
		if ((left_check_result)._typ == 258 /* v.ast.NodeError */) {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(&(*left_check_result._v__ast__NodeError), false);
		}
		Array_string variable_names = (((*expr->_v__ast__InfixExpr).left)._typ == 281 /* v.ast.Ident */ ? (builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){v__ast__Ident_str((*(*expr->_v__ast__InfixExpr).left._v__ast__Ident))}))) : (builtin____new_array_with_default(0, 0, sizeof(string), 0)));
		v__ast__Expr right_check_result = v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &(*expr->_v__ast__InfixExpr).right, variable_names);
		if ((right_check_result)._typ == 258 /* v.ast.NodeError */) {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(&(*right_check_result._v__ast__NodeError), false);
		}
	} else if ((expr)->_typ == 297 /* v.ast.ParExpr */) {
		return v__parser__Parser_check_sql_where_expr_has_no_undefined_variables(p, &(*expr->_v__ast__ParExpr).expr, builtin____new_array_with_default(0, 0, sizeof(string), 0));
	}
	return _const_v__ast__empty_expr;
}
VV_LOC multi_return_int_bool v__parser__Parser_eval_array_fixed_sizes(v__parser__Parser* p, v__ast__Expr* size_expr) {
	int fixed_size = 0;
	bool size_unresolved = true;
	if (size_expr->_typ == 297 /* v.ast.ParExpr */) {
		return v__parser__Parser_eval_array_fixed_sizes(p, &(*size_expr->_v__ast__ParExpr).expr);
	}
	else if (size_expr->_typ == 286 /* v.ast.IntegerLiteral */) {
		fixed_size = builtin__string_int((*size_expr->_v__ast__IntegerLiteral).val);
		size_unresolved = false;
	}
	else if (size_expr->_typ == 272 /* v.ast.ComptimeCall */) {
		if ((*size_expr->_v__ast__ComptimeCall).kind == v__ast__ComptimeCallKind__d) {
			_result_void _t2 = v__ast__ComptimeCall_resolve_compile_value(&(*size_expr->_v__ast__ComptimeCall), p->pref->compile_values);
			if (_t2.is_error) {
				IError err = _t2.err;
				v__parser__Parser_error_with_pos(p, IError_name_table[err._typ]._method_msg(err._object), (*size_expr->_v__ast__ComptimeCall).pos);
			}
			
 ;
			if ((*size_expr->_v__ast__ComptimeCall).result_type != _const_v__ast__i64_type) {
				v__parser__Parser_error_with_pos(p, _S("value from $d() can only be positive integers when used as fixed size"), (*size_expr->_v__ast__ComptimeCall).pos);
			}
			fixed_size = builtin__string_int((*size_expr->_v__ast__ComptimeCall).compile_value);
			size_unresolved = false;
		} else {
			v__parser__Parser_error_with_pos(p, _S("only $d() is supported as fixed array size quantifier at compile time"), (*size_expr->_v__ast__ComptimeCall).pos);
		}
	}
	else if (size_expr->_typ == 268 /* v.ast.CastExpr */) {
		if (!v__ast__Type_is_pure_int((*size_expr->_v__ast__CastExpr).typ)) {
			v__parser__Parser_error_with_pos(p, _S("only integer types are allowed"), (*size_expr->_v__ast__CastExpr).pos);
		}
		if ((*size_expr->_v__ast__CastExpr).expr._typ == 286 /* v.ast.IntegerLiteral */) {
			fixed_size = builtin__string_int((*(*size_expr->_v__ast__CastExpr).expr._v__ast__IntegerLiteral).val);
			size_unresolved = false;
		}
		else if ((*size_expr->_v__ast__CastExpr).expr._typ == 279 /* v.ast.FloatLiteral */) {
			fixed_size = ((int)(builtin__string_f64((*(*size_expr->_v__ast__CastExpr).expr._v__ast__FloatLiteral).val)));
			size_unresolved = false;
		}
		else if ((*size_expr->_v__ast__CastExpr).expr._typ == 278 /* v.ast.EnumVal */) {
			_option_i64 _t3;
			if (_t3 = v__ast__Table_find_enum_field_val(p->table, (*(*size_expr->_v__ast__CastExpr).expr._v__ast__EnumVal).enum_name, (*(*size_expr->_v__ast__CastExpr).expr._v__ast__EnumVal).val), _t3.state == 0) {
				i64 val = *(i64*)_t3.data;
				fixed_size = ((int)(val));
				size_unresolved = false;
			}
		}
		
		else {
			multi_return_int_bool mr_1818 = v__parser__Parser_eval_array_fixed_sizes(p, &(*size_expr->_v__ast__CastExpr).expr);
			int size = mr_1818.arg0;
			bool unresolved = mr_1818.arg1;
			return (multi_return_int_bool){.arg0=((int)(size)), .arg1=unresolved};
		}
		
	}
	else if (size_expr->_typ == 281 /* v.ast.Ident */) {
		_option_v__ast__ConstField_ptr _t5;
		if (_t5 = v__ast__Scope_find_const(p->table->global_scope, builtin__string_all_after(v__ast__Ident_full_name(&(*size_expr->_v__ast__Ident)), _S("builtin."))), _t5.state == 0) {
			v__ast__ConstField* const_field = *(v__ast__ConstField**)_t5.data;
			if ((const_field->expr)._typ == 286 /* v.ast.IntegerLiteral */) {
				fixed_size = builtin__string_int((*const_field->expr._v__ast__IntegerLiteral).val);
				size_unresolved = false;
			} else if ((const_field->expr)._typ == 285 /* v.ast.InfixExpr */) {
				v__transformer__Transformer* t = v__transformer__new_transformer_with_table(p->table, p->pref);
				v__ast__Expr folded_expr = v__transformer__Transformer_infix_expr(t, (voidptr)&(*const_field->expr._v__ast__InfixExpr));
				if ((folded_expr)._typ == 286 /* v.ast.IntegerLiteral */) {
					fixed_size = builtin__string_int((*folded_expr._v__ast__IntegerLiteral).val);
					size_unresolved = false;
				}
			}
		} else {
			if (p->pref->is_fmt) {
				fixed_size = 1;
				size_unresolved = false;
			}
		}
	}
	else if (size_expr->_typ == 285 /* v.ast.InfixExpr */) {
		v__transformer__Transformer* t = v__transformer__new_transformer_with_table(p->table, p->pref);
		v__ast__Expr folded_expr = v__transformer__Transformer_infix_expr(t, &/*mut*/(*size_expr->_v__ast__InfixExpr));
		if ((folded_expr)._typ == 286 /* v.ast.IntegerLiteral */) {
			fixed_size = builtin__string_int((*folded_expr._v__ast__IntegerLiteral).val);
			size_unresolved = false;
		}
	}
	
	else {
		v__parser__Parser_error_with_pos(p, _S("fixed array size cannot use non-constant value"), v__ast__Expr_pos(*size_expr));
	}
	
	return (multi_return_int_bool){.arg0=fixed_size, .arg1=size_unresolved};
}
VV_LOC v__ast__Type v__parser__Parser_parse_array_type(v__parser__Parser* p, v__token__Kind expecting, bool is_option) {
	v__parser__Parser_check(p, expecting);
	if (p->tok.kind != v__token__Kind__rsbr) {
		int fixed_size = 0;
		v__ast__Expr size_expr = v__parser__Parser_expr(p, 0);
		bool size_unresolved = true;
		if (p->pref->is_fmt) {
			fixed_size = 987654321;
		} else {
			multi_return_int_bool mr_3387 = v__parser__Parser_eval_array_fixed_sizes(p, &size_expr);
			fixed_size = mr_3387.arg0;
			size_unresolved = mr_3387.arg1;
		}
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		p->fixed_array_dim++;
		v__ast__Type elem_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(elem_type) == 0) {
			v__ast__Type _t1 = 0;
				{ // defer begin
					p->fixed_array_dim--;
				} // defer end
			return _t1;
		}
		if (elem_type == _const_v__ast__chan_type) {
			v__parser__Parser_chan_type_error(p);
			v__ast__Type _t2 = 0;
				{ // defer begin
					p->fixed_array_dim--;
				} // defer end
			return _t2;
		}
		if (fixed_size <= 0 && !size_unresolved) {
			v__parser__Parser_error_with_pos(p, _S("fixed size cannot be zero or negative"), v__ast__Expr_pos(size_expr));
		}
		int idx = v__ast__Table_find_or_register_array_fixed(p->table, elem_type, fixed_size, size_expr, p->array_dim == 1 && p->fixed_array_dim == 1 && !is_option && p->inside_fn_return);
		if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
			v__ast__Type _t3 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
				{ // defer begin
					p->fixed_array_dim--;
				} // defer end
			return _t3;
		}
		v__ast__Type _t4 = v__ast__new_type(idx);
			{ // defer begin
				p->fixed_array_dim--;
			} // defer end
		return _t4;
		{ // defer begin
			p->fixed_array_dim--;
		} // defer end
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(elem_type) == 0) {
		v__ast__Type _t5 = 0;
		return _t5;
	}
	if (elem_type == _const_v__ast__chan_type) {
		v__parser__Parser_chan_type_error(p);
		v__ast__Type _t6 = 0;
		return _t6;
	}
	if (v__ast__Type_idx(elem_type) == 29) {
		v__parser__Parser_register_auto_import(p, _S("sync.threads"));
	}
	int idx = v__ast__Table_find_or_register_array_with_dims(p->table, elem_type, 1);
	if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
		v__ast__Type _t7 = v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		return _t7;
	}
	v__ast__Type _t8 = v__ast__new_type(idx);
	return _t8;
}
VV_LOC v__ast__Type v__parser__Parser_parse_map_type(v__parser__Parser* p) {
	bool is_option = p->tok.kind == v__token__Kind__question && p->peek_tok.kind == v__token__Kind__name;
	if (is_option) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind__lsbr) {
		if (p->inside_struct_field_decl) {
			v__parser__Parser_error_with_pos(p, _S("cannot use the map type without key and value definition"), v__token__Token_pos(&p->prev_tok));
			return 0;
		}
		return _const_v__ast__map_type;
	}
	v__parser__Parser_check(p, v__token__Kind__lsbr);
	v__ast__Type key_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(key_type) == 0) {
		return 0;
	}
	v__ast__TypeSymbol* key_sym = v__ast__Table_sym(p->table, key_type);
	bool is_alias = key_sym->kind == v__ast__Kind__alias;
	bool key_type_supported = (key_type == _const_v__ast__string_type_idx || key_type == _const_v__ast__voidptr_type_idx) || (key_sym->kind == v__ast__Kind__enum || key_sym->kind == v__ast__Kind__placeholder || key_sym->kind == v__ast__Kind__any) || ((v__ast__Type_is_int(key_type) || v__ast__Type_is_float(key_type) || is_alias) && !v__ast__Type_is_ptr(key_type));
	if (!key_type_supported) {
		if (is_alias) {
			v__parser__Parser_error(p, _S("cannot use the alias type as the parent type is unsupported"));
			return 0;
		}
		string s = v__ast__Table_type_to_str(p->table, key_type);
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("maps only support string, integer, float, rune, enum or voidptr keys for now (not `"), 0xfe10, {.d_s = s}}, {_S("`)"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
		return 0;
	}
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	if (p->tok.kind == v__token__Kind__lsbr) {
		if (!(p->peek_tok.kind == v__token__Kind__rsbr || p->peek_tok.kind == v__token__Kind__number)) {
			string s = v__ast__Table_type_to_str(p->table, key_type);
			v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("maps can only have a single key. To declare a map use `map["), 0xfe10, {.d_s = s}}, {_S("]"), 0xfe10, {.d_s = p->peek_tok.lit}}, {_S("{}` instead"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->peek_tok));
			return 0;
		}
	}
	v__ast__Type value_type = v__parser__Parser_parse_type(p);
	if (v__ast__Type_idx(value_type) == 0) {
		return 0;
	}
	if (value_type == _const_v__ast__chan_type) {
		v__parser__Parser_chan_type_error(p);
		return 0;
	}
	if (v__ast__Type_idx(value_type) == 1) {
		v__parser__Parser_error_with_pos(p, _S("map value type is missing: use `map[KeyType]ValueType`"), v__token__Token_pos(&p->tok));
		return 0;
	}
	int idx = v__ast__Table_find_or_register_map(p->table, key_type, value_type);
	if (v__ast__Type_has_flag(key_type, v__ast__TypeFlag__generic) || v__ast__Type_has_flag(value_type, v__ast__TypeFlag__generic)) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	}
	if (is_option) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__option);
	} else {
		return v__ast__new_type(idx);
	}
	return 0;
}
VV_LOC v__ast__Type v__parser__Parser_parse_chan_type(v__parser__Parser* p) {
	if (!(p->peek_tok.kind == v__token__Kind__name || p->peek_tok.kind == v__token__Kind__key_mut || p->peek_tok.kind == v__token__Kind__amp || p->peek_tok.kind == v__token__Kind__lsbr)) {
		v__parser__Parser_next(p);
		return _const_v__ast__chan_type;
	}
	v__parser__Parser_register_auto_import(p, _S("sync"));
	v__parser__Parser_next(p);
	p->inside_chan_decl = true;
	bool is_mut = p->tok.kind == v__token__Kind__key_mut;
	v__ast__Type elem_type = v__parser__Parser_parse_type(p);
	p->inside_chan_decl = false;
	int idx = v__ast__Table_find_or_register_chan(p->table, elem_type, is_mut);
	if (v__ast__Type_has_flag(elem_type, v__ast__TypeFlag__generic)) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	}
	return v__ast__new_type(idx);
}
VV_LOC v__ast__Type v__parser__Parser_parse_thread_type(v__parser__Parser* p) {
	if (p->peek_tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
		v__ast__Type ret_type = v__parser__Parser_parse_multi_return_type(p);
		int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
		return v__ast__new_type(idx);
	}
	bool is_opt = p->peek_tok.kind == v__token__Kind__question;
	bool is_result = p->peek_tok.kind == v__token__Kind__not;
	if (is_opt || is_result) {
		v__parser__Parser_next(p);
	}
	if (!(p->peek_tok.kind == v__token__Kind__name || p->peek_tok.kind == v__token__Kind__key_pub || p->peek_tok.kind == v__token__Kind__key_mut || p->peek_tok.kind == v__token__Kind__amp || p->peek_tok.kind == v__token__Kind__lsbr)) {
		v__parser__Parser_next(p);
		if (is_opt) {
			v__ast__Type ret_type = _const_v__ast__void_type;
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__option);
			int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
			return v__ast__new_type(idx);
		} else if (is_result) {
			v__ast__Type ret_type = _const_v__ast__void_type;
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__result);
			int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
			return v__ast__new_type(idx);
		} else {
			return _const_v__ast__thread_type;
		}
	}
	if (!is_opt && !is_result) {
		v__parser__Parser_next(p);
	}
	if (is_opt || is_result || (p->tok.kind == v__token__Kind__amp || p->tok.kind == v__token__Kind__lsbr) || (p->tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0))) || v__token__KeywordsMatcherTrie_matches(&_const_v__ast__builtin_type_names_matcher, p->tok.lit) || p->peek_tok.kind == v__token__Kind__dot) {
		v__ast__Type ret_type = v__parser__Parser_parse_type(p);
		if (is_opt) {
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__option);
		} else if (is_result) {
			ret_type = v__ast__Type_set_flag(ret_type, v__ast__TypeFlag__result);
		}
		int idx = v__ast__Table_find_or_register_thread(p->table, ret_type);
		if (v__ast__Type_has_flag(ret_type, v__ast__TypeFlag__generic)) {
			return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
		}
		return v__ast__new_type(idx);
	}
	return _const_v__ast__thread_type;
}
VV_LOC v__ast__Type v__parser__Parser_parse_multi_return_type(v__parser__Parser* p) {
	v__parser__Parser_check(p, v__token__Kind__lpar);
	Array_v__ast__Type mr_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	bool has_generic = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__rpar))) break;
		v__ast__Type mr_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_idx(mr_type) == 0) {
			break;
		}
		if (mr_type == _const_v__ast__chan_type) {
			v__parser__Parser_chan_type_error(p);
			break;
		}
		if (v__ast__Type_has_flag(mr_type, v__ast__TypeFlag__generic)) {
			has_generic = true;
		}
		builtin__array_push((array*)&mr_types, _MOV((v__ast__Type[]){ mr_type }));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		} else {
			break;
		}
	}
	v__parser__Parser_check(p, v__token__Kind__rpar);
	if (mr_types.len == 1) {
		return (*(v__ast__Type*)builtin__array_get(mr_types, 0));
	}
	int idx = v__ast__Table_find_or_register_multi_return(p->table, mr_types);
	if (has_generic) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	}
	return v__ast__new_type(idx);
}
VV_LOC v__ast__Type v__parser__Parser_parse_fn_type(v__parser__Parser* p, string name, Array_v__ast__Type generic_types) {
	v__token__Pos fn_type_pos = v__token__Token_pos(ADDR(v__token__Token, v__parser__Parser_peek_token(p, -2)));
	v__parser__Parser_check(p, v__token__Kind__key_fn);
	for (int _t1 = 0; _t1 < p->attrs.len; ++_t1) {
		v__ast__Attr attr = ((v__ast__Attr*)p->attrs.data)[_t1];

		if (_SLIT_EQ(attr.name.str, attr.name.len, "callconv")) {
			if (!attr.has_arg) {
				v__parser__Parser_error_with_pos(p, _S("callconv attribute is present but its value is missing"), v__token__Token_pos(&p->prev_tok));
			}
			if (!(builtin__fast_string_eq(attr.arg, _S("stdcall")) || builtin__fast_string_eq(attr.arg, _S("fastcall")) || builtin__fast_string_eq(attr.arg, _S("cdecl")))) {
				v__parser__Parser_error_with_pos(p, _S("unsupported calling convention, supported are stdcall, fastcall and cdecl"), v__token__Token_pos(&p->prev_tok));
			}
		}
		else {
		}
	}
	bool has_generic = false;
	int line_nr = p->tok.line_nr;
	multi_return_Array_v__ast__Param_bool_bool_bool mr_9825 = v__parser__Parser_fn_params(p);
	Array_v__ast__Param params = mr_9825.arg0;
	bool is_variadic = mr_9825.arg2;
	bool is_c_variadic = mr_9825.arg3;
	for (int _t2 = 0; _t2 < params.len; ++_t2) {
		v__ast__Param param = ((v__ast__Param*)params.data)[_t2];
		if (v__ast__Type_has_flag(param.typ, v__ast__TypeFlag__generic)) {
			has_generic = true;
			break;
		}
		if (builtin__string__eq(v__ast__Table_sym(p->table, param.typ)->name, name)) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = name}}, {_S("` cannot be a parameter as it references the fntype"), 0, { .d_c = 0 }}})), param.type_pos);
		}
	}
	v__ast__Type return_type = _const_v__ast__void_type;
	v__token__Pos return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	if (p->tok.line_nr == line_nr && v__token__Kind_is_start_of_type(p->tok.kind) && !v__parser__Parser_is_attributes(p)) {
		return_type_pos = v__token__Token_pos(&p->tok);
		return_type = v__parser__Parser_parse_type(p);
		if (v__ast__Type_has_flag(return_type, v__ast__TypeFlag__generic)) {
			has_generic = true;
		}
		return_type_pos = v__token__Pos_extend(return_type_pos, v__token__Token_pos(&p->prev_tok));
	}
	_result_Array_string _t3 = v__parser__Parser_types_to_names(p, generic_types, fn_type_pos, _S("generic_types"));
	if (_t3.is_error) {
		return _const_v__ast__no_type;
	}
	
 	Array_string generic_names = (*(Array_string*)_t3.data);
	v__ast__Fn func = ((v__ast__Fn){
		.params = params,
		.attrs = p->attrs,
		.dep_names = builtin____new_array(0, 0, sizeof(string)),
		.generic_names = generic_names,
		.file = (string){.str=(byteptr)"", .is_lit=1},
		.name = name,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.source_fn = 0,
		.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
		.return_type_pos = return_type_pos,
		.receiver_type = 0,
		.usages = 0,
		.return_type = return_type,
		.from_embedded_type = 0,
		.ctdefine_idx = 0,
		.file_mode = 0,
		.language = 0,
		.is_expand_simple_interpolation = 0,
		.is_c_variadic = is_c_variadic,
		.is_pub = 0,
		.is_ctor_new = 0,
		.is_deprecated = 0,
		.is_noreturn = 0,
		.is_unsafe = 0,
		.is_must_use = 0,
		.is_placeholder = 0,
		.is_main = 0,
		.is_test = 0,
		.is_keep_alive = 0,
		.is_method = false,
		.is_static_type_method = 0,
		.no_body = 0,
		.is_file_translated = 0,
		.is_conditional = 0,
		.is_variadic = is_variadic,
	});
	if (has_generic && generic_types.len == 0 && (name).len != 0) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = name}}, {_S("` type is generic fntype, must specify the generic type names, e.g. "), 0xfe10, {.d_s = name}}, {_S("[T]"), 0, { .d_c = 0 }}})), fn_type_pos);
	}
	if (builtin__string__eq(v__ast__Table_sym(p->table, return_type)->name, name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = name}}, {_S("` cannot be a return type as it references the fntype"), 0, { .d_c = 0 }}})), return_type_pos);
	}
	bool has_decl = p->builtin_mod && builtin__string_starts_with(name, _S("Map")) && builtin__string_ends_with(name, _S("Fn"));
	bool already_exists = v__ast__Table_find_type_idx(p->table, name) != 0;
	int idx = v__ast__Table_find_or_register_fn_type(p->table, func, false, has_decl);
	if (already_exists && v__ast__Table_sym_by_idx(p->table, idx)->kind != v__ast__Kind__function) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register fn `"), 0xfe10, {.d_s = name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}})), fn_type_pos);
	}
	if (has_generic) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	}
	return v__ast__new_type(idx);
}
VV_LOC v__ast__Type v__parser__Parser_parse_type_with_mut(v__parser__Parser* p, bool is_mut) {
	v__ast__Type typ = v__parser__Parser_parse_type(p);
	if (is_mut) {
		return v__ast__Type_set_nr_muls(typ, 1);
	}
	return typ;
}
VV_LOC v__ast__Language v__parser__Parser_parse_language(v__parser__Parser* p) {
	bool _t1 = true;
	v__ast__Language language = ((_t1 == (p->tok.lit.len == 1 && p->tok.lit.str[ 0] == 'C'))? (v__ast__Language__c) : (_t1 == (p->tok.lit.len == 2 && p->tok.lit.str[ 0] == 'J' && p->tok.lit.str[ 1] == 'S'))? (v__ast__Language__js) : (_t1 == (p->tok.lit.len == 4 && p->tok.lit.str[ 0] == 'W' && p->tok.lit.str[ 1] == 'A' && p->tok.lit.str[ 2] == 'S' && p->tok.lit.str[ 3] == 'M'))? (v__ast__Language__wasm) : (v__ast__Language__v));
	if (language != v__ast__Language__v) {
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
	}
	return language;
}
VV_LOC v__ast__Type v__parser__Parser_parse_inline_sum_type(v__parser__Parser* p) {
	v__parser__Parser_error(p, _S("inline sum types have been deprecated and will be removed on January 1, 2023 due to complicating the language and the compiler too much; define named sum types with `type Foo = Bar | Baz` instead"));
	return _const_v__ast__void_type;
}
VV_LOC Array_v__ast__TypeNode v__parser__Parser_parse_sum_type_variants(v__parser__Parser* p) {
	p->inside_sum_type = true;
	Array_v__ast__TypeNode types = builtin____new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
	for (;;) {
		v__token__Pos type_start_pos = v__token__Token_pos(&p->tok);
		v__ast__Type typ = v__parser__Parser_parse_type(p);
		Array_v__ast__Comment end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
		v__token__Token prev_tok = p->prev_tok;
		v__token__Pos type_end_pos = v__token__Token_pos(&prev_tok);
		v__token__Pos type_pos = v__token__Pos_extend(type_start_pos, type_end_pos);
		builtin__array_push((array*)&types, _MOV((v__ast__TypeNode[]){ ((v__ast__TypeNode){.pos = type_pos,.typ = typ,.stmt = _const_v__ast__empty_stmt,.end_comments = end_comments,}) }));
		if (p->tok.kind != v__token__Kind__pipe) {
			break;
		}
		v__parser__Parser_check(p, v__token__Kind__pipe);
	}
	Array_v__ast__TypeNode _t2 = types;
		{ // defer begin
			p->inside_sum_type = false;
		} // defer end
	return _t2;
}
VV_LOC v__ast__Type v__parser__Parser_parse_type(v__parser__Parser* p) {
	bool is_option = false;
	bool is_result = false;
	int line_nr = p->tok.line_nr;
	v__token__Pos option_pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind == v__token__Kind__question) {
		v__parser__Parser_next(p);
		is_option = true;
		if (p->tok.kind == v__token__Kind__not) {
			v__parser__Parser_next(p);
			is_result = true;
		}
	} else if (p->tok.kind == v__token__Kind__not) {
		v__parser__Parser_next(p);
		is_result = true;
		if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_next(p);
			is_option = true;
		}
	}
	if (is_option && is_result) {
		v__parser__Parser_error_with_pos(p, _S("the type must be Option or Result"), v__token__Token_pos(&p->prev_tok));
		return _const_v__ast__void_type;
	}
	if (is_option || is_result) {
		bool is_required_field = p->inside_struct_field_decl && p->tok.kind == v__token__Kind__lsbr && p->peek_tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->peek_tok.lit, _S("required"));
		bool is_attr = p->tok.kind == v__token__Kind__at;
		if (p->tok.line_nr > line_nr || (p->tok.kind == v__token__Kind__comma || p->tok.kind == v__token__Kind__rpar || p->tok.kind == v__token__Kind__assign) || (is_attr || is_required_field) || p->tok.kind == v__token__Kind__comment) {
			v__ast__Type typ = _const_v__ast__void_type;
			if (is_option) {
				typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__option);
			} else if (is_result) {
				typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__result);
			}
			return typ;
		}
	}
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _S("sync"));
	}
	int nr_muls = 0;
	if (p->tok.kind == v__token__Kind__key_mut) {
		if (p->inside_fn_return) {
			v__parser__Parser_error_with_pos(p, _S("cannot use `mut` on fn return type"), v__token__Token_pos(&p->tok));
		} else if (p->inside_struct_field_decl) {
			v__parser__Parser_error_with_pos(p, _S("cannot use `mut` on struct field type"), v__token__Token_pos(&p->tok));
		}
	}
	if (p->tok.kind == v__token__Kind__key_mut || is_shared) {
		nr_muls++;
		v__parser__Parser_next(p);
	}
	if (is_atomic) {
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind__mul) {
		v__parser__Parser_error(p, _S("use `&Type` instead of `*Type` when declaring references"));
		return 0;
	}
	int nr_amps = 0;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__amp)) break;
		nr_amps++;
		nr_muls++;
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind__key_struct) {
		p->anon_struct_decl = v__parser__Parser_struct_decl(p, true);
		int typ = v__ast__Table_find_type_idx(p->table, p->anon_struct_decl.name);
		if (is_option) {
			typ = v__ast__Type_set_flag(v__ast__new_type(typ), v__ast__TypeFlag__option);
		}
		return typ;
	}
	v__ast__Language language = v__parser__Parser_parse_language(p);
	v__ast__Type typ = _const_v__ast__void_type;
	bool is_array = p->tok.kind == v__token__Kind__lsbr;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	if (p->tok.kind != v__token__Kind__lcbr) {
		typ = v__parser__Parser_parse_any_type(p, language, nr_muls > 0, true, is_option);
		if (v__ast__Type_idx(typ) == 0) {
			return 0;
		}
		if (typ == _const_v__ast__chan_type && !p->inside_receiver_param) {
			v__parser__Parser_chan_type_error(p);
			return 0;
		}
		if (typ == _const_v__ast__void_type) {
			v__parser__Parser_error_with_pos(p, _S("use `?` instead of `?void`"), pos);
			return 0;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
		if (p->inside_fn_concrete_type && (sym->info)._typ == 457 /* v.ast.Struct */) {
			if (!v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic) && (*sym->info._v__ast__Struct).generic_types.len > 0) {
				v__parser__Parser_error_with_pos(p, _S("missing concrete type on generic type"), v__token__Pos_extend(option_pos, v__token__Token_pos(&p->prev_tok)));
			}
		}
		if (is_option && (sym->info)._typ == 482 /* v.ast.Alias */ && v__ast__Type_has_flag((*(v__ast__Alias*)builtin____as_cast((sym->info)._v__ast__Alias,(sym->info)._typ, 482)).parent_type, v__ast__TypeFlag__option)) {
			string alias_type_str = v__ast__Table_type_to_str(p->table, typ);
			string parent_type_str = v__ast__Table_type_to_str(p->table, (*sym->info._v__ast__Alias).parent_type);
			v__parser__Parser_error_with_pos(p, builtin__str_intp(4, _MOV((StrIntpData[]){{_S("cannot use double options like `?"), 0xfe10, {.d_s = parent_type_str}}, {_S("`, `?"), 0xfe10, {.d_s = alias_type_str}}, {_S("` is a double option. use `"), 0xfe10, {.d_s = alias_type_str}}, {_S("` instead"), 0, { .d_c = 0 }}})), v__token__Pos_extend(option_pos, v__token__Token_pos(&p->prev_tok)));
		}
	}
	if (is_option) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__option);
	}
	if (is_result) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__result);
	}
	if (is_shared) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__shared_f);
	}
	if (is_atomic) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__atomic_f);
	}
	if (_us32_eq(_const_v__ast__array_type,v__ast__Type_idx(typ)) && !p->builtin_mod && !(builtin__fast_string_eq(p->mod, _S("os")) || builtin__fast_string_eq(p->mod, _S("strconv")) || builtin__fast_string_eq(p->mod, _S("sync"))) && !p->inside_unsafe) {
		v__parser__Parser_error_with_pos(p, _S("`array` is an internal type, it cannot be used directly. Use `[]int`, `[]Foo` etc"), pos);
	}
	if (nr_muls > 0) {
		typ = v__ast__Type_set_nr_muls(typ, nr_muls);
		if (is_array && nr_amps > 0) {
			v__parser__Parser_error_with_pos(p, _S("V arrays are already references behind the scenes,\nthere is no need to use a reference to an array (e.g. use `[]string` instead of `&[]string`).\nIf you need to modify an array in a function, use a mutable argument instead: `fn foo(mut s []string) {}`."), pos);
			return 0;
		}
	}
	return typ;
}
VV_LOC v__ast__Type v__parser__Parser_parse_any_type(v__parser__Parser* p, v__ast__Language language, bool is_ptr, bool check_dot, bool is_option) {
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	string name = p->tok.lit;
	if (language == v__ast__Language__c) {
		name = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if (language == v__ast__Language__js) {
		name = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if (p->peek_tok.kind == v__token__Kind__dot && check_dot && p->tok.lit.len > 0 && !builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0))) {
		string mod = name;
		v__token__Pos mod_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
		string mod_last_part = mod;
		for (;;) {
			if (!(p->peek_tok.kind == v__token__Kind__dot)) break;
			mod_pos = v__token__Pos_extend(mod_pos, v__token__Token_pos(&p->tok));
			mod_last_part = p->tok.lit;
			if (builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0))) {
				break;
			}
			mod = builtin__string__plus(mod, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("."), 0xfe10, {.d_s = mod_last_part}}, {_SLIT0, 0, { .d_c = 0 }}})));
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
		}
		if (!builtin__string__eq(mod, p->mod) && !v__parser__Parser_known_import(p, mod) && !p->pref->is_fmt) {
			string msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown module `"), 0xfe10, {.d_s = mod}}, {_S("`"), 0, { .d_c = 0 }}}));
			if (mod.len > mod_last_part.len && v__parser__Parser_known_import(p, mod_last_part)) {
				msg = builtin__string__plus(msg, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("; did you mean `"), 0xfe10, {.d_s = mod_last_part}}, {_S("`?"), 0, { .d_c = 0 }}})));
			}
			v__parser__Parser_error_with_pos(p, msg, mod_pos);
			return 0;
		}
		if (_IN_MAP(ADDR(string, mod), ADDR(map, p->imports))) {
			v__parser__Parser_register_used_import(p, mod);
			mod = (*(string*)builtin__map_get(ADDR(map, p->imports), &(string[]){mod}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
			if (p->tok.lit.len > 0 && !builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0))) {
				v__parser__Parser_error(p, _S("imported types must start with a capital letter"));
				return 0;
			}
		}
		name = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_S("."), 0xfe10, {.d_s = p->tok.lit}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else if ((p->expr_mod).len != 0 && !p->inside_generic_params) {
		name = builtin__string__plus(builtin__string__plus(p->expr_mod, _S(".")), name);
	} else if (v__parser__Parser_is_imported_symbol(p, name)) {
		bool check = !(*(bool*)builtin__map_get(ADDR(map, p->imported_symbols_used), &(string[]){name}, &(bool[]){ 0 }));
		name = (*(string*)builtin__map_get(ADDR(map, p->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		if (check) {
			v__parser__Parser_register_used_import_for_symbol_name(p, name);
		}
	} else if (!p->builtin_mod && name.len > 1 && !_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs))) {
		name = builtin__string__plus(builtin__string__plus(p->mod, _S(".")), name);
	}

	if (p->tok.kind == (v__token__Kind__key_fn)) {
		return v__parser__Parser_parse_fn_type(p, _S(""), builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0));
	}
	else if (p->tok.kind == (v__token__Kind__lsbr) || p->tok.kind == (v__token__Kind__nilsbr)) {
		p->array_dim++;
		v__ast__Type _t4 = v__parser__Parser_parse_array_type(p, p->tok.kind, is_option);
			{ // defer begin
				p->array_dim--;
			} // defer end
		return _t4;
		{ // defer begin
			p->array_dim--;
		} // defer end
	}
	else {
		if (p->tok.kind == v__token__Kind__lpar) {
			if (is_ptr) {
				v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("`&` before multiple returns"),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = _S("parse_type:"),.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
				v__ast__Type _t5 = 0;
				return _t5;
			}
			v__ast__Type _t6 = v__parser__Parser_parse_multi_return_type(p);
			return _t6;
		}
		if (((p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__pipe) || p->peek_tok.kind == v__token__Kind__pipe) && !p->inside_sum_type && !p->inside_receiver_param) {
			v__ast__Type _t7 = v__parser__Parser_parse_inline_sum_type(p);
			return _t7;
		}
		if (_SLIT_EQ(name.str, name.len, "map")) {
			v__ast__Type _t8 = v__parser__Parser_parse_map_type(p);
			return _t8;
		}
		if (_SLIT_EQ(name.str, name.len, "chan")) {
			v__ast__Type _t9 = v__parser__Parser_parse_chan_type(p);
			return _t9;
		}
		if (_SLIT_EQ(name.str, name.len, "thread")) {
			v__ast__Type _t10 = v__parser__Parser_parse_thread_type(p);
			return _t10;
		}
		v__ast__Type ret = _const_v__ast__no_type;
		if ((name).len == 0) {
			v__parser__Parser_error(p, _S("expecting type declaration"));
		} else {

			if (_SLIT_EQ(name.str, name.len, "voidptr")) {
				ret = _const_v__ast__voidptr_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "byteptr")) {
				ret = _const_v__ast__byteptr_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "charptr")) {
				ret = _const_v__ast__charptr_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "i8")) {
				ret = _const_v__ast__i8_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "i16")) {
				ret = _const_v__ast__i16_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "i32")) {
				ret = _const_v__ast__i32_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "int")) {
				ret = _const_v__ast__int_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "i64")) {
				ret = _const_v__ast__i64_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "u8")) {
				ret = _const_v__ast__u8_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "u16")) {
				ret = _const_v__ast__u16_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "u32")) {
				ret = _const_v__ast__u32_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "u64")) {
				ret = _const_v__ast__u64_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "f32")) {
				ret = _const_v__ast__f32_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "f64")) {
				ret = _const_v__ast__f64_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "string")) {
				ret = _const_v__ast__string_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "char")) {
				ret = _const_v__ast__char_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "bool")) {
				ret = _const_v__ast__bool_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "float_literal")) {
				ret = _const_v__ast__float_literal_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "int_literal")) {
				ret = _const_v__ast__int_literal_type;
			}
			else if (_SLIT_EQ(name.str, name.len, "any")) {
				ret = _const_v__ast__any_type;
			}
			else {
				v__parser__Parser_next(p);
				if (name.len == 1 && builtin__u8_is_capital(builtin__string_at(name, 0))) {
					v__ast__Type _t11 = v__parser__Parser_parse_generic_type(p, name);
					return _t11;
				}
				if (p->tok.kind == v__token__Kind__lsbr && v__token__Token_is_next_to(p->tok, p->prev_tok)) {
					v__ast__Type _t12 = v__parser__Parser_parse_generic_inst_type(p, name, name_pos);
					return _t12;
				}
				v__ast__Type _t13 = v__parser__Parser_find_type_or_add_placeholder(p, name, language);
				return _t13;
			}
		}
		v__parser__Parser_next(p);
		v__ast__Type _t14 = ret;
		return _t14;
	}
	return 0;
}
VV_LOC v__ast__Type v__parser__Parser_find_type_or_add_placeholder(v__parser__Parser* p, string name, v__ast__Language language) {
	int idx = v__ast__Table_find_type_idx_fn_scoped(p->table, name, p->cur_fn_scope);
	if (idx > 0) {
		v__ast__Type typ = v__ast__new_type(idx);
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
		if (sym->info._typ == 457 /* v.ast.Struct */) {
			if (p->init_generic_types.len > 0 && (*sym->info._v__ast__Struct).generic_types.len > 0 && !Array_v__ast__Type_arr_eq(p->init_generic_types, (*sym->info._v__ast__Struct).generic_types)) {
				_result_Array_string _t1 = v__parser__Parser_types_to_names(p, p->init_generic_types, v__token__Token_pos(&p->tok), _S("struct_init_generic_types"));
				if (_t1.is_error) {
					return _const_v__ast__no_type;
				}
				
 				Array_string generic_names = (*(Array_string*)_t1.data);
				string sym_name = builtin__string__plus(sym->name, _S("<"));
				for (int i = 0; i < generic_names.len; ++i) {
					string gt = ((string*)generic_names.data)[i];
					sym_name = builtin__string__plus(sym_name, gt);
					if (i != (int)(generic_names.len - 1)) {
						sym_name = builtin__string__plus(sym_name, _S(","));
					}
				}
				sym_name = builtin__string__plus(sym_name, _S(">"));
				int existing_idx = (*(int*)builtin__map_get(ADDR(map, p->table->type_idxs), &(string[]){sym_name}, &(int[]){ 0 }));
				if (existing_idx > 0) {
					idx = existing_idx;
				} else {
					idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin__array_clone_to_depth(&p->init_generic_types, 0),.methods = (sym)->methods,.mod = (sym)->mod,.name = sym_name,.cname = (sym)->cname,.rname = sym->name,.ngname = (sym)->ngname,.info = (sym)->info,.align = (sym)->align,.idx = (sym)->idx,.size = (sym)->size,.parent_idx = sym->idx,.kind = (sym)->kind,.language = (sym)->language,.is_pub = (sym)->is_pub,.is_builtin = (sym)->is_builtin,}));
				}
				typ = v__ast__new_type(idx);
			}
		}
		else if (sym->info._typ == 485 /* v.ast.Interface */) {
			if (p->init_generic_types.len > 0 && (*sym->info._v__ast__Interface).generic_types.len > 0 && !Array_v__ast__Type_arr_eq(p->init_generic_types, (*sym->info._v__ast__Interface).generic_types)) {
				_result_Array_string _t3 = v__parser__Parser_types_to_names(p, p->init_generic_types, v__token__Token_pos(&p->tok), _S("struct_init_generic_types"));
				if (_t3.is_error) {
					return _const_v__ast__no_type;
				}
				
 				Array_string generic_names = (*(Array_string*)_t3.data);
				string sym_name = builtin__string__plus(sym->name, _S("<"));
				for (int i = 0; i < generic_names.len; ++i) {
					string gt = ((string*)generic_names.data)[i];
					sym_name = builtin__string__plus(sym_name, gt);
					if (i != (int)(generic_names.len - 1)) {
						sym_name = builtin__string__plus(sym_name, _S(","));
					}
				}
				sym_name = builtin__string__plus(sym_name, _S(">"));
				int existing_idx = (*(int*)builtin__map_get(ADDR(map, p->table->type_idxs), &(string[]){sym_name}, &(int[]){ 0 }));
				if (existing_idx > 0) {
					idx = existing_idx;
				} else {
					idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin__array_clone_to_depth(&p->init_generic_types, 0),.methods = (sym)->methods,.mod = (sym)->mod,.name = sym_name,.cname = (sym)->cname,.rname = sym->name,.ngname = (sym)->ngname,.info = (sym)->info,.align = (sym)->align,.idx = (sym)->idx,.size = (sym)->size,.parent_idx = sym->idx,.kind = (sym)->kind,.language = (sym)->language,.is_pub = (sym)->is_pub,.is_builtin = (sym)->is_builtin,}));
				}
				typ = v__ast__new_type(idx);
			}
		}
		else if (sym->info._typ == 486 /* v.ast.SumType */) {
			if (p->init_generic_types.len > 0 && (*sym->info._v__ast__SumType).generic_types.len > 0 && !Array_v__ast__Type_arr_eq(p->init_generic_types, (*sym->info._v__ast__SumType).generic_types)) {
				_result_Array_string _t5 = v__parser__Parser_types_to_names(p, p->init_generic_types, v__token__Token_pos(&p->tok), _S("struct_init_generic_types"));
				if (_t5.is_error) {
					return _const_v__ast__no_type;
				}
				
 				Array_string generic_names = (*(Array_string*)_t5.data);
				string sym_name = builtin__string__plus(sym->name, _S("<"));
				for (int i = 0; i < generic_names.len; ++i) {
					string gt = ((string*)generic_names.data)[i];
					sym_name = builtin__string__plus(sym_name, gt);
					if (i != (int)(generic_names.len - 1)) {
						sym_name = builtin__string__plus(sym_name, _S(","));
					}
				}
				sym_name = builtin__string__plus(sym_name, _S(">"));
				int existing_idx = (*(int*)builtin__map_get(ADDR(map, p->table->type_idxs), &(string[]){sym_name}, &(int[]){ 0 }));
				if (existing_idx > 0) {
					idx = existing_idx;
				} else {
					idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin__array_clone_to_depth(&p->init_generic_types, 0),.methods = (sym)->methods,.mod = (sym)->mod,.name = sym_name,.cname = (sym)->cname,.rname = sym->name,.ngname = (sym)->ngname,.info = (sym)->info,.align = (sym)->align,.idx = (sym)->idx,.size = (sym)->size,.parent_idx = sym->idx,.kind = (sym)->kind,.language = (sym)->language,.is_pub = (sym)->is_pub,.is_builtin = (sym)->is_builtin,}));
				}
				typ = v__ast__new_type(idx);
			}
		}
		else if (sym->info._typ == 495 /* v.ast.FnType */) {
			if (p->init_generic_types.len > 0 && (*sym->info._v__ast__FnType).func.generic_names.len > 0) {
				_result_Array_string _t7 = v__parser__Parser_types_to_names(p, p->init_generic_types, v__token__Token_pos(&p->tok), _S("struct_init_generic_types"));
				if (_t7.is_error) {
					return _const_v__ast__no_type;
				}
				
 				Array_string generic_names = (*(Array_string*)_t7.data);
				if (!Array_string_arr_eq(generic_names, (*sym->info._v__ast__FnType).func.generic_names)) {
					string sym_name = builtin__string__plus(sym->name, _S("<"));
					for (int i = 0; i < generic_names.len; ++i) {
						string gt = ((string*)generic_names.data)[i];
						sym_name = builtin__string__plus(sym_name, gt);
						if (i != (int)(generic_names.len - 1)) {
							sym_name = builtin__string__plus(sym_name, _S(","));
						}
					}
					sym_name = builtin__string__plus(sym_name, _S(">"));
					int existing_idx = (*(int*)builtin__map_get(ADDR(map, p->table->type_idxs), &(string[]){sym_name}, &(int[]){ 0 }));
					if (existing_idx > 0) {
						idx = existing_idx;
					} else {
						v__ast__Fn func = (*sym->info._v__ast__FnType).func;
						func.name = sym_name;
						func.generic_names = builtin__array_clone_to_depth(&generic_names, 1);
						if (v__ast__Type_has_flag(func.return_type, v__ast__TypeFlag__generic)) {
							_option_v__ast__Type _t9;
							if (_t9 = v__ast__Table_convert_generic_type(p->table, func.return_type, (*sym->info._v__ast__FnType).func.generic_names, p->init_generic_types), _t9.state == 0) {
								v__ast__Type to_generic_typ = *(v__ast__Type*)_t9.data;
								func.return_type = to_generic_typ;
							}
						}
						for (int i = 0; i < func.params.len; ++i) {
							if (v__ast__Type_has_flag((*(v__ast__Param*)builtin__array_get(func.params, i)).typ, v__ast__TypeFlag__generic)) {
								_option_v__ast__Type _t10;
								if (_t10 = v__ast__Table_convert_generic_type(p->table, (*(v__ast__Param*)builtin__array_get(func.params, i)).typ, (*sym->info._v__ast__FnType).func.generic_names, p->init_generic_types), _t10.state == 0) {
									v__ast__Type to_generic_typ = *(v__ast__Type*)_t10.data;
									(*(v__ast__Param*)builtin__array_get(func.params, i)).typ = to_generic_typ;
								}
							}
						}
						idx = v__ast__Table_find_or_register_fn_type(p->table, func, false, false);
					}
					typ = v__ast__new_type(idx);
				}
			}
		}
		
		else {
		}
		
		return typ;
	}
	idx = v__ast__Table_add_placeholder_type(p->table, name, name, language);
	return v__ast__new_type(idx);
}
VV_LOC v__ast__Type v__parser__Parser_parse_generic_type(v__parser__Parser* p, string name) {
	int idx = v__ast__Table_find_type_idx(p->table, name);
	if (idx > 0) {
		return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
	}
	idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.name = name,.cname = v__util__no_dots(name),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__any,.language = 0,.is_pub = true,.is_builtin = 0,}));
	return v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic);
}
VV_LOC v__ast__Type v__parser__Parser_parse_generic_inst_type(v__parser__Parser* p, string name, v__token__Pos name_pos) {
	p->generic_type_level++;
	if (p->generic_type_level > 10) {
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("too many levels of Parser.parse_generic_inst_type() calls: "), 0xfe07, {.d_i32 = p->generic_type_level}}, {_S(", probably due to too many layers embedded generic type"), 0, { .d_c = 0 }}})));
		v__ast__Type _t1 = _const_v__ast__void_type;
			{ // defer begin
				p->generic_type_level--;
			} // defer end
		return _t1;
	}
	string bs_name = name;
	string bs_cname = name;
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	p->inside_generic_params = true;
	bs_name = builtin__string__plus(bs_name, _S("["));
	bs_cname = builtin__string__plus(bs_cname, _S("_T_"));
	Array_v__ast__Type concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	bool is_instance = true;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__token__Pos type_pos = v__token__Token_pos(&p->tok);
		v__ast__Type gt = v__parser__Parser_parse_type(p);
		type_pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->prev_tok));
		if (v__ast__Type_has_flag(gt, v__ast__TypeFlag__generic)) {
			is_instance = false;
		}
		if (gt == 0) {
			v__ast__Type _t2 = _const_v__ast__void_type;
				{ // defer begin
					p->generic_type_level--;
				} // defer end
			return _t2;
		}
		v__ast__TypeSymbol* gts = v__ast__Table_sym(p->table, gt);
		if (gts->kind == v__ast__Kind__multi_return) {
			v__parser__Parser_error_with_pos(p, _S("cannot use multi return as generic concrete type"), type_pos);
		}
		if (v__ast__Type_is_ptr(gt)) {
			bs_name = builtin__string__plus(bs_name, _S("&"));
		}
		bs_name = builtin__string__plus(bs_name, gts->name);
		bs_cname = builtin__string__plus(bs_cname, gts->cname);
		builtin__array_push((array*)&concrete_types, _MOV((v__ast__Type[]){ gt }));
		if (p->tok.kind != v__token__Kind__comma) {
			break;
		}
		v__parser__Parser_next(p);
		bs_name = builtin__string__plus(bs_name, _S(", "));
		bs_cname = builtin__string__plus(bs_cname, _S("_"));
	}
	if (!is_instance) {
		p->init_generic_types = concrete_types;
	}
	v__token__Pos concrete_types_pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->tok));
	v__parser__Parser_next(p);
	p->inside_generic_params = false;
	bs_name = builtin__string__plus(bs_name, _S("]"));
	if ((is_instance || p->pref->is_fmt) && concrete_types.len > 0) {
		int gt_idx = v__ast__Table_find_type_idx(p->table, bs_name);
		if (gt_idx > 0) {
			v__ast__Type _t4 = v__ast__new_type(gt_idx);
				{ // defer begin
					p->generic_type_level--;
				} // defer end
			return _t4;
		}
		gt_idx = v__ast__Table_add_placeholder_type(p->table, bs_name, bs_cname, v__ast__Language__v);
		int parent_idx = (*(int*)builtin__map_get(ADDR(map, p->table->type_idxs), &(string[]){name}, &(int[]){ 0 }));
		if (parent_idx == 0) {
			parent_idx = v__ast__Table_add_placeholder_type(p->table, name, name, v__ast__Language__v);
		}
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(p->table, v__ast__new_type(parent_idx));
		if (parent_sym->info._typ == 457 /* v.ast.Struct */) {
			if ((*parent_sym->info._v__ast__Struct).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("struct `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is not a generic struct, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__Struct).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of struct `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		else if (parent_sym->info._typ == 485 /* v.ast.Interface */) {
			if ((*parent_sym->info._v__ast__Interface).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("interface `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is not a generic interface, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__Interface).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of interface `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		else if (parent_sym->info._typ == 486 /* v.ast.SumType */) {
			if ((*parent_sym->info._v__ast__SumType).generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sumtype `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is not a generic sumtype, cannot instantiate to the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			} else if ((*parent_sym->info._v__ast__SumType).generic_types.len != concrete_types.len) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the number of generic types of sumtype `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("` is inconsistent with the concrete types"), 0, { .d_c = 0 }}})), concrete_types_pos);
			}
		}
		
		else {
			if (parent_sym->kind == v__ast__Kind__placeholder && p->inside_struct_field_decl && !builtin__u8_is_capital(builtin__string_at(builtin__string_all_after_last(parent_sym->name, _S(".")), 0))) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown type `"), 0xfe10, {.d_s = parent_sym->name}}, {_S("`"), 0, { .d_c = 0 }}})), name_pos);
			}
		}
		
		string mod = builtin__string_all_before_last(name, _S("."));
		int idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = mod,.name = bs_name,.cname = v__util__no_dots(bs_cname),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = v__ast__GenericInst_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__GenericInst, (((v__ast__GenericInst){.parent_idx = parent_idx,.concrete_types = concrete_types,}))), false),.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__generic_inst,.language = 0,.is_pub = 0,.is_builtin = 0,}));
		v__ast__Type _t5 = v__ast__new_type(idx);
			{ // defer begin
				p->generic_type_level--;
			} // defer end
		return _t5;
	}
	v__ast__Type _t6 = v__ast__Type_set_flag(v__parser__Parser_find_type_or_add_placeholder(p, name, v__ast__Language__v), v__ast__TypeFlag__generic);
		{ // defer begin
			p->generic_type_level--;
		} // defer end
	return _t6;
}
VV_LOC _result_Array_string v__parser__Parser_types_to_names(v__parser__Parser* p, Array_v__ast__Type types, v__token__Pos pos, string error_label) {
	Array_string res = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < types.len; ++_t1) {
		v__ast__Type t = ((v__ast__Type*)types.data)[_t1];
		if (t == 0) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("unknown type found, "), 0xfe10, {.d_s = error_label}}, {_S(": "), 0xfe10, {.d_s = Array_v__ast__Type_str(types)}}, {_SLIT0, 0, { .d_c = 0 }}})), pos);
			return (_result_Array_string){ .is_error=true, .err=builtin___v_error(_S("unknown 0 type")), .data={E_STRUCT} };
		}
		builtin__array_push((array*)&res, _MOV((string[]){ builtin__string_clone(v__ast__Table_sym(p->table, t)->name) }));
	}
	_result_Array_string _t4;
	builtin___result_ok(&(Array_string[]) { res }, (_result*)(&_t4), sizeof(Array_string));
	 
	return _t4;
}
v__ast__Stmt v__parser__parse_stmt(string text, v__ast__Table* table, v__ast__Scope* scope) {
	v__parser__Parser *p = HEAP(v__parser__Parser, (((v__parser__Parser){
		.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
		.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imports = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),
		.tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.prev_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.peek_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.script_mode_start_token = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.warnings = builtin____new_array(0, 0, sizeof(v__errors__Warning)),
		.errors = builtin____new_array(0, 0, sizeof(v__errors__Error)),
		.init_generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.implied_imports = builtin____new_array(0, 0, sizeof(string)),
		.auto_imports = builtin____new_array(0, 0, sizeof(string)),
		.used_imports = builtin____new_array(0, 0, sizeof(string)),
		.ast_imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),
		.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
		.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),
		.template_paths = builtin____new_array(0, 0, sizeof(string)),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.cur_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.left_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.if_cond_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.defer_vars = builtin____new_array(0, 0, sizeof(v__ast__Ident)),
		.global_labels = builtin____new_array(0, 0, sizeof(string)),
		.label_names = builtin____new_array(0, 0, sizeof(string)),
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = (string){.str=(byteptr)"", .is_lit=1},
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_display_path = (string){.str=(byteptr)"", .is_lit=1},
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_mod = (string){.str=(byteptr)"", .is_lit=1},
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
		.pref = ((v__pref__Preferences*)builtin__memdup(&(v__pref__Preferences){.cache_manager = ((v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.linfo = ((v__pref__LineInfo){.method = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.vars_printed = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.compile_values = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.file_list = builtin____new_array(0, 0, sizeof(string)),.compile_defines = builtin____new_array(0, 0, sizeof(string)),.compile_defines_all = builtin____new_array(0, 0, sizeof(string)),.profile_fns = builtin____new_array(0, 0, sizeof(string)),.run_only = builtin____new_array(0, 0, sizeof(string)),.cleanup_files = builtin____new_array(0, 0, sizeof(string)),.trace_fns = builtin____new_array(0, 0, sizeof(string)),.run_args = builtin____new_array(0, 0, sizeof(string)),.printfn_list = builtin____new_array(0, 0, sizeof(string)),.vmodules_paths = builtin____new_array(0, 0, sizeof(string)),.build_options = builtin____new_array(0, 0, sizeof(string)),.lookup_path = builtin____new_array(0, 0, sizeof(string)),.exclude = builtin____new_array(0, 0, sizeof(string)),.dump_defines = (string){.str=(byteptr)"", .is_lit=1},.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.line_info = (string){.str=(byteptr)"", .is_lit=1},.ldflags = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.cppcompiler = (string){.str=(byteptr)"", .is_lit=1},.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.coverage_dir = (string){.str=(byteptr)"", .is_lit=1},.raw_vsh_tmp_prefix = (string){.str=(byteptr)"", .is_lit=1},.print_autofree_vars_in_fn = (string){.str=(byteptr)"", .is_lit=1},.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.dump_modules = (string){.str=(byteptr)"", .is_lit=1},.dump_files = (string){.str=(byteptr)"", .is_lit=1},.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.vlib = (string){.str=(byteptr)"", .is_lit=1},.eval_argument = (string){.str=(byteptr)"", .is_lit=1},.cmain = (string){.str=(byteptr)"", .is_lit=1},.test_runner = (string){.str=(byteptr)"", .is_lit=1},.macosx_version_min = _S("0"),.cflags = (string){.str=(byteptr)"", .is_lit=1},.vroot = (string){.str=(byteptr)"", .is_lit=1},.message_limit = 200,.checker_match_exhaustive_cutoff_limit = 12,.thread_stack_size = 8388608,.wasm_stack_top = (int_literal)(1024 + 16384),.os = 0,.arch = 0,.backend = 0,.ccompiler_type = 0,.gc_mode = v__pref__GarbageCollectionMode__unknown,.assert_failure_mode = 0,.subsystem = 0,.use_color = 0,.output_mode = v__pref__OutputMode__stdout,.build_mode = 0,.building_v = 0,.no_bounds_checking = 0,.force_bounds_checking = 0,.autofree = 0,.print_autofree_vars = 0,.trace_calls = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_bare = 0,.no_preludes = 0,.no_closures = 0,.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.print_v_files = 0,.print_watched_files = 0,.skip_running = 0,.skip_warnings = 0,.skip_notes = 0,.warn_impure_v = 0,.warns_are_errors = 0,.notes_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.no_parallel = 0,.parallel_cc = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.nofloat = 0,.use_coroutines = 0,.fast_math = 0,.wasm_validate = 0,.warn_about_allocs = 0,.div_by_zero_is_zero = 0,.relaxed_gcc14 = true,.is_vls = 0,.json_errors = 0,.new_transform = 0,.new_generic_solver = 0,.backend_set_by_flag = 0,.is_verbose = 0,.is_glibc = 0,.is_musl = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.is_prod = 0,.no_prod_options = 0,.is_repl = 0,.is_eval_argument = 0,.is_run = 0,.is_crun = 0,.is_debug = 0,.is_vlines = 0,.is_stats = 0,.show_asserts = 0,.show_timings = 0,.is_fmt = 0,.is_vet = 0,.is_vweb = 0,.is_ios_simulator = 0,.is_apk = 0,.is_help = 0,.is_quiet = 0,.is_cstrict = 0,.is_callstack = 0,.is_trace = 0,.is_coverage = 0,.is_check_return = 0,.is_check_overflow = 0,.profile_no_inline = 0,.translated = 0,.translated_go = true,.obfuscate_removed = 0,.hide_auto_str = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.show_unused_params = 0,.use_cache = 0,.retry_compilation = true,.use_os_system_to_run = 0,.m64 = 0,}, sizeof(v__pref__Preferences))),
		.table = table,
		.cur_fn_scope = ((void*)0),
		.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode__skip_comments, ((v__pref__Preferences*)builtin__memdup(&(v__pref__Preferences){.cache_manager = ((v__vcache__CacheManager){.basepath = (string){.str=(byteptr)"", .is_lit=1},.original_vopts = (string){.str=(byteptr)"", .is_lit=1},.vopts = (string){.str=(byteptr)"", .is_lit=1},.k2cpath = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.linfo = ((v__pref__LineInfo){.method = 0,.path = (string){.str=(byteptr)"", .is_lit=1},.line_nr = 0,.col = 0,.vars_printed = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}),.compile_values = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.file_list = builtin____new_array(0, 0, sizeof(string)),.compile_defines = builtin____new_array(0, 0, sizeof(string)),.compile_defines_all = builtin____new_array(0, 0, sizeof(string)),.profile_fns = builtin____new_array(0, 0, sizeof(string)),.run_only = builtin____new_array(0, 0, sizeof(string)),.cleanup_files = builtin____new_array(0, 0, sizeof(string)),.trace_fns = builtin____new_array(0, 0, sizeof(string)),.run_args = builtin____new_array(0, 0, sizeof(string)),.printfn_list = builtin____new_array(0, 0, sizeof(string)),.vmodules_paths = builtin____new_array(0, 0, sizeof(string)),.build_options = builtin____new_array(0, 0, sizeof(string)),.lookup_path = builtin____new_array(0, 0, sizeof(string)),.exclude = builtin____new_array(0, 0, sizeof(string)),.dump_defines = (string){.str=(byteptr)"", .is_lit=1},.custom_prelude = (string){.str=(byteptr)"", .is_lit=1},.out_name_c = (string){.str=(byteptr)"", .is_lit=1},.out_name = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.line_info = (string){.str=(byteptr)"", .is_lit=1},.ldflags = (string){.str=(byteptr)"", .is_lit=1},.profile_file = (string){.str=(byteptr)"", .is_lit=1},.ccompiler = (string){.str=(byteptr)"", .is_lit=1},.cppcompiler = (string){.str=(byteptr)"", .is_lit=1},.third_party_option = (string){.str=(byteptr)"", .is_lit=1},.coverage_dir = (string){.str=(byteptr)"", .is_lit=1},.raw_vsh_tmp_prefix = (string){.str=(byteptr)"", .is_lit=1},.print_autofree_vars_in_fn = (string){.str=(byteptr)"", .is_lit=1},.dump_c_flags = (string){.str=(byteptr)"", .is_lit=1},.dump_modules = (string){.str=(byteptr)"", .is_lit=1},.dump_files = (string){.str=(byteptr)"", .is_lit=1},.bare_builtin_dir = (string){.str=(byteptr)"", .is_lit=1},.vlib = (string){.str=(byteptr)"", .is_lit=1},.eval_argument = (string){.str=(byteptr)"", .is_lit=1},.cmain = (string){.str=(byteptr)"", .is_lit=1},.test_runner = (string){.str=(byteptr)"", .is_lit=1},.macosx_version_min = _S("0"),.cflags = (string){.str=(byteptr)"", .is_lit=1},.vroot = (string){.str=(byteptr)"", .is_lit=1},.message_limit = 200,.checker_match_exhaustive_cutoff_limit = 12,.thread_stack_size = 8388608,.wasm_stack_top = (int_literal)(1024 + 16384),.os = 0,.arch = 0,.backend = 0,.ccompiler_type = 0,.gc_mode = v__pref__GarbageCollectionMode__unknown,.assert_failure_mode = 0,.subsystem = 0,.use_color = 0,.output_mode = v__pref__OutputMode__stdout,.build_mode = 0,.building_v = 0,.no_bounds_checking = 0,.force_bounds_checking = 0,.autofree = 0,.print_autofree_vars = 0,.trace_calls = 0,.compress = 0,.no_builtin = 0,.enable_globals = 0,.is_bare = 0,.no_preludes = 0,.no_closures = 0,.output_cross_c = 0,.output_es5 = 0,.prealloc = 0,.print_v_files = 0,.print_watched_files = 0,.skip_running = 0,.skip_warnings = 0,.skip_notes = 0,.warn_impure_v = 0,.warns_are_errors = 0,.notes_are_errors = 0,.fatal_errors = 0,.reuse_tmpc = 0,.no_rsp = 0,.no_std = 0,.no_parallel = 0,.parallel_cc = 0,.only_check_syntax = 0,.check_only = 0,.experimental = 0,.skip_unused = 0,.nofloat = 0,.use_coroutines = 0,.fast_math = 0,.wasm_validate = 0,.warn_about_allocs = 0,.div_by_zero_is_zero = 0,.relaxed_gcc14 = true,.is_vls = 0,.json_errors = 0,.new_transform = 0,.new_generic_solver = 0,.backend_set_by_flag = 0,.is_verbose = 0,.is_glibc = 0,.is_musl = 0,.is_test = 0,.is_script = 0,.is_vsh = 0,.is_livemain = 0,.is_liveshared = 0,.is_shared = 0,.is_o = 0,.is_prof = 0,.is_prod = 0,.no_prod_options = 0,.is_repl = 0,.is_eval_argument = 0,.is_run = 0,.is_crun = 0,.is_debug = 0,.is_vlines = 0,.is_stats = 0,.show_asserts = 0,.show_timings = 0,.is_fmt = 0,.is_vet = 0,.is_vweb = 0,.is_ios_simulator = 0,.is_apk = 0,.is_help = 0,.is_quiet = 0,.is_cstrict = 0,.is_callstack = 0,.is_trace = 0,.is_coverage = 0,.is_check_return = 0,.is_check_overflow = 0,.profile_no_inline = 0,.translated = 0,.translated_go = true,.obfuscate_removed = 0,.hide_auto_str = 0,.sanitize = 0,.sourcemap = 0,.sourcemap_inline = true,.sourcemap_src_included = 0,.show_cc = 0,.show_c_output = 0,.show_callgraph = 0,.show_depgraph = 0,.show_unused_params = 0,.use_cache = 0,.retry_compilation = true,.use_os_system_to_run = 0,.m64 = 0,}, sizeof(v__pref__Preferences)))),
		.scope = scope,
		.generic_type_level = 0,
		.expr_level = 0,
		.max_opened_scopes = 100,
		.opened_scopes = 0,
		.array_dim = 0,
		.n_asm = 0,
		.fixed_array_dim = 0,
		.file_idx = 0,
		.fn_language = 0,
		.language = 0,
		.file_backend_mode = 0,
		.struct_language = 0,
		.content = v__parser__ParseContentKind__stmt,
		.defer_mode = 0,
		.inside_lock_exprs = 0,
		.inside_chan_decl = 0,
		.inside_orm = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.inside_map_init = 0,
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.is_translated = 0,
		.inside_struct_attr_decl = 0,
		.inside_struct_field_decl = 0,
		.inside_receiver_param = 0,
		.inside_generic_params = 0,
		.inside_defer = 0,
		.inside_asm = 0,
		.inside_asm_template = 0,
		.inside_sum_type = 0,
		.inside_unsafe = 0,
		.inside_ct_match_body = 0,
		.inside_ct_match_case = 0,
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.expecting_value = true,
		.inside_ct_match = 0,
		.inside_match_body = 0,
		.inside_match_case = 0,
		.name_error = 0,
		.inside_select = 0,
		.inside_match = 0,
		.comptime_if_cond = 0,
		.inside_assign_rhs = 0,
		.should_abort = 0,
		.inside_infix = 0,
		.inside_in_array = 0,
		.inside_array_lit = 0,
		.inside_str_interp = 0,
		.inside_unsafe_fn = 0,
		.script_mode = 0,
		.inside_call_args = 0,
		.inside_fn_concrete_type = 0,
		.main_already_defined = 0,
		.is_vls = 0,
		.is_vls_skip_file = 0,
		.inside_import_section = 0,
		.inside_fn_return = 0,
		.inside_fn = 0,
		.inside_for_expr = 0,
		.inside_for = 0,
		.inside_or_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_if_cond = 0,
		.inside_if_expr = 0,
		.inside_comptime_if = 0,
		.inside_if = 0,
		.inside_test_file = true,
		.inside_attr_decl = 0,
		.inside_vlib_file = 0,
	})));
	v__parser__Parser_init_parse_fns(&(*(p)));
	v__util__timing_start(_S("PARSE stmt"));
	v__parser__Parser_read_first_token(&(*(p)));
	v__ast__Stmt _t1 = v__parser__Parser_stmt(&(*(p)), false);
		{ // defer begin
			v__util__timing_measure_cumulative(_S("PARSE stmt"));
		} // defer end
	return _t1;
}
v__ast__File* v__parser__parse_comptime(string tmpl_path, string text, v__ast__Table* table, v__pref__Preferences* pref_, v__ast__Scope* scope) {
	v__parser__Parser *p = HEAP(v__parser__Parser, (((v__parser__Parser){
		.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
		.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imports = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),
		.tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.prev_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.peek_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.script_mode_start_token = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.warnings = builtin____new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.errors = builtin____new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.init_generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.implied_imports = builtin____new_array(0, 0, sizeof(string)),
		.auto_imports = builtin____new_array(0, 0, sizeof(string)),
		.used_imports = builtin____new_array(0, 0, sizeof(string)),
		.ast_imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),
		.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
		.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),
		.template_paths = builtin____new_array(0, 0, sizeof(string)),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.cur_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.left_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.if_cond_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.defer_vars = builtin____new_array(0, 0, sizeof(v__ast__Ident)),
		.global_labels = builtin____new_array(0, 0, sizeof(string)),
		.label_names = builtin____new_array(0, 0, sizeof(string)),
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = tmpl_path,
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_display_path = (string){.str=(byteptr)"", .is_lit=1},
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_mod = (string){.str=(byteptr)"", .is_lit=1},
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref_,
		.table = table,
		.cur_fn_scope = ((void*)0),
		.scanner = v__scanner__new_scanner(text, v__scanner__CommentsMode__skip_comments, pref_),
		.scope = scope,
		.generic_type_level = 0,
		.expr_level = 0,
		.max_opened_scopes = 100,
		.opened_scopes = 0,
		.array_dim = 0,
		.n_asm = 0,
		.fixed_array_dim = 0,
		.file_idx = 0,
		.fn_language = 0,
		.language = 0,
		.file_backend_mode = 0,
		.struct_language = 0,
		.content = v__parser__ParseContentKind__comptime,
		.defer_mode = 0,
		.inside_lock_exprs = 0,
		.inside_chan_decl = 0,
		.inside_orm = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.inside_map_init = 0,
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.is_translated = 0,
		.inside_struct_attr_decl = 0,
		.inside_struct_field_decl = 0,
		.inside_receiver_param = 0,
		.inside_generic_params = 0,
		.inside_defer = 0,
		.inside_asm = 0,
		.inside_asm_template = 0,
		.inside_sum_type = 0,
		.inside_unsafe = 0,
		.inside_ct_match_body = 0,
		.inside_ct_match_case = 0,
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.expecting_value = true,
		.inside_ct_match = 0,
		.inside_match_body = 0,
		.inside_match_case = 0,
		.name_error = 0,
		.inside_select = 0,
		.inside_match = 0,
		.comptime_if_cond = 0,
		.inside_assign_rhs = 0,
		.should_abort = 0,
		.inside_infix = 0,
		.inside_in_array = 0,
		.inside_array_lit = 0,
		.inside_str_interp = 0,
		.inside_unsafe_fn = 0,
		.script_mode = 0,
		.inside_call_args = 0,
		.inside_fn_concrete_type = 0,
		.main_already_defined = 0,
		.is_vls = 0,
		.is_vls_skip_file = 0,
		.inside_import_section = 0,
		.inside_fn_return = 0,
		.inside_fn = 0,
		.inside_for_expr = 0,
		.inside_for = 0,
		.inside_or_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_if_cond = 0,
		.inside_if_expr = 0,
		.inside_comptime_if = 0,
		.inside_if = 0,
		.inside_test_file = 0,
		.inside_attr_decl = 0,
		.inside_vlib_file = 0,
	})));
	v__ast__File* res = v__parser__Parser_parse(&(*(p)));
	v__parser__Parser_free_scanner(&(*(p)));
	res->is_template_text = true;
	return res;
}
v__ast__File* v__parser__parse_text(string text, string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_) {
	v__parser__Parser *p = HEAP(v__parser__Parser, (((v__parser__Parser){
		.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
		.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imports = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),
		.tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.prev_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.peek_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.script_mode_start_token = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.warnings = builtin____new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.errors = builtin____new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.init_generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.implied_imports = builtin____new_array(0, 0, sizeof(string)),
		.auto_imports = builtin____new_array(0, 0, sizeof(string)),
		.used_imports = builtin____new_array(0, 0, sizeof(string)),
		.ast_imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),
		.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
		.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),
		.template_paths = builtin____new_array(0, 0, sizeof(string)),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.cur_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.left_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.if_cond_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.defer_vars = builtin____new_array(0, 0, sizeof(v__ast__Ident)),
		.global_labels = builtin____new_array(0, 0, sizeof(string)),
		.label_names = builtin____new_array(0, 0, sizeof(string)),
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = (string){.str=(byteptr)"", .is_lit=1},
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_display_path = (string){.str=(byteptr)"", .is_lit=1},
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_mod = (string){.str=(byteptr)"", .is_lit=1},
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref_,
		.table = table,
		.cur_fn_scope = ((void*)0),
		.scanner = v__scanner__new_scanner(text, comments_mode, pref_),
		.scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = table->global_scope,.detached_from_parent = 0,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope))),
		.generic_type_level = 0,
		.expr_level = 0,
		.max_opened_scopes = 100,
		.opened_scopes = 0,
		.array_dim = 0,
		.n_asm = 0,
		.fixed_array_dim = 0,
		.file_idx = 0,
		.fn_language = 0,
		.language = 0,
		.file_backend_mode = 0,
		.struct_language = 0,
		.content = v__parser__ParseContentKind__text,
		.defer_mode = 0,
		.inside_lock_exprs = 0,
		.inside_chan_decl = 0,
		.inside_orm = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.inside_map_init = 0,
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.is_translated = 0,
		.inside_struct_attr_decl = 0,
		.inside_struct_field_decl = 0,
		.inside_receiver_param = 0,
		.inside_generic_params = 0,
		.inside_defer = 0,
		.inside_asm = 0,
		.inside_asm_template = 0,
		.inside_sum_type = 0,
		.inside_unsafe = 0,
		.inside_ct_match_body = 0,
		.inside_ct_match_case = 0,
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.expecting_value = true,
		.inside_ct_match = 0,
		.inside_match_body = 0,
		.inside_match_case = 0,
		.name_error = 0,
		.inside_select = 0,
		.inside_match = 0,
		.comptime_if_cond = 0,
		.inside_assign_rhs = 0,
		.should_abort = 0,
		.inside_infix = 0,
		.inside_in_array = 0,
		.inside_array_lit = 0,
		.inside_str_interp = 0,
		.inside_unsafe_fn = 0,
		.script_mode = 0,
		.inside_call_args = 0,
		.inside_fn_concrete_type = 0,
		.main_already_defined = 0,
		.is_vls = pref_->is_vls,
		.is_vls_skip_file = pref_->is_vls && !builtin__string__eq(path, pref_->path),
		.inside_import_section = 0,
		.inside_fn_return = 0,
		.inside_fn = 0,
		.inside_for_expr = 0,
		.inside_for = 0,
		.inside_or_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_if_cond = 0,
		.inside_if_expr = 0,
		.inside_comptime_if = 0,
		.inside_if = 0,
		.inside_test_file = 0,
		.inside_attr_decl = 0,
		.inside_vlib_file = 0,
	})));
	v__parser__Parser_set_path(&(*(p)), path);
	v__ast__File* res = v__parser__Parser_parse(&(*(p)));
	v__parser__Parser_free_scanner(&(*(p)));
	res->is_parse_text = true;
	return res;
}
void v__parser__Parser_free(v__parser__Parser* p) {
	v__parser__Parser_free_scanner(p);
}
VV_LOC void v__parser__Parser_free_scanner(v__parser__Parser* p) {
	{ // Unsafe block
		if (p->scanner != 0) {
			v__scanner__Scanner_free(p->scanner);
			p->scanner = ((v__scanner__Scanner*)(((void*)0)));
		}
	}
}
void v__parser__Parser_set_path(v__parser__Parser* p, string path) {
	p->file_path = path;
	p->file_base = os__base(path);
	p->file_display_path = builtin__string_replace(builtin__string_replace_once(os__real_path(p->file_path), _const_v__parser__normalised_working_folder, _S("")), _S("\\"), _S("/"));
	p->inside_vlib_file = builtin__string_contains(os__dir(path), _S("vlib"));
	p->inside_test_file = builtin__string_ends_with(p->file_base, _S("_test.v")) || builtin__string_ends_with(p->file_base, _S("_test.vv")) || builtin__string_ends_with(builtin__string_all_before_last(builtin__string_all_before_last(p->file_base, _S(".v")), _S(".")), _S("_test"));
	u64 hash = hash__fnv1a__sum64_string(path);
	p->unique_prefix = builtin__u64_hex_full(hash);
	p->file_backend_mode = v__ast__Language__v;
	string before_dot_v = builtin__string_all_before_last(path, _S(".v"));
	string language = builtin__string_all_after_last(before_dot_v, _S("."));
	string language_with_underscore = builtin__string_all_after_last(before_dot_v, _S("_"));
	if (builtin__string__eq(language, before_dot_v) && builtin__string__eq(language_with_underscore, before_dot_v)) {
		return;
	}
	string actual_language = (builtin__string__eq(language, before_dot_v) ? (language_with_underscore) : (language));

	if (_SLIT_EQ(actual_language.str, actual_language.len, "c")) {
		p->file_backend_mode = v__ast__Language__c;
	}
	else if (_SLIT_EQ(actual_language.str, actual_language.len, "js")) {
		p->file_backend_mode = v__ast__Language__js;
	}
	else {
		_result_v__pref__Arch _t1 = v__pref__arch_from_string(actual_language);
		if (_t1.is_error) {
			*(v__pref__Arch*) _t1.data = v__pref__Arch___auto;
		}
		
 		v__pref__Arch arch = (*(v__pref__Arch*)_t1.data);
		p->file_backend_mode = v__ast__pref_arch_to_table_language(arch);
		if (arch == v__pref__Arch___auto) {
			p->file_backend_mode = v__ast__Language__v;
		}
	}
}
VV_LOC bool v__parser__should_skip_vls_file(v__pref__Preferences* pref_, string path) {
	if (!pref_->is_vls) {
		return false;
	}
	if ((pref_->line_info).len != 0) {
		string project_dir = (os__is_dir(pref_->path) ? (os__real_path(pref_->path)) : (os__real_path(os__dir(pref_->linfo.path))));
		return !builtin__string_starts_with(os__real_path(path), project_dir);
	}
	return !builtin__string__eq(path, pref_->path);
}
v__ast__File* v__parser__parse_file(string path, v__ast__Table* table, v__scanner__CommentsMode comments_mode, v__pref__Preferences* pref_) {
	i16 file_idx = ((i16)(Array_string_index(table->filelist, path)));
	if (file_idx == -1) {
		file_idx = ((i16)(table->filelist.len));
		builtin__array_push((array*)&table->filelist, _MOV((string[]){ builtin__string_clone(path) }));
	}
		_result_v__scanner__Scanner_ptr _t2 = v__scanner__new_scanner_file(path, file_idx, comments_mode, pref_);
		if (_t2.is_error) {
			IError err = _t2.err;
			builtin___v_panic(builtin__IError_str(err));
			VUNREACHABLE();
		;
		}
		
 	v__parser__Parser *p = HEAP(v__parser__Parser, (((v__parser__Parser){
		.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
		.imported_symbols = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_used = builtin__new_map(sizeof(string), sizeof(bool), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imports = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
		.imported_symbols_trie = ((v__token__KeywordsMatcherTrie){.nodes = builtin____new_array(0, 0, sizeof(v__token__TrieNode*)),.min_len = 999999,.max_len = 0,}),
		.tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.prev_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.peek_tok = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.script_mode_start_token = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,}),
		.warnings = builtin____new_array_with_default(0, 0, sizeof(v__errors__Warning), 0),
		.errors = builtin____new_array_with_default(0, 0, sizeof(v__errors__Error), 0),
		.init_generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.implied_imports = builtin____new_array(0, 0, sizeof(string)),
		.auto_imports = builtin____new_array(0, 0, sizeof(string)),
		.used_imports = builtin____new_array(0, 0, sizeof(string)),
		.ast_imports = builtin____new_array(0, 0, sizeof(v__ast__Import)),
		.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
		.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),
		.template_paths = builtin____new_array(0, 0, sizeof(string)),
		.notices = builtin____new_array(0, 0, sizeof(v__errors__Notice)),
		.cur_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.left_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.if_cond_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
		.defer_vars = builtin____new_array(0, 0, sizeof(v__ast__Ident)),
		.global_labels = builtin____new_array(0, 0, sizeof(string)),
		.label_names = builtin____new_array(0, 0, sizeof(string)),
		.unique_prefix = (string){.str=(byteptr)"", .is_lit=1},
		.cur_fn_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_name = (string){.str=(byteptr)"", .is_lit=1},
		.file_path = (string){.str=(byteptr)"", .is_lit=1},
		.mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_display_path = (string){.str=(byteptr)"", .is_lit=1},
		.expr_mod = (string){.str=(byteptr)"", .is_lit=1},
		.file_base = (string){.str=(byteptr)"", .is_lit=1},
		.last_enum_mod = (string){.str=(byteptr)"", .is_lit=1},
		.codegen_text = (string){.str=(byteptr)"", .is_lit=1},
		.pref = pref_,
		.table = table,
		.cur_fn_scope = ((void*)0),
		.scanner = (*(v__scanner__Scanner**)_t2.data),
		.scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = table->global_scope,.detached_from_parent = 0,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope))),
		.generic_type_level = 0,
		.expr_level = 0,
		.max_opened_scopes = 100,
		.opened_scopes = 0,
		.array_dim = 0,
		.n_asm = 0,
		.fixed_array_dim = 0,
		.file_idx = file_idx,
		.fn_language = 0,
		.language = 0,
		.file_backend_mode = 0,
		.struct_language = 0,
		.content = v__parser__ParseContentKind__file,
		.defer_mode = 0,
		.inside_lock_exprs = 0,
		.inside_chan_decl = 0,
		.inside_orm = 0,
		.or_is_handled = 0,
		.builtin_mod = 0,
		.inside_map_init = 0,
		.is_manualfree = 0,
		.has_globals = 0,
		.is_generated = 0,
		.is_translated = 0,
		.inside_struct_attr_decl = 0,
		.inside_struct_field_decl = 0,
		.inside_receiver_param = 0,
		.inside_generic_params = 0,
		.inside_defer = 0,
		.inside_asm = 0,
		.inside_asm_template = 0,
		.inside_sum_type = 0,
		.inside_unsafe = 0,
		.inside_ct_match_body = 0,
		.inside_ct_match_case = 0,
		.is_amp = 0,
		.returns = 0,
		.is_stmt_ident = 0,
		.expecting_type = 0,
		.expecting_value = true,
		.inside_ct_match = 0,
		.inside_match_body = 0,
		.inside_match_case = 0,
		.name_error = 0,
		.inside_select = 0,
		.inside_match = 0,
		.comptime_if_cond = 0,
		.inside_assign_rhs = 0,
		.should_abort = 0,
		.inside_infix = 0,
		.inside_in_array = 0,
		.inside_array_lit = 0,
		.inside_str_interp = 0,
		.inside_unsafe_fn = 0,
		.script_mode = 0,
		.inside_call_args = 0,
		.inside_fn_concrete_type = 0,
		.main_already_defined = 0,
		.is_vls = pref_->is_vls && builtin__string__eq(path, pref_->path),
		.is_vls_skip_file = v__parser__should_skip_vls_file(pref_, path),
		.inside_import_section = 0,
		.inside_fn_return = 0,
		.inside_fn = 0,
		.inside_for_expr = 0,
		.inside_for = 0,
		.inside_or_expr = 0,
		.inside_ct_if_expr = 0,
		.inside_if_cond = 0,
		.inside_if_expr = 0,
		.inside_comptime_if = 0,
		.inside_if = 0,
		.inside_test_file = 0,
		.inside_attr_decl = 0,
		.inside_vlib_file = 0,
	})));
	v__parser__Parser_set_path(&(*(p)), path);
	v__ast__File* res = v__parser__Parser_parse(&(*(p)));
	v__parser__Parser_free_scanner(&(*(p)));
	return res;
}
v__ast__File* v__parser__Parser_parse(v__parser__Parser* p) {
	v__util__timing_start(_S("PARSE"));
	v__parser__Parser_init_parse_fns(p);
	v__parser__Parser_read_first_token(p);
	Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__comment)) break;
		builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))), false) }));
	}
	v__ast__Module module_decl = v__parser__Parser_module_decl(p);
	if (module_decl.is_skipped) {
		builtin__array_insert(&stmts, 0, &(v__ast__Stmt[]){v__ast__Module_to_sumtype_v__ast__Stmt(&module_decl, false)});
	} else {
		builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__Module_to_sumtype_v__ast__Stmt(&module_decl, false) }));
	}
	p->inside_import_section = true;
	for (;;) {
		if (p->tok.kind == v__token__Kind__key_import) {
			builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p))), false) }));
			continue;
		}
		if (p->tok.kind == v__token__Kind__comment) {
			builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))), false) }));
			continue;
		}
		break;
	}
	for (;;) {
		if (p->tok.kind == v__token__Kind__eof) {
			if (!p->is_vls_skip_file) {
				v__parser__Parser_check_unused_imports(p);
			}
			break;
		}
		v__ast__Stmt stmt = v__parser__Parser_top_stmt(p);
		if (!((stmt)._typ == 321 /* v.ast.ExprStmt */ && ((*(v__ast__ExprStmt*)builtin____as_cast((stmt)._v__ast__ExprStmt,(stmt)._typ, 321)).expr)._typ == 271 /* v.ast.Comment */)) {
			p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		}
		builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ stmt }));
		if (p->should_abort) {
			break;
		}
	}
	p->scope->end_pos = p->tok.pos;
	Array_v__errors__Error errors_ = builtin__array_clone_to_depth(&p->errors, 0);
	Array_v__errors__Warning warnings = builtin__array_clone_to_depth(&p->warnings, 0);
	Array_v__errors__Notice notices = builtin__array_clone_to_depth(&p->notices, 0);
	if (p->pref->check_only) {
		_PUSH_MANY(&errors_, (p->scanner->errors), _t6, Array_v__errors__Error);
		_PUSH_MANY(&warnings, (p->scanner->warnings), _t7, Array_v__errors__Warning);
		_PUSH_MANY(&notices, (p->scanner->notices), _t8, Array_v__errors__Notice);
	}
	if (p->pref->is_check_overflow) {
		v__parser__Parser_register_auto_import(p, _S("builtin.overflow"));
	}
	v__parser__Parser_handle_codegen_for_file(p);
	v__ast__File* ast_file = ((v__ast__File*)builtin__memdup(&(v__ast__File){.nr_lines = p->scanner->line_nr,
		.nr_bytes = p->scanner->text.len,
		.nr_tokens = p->scanner->all_tokens.len,
		.mod = module_decl,
		.global_scope = p->table->global_scope,
		.is_test = p->inside_test_file,
		.is_generated = p->is_generated,
		.is_translated = p->is_translated,
		.language = p->file_backend_mode,
		.idx = 0,
		.path = p->file_path,
		.path_base = p->file_base,
		.scope = p->scope,
		.stmts = stmts,
		.imports = p->ast_imports,
		.auto_imports = p->auto_imports,
		.used_imports = p->used_imports,
		.implied_imports = p->implied_imports,
		.embedded_files = builtin____new_array(0, 0, sizeof(v__ast__EmbeddedFile)),
		.imported_symbols = p->imported_symbols,
		.imported_symbols_trie = v__token__new_keywords_matcher_from_array_trie(builtin__map_keys(&p->imported_symbols)),
		.imported_symbols_used = p->imported_symbols_used,
		.errors = errors_,
		.warnings = warnings,
		.notices = notices,
		.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),
		.generic_fns = builtin____new_array(0, 0, sizeof(v__ast__FnDecl*)),
		.global_labels = p->global_labels,
		.template_paths = p->template_paths,
		.template_line_map = builtin____new_array(0, 0, sizeof(v__ast__TemplateLineInfo)),
		.unique_prefix = p->unique_prefix,
		.is_parse_text = 0,
		.is_template_text = 0,
	}, sizeof(v__ast__File)));
	v__ast__File* _t9 = ast_file;
		{ // defer begin
			v__util__timing_measure_cumulative(_S("PARSE"));
		} // defer end
	return _t9;
}
Array_v__ast__File_ptr v__parser__parse_files(Array_string paths, v__ast__Table* table, v__pref__Preferences* pref_) {
	v__util__Timers* timers = v__util__new_timers(((v__util__TimerParams){.should_print = false,.label = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parse_files: "), 0xfe10, {.d_s = Array_string_str(paths)}}, {_SLIT0, 0, { .d_c = 0 }}})),}));
	{ // Unsafe block
		Array_v__ast__File_ptr files = builtin____new_array_with_default(0, paths.len, sizeof(v__ast__File*), 0);
		for (int _t1 = 0; _t1 < paths.len; ++_t1) {
			string path = ((string*)paths.data)[_t1];
			v__util__Timers_start(timers, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parse_file "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})));
			builtin__array_push((array*)&files, _MOV((v__ast__File*[]){ v__parser__parse_file(path, table, v__scanner__CommentsMode__skip_comments, pref_) }));
			v__util__Timers_show(timers, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("parse_file "), 0xfe10, {.d_s = path}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		v__parser__handle_codegen_for_multiple_files(&files);
		return files;
	}
	return builtin____new_array(0, 0, sizeof(v__ast__File*));
}
VV_LOC void v__parser__Parser_init_parse_fns(v__parser__Parser* p) {
}
VV_LOC void v__parser__Parser_read_first_token(v__parser__Parser* p) {
	v__parser__Parser_next(p);
	v__parser__Parser_next(p);
}
inline VV_LOC v__token__Token v__parser__Parser_peek_token(v__parser__Parser* p, int n) {
	return v__scanner__Scanner_peek_token(p->scanner, (int)(n - 2));
}
VV_LOC v__token__Token v__parser__Parser_peek_token_after_var_list(v__parser__Parser* p) {
	int n = 0;
	v__token__Token tok = p->tok;
	for (;;) {
		if (!(tok.kind != v__token__Kind__eof)) break;
		if (tok.kind == v__token__Kind__key_mut) {
			n += 2;
		} else {
			n++;
		}
		tok = v__scanner__Scanner_peek_token(p->scanner, (int)(n - 2));
		if (tok.kind != v__token__Kind__comma) {
			break;
		} else {
			n++;
			tok = v__scanner__Scanner_peek_token(p->scanner, (int)(n - 2));
		}
	}
	return tok;
}
VV_LOC void v__parser__Parser_open_scope(v__parser__Parser* p) {
	if (p->opened_scopes > p->max_opened_scopes) {
		p->should_abort = true;
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("nested opened scopes limit reached: "), 0xfe07, {.d_i32 = p->max_opened_scopes}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	p->scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = p->scope,.detached_from_parent = 0,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = p->tok.pos,.end_pos = 0,}, sizeof(v__ast__Scope)));
	p->opened_scopes++;
}
VV_LOC void v__parser__Parser_close_scope(v__parser__Parser* p) {
	p->scope->end_pos = p->prev_tok.pos;
	builtin__array_push((array*)&p->scope->parent->children, _MOV((v__ast__Scope*[]){ p->scope }));
	p->scope = p->scope->parent;
	p->opened_scopes--;
}
VV_LOC Array_v__ast__Stmt v__parser__Parser_parse_block(v__parser__Parser* p) {
	v__parser__Parser_open_scope(p);
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	v__parser__Parser_close_scope(p);
	return stmts;
}
VV_LOC bool v__parser__Parser_is_in_top_level_comptime(v__parser__Parser* p, bool inside_assign_rhs) {
	return p->cur_fn_name.len == 0 && (p->inside_ct_if_expr || p->inside_ct_match || p->inside_ct_match_body) && !inside_assign_rhs && !p->script_mode && p->tok.kind != v__token__Kind__name;
}
VV_LOC Array_v__ast__Stmt v__parser__Parser_parse_block_no_scope(v__parser__Parser* p, bool is_top_level) {
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 20, sizeof(v__ast__Stmt), 0);
	bool old_assign_rhs = p->inside_assign_rhs;
	p->inside_assign_rhs = false;
	if (p->tok.kind != v__token__Kind__rcbr) {
		int count = 0;
		for (;;) {
			if (!(!(p->tok.kind == v__token__Kind__eof || p->tok.kind == v__token__Kind__rcbr))) break;
			if (v__parser__Parser_is_in_top_level_comptime(p, old_assign_rhs)) {
				builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_top_stmt(p) }));
			} else {
				builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, is_top_level) }));
			}
			count++;
			if ((int)(count % 100000) == 0) {
				if (p->is_vls) {
					return builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
				}
				builtin__eprintln(builtin__str_intp(3, _MOV((StrIntpData[]){{_S("parsed "), 0xfe07, {.d_i32 = count}}, {_S(" statements so far from fn "), 0xfe10, {.d_s = p->cur_fn_name}}, {_S(" ..."), 0, { .d_c = 0 }}})));
			}
			if (count > 1000000) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("parsed over "), 0xfe07, {.d_i32 = count}}, {_S(" statements from fn "), 0xfe10, {.d_s = p->cur_fn_name}}, {_S(", the parser is probably stuck"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
				return builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
			}
		}
	}
	p->inside_assign_rhs = old_assign_rhs;
	if (is_top_level) {
		v__parser__Parser_top_level_statement_end(p);
	}
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	if (p->inside_assign_rhs && stmts.len > 0) {
		v__ast__Stmt last_stmt = (*(v__ast__Stmt*)builtin__array_last(stmts));
		v__parser__Parser_mark_last_call_return_as_used(p, &last_stmt);
	}
	return stmts;
}
VV_LOC void v__parser__Parser_mark_last_call_return_as_used(v__parser__Parser* p, v__ast__Stmt* last_stmt) {
	if (last_stmt->_typ == 321 /* v.ast.ExprStmt */) {
		if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 267 /* v.ast.CallExpr */) {
			(*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__CallExpr).is_return_used = true;
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__CallExpr).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__CallExpr).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 275 /* v.ast.ConcatExpr */) {
			for (int _t1 = 0; _t1 < (*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ConcatExpr).vals.len; ++_t1) {
				v__ast__Expr* expr = ((v__ast__Expr*)(*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ConcatExpr).vals.data) + _t1;
				if ((expr)->_typ == 267 /* v.ast.CallExpr */) {
					(*expr->_v__ast__CallExpr).is_return_used = true;
				}
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 282 /* v.ast.IfExpr */) {
			for (int _t2 = 0; _t2 < (*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__IfExpr).branches.len; ++_t2) {
				v__ast__IfBranch* branch = ((v__ast__IfBranch*)(*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__IfExpr).branches.data) + _t2;
				if (branch->stmts.len > 0) {
					v__ast__Stmt last_if_stmt = (*(v__ast__Stmt*)builtin__array_last(branch->stmts));
					v__parser__Parser_mark_last_call_return_as_used(p, &last_if_stmt);
				}
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 285 /* v.ast.InfixExpr */) {
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__InfixExpr).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__InfixExpr).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
			v__ast__Expr left_expr = (*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__InfixExpr).left;
			for (;;) {
				if ((left_expr)._typ == 285 /* v.ast.InfixExpr */) {
					if ((*left_expr._v__ast__InfixExpr).or_block.stmts.len > 0) {
						v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*left_expr._v__ast__InfixExpr).or_block.stmts));
						v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
					}
					left_expr = (*left_expr._v__ast__InfixExpr).left;
					continue;
				}
				if ((left_expr)._typ == 267 /* v.ast.CallExpr */) {
					(*left_expr._v__ast__CallExpr).is_return_used = true;
					if ((*left_expr._v__ast__CallExpr).or_block.stmts.len > 0) {
						v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*left_expr._v__ast__CallExpr).or_block.stmts));
						v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
					}
				}
				break;
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 272 /* v.ast.ComptimeCall */) {
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ComptimeCall).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ComptimeCall).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 273 /* v.ast.ComptimeSelector */) {
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ComptimeSelector).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__ComptimeSelector).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 299 /* v.ast.PrefixExpr */) {
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__PrefixExpr).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__PrefixExpr).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
		}
		else if ((*last_stmt->_v__ast__ExprStmt).expr._typ == 302 /* v.ast.SelectorExpr */) {
			if ((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__SelectorExpr).or_block.stmts.len > 0) {
				v__ast__Stmt or_block_last_stmt = (*(v__ast__Stmt*)builtin__array_last((*(*last_stmt->_v__ast__ExprStmt).expr._v__ast__SelectorExpr).or_block.stmts));
				v__parser__Parser_mark_last_call_return_as_used(p, &or_block_last_stmt);
			}
		}
		
		else {
		}
		
	}
	
	else {
	}
	
}
inline VV_LOC void v__parser__Parser_next(v__parser__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->peek_tok;
	p->peek_tok = v__scanner__Scanner_scan(p->scanner);
}
VV_LOC void v__parser__Parser_check(v__parser__Parser* p, v__token__Kind expected) {
	p->name_error = false;
	if (_likely_(p->tok.kind == expected)) {
		v__parser__Parser_next(p);
	} else {
		if (expected == v__token__Kind__name) {
			p->name_error = true;
		}
		string s = v__token__Kind_str(expected);
		if (v__token__is_key(s) || (s.len > 0 && !builtin__u8_is_letter(builtin__string_at(s, 0)))) {
			s = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = s}}, {_S("`"), 0, { .d_c = 0 }}}));
		}
		v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = s,.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
	}
}
VV_LOC string v__parser__Parser_check_js_name(v__parser__Parser* p) {
	string name = _S("");
	for (;;) {
		if (!(p->peek_tok.kind == v__token__Kind__dot)) break;
		name = builtin__string__plus(name, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->tok.lit}}, {_S("."), 0, { .d_c = 0 }}})));
		v__parser__Parser_next(p);
		v__parser__Parser_next(p);
	}
	name = builtin__string__plus(name, p->tok.lit);
	v__parser__Parser_next(p);
	return name;
}
VV_LOC bool v__parser__is_ident_name(string name) {
	if (name.len == 0) {
		return false;
	}
	if (!_const_v__util__name_char_table[name.str[ 0]]) {
		return false;
	}
	for (int i = 1; i < name.len; ++i) {
		if (!_const_v__util__func_char_table[name.str[ i]]) {
			return false;
		}
	}
	return true;
}
VV_LOC string v__parser__Parser_check_name(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	string name = p->tok.lit;
	if (p->tok.kind != v__token__Kind__name && p->peek_tok.kind == v__token__Kind__dot && _IN_MAP(ADDR(string, name), ADDR(map, p->imports))) {
		v__parser__Parser_register_used_import(p, name);
	} else if (p->tok.kind == v__token__Kind__name && v__parser__Parser_is_imported_symbol(p, name) && !(*(bool*)builtin__map_get(ADDR(map, p->imported_symbols_used), &(string[]){name}, &(bool[]){ 0 }))) {
		v__parser__Parser_register_used_import_for_symbol_name(p, (*(string*)builtin__map_get(ADDR(map, p->imported_symbols), &(string[]){name}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} })));
	}
	if (!v__parser__is_ident_name(name)) {
		v__parser__Parser_check(p, v__token__Kind__name);
	} else {
		v__parser__Parser_next(p);
	}
	if (!p->inside_orm && !p->inside_attr_decl && _SLIT_EQ(name.str, name.len, "sql")) {
		v__parser__Parser_error_with_pos(p, _S("unexpected keyword `sql`, expecting name"), pos);
	}
	return name;
}
VV_LOC v__ast__Stmt v__parser__Parser_top_stmt(v__parser__Parser* p) {
	;
	for (;;) {
		bool keep_cur_comments = false;
		if (!(p->tok.kind == v__token__Kind__key_import || p->tok.kind == v__token__Kind__comment || p->tok.kind == v__token__Kind__dollar)) {
			p->inside_import_section = false;
		}

		if (p->tok.kind == (v__token__Kind__key_pub)) {

			if (p->peek_tok.kind == (v__token__Kind__key_const)) {
				v__ast__Stmt _t1 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t1;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_fn)) {
				v__ast__Stmt _t2 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t2;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_struct) || p->peek_tok.kind == (v__token__Kind__key_union)) {
				v__ast__Stmt _t3 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p, false))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t3;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_interface)) {
				v__ast__Stmt _t4 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t4;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_enum)) {
				v__ast__Stmt _t5 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t5;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_type)) {
				v__ast__Stmt _t6 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t6;
			}
			else {
				v__ast__Stmt _t7 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("wrong pub keyword usage")))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t7;
			}
		}
		else if (p->tok.kind == (v__token__Kind__at)) {
			if (p->peek_tok.kind == v__token__Kind__lsbr) {
				v__parser__Parser_attributes(p);
				continue;
			} else {
				v__ast__Stmt _t8 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("@[attr] expected")))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t8;
			}
		}
		else if (p->tok.kind == (v__token__Kind__lsbr)) {
			v__parser__Parser_attributes(p);
			continue;
		}
		else if (p->tok.kind == (v__token__Kind__key_interface)) {
			v__ast__Stmt _t9 = v__ast__InterfaceDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__InterfaceDecl, (v__parser__Parser_interface_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t9;
		}
		else if (p->tok.kind == (v__token__Kind__key_import)) {
			if (!p->inside_import_section) {
				v__parser__Parser_error_with_pos(p, _S("`import x` can only be declared at the beginning of the file"), v__token__Token_pos(&p->tok));
			}
			v__ast__Stmt _t10 = v__ast__Import_to_sumtype_v__ast__Stmt(ADDR(v__ast__Import, (v__parser__Parser_import_stmt(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t10;
		}
		else if (p->tok.kind == (v__token__Kind__key_global)) {
			v__ast__Stmt _t11 = v__ast__GlobalDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__GlobalDecl, (v__parser__Parser_global_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t11;
		}
		else if (p->tok.kind == (v__token__Kind__key_const)) {
			v__ast__Stmt _t12 = v__ast__ConstDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__ConstDecl, (v__parser__Parser_const_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t12;
		}
		else if (p->tok.kind == (v__token__Kind__key_fn)) {
			v__ast__Stmt _t13 = v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (v__parser__Parser_fn_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t13;
		}
		else if (p->tok.kind == (v__token__Kind__key_struct)) {
			v__ast__Stmt _t14 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p, false))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t14;
		}
		else if (p->tok.kind == (v__token__Kind__dollar)) {

			if (p->peek_tok.kind == (v__token__Kind__eof)) {
				v__ast__Stmt _t15 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("eof"),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t15;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_for)) {
				v__ast__ComptimeFor comptime_for_stmt = v__parser__Parser_comptime_for(p);
				v__ast__Stmt _t16 = v__parser__Parser_other_stmts(p, v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(&comptime_for_stmt, false));
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t16;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_if)) {
				v__ast__IfExpr if_expr = v__parser__Parser_if_expr(p, true, false);
				v__ast__ExprStmt cur_stmt = ((v__ast__ExprStmt){.pos = if_expr.pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(&if_expr, false),.is_expr = 0,.typ = 0,});
				if (p->pref->is_fmt || v__parser__comptime_if_expr_contains_top_stmt(if_expr)) {
					v__ast__Stmt _t17 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&cur_stmt, false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t17;
				} else {
					v__ast__Stmt _t18 = v__parser__Parser_other_stmts(p, v__ast__ExprStmt_to_sumtype_v__ast__Stmt(&cur_stmt, false));
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t18;
				}
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_match)) {
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				v__ast__MatchExpr expr = v__parser__Parser_match_expr(p, true, false);
				v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__Stmt _t19 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__MatchExpr_to_sumtype_v__ast__Expr(&expr, false),.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t19;
			}
			else if (p->peek_tok.kind == (v__token__Kind__name)) {
				if (builtin__fast_string_eq(p->peek_tok.lit, _S("dbg"))) {
					v__ast__Stmt _t20 = v__ast__DebuggerStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__DebuggerStmt, (v__parser__Parser_dbg_stmt(p))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t20;
				} else {
					v__token__Pos pos = v__token__Token_pos(&p->tok);
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
					v__ast__Stmt _t21 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = expr,.is_expr = 0,.typ = 0,}))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t21;
				}
			}
			else {
				v__ast__Stmt _t22 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = (string){.str=(byteptr)"", .is_lit=1},.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t22;
			}
		}
		else if (p->tok.kind == (v__token__Kind__hash)) {
			v__ast__Stmt _t23 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t23;
		}
		else if (p->tok.kind == (v__token__Kind__key_type)) {
			v__ast__Stmt _t24 = v__ast__TypeDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__TypeDecl, (v__parser__Parser_type_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t24;
		}
		else if (p->tok.kind == (v__token__Kind__key_enum)) {
			v__ast__Stmt _t25 = v__ast__EnumDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__EnumDecl, (v__parser__Parser_enum_decl(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t25;
		}
		else if (p->tok.kind == (v__token__Kind__key_union)) {
			v__ast__Stmt _t26 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p, false))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t26;
		}
		else if (p->tok.kind == (v__token__Kind__comment)) {
			keep_cur_comments = true;
			v__ast__Stmt _t27 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t27;
		}
		else if (p->tok.kind == (v__token__Kind__semicolon)) {
			v__ast__Stmt _t28 = v__ast__SemicolonStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__SemicolonStmt, (v__parser__Parser_semicolon_stmt(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t28;
		}
		else if (p->tok.kind == (v__token__Kind__key_asm)) {
			v__ast__Stmt _t29 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, true))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t29;
		}
		else {
			v__ast__Stmt _t30 = v__parser__Parser_other_stmts(p, _const_v__ast__empty_stmt);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t30;
		}
		if (!keep_cur_comments && p->pref->is_vls) {
			builtin__array_clear(&p->cur_comments);
		}
		if (p->should_abort) {
			break;
		}
		{ // defer begin
			if (!keep_cur_comments && p->pref->is_vls) {
				builtin__array_clear(&p->cur_comments);
			}
		} // defer end
	}
	v__ast__Stmt _t31 = _const_v__ast__empty_stmt;
	return _t31;
}
VV_LOC bool v__parser__comptime_if_expr_contains_top_stmt(v__ast__IfExpr if_expr) {
	for (int _t1 = 0; _t1 < if_expr.branches.len; ++_t1) {
		v__ast__IfBranch branch = ((v__ast__IfBranch*)if_expr.branches.data)[_t1];
		for (int _t2 = 0; _t2 < branch.stmts.len; ++_t2) {
			v__ast__Stmt stmt = ((v__ast__Stmt*)branch.stmts.data)[_t2];
			if ((stmt)._typ == 321 /* v.ast.ExprStmt */) {
				if (((*stmt._v__ast__ExprStmt).expr)._typ == 282 /* v.ast.IfExpr */) {
					if (!v__parser__comptime_if_expr_contains_top_stmt((*(*stmt._v__ast__ExprStmt).expr._v__ast__IfExpr))) {
						return false;
					}
				} else if (((*stmt._v__ast__ExprStmt).expr)._typ == 267 /* v.ast.CallExpr */) {
					return false;
				}
			} else if ((stmt)._typ == 313 /* v.ast.AssignStmt */) {
				return false;
			} else if ((stmt)._typ == 328 /* v.ast.HashStmt */) {
				return true;
			}
		}
	}
	return true;
}
VV_LOC v__ast__Stmt v__parser__Parser_other_stmts(v__parser__Parser* p, v__ast__Stmt cur_stmt) {
	p->inside_fn = true;
	if (p->pref->is_script && !p->pref->is_test) {
		p->script_mode = true;
		p->script_mode_start_token = p->tok;
		if (p->main_already_defined) {
			v__parser__Parser_error(p, _S("function `main` is already defined, put your script statements inside it"));
		}
		v__parser__Parser_open_scope(p);
		p->cur_fn_name = _S("main.main");
		Array_v__ast__Stmt stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		if (!v__ast__Stmt_sumtype_eq(cur_stmt, _const_v__ast__empty_stmt)) {
			builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ cur_stmt }));
		}
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__eof)) break;
			builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
		}
		v__parser__Parser_close_scope(p);
		p->script_mode = false;
		return v__ast__FnDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__FnDecl, (((v__ast__FnDecl){
			.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),
			.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
			.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.label_names = p->label_names,
			.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),
			.stmts = stmts,
			.params = builtin____new_array(0, 0, sizeof(v__ast__Param)),
			.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
			.generic_names = builtin____new_array(0, 0, sizeof(string)),
			.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
			.name = _S("main.main"),
			.file = p->file_path,
			.mod = _S("main"),
			.short_name = _S("main"),
			.scope = p->scope,
			.source_file = ((void*)0),
			.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.ninstances = 0,
			.return_type = _const_v__ast__void_type,
			.idx = 0,
			.ctdefine_idx = -1,
			.method_idx = 0,
			.kind = 0,
			.language = 0,
			.file_mode = 0,
			.rec_share = 0,
			.is_exported = 0,
			.is_keep_alive = 0,
			.no_body = 0,
			.is_builtin = 0,
			.is_deprecated = 0,
			.rec_mut = 0,
			.is_conditional = 0,
			.is_test = 0,
			.is_direct_arr = 0,
			.is_main = true,
			.is_pub = 0,
			.is_c_variadic = 0,
			.is_manualfree = 0,
			.is_noreturn = 0,
			.is_weak = 0,
			.is_anon = 0,
			.is_static_type_method = 0,
			.is_expand_simple_interpolation = 0,
			.has_return = 0,
			.should_be_skipped = 0,
			.is_method = 0,
			.has_await = 0,
			.is_variadic = 0,
			.is_c_extern = 0,
			.is_unsafe = 0,
			.is_must_use = 0,
			.is_markused = 0,
			.is_ignore_overflow = 0,
			.is_file_translated = 0,
			.is_closure = 0,
			.has_break_line = 0,
			.has_prev_newline = 0,
		}))), false);
	} else if (p->pref->is_fmt || p->pref->is_vet) {
		return v__parser__Parser_stmt(p, false);
	} else {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__string__plus(_S("bad top level statement "), v__token__Token_str(p->tok))))), false);
	}
	return (v__ast__Stmt){._v__ast__AsmStmt=HEAP(v__ast__AsmStmt, ((v__ast__AsmStmt){.local_labels = builtin____new_array(0, 0, sizeof(string)),.clobbered = builtin____new_array(0, 0, sizeof(v__ast__AsmClobbered)),.templates = builtin____new_array(0, 0, sizeof(v__ast__AsmTemplate)),.output = builtin____new_array(0, 0, sizeof(v__ast__AsmIO)),.input = builtin____new_array(0, 0, sizeof(v__ast__AsmIO)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.scope = ((void*)0),.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.arch = 0,.is_basic = 0,.is_volatile = 0,.is_goto = 0,})),._typ=311};
}
VV_LOC v__ast__Comment v__parser__Parser_check_comment(v__parser__Parser* p) {
	if (p->tok.kind == v__token__Kind__comment) {
		return v__parser__Parser_comment(p);
	}
	return ((v__ast__Comment){.text = (string){.str=(byteptr)"", .is_lit=1},.is_multi = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),});
}
VV_LOC v__ast__Comment v__parser__Parser_comment(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	string text = p->tok.lit;
	int num_newlines = builtin__string_count(text, _S("\n"));
	bool is_multi = num_newlines > 0;
	pos.last_line = (int)(pos.line_nr + num_newlines);
	v__parser__Parser_next(p);
	return ((v__ast__Comment){.text = text,.is_multi = is_multi,.pos = pos,});
}
VV_LOC v__ast__ExprStmt v__parser__Parser_comment_stmt(v__parser__Parser* p) {
	v__ast__Comment comment = v__parser__Parser_comment(p);
	if (p->pref->is_vls) {
		builtin__array_push((array*)&p->cur_comments, _MOV((v__ast__Comment[]){ comment }));
	}
	return ((v__ast__ExprStmt){.pos = comment.pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__Comment_to_sumtype_v__ast__Expr(&comment, false),.is_expr = 0,.typ = 0,});
}
VV_LOC Array_v__ast__Comment v__parser__Parser_eat_comments(v__parser__Parser* p, v__parser__EatCommentsConfig cfg) {
	int line = (int)(p->prev_tok.line_nr + builtin__string_count(p->prev_tok.lit, _S("\n")));
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		if (p->tok.kind != v__token__Kind__comment || (cfg.same_line && p->tok.line_nr > line) || (cfg.follow_up && p->tok.line_nr > (int)(line + 1))) {
			break;
		}
		builtin__array_push((array*)&comments, _MOV((v__ast__Comment[]){ v__parser__Parser_comment(p) }));
		if (cfg.follow_up) {
			line = (int)(p->prev_tok.line_nr + builtin__string_count(p->prev_tok.lit, _S("\n")));
		}
	}
	return comments;
}
VV_LOC void v__parser__Parser_goto_eof(v__parser__Parser* p) {
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__eof)) break;
		v__parser__Parser_next(p);
	}
}
VV_LOC v__ast__Stmt v__parser__Parser_stmt(v__parser__Parser* p, bool is_top_level) {
	if (p->should_abort) {
		v__token__Pos abort_pos = v__token__Token_pos(&p->tok);
		v__parser__Parser_goto_eof(p);
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (((v__ast__NodeError){.idx = 0,.pos = abort_pos,}))), false);
	}
	bool keep_cur_comments = false;
	;
	p->is_stmt_ident = p->tok.kind == v__token__Kind__name;
	switch (p->tok.kind) {
		case v__token__Kind__lcbr: {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			if (v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__colon) {
				v__ast__Expr expr = v__parser__Parser_expr(p, 0);
				v__ast__Stmt _t2 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = expr,.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t2;
			} else {
				Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
				v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__Stmt _t3 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, (((v__ast__Block){.is_unsafe = 0,.pos = pos,.scope = (*(v__ast__Scope**)builtin__array_last(p->scope->children)),.stmts = stmts,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t3;
			}
			break;
		}
		case v__token__Kind__name: {
			if (p->peek_tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("sql"))) {
				v__ast__Stmt _t4 = v__ast__SqlStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__SqlStmt, (v__parser__Parser_sql_stmt(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t4;
			}
			if (p->peek_tok.kind == v__token__Kind__colon) {
				v__token__Pos spos = v__token__Token_pos(&p->tok);
				string name = v__parser__Parser_check_name(p);
				if ((Array_string_contains(p->label_names, name))) {
					v__ast__Stmt _t5 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicate label `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), spos))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t5;
				}
				builtin__array_push((array*)&p->label_names, _MOV((string[]){ builtin__string_clone(name) }));
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind__key_for) {
					v__token__Pos for_pos = v__token__Token_pos(&p->tok);
					v__ast__Stmt stmt = v__parser__Parser_stmt(p, is_top_level);
					if (stmt._typ == 324 /* v.ast.ForStmt */) {
						(*stmt._v__ast__ForStmt).label = name;
						v__ast__Stmt _t7 = v__ast__ForStmt_to_sumtype_v__ast__Stmt(&(*stmt._v__ast__ForStmt), false);
							{ // defer begin
								if (!keep_cur_comments && p->pref->is_vls) {
									builtin__array_clear(&p->cur_comments);
								}
							} // defer end
						return _t7;
					}
					else if (stmt._typ == 323 /* v.ast.ForInStmt */) {
						(*stmt._v__ast__ForInStmt).label = name;
						v__ast__Stmt _t8 = v__ast__ForInStmt_to_sumtype_v__ast__Stmt(&(*stmt._v__ast__ForInStmt), false);
							{ // defer begin
								if (!keep_cur_comments && p->pref->is_vls) {
									builtin__array_clear(&p->cur_comments);
								}
							} // defer end
						return _t8;
					}
					else if (stmt._typ == 322 /* v.ast.ForCStmt */) {
						(*stmt._v__ast__ForCStmt).label = name;
						v__ast__Stmt _t9 = v__ast__ForCStmt_to_sumtype_v__ast__Stmt(&(*stmt._v__ast__ForCStmt), false);
							{ // defer begin
								if (!keep_cur_comments && p->pref->is_vls) {
									builtin__array_clear(&p->cur_comments);
								}
							} // defer end
						return _t9;
					}
					
					else {
						v__ast__Stmt _t10 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("unknown kind of For statement"), for_pos))), false);
							{ // defer begin
								if (!keep_cur_comments && p->pref->is_vls) {
									builtin__array_clear(&p->cur_comments);
								}
							} // defer end
						return _t10;
					}
					
				}
				v__ast__Stmt _t11 = v__ast__GotoLabel_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoLabel, (((v__ast__GotoLabel){.name = name,.pos = v__token__Pos_extend(spos, v__token__Token_pos(&p->tok)),.is_used = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t11;
			} else if (p->peek_tok.kind == v__token__Kind__name) {
				if (p->is_vls) {
					v__parser__Parser_next(p);
					v__ast__Stmt _t12 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_ident(p, v__ast__Language__v))), false),.is_expr = 0,.typ = 0,}))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t12;
				}
				v__ast__Stmt _t13 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("name `"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`"), 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t13;
			} else if (!p->inside_if_expr && !p->inside_match_body && !p->inside_or_expr && (p->peek_tok.kind == v__token__Kind__rcbr || p->peek_tok.kind == v__token__Kind__eof) && !v__ast__Scope_mark_var_as_used(p->scope, p->tok.lit)) {
				v__ast__Stmt _t14 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = p->tok.lit}}, {_S("` evaluated but not used"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok)))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t14;
			}
			v__ast__Stmt _t15 = v__parser__Parser_parse_multi_expr(p, is_top_level);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t15;
		}
		case v__token__Kind__key_for: {
			v__ast__Stmt _t16 = v__parser__Parser_for_stmt(p);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t16;
		}
		case v__token__Kind__comment: {
			keep_cur_comments = true;
			v__ast__Stmt _t17 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (v__parser__Parser_comment_stmt(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t17;
		}
		case v__token__Kind__key_return: {
			if (!p->inside_defer) {
				v__ast__Stmt _t18 = v__ast__Return_to_sumtype_v__ast__Stmt(ADDR(v__ast__Return, (v__parser__Parser_return_stmt(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t18;
			} else {
				v__ast__Stmt _t19 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("`return` not allowed inside `defer` block"), v__token__Token_pos(&p->tok)))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t19;
			}
			break;
		}
		case v__token__Kind__dollar: {

			if (p->peek_tok.kind == (v__token__Kind__key_if)) {
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				v__ast__IfExpr expr = v__parser__Parser_if_expr(p, true, false);
				v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__Stmt _t20 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__IfExpr_to_sumtype_v__ast__Expr(&expr, false),.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t20;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_for)) {
				v__ast__Stmt _t21 = v__ast__ComptimeFor_to_sumtype_v__ast__Stmt(ADDR(v__ast__ComptimeFor, (v__parser__Parser_comptime_for(p))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t21;
			}
			else if (p->peek_tok.kind == (v__token__Kind__key_match)) {
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				v__ast__MatchExpr expr = v__parser__Parser_match_expr(p, true, false);
				v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__Stmt _t22 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__MatchExpr_to_sumtype_v__ast__Expr(&expr, false),.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t22;
			}
			else if (p->peek_tok.kind == (v__token__Kind__name)) {
				if (builtin__fast_string_eq(p->peek_tok.lit, _S("dbg"))) {
					v__ast__Stmt _t23 = v__ast__DebuggerStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__DebuggerStmt, (v__parser__Parser_dbg_stmt(p))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t23;
				} else {
					v__token__Pos pos = v__token__Token_pos(&p->tok);
					v__ast__Expr expr = v__parser__Parser_expr(p, 0);
					v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
					v__ast__Stmt _t24 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = expr,.is_expr = 0,.typ = 0,}))), false);
						{ // defer begin
							if (!keep_cur_comments && p->pref->is_vls) {
								builtin__array_clear(&p->cur_comments);
							}
						} // defer end
					return _t24;
				}
			}
			else {
				v__ast__Stmt _t25 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("$"),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},})))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t25;
			}
			break;
		}
		case v__token__Kind__key_continue: case v__token__Kind__key_break: {
			v__token__Token tok = p->tok;
			int line = p->tok.line_nr;
			v__parser__Parser_next(p);
			string label = _S("");
			if (p->tok.line_nr == line && p->tok.kind == v__token__Kind__name) {
				label = v__parser__Parser_check_name(p);
			}
			v__ast__Stmt _t26 = v__ast__BranchStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__BranchStmt, (((v__ast__BranchStmt){.label = label,.scope = p->scope,.pos = v__token__Token_pos(&tok),.kind = tok.kind,}))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t26;
		}
		case v__token__Kind__key_unsafe: {
			v__ast__Stmt _t27 = v__parser__Parser_unsafe_stmt(p);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t27;
		}
		case v__token__Kind__hash: {
			v__ast__Stmt _t28 = v__ast__HashStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__HashStmt, (v__parser__Parser_hash(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t28;
		}
		case v__token__Kind__key_assert: {
			v__parser__Parser_next(p);
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
			v__ast__Expr extra = _const_v__ast__empty_expr;
			v__token__Pos extra_pos = v__token__Token_pos(&p->tok);
			if (p->tok.kind == v__token__Kind__comma) {
				v__parser__Parser_next(p);
				extra_pos = v__token__Token_pos(&p->tok);
				extra = v__parser__Parser_expr(p, 0);
				extra_pos = v__token__Pos_extend(extra_pos, v__token__Token_pos(&p->tok));
			}
			v__ast__Stmt _t29 = v__ast__AssertStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AssertStmt, (((v__ast__AssertStmt){.expr = expr,.extra = extra,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->tok)),.extra_pos = extra_pos,.is_used = p->inside_test_file || !p->pref->is_prod,}))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t29;
		}
		case v__token__Kind__key_defer: {
			if (!p->inside_defer) {
				v__token__Pos spos = v__token__Token_pos(&p->tok);
				v__parser__Parser_next(p);
				v__ast__DeferMode defer_mode = v__ast__DeferMode__scoped;
				if (p->tok.kind == v__token__Kind__lpar) {
					v__parser__Parser_next(p);
					v__token__Pos mode_pos = v__token__Token_pos(&p->tok);
					string mode = v__parser__Parser_check_name(p);

					if (_SLIT_EQ(mode.str, mode.len, "fn")) {
						defer_mode = v__ast__DeferMode__function;
					}
					else {
						v__ast__Stmt _t30 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown `defer` mode: `"), 0xfe10, {.d_s = mode}}, {_S("`"), 0, { .d_c = 0 }}})), mode_pos))), false);
							{ // defer begin
								if (!keep_cur_comments && p->pref->is_vls) {
									builtin__array_clear(&p->cur_comments);
								}
							} // defer end
						return _t30;
					}
					v__parser__Parser_check(p, v__token__Kind__rpar);
				}
				p->inside_defer = true;
				p->defer_mode = defer_mode;
				p->defer_vars = builtin____new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
				Array_v__ast__Stmt stmts = v__parser__Parser_parse_block(p);
				p->inside_defer = false;
				v__ast__Stmt _t31 = v__ast__DeferStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__DeferStmt, (((v__ast__DeferStmt){.stmts = stmts,.defer_vars = builtin__array_clone_to_depth(&p->defer_vars, 0),.ifdef = (string){.str=(byteptr)"", .is_lit=1},.scope = p->scope,.pos = v__token__Pos_extend_with_last_line(spos, v__token__Token_pos(&p->prev_tok), p->prev_tok.line_nr),.idx_in_fn = -1,.mode = defer_mode,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t31;
			} else {
				v__ast__Stmt _t32 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("`defer` blocks cannot be nested"), v__token__Token_pos(&p->tok)))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t32;
			}
			break;
		}
		case v__token__Kind__key_go: case v__token__Kind__key_spawn: {
			if ((p->pref->use_coroutines || p->pref->is_fmt) && p->tok.kind == v__token__Kind__key_go) {
				v__ast__GoExpr go_expr = v__parser__Parser_go_expr(p);
				v__ast__Stmt _t33 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = go_expr.pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__GoExpr_to_sumtype_v__ast__Expr(&go_expr, false),.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t33;
			} else {
				v__ast__SpawnExpr spawn_expr = v__parser__Parser_spawn_expr(p);
				v__ast__Stmt _t34 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = spawn_expr.pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__SpawnExpr_to_sumtype_v__ast__Expr(&spawn_expr, false),.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t34;
			}
			break;
		}
		case v__token__Kind__key_goto: {
			v__parser__Parser_next(p);
			v__token__Pos spos = v__token__Token_pos(&p->tok);
			string name = v__parser__Parser_check_name(p);
			v__ast__Stmt _t35 = v__ast__GotoStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__GotoStmt, (((v__ast__GotoStmt){.name = name,.pos = spos,}))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t35;
		}
		case v__token__Kind__key_const: {
			v__ast__Stmt _t36 = v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("const can only be defined at the top level (outside of functions)"), v__token__Token_pos(&p->tok)))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t36;
		}
		case v__token__Kind__key_asm: {
			v__ast__Stmt _t37 = v__ast__AsmStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__AsmStmt, (v__parser__Parser_asm_stmt(p, false))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t37;
		}
		case v__token__Kind__semicolon: {
			v__ast__Stmt _t38 = v__ast__SemicolonStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__SemicolonStmt, (v__parser__Parser_semicolon_stmt(p))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t38;
		}
		case v__token__Kind__key_struct: case v__token__Kind__key_union: {
			v__ast__Stmt _t39 = v__ast__StructDecl_to_sumtype_v__ast__Stmt(ADDR(v__ast__StructDecl, (v__parser__Parser_struct_decl(p, false))), false);
				{ // defer begin
					if (!keep_cur_comments && p->pref->is_vls) {
						builtin__array_clear(&p->cur_comments);
					}
				} // defer end
			return _t39;
		}
		case v__token__Kind__unknown:
		case v__token__Kind__eof:
		case v__token__Kind__number:
		case v__token__Kind__string:
		case v__token__Kind__str_inter:
		case v__token__Kind__chartoken:
		case v__token__Kind__plus:
		case v__token__Kind__minus:
		case v__token__Kind__mul:
		case v__token__Kind__div:
		case v__token__Kind__mod:
		case v__token__Kind__xor:
		case v__token__Kind__pipe:
		case v__token__Kind__inc:
		case v__token__Kind__dec:
		case v__token__Kind__and:
		case v__token__Kind__logical_or:
		case v__token__Kind__not:
		case v__token__Kind__bit_not:
		case v__token__Kind__question:
		case v__token__Kind__comma:
		case v__token__Kind__colon:
		case v__token__Kind__arrow:
		case v__token__Kind__amp:
		case v__token__Kind__at:
		case v__token__Kind__str_dollar:
		case v__token__Kind__left_shift:
		case v__token__Kind__right_shift:
		case v__token__Kind__unsigned_right_shift:
		case v__token__Kind__not_in:
		case v__token__Kind__not_is:
		case v__token__Kind__assign:
		case v__token__Kind__decl_assign:
		case v__token__Kind__plus_assign:
		case v__token__Kind__minus_assign:
		case v__token__Kind__div_assign:
		case v__token__Kind__mult_assign:
		case v__token__Kind__xor_assign:
		case v__token__Kind__mod_assign:
		case v__token__Kind__or_assign:
		case v__token__Kind__and_assign:
		case v__token__Kind__right_shift_assign:
		case v__token__Kind__left_shift_assign:
		case v__token__Kind__unsigned_right_shift_assign:
		case v__token__Kind__boolean_and_assign:
		case v__token__Kind__boolean_or_assign:
		case v__token__Kind__rcbr:
		case v__token__Kind__lpar:
		case v__token__Kind__rpar:
		case v__token__Kind__lsbr:
		case v__token__Kind__nilsbr:
		case v__token__Kind__rsbr:
		case v__token__Kind__eq:
		case v__token__Kind__ne:
		case v__token__Kind__gt:
		case v__token__Kind__lt:
		case v__token__Kind__ge:
		case v__token__Kind__le:
		case v__token__Kind__nl:
		case v__token__Kind__dot:
		case v__token__Kind__dotdot:
		case v__token__Kind__ellipsis:
		case v__token__Kind__keyword_beg:
		case v__token__Kind__key_as:
		case v__token__Kind__key_atomic:
		case v__token__Kind__key_else:
		case v__token__Kind__key_enum:
		case v__token__Kind__key_false:
		case v__token__Kind__key_fn:
		case v__token__Kind__key_global:
		case v__token__Kind__key_if:
		case v__token__Kind__key_import:
		case v__token__Kind__key_in:
		case v__token__Kind__key_interface:
		case v__token__Kind__key_is:
		case v__token__Kind__key_match:
		case v__token__Kind__key_module:
		case v__token__Kind__key_mut:
		case v__token__Kind__key_nil:
		case v__token__Kind__key_shared:
		case v__token__Kind__key_lock:
		case v__token__Kind__key_rlock:
		case v__token__Kind__key_none:
		case v__token__Kind__key_select:
		case v__token__Kind__key_like:
		case v__token__Kind__key_ilike:
		case v__token__Kind__key_sizeof:
		case v__token__Kind__key_isreftype:
		case v__token__Kind__key_likely:
		case v__token__Kind__key_unlikely:
		case v__token__Kind__key_offsetof:
		case v__token__Kind__key_true:
		case v__token__Kind__key_type:
		case v__token__Kind__key_typeof:
		case v__token__Kind__key_dump:
		case v__token__Kind__key_orelse:
		case v__token__Kind__key_pub:
		case v__token__Kind__key_static:
		case v__token__Kind__key_volatile:
		case v__token__Kind__key_implements:
		case v__token__Kind__keyword_end:
		case v__token__Kind___end_:
		default: {
			{
				v__ast__Stmt _t40 = v__parser__Parser_parse_multi_expr(p, is_top_level);
					{ // defer begin
						if (!keep_cur_comments && p->pref->is_vls) {
							builtin__array_clear(&p->cur_comments);
						}
					} // defer end
				return _t40;
			}
		}
	}
	
	return (v__ast__Stmt){._v__ast__AsmStmt=HEAP(v__ast__AsmStmt, ((v__ast__AsmStmt){.local_labels = builtin____new_array(0, 0, sizeof(string)),.clobbered = builtin____new_array(0, 0, sizeof(v__ast__AsmClobbered)),.templates = builtin____new_array(0, 0, sizeof(v__ast__AsmTemplate)),.output = builtin____new_array(0, 0, sizeof(v__ast__AsmIO)),.input = builtin____new_array(0, 0, sizeof(v__ast__AsmIO)),.global_labels = builtin____new_array(0, 0, sizeof(string)),.scope = ((void*)0),.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},.arch = 0,.is_basic = 0,.is_volatile = 0,.is_goto = 0,})),._typ=311};
}
VV_LOC v__ast__DebuggerStmt v__parser__Parser_dbg_stmt(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__dollar);
	v__parser__Parser_check(p, v__token__Kind__name);
	v__parser__Parser_register_auto_import(p, _S("v.debug"));
	return ((v__ast__DebuggerStmt){.pos = pos,});
}
VV_LOC v__ast__SemicolonStmt v__parser__Parser_semicolon_stmt(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__semicolon);
	return ((v__ast__SemicolonStmt){.pos = pos,});
}
VV_LOC Array_v__ast__Expr v__parser__Parser_expr_list(v__parser__Parser* p, bool expect_value) {
	Array_v__ast__Expr exprs = builtin____new_array_with_default(0, 1, sizeof(v__ast__Expr), 0);
	for (;;) {
		v__ast__Expr expr = (expect_value ? (v__parser__Parser_expr(p, 0)) : (v__parser__Parser_expr_no_value(p, 0)));
		if ((expr)._typ != 271 /* v.ast.Comment */) {
			builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ expr }));
			if (p->tok.kind != v__token__Kind__comma) {
				break;
			}
			v__parser__Parser_next(p);
		}
	}
	return exprs;
}
VV_LOC v__ast__Stmt v__parser__Parser_parse_multi_expr(v__parser__Parser* p, bool is_top_level) {
	v__token__Token tok = p->tok;
	v__token__Pos pos = v__token__Token_pos(&tok);
	Array_v__ast__Ident defer_vars = builtin__array_clone_to_depth(&p->defer_vars, 0);
	p->defer_vars = builtin____new_array_with_default(0, 0, sizeof(v__ast__Ident), 0);
	Array_v__ast__Expr left = v__parser__Parser_expr_list(p, p->inside_assign_rhs);
	if (!(p->inside_defer && p->defer_mode == v__ast__DeferMode__function && p->tok.kind == v__token__Kind__decl_assign)) {
		_PUSH_MANY(&defer_vars, (p->defer_vars), _t1, Array_v__ast__Ident);
	}
	p->defer_vars = defer_vars;
	v__ast__Expr left0 = ((v__ast__Expr*)left.data)[0];
	if ((tok.kind == v__token__Kind__key_mut || tok.kind == v__token__Kind__key_shared || tok.kind == v__token__Kind__key_atomic) && v__ast__Expr_is_blank_ident(left0)) {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot use `"), 0xfe10, {.d_s = v__token__Kind_str(tok.kind)}}, {_S("` on `_`"), 0, { .d_c = 0 }}})), v__token__Token_pos(&tok)))), false);
	}
	if (tok.kind == v__token__Kind__key_mut && p->tok.kind != v__token__Kind__decl_assign) {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("expecting `:=` (e.g. `mut x :=`)")))), false);
	}
	if (v__token__Kind_is_assign(p->tok.kind)) {
		return v__parser__Parser_partial_assign_stmt(p, left);
	} else if (!p->pref->translated && !p->is_translated && !p->pref->is_fmt && !p->pref->is_vet && !(tok.kind == v__token__Kind__key_if || tok.kind == v__token__Kind__key_match || tok.kind == v__token__Kind__key_lock || tok.kind == v__token__Kind__key_rlock || tok.kind == v__token__Kind__key_select)) {
		for (int _t5 = 0; _t5 < left.len; ++_t5) {
			v__ast__Expr node = ((v__ast__Expr*)left.data)[_t5];
			if ((is_top_level || !(p->tok.kind == v__token__Kind__comment || p->tok.kind == v__token__Kind__rcbr)) && !((node)._typ == 267 /* v.ast.CallExpr */ || (node)._typ == 298 /* v.ast.PostfixExpr */ || (node)._typ == 272 /* v.ast.ComptimeCall */ || (node)._typ == 302 /* v.ast.SelectorExpr */ || (node)._typ == 276 /* v.ast.DumpExpr */)) {
				bool is_complex_infix_expr = (node)._typ == 285 /* v.ast.InfixExpr */ && ((*(v__ast__InfixExpr*)builtin____as_cast((node)._v__ast__InfixExpr,(node)._typ, 285)).op == v__token__Kind__left_shift || (*(v__ast__InfixExpr*)builtin____as_cast((node)._v__ast__InfixExpr,(node)._typ, 285)).op == v__token__Kind__right_shift || (*(v__ast__InfixExpr*)builtin____as_cast((node)._v__ast__InfixExpr,(node)._typ, 285)).op == v__token__Kind__unsigned_right_shift || (*(v__ast__InfixExpr*)builtin____as_cast((node)._v__ast__InfixExpr,(node)._typ, 285)).op == v__token__Kind__arrow);
				if (!is_complex_infix_expr && !p->is_vls) {
					return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("expression evaluated but not used"), v__ast__Expr_pos(node)))), false);
				}
			}
		}
	}
	v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
	if (left.len == 1) {
		return v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = v__ast__Expr_pos(left0),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = left0,.is_expr = p->inside_for,.typ = 0,}))), false);
	}
	return v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = v__ast__ConcatExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__ConcatExpr, (((v__ast__ConcatExpr){.vals = left,.pos = v__token__Token_pos(&tok),.return_type = 0,}))), false),.is_expr = 0,.typ = 0,}))), false);
}
VV_LOC v__ast__Ident v__parser__Parser_ident(v__parser__Parser* p, v__ast__Language language) {
	bool is_option = p->tok.kind == v__token__Kind__question && p->peek_tok.kind == v__token__Kind__lsbr;
	if (is_option) {
		v__parser__Parser_next(p);
	}
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_atomic = p->tok.kind == v__token__Kind__key_atomic;
	if (is_shared) {
		v__parser__Parser_register_auto_import(p, _S("sync"));
	}
	v__token__Pos mut_pos = v__token__Token_pos(&p->tok);
	v__token__Kind modifier_kind = p->tok.kind;
	bool is_mut = p->tok.kind == v__token__Kind__key_mut || is_shared || is_atomic;
	if (is_mut) {
		v__parser__Parser_next(p);
	}
	bool is_static = p->tok.kind == v__token__Kind__key_static;
	if (is_static) {
		v__parser__Parser_next(p);
	}
	bool is_volatile = p->tok.kind == v__token__Kind__key_volatile;
	if (is_volatile) {
		v__parser__Parser_next(p);
	}
	if (!(p->tok.kind == v__token__Kind__name || p->tok.kind == v__token__Kind__key_type)) {
		if (is_mut || is_static || is_volatile) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("the `"), 0xfe10, {.d_s = v__token__Kind_str(modifier_kind)}}, {_S("` keyword is invalid here"), 0, { .d_c = 0 }}})), mut_pos);
		} else {
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("token `"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`"), 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
		}
		return ((v__ast__Ident){.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.obj = _const_v__ast__empty_scope_object,.mod = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.full_name = (string){.str=(byteptr)"", .is_lit=1},.cached_name = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__IdentInfo){._v__ast__IdentFn=HEAP(v__ast__IdentFn, ((v__ast__IdentFn){.typ = 0,})),._typ=407},.scope = p->scope,.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.tok_kind = 0,.language = 0,.kind = 0,.is_mut = 0,.comptime = 0,.ct_expr = 0,});
	}
	bool in_select = p->prev_tok.kind == v__token__Kind__arrow;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	string name = v__parser__Parser_check_name(p);
	if (_SLIT_EQ(name.str, name.len, "_")) {
		return ((v__ast__Ident){
			.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
			.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.obj = _const_v__ast__empty_scope_object,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.name = _S("_"),
			.full_name = (string){.str=(byteptr)"", .is_lit=1},
			.cached_name = (string){.str=(byteptr)"", .is_lit=1},
			.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, (((v__ast__IdentVar){.typ = 0,.share = 0,.is_mut = 0,.is_static = 0,.is_volatile = 0,.is_option = is_option,}))), false),
			.scope = p->scope,
			.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
			.pos = pos,
			.tok_kind = p->tok.kind,
			.language = 0,
			.kind = v__ast__IdentKind__blank_ident,
			.is_mut = 0,
			.comptime = p->comptime_if_cond,
			.ct_expr = 0,
		});
	}
	bool is_following_concrete_types = v__parser__Parser_is_following_concrete_types(p);
	Array_v__ast__Type concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (p->expr_mod.len > 0) {
		name = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = p->expr_mod}}, {_S("."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	bool allowed_cases = !in_select && !p->inside_comptime_if && !p->inside_ct_if_expr;
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Pos or_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (allowed_cases && p->tok.kind == v__token__Kind__question && p->peek_tok.kind != v__token__Kind__lpar) {
		or_kind = v__ast__OrKind__propagate_option;
		or_scope = p->scope;
		v__parser__Parser_check(p, v__token__Kind__question);
	} else if (allowed_cases && p->tok.kind == v__token__Kind__key_orelse) {
		or_kind = v__ast__OrKind__block;
		multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_39741 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__no_err_var);
		or_stmts = mr_39741.arg0;
		or_pos = mr_39741.arg1;
		or_scope = mr_39741.arg2;
	} else if (is_following_concrete_types) {
		concrete_types = v__parser__Parser_parse_concrete_types(p);
	}
	int_literal _t3 = 0;
	
	if (p->peek_tok.kind == (v__token__Kind__string)) {
		_t3 = _const_v__ast__string_type_idx;
	}
	else if (p->peek_tok.kind == (v__token__Kind__lsbr)) {
		_t3 = _const_v__ast__array_type_idx;
	}
	else {
		v__ast__Type _t4; /* if prepend */
		if (p->tok.kind == v__token__Kind__dot) {
			v__ast__Type _t6; /* if prepend */
			_option_v__ast__Var_ptr _t8;
			if (_t8 = v__ast__Scope_find_var(p->scope, name), _t8.state == 0) {
				v__ast__Var* var = *(v__ast__Var**)_t8.data;
				_t6 = var->typ;
				goto _t7;
			};
			{
				_t6 = 0;
			}
	_t7: {};
						_t4 = _t6;
			goto _t5;
		};
		{
			_t4 = 0;
		}
	_t5: {};
				_t3 = _t4;
	}int typ = _t3;
	return ((v__ast__Ident){
		.or_expr = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),
		.concrete_types = concrete_types,
		.obj = _const_v__ast__empty_scope_object,
		.mod = p->mod,
		.name = name,
		.full_name = (string){.str=(byteptr)"", .is_lit=1},
		.cached_name = (string){.str=(byteptr)"", .is_lit=1},
		.info = v__ast__IdentVar_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentVar, (((v__ast__IdentVar){
			.typ = typ,
			.share = v__ast__sharetype_from_flags(is_shared, is_atomic),
			.is_mut = is_mut,
			.is_static = is_static,
			.is_volatile = is_volatile,
			.is_option = or_kind != v__ast__OrKind__absent,
		}))), false),
		.scope = p->scope,
		.mut_pos = mut_pos,
		.pos = pos,
		.tok_kind = p->tok.kind,
		.language = language,
		.kind = v__ast__IdentKind__unresolved,
		.is_mut = is_mut,
		.comptime = p->comptime_if_cond,
		.ct_expr = 0,
	});
}
VV_LOC v__ast__Type v__parser__Parser_alias_array_type(v__parser__Parser* p) {
	string full_name = v__parser__Parser_prepend_mod(p, p->tok.lit);
	int* _t2 = (int*)(builtin__map_get_check(ADDR(map, p->table->type_idxs), &(string[]){full_name}));
	_option_int _t1 = {0};
	if (_t2) {
		*((int*)&_t1.data) = *((int*)_t2);
	} else {
		_t1.state = 2; _t1.err = builtin___v_error(_S("map key does not exist"));
	}
	
	if (_t1.state == 0) {
		int idx = (*(int*)_t1.data);
		if (idx == 0) {
			return _const_v__ast__void_type;
		}
		v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, v__ast__idx_to_type(idx));
		if ((sym->info)._typ == 482 /* v.ast.Alias */) {
			if ((*sym->info._v__ast__Alias).parent_type == 0) {
				return _const_v__ast__void_type;
			}
			if (v__ast__Table_sym(p->table, (*sym->info._v__ast__Alias).parent_type)->kind == v__ast__Kind__array) {
				return idx;
			}
		}
	}
	return _const_v__ast__void_type;
}
VV_LOC v__ast__Expr v__parser__Parser_name_expr(v__parser__Parser* p) {
	v__token__Kind prev_tok_kind = p->prev_tok.kind;
	v__ast__Expr node = _const_v__ast__empty_expr;
	if (p->expecting_type) {
		if (p->tok.kind == v__token__Kind__dollar) {
			node = v__ast__ComptimeType_to_sumtype_v__ast__Expr(ADDR(v__ast__ComptimeType, (v__parser__Parser_parse_comptime_type(p))), false);
			p->expecting_type = false;
			return node;
		}
		p->expecting_type = false;
		bool is_known_var = v__ast__Scope_known_var(p->scope, p->tok.lit);
		if (is_known_var) {
			v__ast__Scope_mark_var_as_used(p->scope, p->tok.lit);
			return v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (v__parser__Parser_ident(p, v__ast__Language__v))), false);
		} else {
			v__token__Pos type_pos = v__token__Token_pos(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			return v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, (((v__ast__TypeNode){.pos = type_pos,.typ = typ,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}))), false);
		}
	}
	v__ast__Language language = ((_SLIT_EQ(p->tok.lit.str, p->tok.lit.len, "C"))? (v__ast__Language__c) : (_SLIT_EQ(p->tok.lit.str, p->tok.lit.len, "JS"))? (v__ast__Language__js) : (_SLIT_EQ(p->tok.lit.str, p->tok.lit.len, "WASM"))? (v__ast__Language__wasm) : (v__ast__Language__v));
	if (language != v__ast__Language__v) {
		v__parser__Parser_check_for_impure_v(p, language, v__token__Token_pos(&p->tok));
	}
	bool is_option = p->tok.kind == v__token__Kind__question;
	if (is_option) {
		if (p->peek_tok.kind == v__token__Kind__name || p->peek_tok.kind == v__token__Kind__lsbr) {
			v__parser__Parser_check(p, v__token__Kind__question);
		}
	}
	bool is_array = p->tok.kind == v__token__Kind__lsbr;
	bool is_fixed_array = is_array && p->peek_tok.kind == v__token__Kind__number;
	string mod = _S("");
	p->expr_mod = _S("");
	if (p->peek_tok.kind == v__token__Kind__lsbr && builtin__fast_string_eq(p->tok.lit, _S("map"))) {
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		v__ast__Type map_type = v__parser__Parser_parse_map_type(p);
		if (p->tok.kind == v__token__Kind__lcbr) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__rcbr) {
				pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->tok));
				v__parser__Parser_next(p);
			} else {
				if (p->pref->is_fmt) {
					v__ast__MapInit map_init = v__parser__Parser_map_init(p);
					v__parser__Parser_check(p, v__token__Kind__rcbr);
					return v__ast__MapInit_to_sumtype_v__ast__Expr(&map_init, false);
				}
				v__parser__Parser_error(p, _S("`}` expected; explicit `map` initialization does not support parameters"));
			}
		}
		if (is_option) {
			map_type = v__ast__Type_set_flag(map_type, v__ast__TypeFlag__option);
		}
		node = v__ast__MapInit_to_sumtype_v__ast__Expr(ADDR(v__ast__MapInit, (((v__ast__MapInit){.comments = builtin____new_array(0, 0, sizeof(Array_v__ast__Comment)),.pre_cmnts = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.keys = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.vals = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.val_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.update_expr_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.update_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = pos,.update_expr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.key_type = 0,.typ = map_type,.value_type = 0,.has_update_expr = 0,}))), false);
		if (p->tok.kind == v__token__Kind__lpar) {
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			return v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, (((v__ast__CastExpr){.arg = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.expr = expr,.typname = v__ast__Table_sym(p->table, map_type)->name,.pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->tok)),.typ = map_type,.expr_type = 0,.has_arg = 0,}))), false);
		}
		return node;
	}
	if (builtin__fast_string_eq(p->tok.lit, _S("chan"))) {
		v__token__Pos first_pos = v__token__Token_pos(&p->tok);
		v__token__Pos last_pos = first_pos;
		v__token__Pos elem_type_pos = v__token__Token_pos(&p->peek_tok);
		if (p->peek_tok.kind == v__token__Kind__not) {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("cannot use chan with Result type"), v__token__Token_pos(&p->peek_tok)))), false);
		}
		v__ast__Type chan_type = v__parser__Parser_parse_chan_type(p);
		elem_type_pos = v__token__Pos_extend(elem_type_pos, v__token__Token_pos(&p->prev_tok));
		bool has_cap = false;
		v__ast__Expr cap_expr = _const_v__ast__empty_expr;
		v__parser__Parser_check(p, v__token__Kind__lcbr);
		if (p->tok.kind == v__token__Kind__rcbr) {
			last_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_next(p);
		} else {
			string key = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__colon);

			if (_SLIT_EQ(key.str, key.len, "cap")) {
				has_cap = true;
				cap_expr = v__parser__Parser_expr(p, 0);
			}
			else if (_SLIT_EQ(key.str, key.len, "len") || _SLIT_EQ(key.str, key.len, "init")) {
				return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = key}}, {_S("` cannot be initialized for `chan`. Did you mean `cap`?"), 0, { .d_c = 0 }}}))))), false);
			}
			else {
				return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("wrong field `"), 0xfe10, {.d_s = key}}, {_S("`, expecting `cap`"), 0, { .d_c = 0 }}}))))), false);
			}
			last_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rcbr);
		}
		if (chan_type == _const_v__ast__chan_type) {
			v__parser__Parser_error_with_pos(p, _S("`chan` has no type specified. Use `chan Type{}` instead of `chan{}`"), v__token__Pos_extend(first_pos, last_pos));
		}
		return v__ast__ChanInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ChanInit, (((v__ast__ChanInit){.pos = v__token__Pos_extend(first_pos, last_pos),.elem_type_pos = elem_type_pos,.has_cap = has_cap,.cap_expr = cap_expr,.typ = chan_type,.elem_type = 0,}))), false);
	}
	if (p->peek_tok.kind == v__token__Kind__string && p->tok.line_nr == p->peek_tok.line_nr && !p->inside_str_interp && v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__colon) {
		if (p->tok.kind == v__token__Kind__name && (builtin__fast_string_eq(p->tok.lit, _S("r")) || builtin__fast_string_eq(p->tok.lit, _S("c")) || builtin__fast_string_eq(p->tok.lit, _S("js")))) {
			return v__parser__Parser_string_expr(p);
		} else {
			return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("only `c`, `r`, `js` are recognized string prefixes, but you tried to use `"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`"), 0, { .d_c = 0 }}}))))), false);
		}
	}
	if (p->peek_tok.kind == v__token__Kind__chartoken && p->tok.lit.len == 1 && (p->tok.lit.str[ 0] == 'r' || p->tok.lit.str[ 0] == 'c')) {
		string opt = (builtin__fast_string_eq(p->tok.lit, _S("r")) ? (_S("`r` (raw string)")) : (_S("`c` (c string)")));
		return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot use "), 0xfe10, {.d_s = opt}}, {_S(" with `byte` and `rune`"), 0, { .d_c = 0 }}}))))), false);
	}
	bool known_var = (v__token__Kind_is_assign(p->peek_tok.kind) ? (v__ast__Scope_known_var(p->scope, p->tok.lit)) : (v__ast__Scope_mark_var_as_used(p->scope, p->tok.lit)));
	bool is_mod_cast = false;
	if (p->peek_tok.kind == v__token__Kind__dot && !known_var && (language != v__ast__Language__v || v__parser__Parser_known_import(p, p->tok.lit) || builtin__string__eq(builtin__string_all_after_last(p->mod, _S(".")), p->tok.lit))) {
		if (language == v__ast__Language__c || language == v__ast__Language__js || language == v__ast__Language__wasm) {
			mod = builtin__string_to_upper_ascii(v__ast__Language_str(language));
		} else {
			if (_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
				v__parser__Parser_register_used_import(p, p->tok.lit);
				v__token__Token tk2 = v__parser__Parser_peek_token(p, 2);
				if (p->peek_tok.kind == v__token__Kind__dot && tk2.kind != v__token__Kind__eof && tk2.lit.len > 0 && builtin__u8_is_capital(tk2.lit.str[ 0])) {
					is_mod_cast = true;
				} else if (p->peek_tok.kind == v__token__Kind__dot && tk2.kind != v__token__Kind__eof && tk2.lit.len == 0) {
					v__ast__Ident ident = v__parser__Parser_ident(p, language);
					node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident, false);
					v__parser__Parser_add_defer_var(p, ident);
					return node;
				}
			}
			mod = (*(string*)builtin__map_get(ADDR(map, p->imports), &(string[]){p->tok.lit}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
		}
		int line_nr = p->tok.line_nr;
		v__parser__Parser_next(p);
		v__parser__Parser_check(p, v__token__Kind__dot);
		if (p->is_vls && p->tok.line_nr != line_nr) {
			return v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (((v__ast__Ident){.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.obj = _const_v__ast__empty_scope_object,.mod = mod,.name = _S(""),.full_name = (string){.str=(byteptr)"", .is_lit=1},.cached_name = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__IdentInfo){._v__ast__IdentFn=HEAP(v__ast__IdentFn, ((v__ast__IdentFn){.typ = 0,})),._typ=407},.scope = ((void*)0),.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = v__token__Token_pos(&p->prev_tok),.tok_kind = 0,.language = 0,.kind = 0,.is_mut = 0,.comptime = 0,.ct_expr = 0,}))), false);
		}
		p->expr_mod = mod;
	}
	bool lit0_is_capital = (p->tok.kind != v__token__Kind__eof && p->tok.lit.len > 0 ? (builtin__u8_is_capital(p->tok.lit.str[ 0])) : (false));
	bool is_generic_call = v__parser__Parser_is_generic_call(p);
	bool is_generic_cast = v__parser__Parser_is_generic_cast(p);
	bool is_generic_struct_init = v__parser__Parser_is_generic_struct_init(p);
	if (p->peek_tok.kind == v__token__Kind__lpar && p->tok.line_nr != p->peek_tok.line_nr && v__token__Token_is_next_to(v__parser__Parser_peek_token(p, 2), p->peek_tok)) {
		v__ast__Ident ident = v__parser__Parser_ident(p, language);
		node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident, false);
		v__parser__Parser_add_defer_var(p, ident);
	} else if (p->peek_tok.kind == v__token__Kind__lpar || is_generic_call || is_generic_cast || (p->tok.kind == v__token__Kind__lsbr && p->peek_tok.kind == v__token__Kind__rsbr && (v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__lpar || v__parser__Parser_peek_token(p, 5).kind == v__token__Kind__lpar)) || (p->tok.kind == v__token__Kind__lsbr && p->peek_tok.kind == v__token__Kind__number && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__rsbr && (v__parser__Parser_peek_token(p, 4).kind == v__token__Kind__lpar || v__parser__Parser_peek_token(p, 6).kind == v__token__Kind__lpar))) {
		string original_name = (is_array ? (v__parser__Parser_peek_token(p, (is_fixed_array ? (3) : (2))).lit) : (p->tok.lit));
		if (is_fixed_array && v__parser__Parser_peek_token(p, 4).kind == v__token__Kind__dot) {
			mod = original_name;
			original_name = v__parser__Parser_peek_token(p, 5).lit;
		} else if (is_array && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__dot) {
			mod = original_name;
			original_name = v__parser__Parser_peek_token(p, 4).lit;
		}
		string name = ((mod).len != 0 ? (builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod}}, {_S("."), 0xfe10, {.d_s = original_name}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (original_name));
		string name_w_mod = v__parser__Parser_prepend_mod(p, name);
		bool is_c_pointer_cast = language == v__ast__Language__c && prev_tok_kind == v__token__Kind__amp;
		bool is_c_type_cast = language == v__ast__Language__c && ((_SLIT_EQ(original_name.str, original_name.len, "intptr_t") || _SLIT_EQ(original_name.str, original_name.len, "uintptr_t")) || (builtin__u8_is_capital(original_name.str[ 0]) && _IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs))));
		bool is_capital_after_last_dot = builtin__u8_is_capital(builtin__string_all_after_last(name, _S(".")).str[ 0]);
		bool is_js_cast = language == v__ast__Language__js && is_capital_after_last_dot;
		if ((is_option || (p->peek_tok.kind == v__token__Kind__lsbr || p->peek_tok.kind == v__token__Kind__lpar)) && (is_mod_cast || is_c_pointer_cast || is_c_type_cast || is_js_cast || is_generic_cast || (language == v__ast__Language__v && (name).len != 0 && (is_capital_after_last_dot || builtin__u8_is_capital(name.str[ 0]) || (!known_var && (_IN_MAP(ADDR(string, name), ADDR(map, p->table->type_idxs)) || _IN_MAP(ADDR(string, name_w_mod), ADDR(map, p->table->type_idxs)))))))) {
			v__token__Pos start_pos = v__token__Token_pos(&p->tok);
			v__ast__Type to_typ = v__parser__Parser_parse_type(p);
			p->is_amp = false;
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Expr expr = _const_v__ast__empty_expr;
			v__ast__Expr arg = _const_v__ast__empty_expr;
			bool has_arg = false;
			expr = v__parser__Parser_expr(p, 0);
			if (p->tok.kind == v__token__Kind__comma && v__ast__Type_idx(to_typ) == 21) {
				v__parser__Parser_next(p);
				arg = v__parser__Parser_expr(p, 0);
				has_arg = true;
			}
			if (p->tok.kind == v__token__Kind__comma && p->peek_tok.kind == v__token__Kind__rpar) {
				v__parser__Parser_next(p);
			}
			v__token__Pos end_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			if (is_option) {
				to_typ = v__ast__Type_set_flag(to_typ, v__ast__TypeFlag__option);
			}
			node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, (((v__ast__CastExpr){
				.arg = arg,
				.expr = expr,
				.typname = (to_typ != 0 ? (v__ast__Table_sym(p->table, to_typ)->name) : (_S("unknown typename"))),
				.pos = v__token__Pos_extend(start_pos, end_pos),
				.typ = to_typ,
				.expr_type = 0,
				.has_arg = has_arg,
			}))), false);
			p->expr_mod = _S("");
			return node;
		} else {
			if (is_option) {
				v__parser__Parser_unexpected_with_pos(p, v__token__Token_pos(&p->prev_tok), ((v__parser__ParamsForUnexpected){.got = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = v__token__Token_str(p->prev_tok)}}, {_SLIT0, 0, { .d_c = 0 }}})),.expecting = (string){.str=(byteptr)"", .is_lit=1},.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			}
			if (p->peek_tok.kind == v__token__Kind__dot && (v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__comma || v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__rpar)) {
				node = v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (v__parser__Parser_enum_val_expr(p, mod))), false);
			} else {
				node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))), false);
				if (p->tok.kind == v__token__Kind__lpar && p->prev_tok.line_nr == p->tok.line_nr) {
					v__parser__Parser_next(p);
					v__token__Pos pos = v__token__Token_pos(&p->tok);
					Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
					v__parser__Parser_check(p, v__token__Kind__rpar);
					v__ast__OrExpr or_block = v__parser__Parser_gen_or_block(p);
					node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (((v__ast__CallExpr){
						.or_block = or_block,
						.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.args = args,
						.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
						.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
						.name = (string){.str=(byteptr)"", .is_lit=1},
						.const_name = (string){.str=(byteptr)"", .is_lit=1},
						.left = node,
						.mod = (string){.str=(byteptr)"", .is_lit=1},
						.scope = p->scope,
						.pos = pos,
						.concrete_list_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
						.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
						.receiver_type = 0,
						.return_type = 0,
						.return_type_generic = 0,
						.nr_ret_values = -1,
						.fn_var_type = 0,
						.left_type = 0,
						.receiver_concrete_type = 0,
						.kind = 0,
						.language = 0,
						.is_unwrapped_fn_selector = 0,
						.is_method = 0,
						.is_field = 0,
						.is_fn_var = 0,
						.is_fn_a_const = 0,
						.is_keep_alive = 0,
						.is_noreturn = 0,
						.is_ctor_new = 0,
						.is_file_translated = 0,
						.is_static_method = 0,
						.is_variadic = 0,
						.is_c_variadic = 0,
						.comptime_ret_val = 0,
						.should_be_skipped = 0,
						.free_receiver = 0,
						.is_return_used = p->expecting_value,
						.is_expand_simple_interpolation = 0,
					}))), false);
				}
			}
		}
	} else if (!known_var && (p->peek_tok.kind == v__token__Kind__lcbr || is_generic_struct_init) && (!p->inside_match || (p->inside_select && prev_tok_kind == v__token__Kind__arrow && lit0_is_capital)) && !p->inside_match_case && (!p->inside_if || p->inside_select) && (!p->inside_for || p->inside_select) && !p->inside_lock_exprs) {
		v__ast__Type alias_array_type = v__parser__Parser_alias_array_type(p);
		if (alias_array_type != _const_v__ast__void_type) {
			return v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (v__parser__Parser_array_init(p, is_option, alias_array_type))), false);
		} else {
			return v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit), v__ast__StructInitKind__normal, is_option))), false);
		}
	} else if (p->peek_tok.kind == v__token__Kind__lcbr && ((p->inside_if && lit0_is_capital && p->tok.lit.len > 1 && !known_var && language == v__ast__Language__v) || (p->inside_match_case && lit0_is_capital && p->tok.kind == v__token__Kind__name && v__token__Token_is_next_to(p->peek_tok, p->tok)))) {
		return v__ast__StructInit_to_sumtype_v__ast__Expr(ADDR(v__ast__StructInit, (v__parser__Parser_struct_init(p, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit), v__ast__StructInitKind__normal, is_option))), false);
	} else if (p->peek_tok.kind == v__token__Kind__dot && lit0_is_capital && !known_var && language == v__ast__Language__v) {
		if (v__parser__Parser_is_generic_name(p) && v__parser__Parser_peek_token(p, 3).kind != v__token__Kind__lpar) {
			v__token__Pos pos = v__token__Token_pos(&p->tok);
			string name = v__parser__Parser_check_name(p);
			v__parser__Parser_check(p, v__token__Kind__dot);
			string field = v__parser__Parser_check_name(p);
			v__ast__GenericKindField fkind = ((_SLIT_EQ(field.str, field.len, "name"))? (v__ast__GenericKindField__name) : (_SLIT_EQ(field.str, field.len, "typ"))? (v__ast__GenericKindField__typ) : (_SLIT_EQ(field.str, field.len, "unaliased_typ"))? (v__ast__GenericKindField__unaliased_typ) : (_SLIT_EQ(field.str, field.len, "indirections"))? (v__ast__GenericKindField__indirections) : (v__ast__GenericKindField__unknown));
			v__token__Pos_extend(pos, v__token__Token_pos(&p->tok));
			return v__ast__SelectorExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__SelectorExpr, (((v__ast__SelectorExpr){.or_block = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.generic_from_embed_types = builtin____new_array(0, 0, sizeof(Array_v__ast__Type)),.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.expr = v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (((v__ast__Ident){.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.obj = _const_v__ast__empty_scope_object,.mod = (string){.str=(byteptr)"", .is_lit=1},.name = name,.full_name = (string){.str=(byteptr)"", .is_lit=1},.cached_name = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__IdentInfo){._v__ast__IdentFn=HEAP(v__ast__IdentFn, ((v__ast__IdentFn){.typ = 0,})),._typ=407},.scope = p->scope,.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.tok_kind = 0,.language = 0,.kind = 0,.is_mut = 0,.comptime = 0,.ct_expr = 0,}))), false),.field_name = field,.scope = p->scope,.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = pos,.name_type = 0,.expr_type = 0,.typ = 0,.next_token = 0,.gkind_field = fkind,.is_mut = 0,.has_hidden_receiver = 0,.is_field_typ = 0,}))), false);
		}
		if (!known_var && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__lpar) {
			if (lit0_is_capital && p->peek_tok.kind == v__token__Kind__dot && language == v__ast__Language__v) {
				p->expr_mod = _S("");
				return v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))), false);
			} else {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = lit0_is_capital ? _S("true") : _S("false")}}, {_S(" the receiver of the method call must be an instantiated object, e.g. `foo.bar()`"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
			}
		}
		if (!known_var && lit0_is_capital && p->peek_tok.kind == v__token__Kind__dot && language == v__ast__Language__v && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name) {
			_option_v__ast__Fn _t22;
			if (_t22 = v__ast__Table_find_fn(p->table, builtin__string__plus(builtin__string__plus(v__parser__Parser_prepend_mod(p, p->tok.lit), _S("__static__")), v__parser__Parser_peek_token(p, 2).lit)), _t22.state == 0) {
				v__ast__Fn func = *(v__ast__Fn*)_t22.data;
				v__ast__Type fn_type = v__ast__new_type(v__ast__Table_find_or_register_fn_type(p->table, func, false, true));
				v__token__Pos pos = v__token__Token_pos(&p->tok);
				string typ_name = v__parser__Parser_check_name(p);
				v__parser__Parser_check(p, v__token__Kind__dot);
				string field_name = v__parser__Parser_check_name(p);
				v__token__Pos_extend(pos, v__token__Token_pos(&p->tok));
				return v__ast__Ident_to_sumtype_v__ast__Expr(ADDR(v__ast__Ident, (((v__ast__Ident){
					.or_expr = ((v__ast__OrExpr){.kind = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.scope = ((void*)0),.err_used = 0,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}),
					.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
					.obj = _const_v__ast__empty_scope_object,
					.mod = p->mod,
					.name = builtin__string__plus(builtin__string__plus(v__parser__Parser_prepend_mod(p, typ_name), _S("__static__")), field_name),
					.full_name = (string){.str=(byteptr)"", .is_lit=1},
					.cached_name = (string){.str=(byteptr)"", .is_lit=1},
					.info = v__ast__IdentFn_to_sumtype_v__ast__IdentInfo(ADDR(v__ast__IdentFn, (((v__ast__IdentFn){.typ = fn_type,}))), false),
					.scope = p->scope,
					.mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
					.pos = pos,
					.tok_kind = 0,
					.language = 0,
					.kind = v__ast__IdentKind__function,
					.is_mut = 0,
					.comptime = 0,
					.ct_expr = 0,
				}))), false);
			}
		}
		return v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (v__parser__Parser_enum_val_expr(p, mod))), false);
	} else if (language == v__ast__Language__js && p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).kind == v__token__Kind__name) {
		node = v__ast__CallExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CallExpr, (v__parser__Parser_call_expr(p, language, mod))), false);
	} else {
		if (p->inside_in_array && ((lit0_is_capital && !known_var && language == v__ast__Language__v) || (p->peek_tok.kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, 2).lit.len > 0 && builtin__u8_is_capital(v__parser__Parser_peek_token(p, 2).lit.str[ 0])) || v__ast__Table_find_type_idx(p->table, builtin__string__plus(builtin__string__plus(p->mod, _S(".")), p->tok.lit)) > 0 || p->inside_comptime_if)) {
			v__token__Pos type_pos = v__token__Token_pos(&p->tok);
			v__ast__Type typ = v__parser__Parser_parse_type(p);
			if (is_option) {
				typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__option);
			}
			return v__ast__TypeNode_to_sumtype_v__ast__Expr(ADDR(v__ast__TypeNode, (((v__ast__TypeNode){.pos = type_pos,.typ = typ,.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}))), false);
		} else if (!known_var && language == v__ast__Language__v && (lit0_is_capital || v__ast__Table_known_type(p->table, p->tok.lit)) && p->peek_tok.kind == v__token__Kind__pipe) {
			v__token__Pos start_pos = v__token__Token_pos(&p->tok);
			v__ast__Type to_typ = v__parser__Parser_parse_type(p);
			v__parser__Parser_check(p, v__token__Kind__lpar);
			v__ast__Expr expr = v__parser__Parser_expr(p, 0);
			v__token__Pos end_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__rpar);
			node = v__ast__CastExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__CastExpr, (((v__ast__CastExpr){
				.arg = _const_v__ast__empty_expr,
				.expr = expr,
				.typname = (to_typ != 0 ? (v__ast__Table_sym(p->table, to_typ)->name) : (_S("unknown type name"))),
				.pos = v__token__Pos_extend(start_pos, end_pos),
				.typ = to_typ,
				.expr_type = 0,
				.has_arg = false,
			}))), false);
			p->expr_mod = _S("");
			return node;
		} else if (is_option && p->tok.kind == v__token__Kind__lsbr) {
			return v__ast__ArrayInit_to_sumtype_v__ast__Expr(ADDR(v__ast__ArrayInit, (v__parser__Parser_array_init(p, is_option, _const_v__ast__void_type))), false);
		} else if (!known_var && language == v__ast__Language__v && p->peek_tok.kind == v__token__Kind__dot && !p->pref->is_fmt) {
			v__token__Token peek_tok2 = v__parser__Parser_peek_token(p, 2);
			v__token__Token peek_tok3 = v__parser__Parser_peek_token(p, 3);
			mod = p->tok.lit;
			int n = -1;
			for (;;) {
				if (!(v__parser__Parser_peek_token(p, n).kind == v__token__Kind__dot && v__parser__Parser_peek_token(p, (int)(n - 1)).kind == v__token__Kind__name)) break;
				mod = builtin__string__plus(builtin__string__plus(v__parser__Parser_peek_token(p, (int)(n - 1)).lit, _S(".")), mod);
				n -= 2;
			}
			if (peek_tok2.kind == v__token__Kind__name && peek_tok2.lit.len > 0 && builtin__u8_is_capital(peek_tok2.lit.str[ 0]) && peek_tok3.kind == v__token__Kind__lcbr && (mod.len > p->tok.lit.len || !v__parser__Parser_known_import(p, p->tok.lit))) {
				string msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("unknown module `"), 0xfe10, {.d_s = mod}}, {_S("`"), 0, { .d_c = 0 }}}));
				if (mod.len > p->tok.lit.len && v__parser__Parser_known_import(p, p->tok.lit)) {
					msg = builtin__string__plus(msg, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("; did you mean `"), 0xfe10, {.d_s = p->tok.lit}}, {_S("`?"), 0, { .d_c = 0 }}})));
				}
				v__parser__Parser_error_with_pos(p, msg, v__token__Token_pos(&p->tok));
			}
		}
		v__ast__Ident ident = v__parser__Parser_ident(p, language);
		node = v__ast__Ident_to_sumtype_v__ast__Expr(&ident, false);
		v__parser__Parser_add_defer_var(p, ident);
	}
	p->expr_mod = _S("");
	return node;
}
VV_LOC multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope v__parser__Parser_or_block(v__parser__Parser* p, v__parser__OrBlockErrVarMode err_var_mode) {
	bool was_inside_or_expr = p->inside_or_expr;
	p->inside_or_expr = true;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	v__parser__Parser_open_scope(p);
	v__ast__Scope* or_scope = p->scope;
	if (err_var_mode == v__parser__OrBlockErrVarMode__with_err_var) {
		v__ast__Scope_register(p->scope, v__ast__Var_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__Var, (((v__ast__Var){
			.smartcasts = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
			.name = _S("err"),
			.pos = v__token__Token_pos(&p->tok),
			.typ = _const_v__ast__error_type,
			.orig_type = 0,
			.ct_type_var = 0,
			.share = 0,
			.is_arg = 0,
			.is_auto_deref = 0,
			.is_unwrapped = 0,
			.is_index_var = 0,
			.is_volatile = 0,
			.is_static = 0,
			.is_special = true,
			.is_mut = 0,
			.is_used = false,
			.is_changed = 0,
			.ct_type_unwrapped = 0,
			.is_or = 0,
			.is_tmp = 0,
			.is_auto_heap = 0,
			.is_stack_obj = true,
			.is_inherited = 0,
			.is_autofree_tmp = 0,
			.has_inherited = 0,
		}))), false));
	}
	Array_v__ast__Stmt stmts = v__parser__Parser_parse_block_no_scope(p, false);
	pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok));
	multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope _t1 = (multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope){.arg0=stmts, .arg1=pos, .arg2=or_scope};
		{ // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
		{ // defer begin
			p->inside_or_expr = was_inside_or_expr;
		} // defer end
	return _t1;
}
VV_LOC v__ast__IndexExpr v__parser__Parser_index_expr(v__parser__Parser* p, v__ast__Expr left, bool is_gated) {
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	bool has_low = true;
	if (p->tok.kind == v__token__Kind__dotdot) {
		has_low = false;
		v__parser__Parser_next(p);
		v__ast__Expr high = _const_v__ast__empty_expr;
		bool has_high = false;
		if (p->tok.kind != v__token__Kind__rsbr) {
			high = v__parser__Parser_expr(p, 0);
			has_high = true;
		}
		v__token__Pos pos_high = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->tok));
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__OrKind or_kind_high = v__ast__OrKind__absent;
		Array_v__ast__Stmt or_stmts_high = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__token__Pos or_pos_high = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		v__ast__Scope* or_scope = _const_v__ast__empty_scope;
		if (!p->or_is_handled) {
			if (p->tok.kind == v__token__Kind__key_orelse) {
				multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_57100 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__no_err_var);
				or_stmts_high = mr_57100.arg0;
				or_pos_high = mr_57100.arg1;
				or_scope = mr_57100.arg2;
				return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = v__ast__OrKind__block,.pos = or_pos_high,.scope = or_scope,.err_used = 0,.stmts = or_stmts_high,}),.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){.low = _const_v__ast__empty_expr,.high = high,.pos = pos_high,.typ = 0,.has_high = has_high,.has_low = 0,.is_gated = is_gated,}))), false),.left = left,.pos = pos_high,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
			}
			if (p->tok.kind == v__token__Kind__not) {
				or_pos_high = v__token__Token_pos(&p->tok);
				or_kind_high = v__ast__OrKind__propagate_result;
				or_scope = p->scope;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__question) {
				v__parser__Parser_error_with_pos(p, _S("`?` for propagating errors from index expressions is no longer supported, use `!` instead of `?`"), v__token__Token_pos(&p->tok));
			}
		}
		return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = or_kind_high,.pos = or_pos_high,.scope = or_scope,.err_used = 0,.stmts = or_stmts_high,}),.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){.low = _const_v__ast__empty_expr,.high = high,.pos = pos_high,.typ = 0,.has_high = has_high,.has_low = 0,.is_gated = is_gated,}))), false),.left = left,.pos = pos_high,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
	}
	v__ast__Expr expr = v__parser__Parser_expr(p, 0);
	bool has_high = false;
	if (p->tok.kind == v__token__Kind__dotdot) {
		v__parser__Parser_next(p);
		v__ast__Expr high = _const_v__ast__empty_expr;
		if (p->tok.kind != v__token__Kind__rsbr) {
			has_high = true;
			high = v__parser__Parser_expr(p, 0);
		}
		v__token__Pos pos_low = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->tok));
		v__parser__Parser_check(p, v__token__Kind__rsbr);
		v__ast__OrKind or_kind_low = v__ast__OrKind__absent;
		Array_v__ast__Stmt or_stmts_low = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
		v__token__Pos or_pos_low = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		v__ast__Scope* or_scope = _const_v__ast__empty_scope;
		if (!p->or_is_handled) {
			if (p->tok.kind == v__token__Kind__key_orelse) {
				multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_58800 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__no_err_var);
				or_stmts_low = mr_58800.arg0;
				or_pos_low = mr_58800.arg1;
				or_scope = mr_58800.arg2;
				return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = v__ast__OrKind__block,.pos = or_pos_low,.scope = or_scope,.err_used = 0,.stmts = or_stmts_low,}),.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){
					.low = expr,
					.high = high,
					.pos = pos_low,
					.typ = 0,
					.has_high = has_high,
					.has_low = has_low,
					.is_gated = is_gated,
				}))), false),.left = left,.pos = pos_low,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
			}
			if (p->tok.kind == v__token__Kind__not) {
				or_pos_low = v__token__Token_pos(&p->tok);
				or_kind_low = v__ast__OrKind__propagate_result;
				or_scope = p->scope;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__question) {
				v__parser__Parser_error_with_pos(p, _S("`?` for propagating errors from index expressions is no longer supported, use `!` instead of `?`"), v__token__Token_pos(&p->tok));
			}
		}
		return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = or_kind_low,.pos = or_pos_low,.scope = or_scope,.err_used = 0,.stmts = or_stmts_low,}),.index = v__ast__RangeExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__RangeExpr, (((v__ast__RangeExpr){
			.low = expr,
			.high = high,
			.pos = pos_low,
			.typ = 0,
			.has_high = has_high,
			.has_low = has_low,
			.is_gated = is_gated,
		}))), false),.left = left,.pos = pos_low,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
	}
	v__token__Pos pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->tok));
	v__parser__Parser_check(p, v__token__Kind__rsbr);
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Pos or_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (!p->or_is_handled) {
		if (p->tok.kind == v__token__Kind__key_orelse) {
			multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_60240 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__no_err_var);
			or_stmts = mr_60240.arg0;
			or_pos = mr_60240.arg1;
			or_scope = mr_60240.arg2;
			return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = v__ast__OrKind__block,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),.index = expr,.left = left,.pos = pos,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
		}
		if (p->tok.kind == v__token__Kind__not) {
			or_pos = v__token__Token_pos(&p->tok);
			or_kind = v__ast__OrKind__propagate_result;
			or_scope = p->scope;
			v__parser__Parser_next(p);
		} else if (p->tok.kind == v__token__Kind__question) {
			v__parser__Parser_error_with_pos(p, _S("`?` for propagating errors from index expressions is no longer supported, use `!` instead of `?`"), v__token__Token_pos(&p->tok));
		}
	}
	return ((v__ast__IndexExpr){.or_expr = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),.index = expr,.left = left,.pos = pos,.typ = 0,.left_type = 0,.is_map = 0,.is_array = 0,.is_farray = 0,.is_option = 0,.is_direct = 0,.is_gated = is_gated,.is_setter = 0,});
}
VV_LOC v__ast__Expr v__parser__Parser_dot_expr(v__parser__Parser* p, v__ast__Expr left) {
	bool v__parser__Parser_dot_expr_defer_0 = false;
	int prev_line = v__token__Token_pos(&p->prev_tok).line_nr;
	v__parser__Parser_next(p);
	if (p->tok.kind == v__token__Kind__dollar) {
		return v__parser__Parser_comptime_selector(p, left);
	}
	bool is_generic_call = v__parser__Parser_is_generic_call(p);
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	if (!is_generic_call && p->tok.kind == v__token__Kind__name && p->inside_array_lit && (p->last_enum_name).len != 0 && prev_line != name_pos.line_nr) {
		p->name_error = true;
		return v__ast__EnumVal_to_sumtype_v__ast__Expr(ADDR(v__ast__EnumVal, (((v__ast__EnumVal){.enum_name = p->last_enum_name,.val = v__parser__Parser_check_name(p),.mod = p->last_enum_mod,.pos = v__token__Token_pos(&p->tok),.typ = 0,}))), false);
	}
	string field_name = _S("");
	if (v__token__Token_pos(&p->prev_tok).line_nr == name_pos.line_nr || p->tok.kind != v__token__Kind__name) {
		if (p->is_vls && p->tok.kind != v__token__Kind__name) {
			if (p->tok.kind == v__token__Kind__rpar || p->tok.kind == v__token__Kind__rcbr) {
				return left;
			} else if (name_pos.line_nr != p->tok.line_nr) {
				return left;
			}
		}
		field_name = v__parser__Parser_check_name(p);
	} else {
		p->name_error = true;
	}
	if (v__token__KeywordsMatcherTrie_matches(&_const_v__ast__builtin_array_generic_methods_matcher, field_name)) {
		if (p->file_backend_mode == v__ast__Language__v || p->file_backend_mode == v__ast__Language__c) {
			v__parser__Parser_register_auto_import(p, _S("builtin.closure"));
		}
		v__parser__Parser_open_scope(p);
		v__parser__Parser_dot_expr_defer_0 = true;
	}
	if (p->tok.kind == v__token__Kind__not && p->peek_tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__Type concrete_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__token__Pos concrete_list_pos = v__token__Token_pos(&p->tok);
	if (is_generic_call) {
		concrete_types = v__parser__Parser_parse_concrete_types(p);
		concrete_list_pos = v__token__Pos_extend(concrete_list_pos, v__token__Token_pos(&p->prev_tok));
		bool _t5 = false;
		Array_v__ast__Type _t5_orig = concrete_types;
		int _t5_len = _t5_orig.len;
		for (int _t6 = 0; _t6 < _t5_len; ++_t6) {
			v__ast__Type it = ((v__ast__Type*) _t5_orig.data)[_t6];
			if (v__ast__Type_has_flag(it, v__ast__TypeFlag__generic)) {
				_t5 = true;
				break;
			}
		}
		bool has_generic =_t5;
		if (!has_generic) {
			v__ast__Table_register_fn_concrete_types(p->table, field_name, concrete_types);
		}
	}
	if (p->tok.kind == v__token__Kind__lpar) {
		v__parser__Parser_next(p);
		Array_v__ast__CallArg args = v__parser__Parser_call_args(p);
		v__parser__Parser_check(p, v__token__Kind__rpar);
		v__ast__OrExpr or_block = v__parser__Parser_gen_or_block(p);
		v__token__Pos end_pos = v__token__Token_pos(&p->prev_tok);
		v__token__Pos pos = v__token__Pos_extend(name_pos, end_pos);
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
		v__ast__Expr left_node = left;
		if ((left_node)._typ == 267 /* v.ast.CallExpr */) {
			(*left_node._v__ast__CallExpr).is_return_used = true;
		}
		if (p->pref->is_fmt) {
			if ((left_node)._typ == 281 /* v.ast.Ident */) {
				if ((builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("time")) || builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("os")) || builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("strings")) || builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("math")) || builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("json")) || builtin__fast_string_eq((*left_node._v__ast__Ident).name, _S("base64"))) && !v__ast__Scope_known_var((*left_node._v__ast__Ident).scope, (*left_node._v__ast__Ident).name)) {
					v__parser__Parser_register_implied_import(p, (*left_node._v__ast__Ident).name);
				}
			}
		}
		v__ast__CallExpr mcall_expr = ((v__ast__CallExpr){
			.or_block = or_block,
			.expected_arg_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.args = args,
			.concrete_types = concrete_types,
			.raw_concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.comments = comments,
			.name = field_name,
			.const_name = (string){.str=(byteptr)"", .is_lit=1},
			.left = left,
			.mod = (string){.str=(byteptr)"", .is_lit=1},
			.scope = p->scope,
			.pos = pos,
			.concrete_list_pos = concrete_list_pos,
			.name_pos = name_pos,
			.receiver_type = 0,
			.return_type = 0,
			.return_type_generic = 0,
			.nr_ret_values = -1,
			.fn_var_type = 0,
			.left_type = 0,
			.receiver_concrete_type = 0,
			.kind = v__parser__Parser_call_kind(p, field_name),
			.language = 0,
			.is_unwrapped_fn_selector = 0,
			.is_method = true,
			.is_field = 0,
			.is_fn_var = 0,
			.is_fn_a_const = 0,
			.is_keep_alive = 0,
			.is_noreturn = 0,
			.is_ctor_new = 0,
			.is_file_translated = 0,
			.is_static_method = 0,
			.is_variadic = 0,
			.is_c_variadic = 0,
			.comptime_ret_val = 0,
			.should_be_skipped = 0,
			.free_receiver = 0,
			.is_return_used = p->expecting_value,
			.is_expand_simple_interpolation = 0,
		});
		v__ast__Expr _t7 = v__ast__CallExpr_to_sumtype_v__ast__Expr(&mcall_expr, false);
			if (v__parser__Parser_dot_expr_defer_0) { // defer begin
				v__parser__Parser_close_scope(p);
			} // defer end
		return _t7;
	}
	bool is_mut = false;
	v__token__Pos mut_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	if (p->inside_match || p->inside_if_expr || p->inside_for) {
		if (left._typ == 281 /* v.ast.Ident */) {
			is_mut = (*left._v__ast__Ident).is_mut;
			mut_pos = (*left._v__ast__Ident).mut_pos;
		}
		else if (left._typ == 302 /* v.ast.SelectorExpr */) {
			is_mut = (*left._v__ast__SelectorExpr).is_mut;
			mut_pos = (*left._v__ast__SelectorExpr).mut_pos;
		}
		
		else {
		}
		
	}
	v__token__Pos pos = (p->name_error ? (v__token__Pos_extend(v__ast__Expr_pos(left), name_pos)) : (name_pos));
	v__ast__OrKind or_kind = v__ast__OrKind__absent;
	Array_v__ast__Stmt or_stmts = builtin____new_array_with_default(0, 0, sizeof(v__ast__Stmt), 0);
	v__token__Pos or_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	v__ast__Scope* or_scope = _const_v__ast__empty_scope;
	if (p->tok.kind == v__token__Kind__key_orelse) {
		or_kind = v__ast__OrKind__block;
		multi_return_Array_v__ast__Stmt_v__token__Pos_ref_v__ast__Scope mr_64743 = v__parser__Parser_or_block(p, v__parser__OrBlockErrVarMode__with_err_var);
		or_stmts = mr_64743.arg0;
		or_pos = mr_64743.arg1;
		or_scope = mr_64743.arg2;
	} else if (p->tok.kind == v__token__Kind__not) {
		or_kind = v__ast__OrKind__propagate_result;
		or_pos = v__token__Token_pos(&p->tok);
		or_scope = p->scope;
		v__parser__Parser_next(p);
	} else if (p->tok.kind == v__token__Kind__question) {
		or_kind = v__ast__OrKind__propagate_option;
		or_pos = v__token__Token_pos(&p->tok);
		or_scope = p->scope;
		v__parser__Parser_next(p);
	}
	v__ast__SelectorExpr sel_expr = ((v__ast__SelectorExpr){
		.or_block = ((v__ast__OrExpr){.kind = or_kind,.pos = or_pos,.scope = or_scope,.err_used = 0,.stmts = or_stmts,}),
		.generic_from_embed_types = builtin____new_array(0, 0, sizeof(Array_v__ast__Type)),
		.from_embed_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.expr = left,
		.field_name = field_name,
		.scope = p->scope,
		.mut_pos = mut_pos,
		.pos = pos,
		.name_type = 0,
		.expr_type = 0,
		.typ = 0,
		.next_token = p->tok.kind,
		.gkind_field = 0,
		.is_mut = is_mut,
		.has_hidden_receiver = 0,
		.is_field_typ = 0,
	});
	v__ast__Expr left_node = left;
	if ((left_node)._typ == 267 /* v.ast.CallExpr */) {
		(*left_node._v__ast__CallExpr).is_return_used = true;
	}
	v__ast__Expr _t8 = v__ast__SelectorExpr_to_sumtype_v__ast__Expr(&sel_expr, false);
		if (v__parser__Parser_dot_expr_defer_0) { // defer begin
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t8;
}
VV_LOC multi_return_Array_v__ast__Type_Array_string v__parser__Parser_parse_generic_types(v__parser__Parser* p) {
	Array_v__ast__Type types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_string param_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (p->tok.kind != v__token__Kind__lsbr) {
		return (multi_return_Array_v__ast__Type_Array_string){.arg0=types, .arg1=param_names};
	}
	v__token__Kind end_kind = v__token__Kind__rsbr;
	v__parser__Parser_next(p);
	bool first_done = false;
	int count = 0;
	for (;;) {
		if (!(!(p->tok.kind == end_kind || p->tok.kind == v__token__Kind__eof))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
		string name = p->tok.lit;
		if ((name).len != 0 && !builtin__u8_is_capital(builtin__string_at(name, 0))) {
			v__parser__Parser_error(p, _S("generic parameter needs to be uppercase"));
		}
		if (name.len > 1) {
			v__parser__Parser_error(p, _S("generic parameter name needs to be exactly one char"));
		}
		if (!v__util__is_generic_type_name(p->tok.lit)) {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = p->tok.lit}}, {_S("` is a reserved name and cannot be used for generics"), 0, { .d_c = 0 }}})));
		}
		if ((Array_string_contains(param_names, name))) {
			v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicated generic parameter `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})));
		}
		if (count > 8) {
			v__parser__Parser_error(p, _S("cannot have more than 9 generic parameters"));
		}
		v__parser__Parser_check(p, v__token__Kind__name);
		builtin__array_push((array*)&param_names, _MOV((string[]){ builtin__string_clone(name) }));
		int idx = v__ast__Table_find_type_idx(p->table, name);
		if (idx == 0) {
			idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.mod = p->mod,.name = name,.cname = v__util__no_dots(name),.rname = (string){.str=(byteptr)"", .is_lit=1},.ngname = (string){.str=(byteptr)"", .is_lit=1},.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},.align = -1,.idx = 0,.size = -1,.parent_idx = 0,.kind = v__ast__Kind__any,.language = 0,.is_pub = true,.is_builtin = 0,}));
		}
		builtin__array_push((array*)&types, _MOV((v__ast__Type[]){ v__ast__Type_set_flag(v__ast__new_type(idx), v__ast__TypeFlag__generic) }));
		first_done = true;
		count++;
	}
	v__parser__Parser_check(p, end_kind);
	return (multi_return_Array_v__ast__Type_Array_string){.arg0=types, .arg1=param_names};
}
VV_LOC Array_v__ast__Type v__parser__Parser_parse_concrete_types(v__parser__Parser* p) {
	Array_v__ast__Type types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	if (p->tok.kind != v__token__Kind__lsbr) {
		return types;
	}
	p->inside_fn_concrete_type = true;
	v__token__Kind end_kind = v__token__Kind__rsbr;
	v__parser__Parser_next(p);
	bool first_done = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__eof || p->tok.kind == end_kind))) break;
		if (first_done) {
			v__parser__Parser_check(p, v__token__Kind__comma);
		}
		builtin__array_push((array*)&types, _MOV((v__ast__Type[]){ v__parser__Parser_parse_type(p) }));
		first_done = true;
	}
	v__parser__Parser_check(p, end_kind);
	Array_v__ast__Type _t3 = types;
		{ // defer begin
			p->inside_fn_concrete_type = false;
		} // defer end
	return _t3;
}
VV_LOC v__ast__Expr v__parser__Parser_string_expr(v__parser__Parser* p) {
	bool is_raw = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("r"));
	bool is_cstr = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("c"));
	bool is_js_str = p->tok.kind == v__token__Kind__name && builtin__fast_string_eq(p->tok.lit, _S("js"));
	if (is_raw || is_cstr || is_js_str) {
		v__parser__Parser_next(p);
	}
	v__ast__Expr node = _const_v__ast__empty_expr;
	string val = p->tok.lit;
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	pos.last_line = (int)(pos.line_nr + builtin__string_count(val, _S("\n")));
	if (p->peek_tok.kind != v__token__Kind__str_dollar) {
		v__parser__Parser_next(p);
		bool _t1 = true;
		v__ast__Language _t2 = 0;
		
		if (_t1 == (is_cstr)) {
			_t2 = v__ast__Language__c;
		}
		else if (_t1 == (is_js_str)) {
			_t2 = v__ast__Language__js;
		}
		else {
			_t2 = v__ast__Language__v;
		}node = v__ast__StringLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringLiteral, (((v__ast__StringLiteral){.val = val,.pos = pos,.language = _t2,.is_raw = is_raw,}))), false);
		return node;
	}
	Array_v__ast__Expr exprs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Expr), 0);
	Array_string vals = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	Array_bool has_fmts = builtin____new_array_with_default(0, 0, sizeof(bool), 0);
	Array_int fwidths = builtin____new_array_with_default(0, 0, sizeof(int), 0);
	Array_int precisions = builtin____new_array_with_default(0, 0, sizeof(int), 0);
	Array_bool visible_pluss = builtin____new_array_with_default(0, 0, sizeof(bool), 0);
	Array_bool fills = builtin____new_array_with_default(0, 0, sizeof(bool), 0);
	Array_u8 fmts = builtin____new_array_with_default(0, 0, sizeof(u8), 0);
	Array_v__token__Pos fposs = builtin____new_array_with_default(0, 0, sizeof(v__token__Pos), 0);
	p->inside_str_interp = true;
	for (;;) {
		if (!(p->tok.kind == v__token__Kind__string)) break;
		builtin__array_push((array*)&vals, _MOV((string[]){ builtin__string_clone(p->tok.lit) }));
		v__parser__Parser_next(p);
		if (p->tok.kind != v__token__Kind__str_dollar) {
			break;
		}
		v__parser__Parser_next(p);
		builtin__array_push((array*)&exprs, _MOV((v__ast__Expr[]){ v__parser__Parser_expr(p, 0) }));
		bool has_fmt = false;
		int fwidth = 0;
		bool fwidthneg = false;
		int precision = 987698;
		bool visible_plus = false;
		bool fill = false;
		rune fmt = '_';
		if (p->tok.kind == v__token__Kind__colon) {
			v__parser__Parser_next(p);
			if (p->tok.kind == v__token__Kind__minus) {
				fwidthneg = true;
				v__parser__Parser_next(p);
			} else if (p->tok.kind == v__token__Kind__plus) {
				visible_plus = true;
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__number) {
				Array_string fields = builtin__string_split(p->tok.lit, _S("."));
				if ((*(string*)builtin__array_get(fields, 0)).len > 0 && builtin__string_at((*(string*)builtin__array_get(fields, 0)), 0) == '0') {
					fill = true;
				}
				fwidth = builtin__string_int((*(string*)builtin__array_get(fields, 0)));
				if (fwidthneg) {
					fwidth = -fwidth;
				}
				if (fields.len > 1) {
					precision = builtin__string_int((*(string*)builtin__array_get(fields, 1)));
				}
				v__parser__Parser_next(p);
			}
			if (p->tok.kind == v__token__Kind__name) {
				if (p->tok.lit.len == 1) {
					fmt = builtin__string_at(p->tok.lit, 0);
					has_fmt = true;
					v__parser__Parser_next(p);
				} else {
					return v__ast__NodeError_to_sumtype_v__ast__Expr(ADDR(v__ast__NodeError, (v__parser__Parser_error(p, _S("format specifier may only be one letter")))), false);
				}
			}
		}
		builtin__array_push((array*)&fwidths, _MOV((int[]){ fwidth }));
		builtin__array_push((array*)&has_fmts, _MOV((bool[]){ has_fmt }));
		builtin__array_push((array*)&precisions, _MOV((int[]){ precision }));
		builtin__array_push((array*)&visible_pluss, _MOV((bool[]){ visible_plus }));
		builtin__array_push((array*)&fmts, _MOV((u8[]){ fmt }));
		builtin__array_push((array*)&fills, _MOV((bool[]){ fill }));
		builtin__array_push((array*)&fposs, _MOV((v__token__Pos[]){ v__token__Token_pos(&p->prev_tok) }));
	}
	pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->prev_tok));
	node = v__ast__StringInterLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__StringInterLiteral, (((v__ast__StringInterLiteral){
		.vals = vals,
		.fwidths = fwidths,
		.precisions = precisions,
		.pluss = visible_pluss,
		.fills = fills,
		.fmt_poss = fposs,
		.pos = pos,
		.exprs = exprs,
		.expr_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.fmts = fmts,
		.need_fmts = has_fmts,
	}))), false);
	p->inside_str_interp = false;
	return node;
}
VV_LOC v__ast__Expr v__parser__Parser_parse_number_literal(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	bool is_neg = p->tok.kind == v__token__Kind__minus;
	if (is_neg) {
		v__parser__Parser_next(p);
		pos = v__token__Pos_extend(pos, v__token__Token_pos(&p->tok));
	}
	string lit = p->tok.lit;
	string full_lit = (is_neg ? (builtin__string__plus(_S("-"), lit)) : (lit));
	v__ast__Expr node = _const_v__ast__empty_expr;
	if (builtin__string_index_any(lit, _S(".eE")) >= 0 && !(builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0x")) || builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0X")) || builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0o")) || builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0O")) || builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0b")) || builtin__fast_string_eq(builtin__string_substr(lit, 0, 2), _S("0B")))) {
		node = v__ast__FloatLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__FloatLiteral, (((v__ast__FloatLiteral){.val = full_lit,.pos = pos,}))), false);
	} else {
		node = v__ast__IntegerLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__IntegerLiteral, (((v__ast__IntegerLiteral){.val = full_lit,.pos = pos,}))), false);
	}
	v__parser__Parser_next(p);
	return node;
}
VV_LOC v__ast__ConstDecl v__parser__Parser_const_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	Array_v__ast__Attr attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	if (p->attrs.len > 0) {
		attrs = builtin__array_clone_to_depth(&p->attrs, 0);
		p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	}
	bool is_markused = false;
	bool is_exported = false;
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr ga = ((v__ast__Attr*)attrs.data)[_t1];

		if (_SLIT_EQ(ga.name.str, ga.name.len, "markused")) {
			is_markused = true;
		}
		else if (_SLIT_EQ(ga.name.str, ga.name.len, "export")) {
			is_exported = true;
		}
		else {
		}
	}
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__token__Pos const_pos = v__token__Token_pos(&p->tok);
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		return ((v__ast__ConstDecl){.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_pub = 0,.is_block = 0,});
	}
	v__parser__Parser_check(p, v__token__Kind__key_const);
	bool is_block = p->tok.kind == v__token__Kind__lpar;
	if (is_block) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__ConstField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__ConstField), 0);
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	Array_v__ast__Comment end_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		if (is_block && p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("eof"),.expecting = _S("\302\264)\302\264"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			return ((v__ast__ConstDecl){.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_pub = 0,.is_block = 0,});
		}
		if (p->tok.kind == v__token__Kind__rpar) {
			break;
		}
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		string name = v__parser__Parser_check_name(p);
		_PUSH_MANY(&end_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t4, Array_v__ast__Comment);
		bool is_virtual_c_const = false;
		v__ast__Type typ = _const_v__ast__void_type;
		if (_SLIT_EQ(name.str, name.len, "C") && p->tok.kind == v__token__Kind__dot) {
			v__parser__Parser_next(p);
			name = builtin__string__plus(name, builtin__string__plus(_S("."), v__parser__Parser_check_name(p)));
			typ = v__parser__Parser_parse_type(p);
			is_virtual_c_const = true;
		}
		if (!p->pref->translated && !p->is_translated && !is_virtual_c_const && v__util__contains_capital(name)) {
			v__parser__Parser_error_with_pos(p, _S("const names cannot contain uppercase letters, use snake_case instead"), pos);
		}
		string full_name = (is_virtual_c_const ? (name) : (v__parser__Parser_prepend_mod(p, name)));
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_error_with_pos(p, _S("const declaration do not support multiple assign yet"), v__token__Token_pos(&p->tok));
		}
		if (p->tok.kind == v__token__Kind__decl_assign) {
			v__parser__Parser_check(p, v__token__Kind__decl_assign);
		} else {
			if (!is_virtual_c_const) {
				v__parser__Parser_check(p, v__token__Kind__assign);
			}
		}
		_PUSH_MANY(&end_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t5, Array_v__ast__Comment);
		if (p->tok.kind == v__token__Kind__key_fn && !is_virtual_c_const) {
			v__parser__Parser_error(p, _S("const initializer fn literal is not a constant"));
			return ((v__ast__ConstDecl){.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_pub = 0,.is_block = 0,});
		}
		if (p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("eof"),.expecting = _S("an expression"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			return ((v__ast__ConstDecl){.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__ConstField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_pub = 0,.is_block = 0,});
		}
		v__ast__Expr expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258};
		if (!is_virtual_c_const) {
			bool old_inside_assign_rhs = p->inside_assign_rhs;
			p->inside_assign_rhs = true;
			expr = v__parser__Parser_expr(p, 0);
			p->inside_assign_rhs = old_inside_assign_rhs;
		}
		if (is_block || p->pref->is_vls) {
			_PUSH_MANY(&end_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t8, Array_v__ast__Comment);
		}
		v__ast__ConstField field = ((v__ast__ConstField){
			.mod = p->mod,
			.name = full_name,
			.is_pub = is_pub,
			.is_markused = is_markused,
			.is_exported = is_exported,
			.pos = v__token__Pos_extend(pos, v__ast__Expr_pos(expr)),
			.attrs = attrs,
			.is_virtual_c = is_virtual_c_const,
			.expr = expr,
			.typ = 0,
			.comments = comments,
			.end_comments = end_comments,
			.comptime_expr_value = _const_v__ast__empty_comptime_const_value,
		});
		if (is_virtual_c_const) {
			field.typ = typ;
		}
		builtin__array_push((array*)&fields, _MOV((v__ast__ConstField[]){ field }));
		v__ast__Scope_register(p->table->global_scope, v__ast__ConstField_to_sumtype_v__ast__ScopeObject(&field, false));
		if (p->pref->is_vls) {
			string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("const_"), 0xfe10, {.d_s = full_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			string _t10; /* if prepend */
			if (fields.len == 1) {
				_PUSH_MANY(&p->cur_comments, (comments), _t12, Array_v__ast__Comment);
				_t10 = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, name, p->cur_comments), v__parser__Parser_comments_to_string(p, end_comments));
				goto _t11;
			};
			{
				_t10 = builtin__string__plus(v__parser__Parser_comments_to_string(p, comments), v__parser__Parser_comments_to_string(p, end_comments));
			}
	_t11: {};
						string doc = _t10;
			v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = field.pos,.doc = doc,});
			v__ast__Table_register_vls_info(p->table, key, val);
		}
		comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (is_block) {
			end_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		}
		if (!is_block) {
			break;
		}
	}
	v__parser__Parser_top_level_statement_end(p);
	if (is_block) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	} else {
		_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t13, Array_v__ast__Comment);
	}
	v__ast__ConstDecl const_decl = ((v__ast__ConstDecl){
		.attrs = attrs,
		.fields = fields,
		.end_comments = comments,
		.pos = v__token__Pos_extend_with_last_line(start_pos, const_pos, p->prev_tok.line_nr),
		.is_pub = is_pub,
		.is_block = is_block,
	});
	return const_decl;
}
VV_LOC v__ast__Return v__parser__Parser_return_stmt(v__parser__Parser* p) {
	v__token__Pos first_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	if (p->tok.kind == v__token__Kind__rcbr || (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__colon)) {
		return ((v__ast__Return){.scope = p->scope,.pos = first_pos,.comments = comments,.exprs = builtin____new_array(0, 0, sizeof(v__ast__Expr)),.types = builtin____new_array(0, 0, sizeof(v__ast__Type)),});
	}
	bool old_assign_rhs = p->inside_assign_rhs;
	p->inside_assign_rhs = true;
	Array_v__ast__Expr exprs = v__parser__Parser_expr_list(p, true);
	p->inside_assign_rhs = old_assign_rhs;
	v__token__Pos end_pos = v__ast__Expr_pos((*(v__ast__Expr*)builtin__array_last(exprs)));
	return ((v__ast__Return){.scope = p->scope,.pos = v__token__Pos_extend(first_pos, end_pos),.comments = comments,.exprs = exprs,.types = builtin____new_array(0, 0, sizeof(v__ast__Type)),});
}
VV_LOC v__ast__GlobalDecl v__parser__Parser_global_decl(v__parser__Parser* p) {
	Array_v__ast__Attr attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	if (p->attrs.len > 0) {
		attrs = builtin__array_clone_to_depth(&p->attrs, 0);
		p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	}
	bool is_markused = false;
	bool is_exported = false;
	bool is_weak = false;
	bool is_hidden = false;
	bool is_extern = false;
	for (int _t1 = 0; _t1 < attrs.len; ++_t1) {
		v__ast__Attr ga = ((v__ast__Attr*)attrs.data)[_t1];

		if (_SLIT_EQ(ga.name.str, ga.name.len, "export")) {
			is_exported = true;
		}
		else if (_SLIT_EQ(ga.name.str, ga.name.len, "markused")) {
			is_markused = true;
		}
		else if (_SLIT_EQ(ga.name.str, ga.name.len, "weak")) {
			is_weak = true;
		}
		else if (_SLIT_EQ(ga.name.str, ga.name.len, "hidden")) {
			is_hidden = true;
		}
		else if (_SLIT_EQ(ga.name.str, ga.name.len, "c_extern")) {
			is_extern = true;
		}
		else {
		}
	}
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_check(p, v__token__Kind__key_global);
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		return ((v__ast__GlobalDecl){.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_block = 0,.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__GlobalField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
	}
	bool is_block = p->tok.kind == v__token__Kind__lpar;
	if (is_block) {
		v__parser__Parser_next(p);
	}
	Array_v__ast__GlobalField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__GlobalField), 0);
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	for (;;) {
		comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		bool is_volatile = p->tok.kind == v__token__Kind__key_volatile;
		if (is_volatile) {
			v__parser__Parser_next(p);
		}
		if (is_block && p->tok.kind == v__token__Kind__eof) {
			v__parser__Parser_unexpected(p, ((v__parser__ParamsForUnexpected){.got = _S("eof"),.expecting = _S("`)`"),.prepend_msg = (string){.str=(byteptr)"", .is_lit=1},.additional_msg = (string){.str=(byteptr)"", .is_lit=1},}));
			return ((v__ast__GlobalDecl){.mod = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.is_block = 0,.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.fields = builtin____new_array(0, 0, sizeof(v__ast__GlobalField)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),});
		}
		if (p->tok.kind == v__token__Kind__rpar) {
			break;
		}
		v__ast__Language language = v__parser__Parser_parse_language(p);
		v__token__Pos pos = v__token__Token_pos(&p->tok);
		string name = v__parser__Parser_check_name(p);
		bool has_expr = p->tok.kind == v__token__Kind__assign;
		v__ast__Expr expr = _const_v__ast__empty_expr;
		v__ast__Type typ = _const_v__ast__void_type;
		v__token__Pos typ_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		if (has_expr) {
			v__parser__Parser_next(p);
			bool old_assign_rhs = p->inside_assign_rhs;
			p->inside_assign_rhs = true;
			expr = v__parser__Parser_expr(p, 0);
			p->inside_assign_rhs = old_assign_rhs;
			if (expr._typ == 268 /* v.ast.CastExpr */) {
				typ = (*expr._v__ast__CastExpr).typ;
			}
			else if (expr._typ == 236 /* v.ast.StructInit */) {
				typ = (*expr._v__ast__StructInit).typ;
			}
			else if (expr._typ == 261 /* v.ast.ArrayInit */) {
				typ = (*expr._v__ast__ArrayInit).typ;
			}
			else if (expr._typ == 269 /* v.ast.ChanInit */) {
				typ = (*expr._v__ast__ChanInit).typ;
			}
			else if (expr._typ == 265 /* v.ast.BoolLiteral */) {
				typ = _const_v__ast__bool_type;
			}
			else if (expr._typ == 287 /* v.ast.IsRefType */) {
				typ = _const_v__ast__bool_type;
			}
			else if (expr._typ == 270 /* v.ast.CharLiteral */) {
				typ = _const_v__ast__char_type;
			}
			else if (expr._typ == 279 /* v.ast.FloatLiteral */) {
				typ = _const_v__ast__f64_type;
			}
			else if (expr._typ == 286 /* v.ast.IntegerLiteral */) {
				typ = _const_v__ast__int_type;
			}
			else if (expr._typ == 303 /* v.ast.SizeOf */) {
				typ = _const_v__ast__int_type;
			}
			else if (expr._typ == 237 /* v.ast.StringLiteral */) {
				typ = _const_v__ast__string_type;
			}
			else if (expr._typ == 306 /* v.ast.StringInterLiteral */) {
				typ = _const_v__ast__string_type;
			}
			
			else {
			}
			
		} else {
			typ_pos = v__token__Token_pos(&p->tok);
			typ = v__parser__Parser_parse_type(p);
		}
		if (language == v__ast__Language__c) {
			name = builtin__string__plus(_S("C."), name);
		}
		v__ast__GlobalField field = ((v__ast__GlobalField){
			.comments = comments,
			.name = name,
			.expr = expr,
			.typ_pos = typ_pos,
			.pos = pos,
			.typ = typ,
			.language = language,
			.is_weak = is_weak,
			.is_hidden = is_hidden,
			.is_extern = is_extern,
			.has_expr = has_expr,
			.is_volatile = is_volatile,
			.is_markused = is_markused,
			.is_exported = is_exported,
		});
		builtin__array_push((array*)&fields, _MOV((v__ast__GlobalField[]){ field }));
		if (!(Array_string_contains(_const_v__ast__global_reserved_type_names, name))) {
			v__ast__Scope_register(p->table->global_scope, v__ast__GlobalField_to_sumtype_v__ast__ScopeObject(&field, false));
		}
		comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		if (!is_block) {
			break;
		}
	}
	if (is_block) {
		v__parser__Parser_check(p, v__token__Kind__rpar);
	}
	v__ast__GlobalDecl global_decl = ((v__ast__GlobalDecl){
		.mod = p->mod,
		.pos = v__token__Pos_extend(start_pos, v__token__Token_pos(&p->prev_tok)),
		.is_block = is_block,
		.attrs = attrs,
		.fields = fields,
		.end_comments = comments,
	});
	if (p->pref->is_vls) {
		for (int i = 0; i < fields.len; ++i) {
			v__ast__GlobalField f = ((v__ast__GlobalField*)fields.data)[i];
			string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("global_"), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			string _t5; /* if prepend */
			if (i == 0) {
				_PUSH_MANY(&p->cur_comments, (f.comments), _t7, Array_v__ast__Comment);
				_t5 = v__parser__Parser_keyword_comments_to_string(p, f.name, p->cur_comments);
				goto _t6;
			};
			{
				_t5 = v__parser__Parser_comments_to_string(p, f.comments);
			}
	_t6: {};
						string doc = _t5;
			v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = f.pos,.doc = doc,});
			v__ast__Table_register_vls_info(p->table, key, val);
			key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("global_"), 0xfe10, {.d_s = v__parser__Parser_prepend_mod(p, f.name)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__ast__Table_register_vls_info(p->table, key, val);
		}
	}
	return global_decl;
}
VV_LOC string v__parser__source_name(string name) {
	if (v__token__is_key(name)) {
		return builtin__str_intp(2, _MOV((StrIntpData[]){{_S("@"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return name;
}
VV_LOC v__ast__TypeDecl v__parser__Parser_type_decl(v__parser__Parser* p) {
	Array_v__ast__Attr attrs = p->attrs;
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_check(p, v__token__Kind__key_type);
	Array_v__ast__Comment _t1; /* if prepend */
	if (p->pref->is_vls) {
		_t1 = builtin__array_clone_to_depth(&p->cur_comments, 0);
		goto _t2;
	};
	{
		_t1 = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	_t2: {};
		Array_v__ast__Comment comments_before_key_type = _t1;
	v__token__Pos end_pos = v__token__Token_pos(&p->tok);
	v__token__Pos decl_pos = v__token__Pos_extend(start_pos, end_pos);
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		return v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__SumTypeDecl, (((v__ast__SumTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.variants = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.is_markused = 0,}))), false);
	}
	if (p->is_vls && v__token__Token_is_key(p->tok)) {
		v__parser__Parser_error(p, _S("expecting type name"));
		p->should_abort = true;
		return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
	}
	string name = v__parser__Parser_check_name(p);
	v__ast__Language language = v__ast__Language__v;
	if (name.len == 1 && builtin__u8_is_capital(builtin__string_at(name, 0))) {
		if (_SLIT_EQ(name.str, name.len, "C") && p->tok.kind == v__token__Kind__dot) {
			v__parser__Parser_next(p);
			name = builtin__string__plus(_S("C."), v__parser__Parser_check_name(p));
			language = v__ast__Language__c;
		} else {
			v__parser__Parser_error_with_pos(p, _S("single letter capital names are reserved for generic template types"), name_pos);
			return v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__FnTypeDecl, (((v__ast__FnTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.is_markused = 0,}))), false);
		}
	}
	if (v__parser__Parser_is_imported_symbol(p, name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register alias `"), 0xfe10, {.d_s = name}}, {_S("`, this type was already imported"), 0, { .d_c = 0 }}})), end_pos);
		return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
	}
	Array_v__ast__TypeNode sum_variants = builtin____new_array_with_default(0, 0, sizeof(v__ast__TypeNode), 0);
	multi_return_Array_v__ast__Type_Array_string mr_80016 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_80016.arg0;
	v__token__Pos decl_pos_with_generics = v__token__Pos_extend(decl_pos, v__token__Token_pos(&p->prev_tok));
	v__parser__Parser_check(p, v__token__Kind__assign);
	v__token__Pos type_pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	if (p->tok.kind == v__token__Kind__key_fn && v__parser__Parser_is_fn_type_decl(p)) {
		string fn_name = v__parser__Parser_prepend_mod(p, name);
		v__ast__Type fn_type = v__parser__Parser_parse_fn_type(p, fn_name, generic_types);
		v__ast__Table_sym(p->table, fn_type)->is_pub = is_pub;
		type_pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->tok));
		comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
		p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
		v__ast__FnTypeDecl fn_type_decl = ((v__ast__FnTypeDecl){
			.name = fn_name,
			.mod = p->mod,
			.is_pub = is_pub,
			.typ = fn_type,
			.pos = decl_pos,
			.type_pos = type_pos,
			.comments = comments,
			.generic_types = generic_types,
			.attrs = attrs,
			.is_markused = Array_v__ast__Attr_contains(attrs, _S("markused")),
		});
		if (p->pref->is_vls) {
			string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("fntype_"), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = decl_pos,.doc = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, name, comments_before_key_type), v__parser__Parser_comments_to_string(p, comments)),});
			v__ast__Table_register_vls_info(p->table, key, val);
		}
		return v__ast__FnTypeDecl_to_sumtype_v__ast__TypeDecl(&fn_type_decl, false);
	}
	_PUSH_MANY(&sum_variants, (v__parser__Parser_parse_sum_type_variants(p)), _t8, Array_v__ast__TypeNode);
	if (sum_variants.len > 1) {
		for (int _t9 = 0; _t9 < sum_variants.len; ++_t9) {
			v__ast__TypeNode variant = ((v__ast__TypeNode*)sum_variants.data)[_t9];
			if (variant.typ == 0) {
				continue;
			}
			v__ast__TypeSymbol* variant_sym = v__ast__Table_sym(p->table, variant.typ);
			if (variant_sym->kind == v__ast__Kind__none) {
				v__parser__Parser_error_with_pos(p, _S("named sum type cannot have none as its variant"), variant.pos);
				return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
			}
		}
		Array_v__ast__Type _t11 = {0};
		Array_v__ast__TypeNode _t11_orig = sum_variants;
		int _t11_len = _t11_orig.len;
		_t11 = builtin____new_array(0, _t11_len, sizeof(v__ast__Type));

		for (int _t13 = 0; _t13 < _t11_len; ++_t13) {
			v__ast__TypeNode it = ((v__ast__TypeNode*) _t11_orig.data)[_t13];
			v__ast__Type _t12 = it.typ;
			builtin__array_push((array*)&_t11, &_t12);
		}
		Array_v__ast__Type variant_types =_t11;
		string prepend_mod_name = v__parser__Parser_prepend_mod(p, name);
		int typ = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){
			.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
			.mod = p->mod,
			.name = prepend_mod_name,
			.cname = v__util__no_dots(prepend_mod_name),
			.rname = (string){.str=(byteptr)"", .is_lit=1},
			.ngname = (string){.str=(byteptr)"", .is_lit=1},
			.info = v__ast__SumType_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__SumType, (((v__ast__SumType){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.variants = variant_types,.generic_types = generic_types,.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name_pos = name_pos,.parent_type = 0,.found_fields = 0,.is_anon = 0,.is_generic = generic_types.len > 0,}))), false),
			.align = -1,
			.idx = 0,
			.size = -1,
			.parent_idx = 0,
			.kind = v__ast__Kind__sum_type,
			.language = 0,
			.is_pub = is_pub,
			.is_builtin = 0,
		}));
		if ((typ == _const_v__ast__string_type_idx || typ == _const_v__ast__rune_type_idx || typ == _const_v__ast__array_type_idx || typ == _const_v__ast__map_type_idx) && !p->pref->is_fmt) {
			v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register sum type `"), 0xfe10, {.d_s = name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
			return v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__SumTypeDecl, (((v__ast__SumTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = 0,.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.variants = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.is_markused = 0,}))), false);
		}
		v__ast__SumTypeDecl node = ((v__ast__SumTypeDecl){
			.name = name,
			.mod = p->mod,
			.is_pub = is_pub,
			.pos = decl_pos,
			.name_pos = name_pos,
			.typ = typ,
			.generic_types = generic_types,
			.attrs = p->attrs,
			.variants = sum_variants,
			.is_markused = Array_v__ast__Attr_contains(attrs, _S("markused")),
		});
		v__ast__Table_register_sumtype(p->table, node);
		if (p->pref->is_vls) {
			string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sumtype_"), 0xfe10, {.d_s = v__parser__Parser_prepend_mod(p, name)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = node.pos,.doc = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, name, comments_before_key_type), v__parser__Parser_comments_to_string(p, (*(v__ast__TypeNode*)builtin__array_get(sum_variants, (int)(sum_variants.len - 1))).end_comments)),});
			v__ast__Table_register_vls_info(p->table, key, val);
		}
		return v__ast__SumTypeDecl_to_sumtype_v__ast__TypeDecl(&node, false);
	}
	if (generic_types.len > 0) {
		v__parser__Parser_error_with_pos(p, _S("generic type aliases are not yet implemented"), decl_pos_with_generics);
		return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
	}
	v__ast__Type parent_type = (*(v__ast__TypeNode*)builtin__array_get(sum_variants, 0)).typ;
	int pidx = v__ast__Type_idx(parent_type);
	v__ast__Language parent_language = v__ast__Language__v;
	if (parent_type != 0) {
		v__ast__TypeSymbol* parent_sym = v__ast__Table_sym(p->table, parent_type);
		parent_language = parent_sym->language;
		v__parser__Parser_check_for_impure_v(p, parent_sym->language, decl_pos);
	}
	string prepend_mod_name = (language == v__ast__Language__v ? (v__parser__Parser_prepend_mod(p, name)) : (name));
	int idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.name = prepend_mod_name,
		.cname = v__util__no_dots(prepend_mod_name),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = (string){.str=(byteptr)"", .is_lit=1},
		.info = v__ast__Alias_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Alias, (((v__ast__Alias){.name_pos = name_pos,.parent_type = parent_type,.language = parent_language,.is_import = 0,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = pidx,
		.kind = v__ast__Kind__alias,
		.language = 0,
		.is_pub = is_pub,
		.is_builtin = 0,
	}));
	v__token__Pos type_end_pos = v__token__Token_pos(&p->prev_tok);
	if ((idx == _const_v__ast__string_type_idx || idx == _const_v__ast__rune_type_idx || idx == _const_v__ast__array_type_idx || idx == _const_v__ast__map_type_idx) && !p->pref->is_fmt) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register alias `"), 0xfe10, {.d_s = name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
		return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
	}
	if (idx == pidx) {
		v__token__Pos type_alias_pos = (*(v__ast__TypeNode*)builtin__array_get(sum_variants, 0)).pos;
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("a type alias can not refer to itself: "), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}})), v__token__Pos_extend(decl_pos, type_alias_pos));
		return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(ADDR(v__ast__AliasTypeDecl, (((v__ast__AliasTypeDecl){.name = (string){.str=(byteptr)"", .is_lit=1},.mod = (string){.str=(byteptr)"", .is_lit=1},.is_pub = 0,.typ = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.parent_type = 0,.is_markused = 0,}))), false);
	}
	comments = builtin__array_clone_to_depth(&(*(v__ast__TypeNode*)builtin__array_get(sum_variants, 0)).end_comments, 0);
	p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
	v__ast__AliasTypeDecl alias_type_decl = ((v__ast__AliasTypeDecl){
		.name = name,
		.mod = p->mod,
		.is_pub = is_pub,
		.typ = idx,
		.pos = decl_pos,
		.type_pos = v__token__Pos_extend(type_pos, type_end_pos),
		.comments = comments,
		.attrs = attrs,
		.parent_type = parent_type,
		.is_markused = Array_v__ast__Attr_contains(attrs, _S("markused")),
	});
	if (p->pref->is_vls) {
		string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("aliastype_"), 0xfe10, {.d_s = v__parser__Parser_prepend_mod(p, name)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = alias_type_decl.pos,.doc = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, name, comments_before_key_type), v__parser__Parser_comments_to_string(p, comments)),});
		v__ast__Table_register_vls_info(p->table, key, val);
	}
	return v__ast__AliasTypeDecl_to_sumtype_v__ast__TypeDecl(&alias_type_decl, false);
}
VV_LOC v__ast__Expr v__parser__Parser_new_true_expr(v__parser__Parser* p) {
	return v__ast__BoolLiteral_to_sumtype_v__ast__Expr(ADDR(v__ast__BoolLiteral, (((v__ast__BoolLiteral){.val = true,.pos = v__token__Token_pos(&p->tok),}))), false);
}
VV_LOC void v__parser__Parser_top_level_statement_start(v__parser__Parser* p) {
	if (p->scanner->comments_mode == v__scanner__CommentsMode__toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, true);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}
VV_LOC void v__parser__Parser_top_level_statement_end(v__parser__Parser* p) {
	if (p->scanner->comments_mode == v__scanner__CommentsMode__toplevel_comments) {
		v__scanner__Scanner_set_is_inside_toplevel_statement(p->scanner, false);
		v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(p);
	}
}
VV_LOC void v__parser__Parser_rewind_scanner_to_current_token_in_new_mode(v__parser__Parser* p) {
	int tidx = p->tok.tidx;
	v__scanner__Scanner_set_current_tidx(p->scanner, (int)(tidx - 5));
	v__token__Token no_token = ((v__token__Token){.lit = (string){.str=(byteptr)"", .is_lit=1},.pos = 0,.len = 0,.line_nr = 0,.tidx = 0,.file_idx = 0,.col = 0,.kind = 0,});
	p->prev_tok = no_token;
	p->tok = no_token;
	p->peek_tok = no_token;
	v__parser__Parser_next(p);
	for (;;) {
		v__parser__Parser_next(p);
		if (tidx == p->tok.tidx) {
			break;
		}
	}
}
VV_LOC v__ast__Stmt v__parser__Parser_unsafe_stmt(v__parser__Parser* p) {
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	v__parser__Parser_next(p);
	if (p->tok.kind != v__token__Kind__lcbr) {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("please use `unsafe {`"), v__token__Token_pos(&p->tok)))), false);
	}
	v__parser__Parser_next(p);
	if (p->inside_unsafe && !p->inside_defer) {
		return v__ast__NodeError_to_sumtype_v__ast__Stmt(ADDR(v__ast__NodeError, (v__parser__Parser_error_with_pos(p, _S("already inside `unsafe` block"), pos))), false);
	}
	p->inside_unsafe = true;
	v__parser__Parser_open_scope(p);
	v__ast__Scope* sc = p->scope;
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__token__Pos_update_last_line(&pos, p->tok.line_nr);
		v__parser__Parser_next(p);
		v__ast__Stmt _t3 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, (((v__ast__Block){.is_unsafe = true,.pos = pos,.scope = sc,.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),}))), false);
			{ // defer begin
				p->inside_unsafe = false;
				v__parser__Parser_close_scope(p);
			} // defer end
		return _t3;
	}
	v__ast__Stmt stmt = v__parser__Parser_stmt(p, false);
	if (p->tok.kind == v__token__Kind__rcbr) {
		if ((stmt)._typ == 321 /* v.ast.ExprStmt */) {
			if (v__ast__Expr_is_expr((*stmt._v__ast__ExprStmt).expr)) {
				v__parser__Parser_next(p);
				v__token__Pos_update_last_line(&pos, p->prev_tok.line_nr);
				v__ast__UnsafeExpr ue = ((v__ast__UnsafeExpr){.pos = pos,.expr = (*stmt._v__ast__ExprStmt).expr,});
				v__ast__Expr expr = v__parser__Parser_expr_with_left(p, v__ast__UnsafeExpr_to_sumtype_v__ast__Expr(&ue, false), 0, p->is_stmt_ident);
				v__ast__Stmt _t4 = v__ast__ExprStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__ExprStmt, (((v__ast__ExprStmt){.pos = pos,.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.expr = expr,.is_expr = 0,.typ = 0,}))), false);
					{ // defer begin
						p->inside_unsafe = false;
						v__parser__Parser_close_scope(p);
					} // defer end
				return _t4;
			}
		}
	}
	Array_v__ast__Stmt stmts = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Stmt), _MOV((v__ast__Stmt[1]){stmt}));
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr)) break;
		builtin__array_push((array*)&stmts, _MOV((v__ast__Stmt[]){ v__parser__Parser_stmt(p, false) }));
	}
	v__parser__Parser_next(p);
	v__token__Pos_update_last_line(&pos, p->tok.line_nr);
	v__ast__Stmt _t6 = v__ast__Block_to_sumtype_v__ast__Stmt(ADDR(v__ast__Block, (((v__ast__Block){.is_unsafe = true,.pos = pos,.scope = sc,.stmts = stmts,}))), false);
		{ // defer begin
			p->inside_unsafe = false;
			v__parser__Parser_close_scope(p);
		} // defer end
	return _t6;
}
VV_LOC bool v__parser__Parser_disallow_declarations_in_script_mode(v__parser__Parser* p) {
	if (p->script_mode) {
		v__parser__Parser_note_with_pos(p, _S("script mode started here"), v__token__Token_pos(&p->script_mode_start_token));
		v__parser__Parser_error_with_pos(p, _S("all definitions must occur before code in script mode"), v__token__Token_pos(&p->tok));
		return true;
	}
	return false;
}
VV_LOC void v__parser__Parser_add_defer_var(v__parser__Parser* p, v__ast__Ident ident) {
	if (p->inside_defer && p->defer_mode == v__ast__DeferMode__function) {
		bool _t1 = false;
		Array_v__ast__Ident _t1_orig = p->defer_vars;
		int _t1_len = _t1_orig.len;
		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__ast__Ident it = ((v__ast__Ident*) _t1_orig.data)[_t2];
			if (builtin__string__eq(it.name, ident.name) && builtin__string__eq(it.mod, ident.mod)) {
				_t1 = true;
				break;
			}
		}
		if (!_t1 && !(builtin__fast_string_eq(ident.name, _S("err")) || builtin__fast_string_eq(ident.name, _S("it")))) {
			builtin__array_push((array*)&p->defer_vars, _MOV((v__ast__Ident[]){ ident }));
		}
	}
}
VV_LOC void v__parser__Parser_skip_scope(v__parser__Parser* p) {
	int br_cnt = 0;
	for (;;) {

		if (p->tok.kind == (v__token__Kind__lcbr)) {
			br_cnt++;
		}
		else if (p->tok.kind == (v__token__Kind__rcbr)) {
			br_cnt--;
		}
		else if (p->tok.kind == (v__token__Kind__eof)) {
			break;
		}
		else {
		}
		if (br_cnt == 0) {
			break;
		}
		v__parser__Parser_next(p);
	}
	if (p->tok.kind == v__token__Kind__rcbr) {
		v__parser__Parser_next(p);
	}
}
VV_LOC string v__parser__Parser_keyword_comments_to_string(v__parser__Parser* p, string keyword, Array_v__ast__Comment comments) {
	strings__Builder sb = strings__new_builder(128);
	bool is_found_keyword = false;
	for (int _t1 = 0; _t1 < comments.len; ++_t1) {
		v__ast__Comment line = ((v__ast__Comment*)comments.data)[_t1];
		string trim_line = (line.text.len > 0 && builtin__string_at(line.text, 0) == 1 ? (builtin__string_trim_space(builtin__string_substr(line.text, 1, 2147483647))) : (builtin__string_trim_space(line.text)));
		if (!is_found_keyword && builtin__string_starts_with(trim_line, keyword)) {
			is_found_keyword = true;
		}
		if (is_found_keyword) {
			strings__Builder_writeln(&sb, trim_line);
		}
	}
	return strings__Builder_str(&sb);
}
VV_LOC string v__parser__Parser_comments_to_string(v__parser__Parser* p, Array_v__ast__Comment comments) {
	strings__Builder sb = strings__new_builder(128);
	for (int _t1 = 0; _t1 < comments.len; ++_t1) {
		v__ast__Comment line = ((v__ast__Comment*)comments.data)[_t1];
		string trim_line = (line.text.len > 0 && builtin__string_at(line.text, 0) == 1 ? (builtin__string_trim_space(builtin__string_substr(line.text, 1, 2147483647))) : (builtin__string_trim_space(line.text)));
		strings__Builder_writeln(&sb, trim_line);
	}
	return strings__Builder_str(&sb);
}
VV_LOC v__ast__StructDecl v__parser__Parser_struct_decl(v__parser__Parser* p, bool is_anon) {
	bool v__parser__Parser_struct_decl_defer_0 = false;
	v__ast__Language old_struct_language;
	v__parser__Parser_top_level_statement_start(p);
	Array_v__ast__Attr attrs = p->attrs;
	v__token__Pos start_pos = v__token__Token_pos(&p->tok);
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	bool is_shared = p->tok.kind == v__token__Kind__key_shared;
	bool is_option = is_anon && p->prev_tok.kind == v__token__Kind__question;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	if (is_anon) {
		if (is_shared) {
			v__parser__Parser_register_auto_import(p, _S("sync"));
			v__parser__Parser_next(p);
		}
		is_pub = true;
	}
	bool is_union = p->tok.kind == v__token__Kind__key_union;
	if (p->tok.kind == v__token__Kind__key_struct) {
		v__parser__Parser_next(p);
	} else {
		v__parser__Parser_check(p, v__token__Kind__key_union);
	}
	v__ast__Language language = v__parser__Parser_parse_language(p);
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	if (p->inside_struct_field_decl && language == v__ast__Language__v) {
		language = p->struct_language;
	} else {
		old_struct_language = p->struct_language;
		p->struct_language = language;
		v__parser__Parser_struct_decl_defer_0 = true;
	}
	v__parser__Parser_check_for_impure_v(p, language, name_pos);
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		v__ast__StructDecl _t1 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t1;
	}
	string _t2; /* if prepend */
	if (is_anon) {
		string _t4; /* if prepend */
		if (is_union) {
			p->table->anon_union_counter++;
			_t4 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_VAnonUnion"), 0xfe07, {.d_i32 = p->table->anon_union_counter}}, {_SLIT0, 0, { .d_c = 0 }}}));
			goto _t5;
		};
		{
			p->table->anon_struct_counter++;
			_t4 = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("_VAnonStruct"), 0xfe07, {.d_i32 = p->table->anon_struct_counter}}, {_SLIT0, 0, { .d_c = 0 }}}));
		}
	_t5: {};
				_t2 = _t4;
		goto _t3;
	};
	{
		_t2 = v__parser__Parser_check_name(p);
	}
	_t3: {};
		string name = _t2;
	if (name.len == 1 && builtin__u8_is_capital(builtin__string_at(name, 0))) {
		v__parser__Parser_error_with_pos(p, _S("single letter capital names are reserved for generic template types."), name_pos);
		v__ast__StructDecl _t6 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t6;
	}
	if (_SLIT_EQ(name.str, name.len, "IError") && !builtin__fast_string_eq(p->mod, _S("builtin"))) {
		v__parser__Parser_error_with_pos(p, _S("cannot register struct `IError`, it is builtin interface type"), name_pos);
	}
	v__ast__Table_start_parsing_type(p->table, v__parser__Parser_prepend_mod(p, name));
	multi_return_Array_v__ast__Type_Array_string mr_2055 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_2055.arg0;
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	Array_v__ast__Comment _t7; /* if prepend */
	if (p->pref->is_vls) {
		_t7 = builtin__array_clone_to_depth(&p->cur_comments, 0);
		goto _t8;
	};
	{
		_t7 = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	_t8: {};
		Array_v__ast__Comment comments_before_key_struct = _t7;
	builtin__array_clear(&p->cur_comments);
	bool no_body = p->tok.kind != v__token__Kind__lcbr && p->tok.kind != v__token__Kind__key_implements;
	if (language == v__ast__Language__v && no_body) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("`"), 0xfe10, {.d_s = p->tok.lit}}, {_S("` lacks body"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t9 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			{ // defer begin
				v__ast__Table_reset_parsing_type(p->table);
			} // defer end
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t9;
	}
	if (name.len == 1) {
		v__parser__Parser_error_with_pos(p, _S("struct names must have more than one character"), name_pos);
		v__ast__StructDecl _t10 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			{ // defer begin
				v__ast__Table_reset_parsing_type(p->table);
			} // defer end
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t10;
	}
	if (v__parser__Parser_is_imported_symbol(p, name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register struct `"), 0xfe10, {.d_s = name}}, {_S("`, this type was already imported"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t11 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			{ // defer begin
				v__ast__Table_reset_parsing_type(p->table);
			} // defer end
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t11;
	}
	string orig_name = name;
	if (language == v__ast__Language__c) {
		name = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("C."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		orig_name = name;
	} else if (language == v__ast__Language__js) {
		name = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("JS."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		orig_name = name;
	} else if (language == v__ast__Language__wasm) {
		name = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("WASM."), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		orig_name = name;
	} else {
		name = v__parser__Parser_prepend_mod(p, name);
	}
	Array_v__ast__StructField ast_fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__StructField fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructField), 0);
	Array_v__ast__Type embed_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	Array_v__ast__Embed embeds = builtin____new_array_with_default(0, 0, sizeof(v__ast__Embed), 0);
	Array_string embed_field_names = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	int mut_pos = -1;
	int pub_pos = -1;
	int pub_mut_pos = -1;
	int global_pos = -1;
	int module_pos = -1;
	bool is_field_mut = language == v__ast__Language__c;
	bool is_field_pub = language == v__ast__Language__c;
	bool is_field_global = false;
	bool is_implements = false;
	Array_v__ast__TypeNode implements_types = builtin____new_array_with_default(0, 3, sizeof(v__ast__TypeNode), 0);
	int last_line = (int)(v__token__Token_pos(&p->prev_tok).line_nr + 1);
	Array_v__ast__Comment end_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool has_option = false;
	if (!no_body) {
		if (p->tok.kind == v__token__Kind__key_implements) {
			is_implements = true;
			for (;;) {
				v__parser__Parser_next(p);
				v__token__Pos type_pos = v__token__Token_pos(&p->tok);
				builtin__array_push((array*)&implements_types, _MOV((v__ast__TypeNode[]){ ((v__ast__TypeNode){.pos = type_pos,.typ = v__parser__Parser_parse_type(p),.stmt = _const_v__ast__empty_stmt,.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),}) }));
				if (p->tok.kind != v__token__Kind__comma) {
					break;
				}
			}
		}
		v__parser__Parser_check(p, v__token__Kind__lcbr);
		if (p->is_vls && v__token__Token_is_key(p->tok) && !((p->tok.kind == v__token__Kind__key_pub || p->tok.kind == v__token__Kind__key_mut) && (p->peek_tok.kind == v__token__Kind__colon || p->peek_tok.kind == v__token__Kind__key_mut))) {
			v__parser__Parser_error(p, _S("expected `}` to finish a struct definition"));
			p->should_abort = true;
			v__ast__StructDecl _t13 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = name,.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
				{ // defer begin
					v__ast__Table_reset_parsing_type(p->table);
				} // defer end
				if (v__parser__Parser_struct_decl_defer_0) { // defer begin
					p->struct_language = old_struct_language;
				} // defer end
			return _t13;
		}
		_PUSH_MANY(&pre_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t14, Array_v__ast__Comment);
		int i = 0;
		for (;;) {
			if (!(p->tok.kind != v__token__Kind__rcbr)) break;
			Array_v__ast__Comment comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			if (p->tok.kind == v__token__Kind__rcbr) {
				end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
				break;
			}
			if (p->tok.kind == v__token__Kind__key_pub && (p->peek_tok.kind == v__token__Kind__key_mut || p->peek_tok.kind == v__token__Kind__colon)) {
				v__parser__Parser_next(p);
				if (p->tok.kind == v__token__Kind__key_mut) {
					if (pub_mut_pos != -1) {
						v__parser__Parser_error(p, _S("redefinition of `pub mut` section"));
						v__ast__StructDecl _t15 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
							{ // defer begin
								v__ast__Table_reset_parsing_type(p->table);
							} // defer end
							if (v__parser__Parser_struct_decl_defer_0) { // defer begin
								p->struct_language = old_struct_language;
							} // defer end
						return _t15;
					}
					v__parser__Parser_next(p);
					pub_mut_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = true;
					is_field_global = false;
				} else {
					if (pub_pos != -1) {
						v__parser__Parser_error(p, _S("redefinition of `pub` section"));
						v__ast__StructDecl _t16 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
							{ // defer begin
								v__ast__Table_reset_parsing_type(p->table);
							} // defer end
							if (v__parser__Parser_struct_decl_defer_0) { // defer begin
								p->struct_language = old_struct_language;
							} // defer end
						return _t16;
					}
					pub_pos = ast_fields.len;
					is_field_pub = true;
					is_field_mut = false;
					is_field_global = false;
				}
				v__parser__Parser_check(p, v__token__Kind__colon);
			} else if (p->tok.kind == v__token__Kind__key_mut && p->peek_tok.kind == v__token__Kind__colon) {
				if (mut_pos != -1) {
					v__parser__Parser_error(p, _S("redefinition of `mut` section"));
					v__ast__StructDecl _t17 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t17;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				mut_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = true;
				is_field_global = false;
			} else if (p->tok.kind == v__token__Kind__key_global && p->peek_tok.kind == v__token__Kind__colon) {
				if (global_pos != -1) {
					v__parser__Parser_error(p, _S("redefinition of `global` section"));
					v__ast__StructDecl _t18 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t18;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				global_pos = ast_fields.len;
				is_field_pub = true;
				is_field_mut = true;
				is_field_global = true;
			} else if (p->tok.kind == v__token__Kind__key_module && p->peek_tok.kind == v__token__Kind__colon) {
				if (module_pos != -1) {
					v__parser__Parser_error(p, _S("redefinition of `module` section"));
					v__ast__StructDecl _t19 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t19;
				}
				v__parser__Parser_next(p);
				v__parser__Parser_check(p, v__token__Kind__colon);
				module_pos = ast_fields.len;
				is_field_pub = false;
				is_field_mut = false;
				is_field_global = false;
			}
			Array_v__ast__Comment pre_field_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			Array_v__ast__Comment next_field_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
			v__token__Pos field_start_pos = v__token__Token_pos(&p->tok);
			bool is_field_volatile = false;
			bool is_field_deprecated = false;
			if (p->tok.kind == v__token__Kind__key_volatile && v__parser__Parser_peek_token(p, 2).line_nr == p->tok.line_nr) {
				v__parser__Parser_next(p);
				is_field_volatile = true;
			}
			bool is_embed = ((p->tok.lit.len > 1 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) && (p->peek_tok.line_nr != p->tok.line_nr || !(p->peek_tok.kind == v__token__Kind__name || p->peek_tok.kind == v__token__Kind__amp)) && (p->peek_tok.kind != v__token__Kind__lsbr || v__parser__Parser_peek_token(p, 2).kind != v__token__Kind__rsbr)) || p->peek_tok.kind == v__token__Kind__dot) && language == v__ast__Language__v && p->peek_tok.kind != v__token__Kind__key_fn;
			bool is_on_top = ast_fields.len == 0 && !(is_field_pub || is_field_mut || is_field_global);
			bool has_prev_newline = v__parser__Parser_has_prev_newline(p);
			bool has_break_line = has_prev_newline || v__parser__Parser_has_prev_line_comment_or_label(p);
			string field_name = _S("");
			v__ast__Type typ = _const_v__ast__no_type;
			v__token__Pos type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
			v__token__Pos field_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
			v__token__Pos option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
			if (p->tok.kind == v__token__Kind__rcbr) {
				if (ast_fields.len > 0) {
					_PUSH_MANY(&(*(v__ast__StructField*)builtin__array_last(ast_fields)).next_comments, (pre_field_comments), _t20, Array_v__ast__Comment);
				}
				break;
			}
			if (is_embed) {
				if (p->peek_tok.kind == v__token__Kind__dot && p->peek_tok.line_nr == v__parser__Parser_peek_token(p, 3).line_nr && v__parser__Parser_peek_token(p, 3).kind == v__token__Kind__name) {
					v__parser__Parser_error_with_pos(p, _S("invalid field name"), v__token__Token_pos(&p->tok));
					v__ast__StructDecl _t21 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t21;
				}
				type_pos = v__token__Token_pos(&p->tok);
				typ = v__parser__Parser_parse_type(p);
				_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t22, Array_v__ast__Comment);
				type_pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->prev_tok));
				if (!is_on_top) {
					v__parser__Parser_error_with_pos(p, _S("struct embedding must be declared at the beginning of the struct body"), type_pos);
					v__ast__StructDecl _t23 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t23;
				}
				v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
				if ((Array_v__ast__Type_contains(embed_types, typ))) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot embed `"), 0xfe10, {.d_s = sym->name}}, {_S("` more than once"), 0, { .d_c = 0 }}})), type_pos);
					v__ast__StructDecl _t24 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t24;
				}
				field_name = v__ast__TypeSymbol_embed_name(sym);
				if ((Array_string_contains(embed_field_names, field_name))) {
					v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicate field `"), 0xfe10, {.d_s = field_name}}, {_S("`"), 0, { .d_c = 0 }}})), type_pos);
					v__ast__StructDecl _t25 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t25;
				}
				if (p->tok.kind == v__token__Kind__lsbr) {
					v__parser__Parser_error(p, _S("cannot use attributes on embedded structs"));
				}
				builtin__array_push((array*)&embed_field_names, _MOV((string[]){ builtin__string_clone(field_name) }));
				builtin__array_push((array*)&embed_types, _MOV((v__ast__Type[]){ typ }));
				builtin__array_push((array*)&embeds, _MOV((v__ast__Embed[]){ ((v__ast__Embed){.typ = typ,.pos = type_pos,.comments = comments,}) }));
			} else {
				field_name = v__parser__Parser_check_name(p);
				p->inside_struct_field_decl = true;
				bool is_anon_struct = p->tok.kind == v__token__Kind__key_struct || (p->tok.kind == v__token__Kind__key_shared && p->peek_tok.kind == v__token__Kind__key_struct);
				bool is_anon_union = p->tok.kind == v__token__Kind__key_union || (p->tok.kind == v__token__Kind__key_shared && p->peek_tok.kind == v__token__Kind__key_union);
				if (is_anon_struct || is_anon_union) {
					bool field_is_shared = p->tok.kind == v__token__Kind__key_shared;
					p->anon_struct_decl = v__parser__Parser_struct_decl(p, true);
					p->anon_struct_decl.language = language;
					typ = v__ast__Table_find_type_idx(p->table, p->anon_struct_decl.name);
					if (field_is_shared) {
						typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__shared_f);
						typ = v__ast__Type_set_nr_muls(typ, 1);
					}
				} else {
					v__token__Pos start_type_pos = v__token__Token_pos(&p->tok);
					typ = v__parser__Parser_parse_type(p);
					type_pos = v__token__Pos_extend(start_type_pos, v__token__Token_pos(&p->prev_tok));
				}
				p->inside_struct_field_decl = false;
				if (v__ast__Type_idx(typ) == 0) {
					v__ast__StructDecl _t29 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
						{ // defer begin
							v__ast__Table_reset_parsing_type(p->table);
						} // defer end
						if (v__parser__Parser_struct_decl_defer_0) { // defer begin
							p->struct_language = old_struct_language;
						} // defer end
					return _t29;
				}
				if (p->file_backend_mode == v__ast__Language__v || p->file_backend_mode == v__ast__Language__c) {
					v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
					v__ast__Kind elem_kind = v__ast__Kind__placeholder;
					if (sym->kind == v__ast__Kind__array && ((sym->info)._typ == 452 /* v.ast.Array */ || (sym->info)._typ == 482 /* v.ast.Alias */)) {
						elem_kind = v__ast__Table_sym(p->table, v__ast__TypeSymbol_array_info(sym).elem_type)->kind;
					} else if (sym->kind == v__ast__Kind__array_fixed && ((sym->info)._typ == 491 /* v.ast.ArrayFixed */ || (sym->info)._typ == 482 /* v.ast.Alias */)) {
						elem_kind = v__ast__Table_sym(p->table, v__ast__TypeSymbol_array_fixed_info(sym).elem_type)->kind;
					}
					if (elem_kind == v__ast__Kind__function) {
						v__parser__Parser_register_auto_import(p, _S("builtin.closure"));
					}
				}
				field_pos = v__token__Pos_extend(field_start_pos, v__token__Token_pos(&p->prev_tok));
				if (v__ast__Type_has_option_or_result(typ)) {
					option_pos = v__token__Token_pos(ADDR(v__token__Token, v__parser__Parser_peek_token(p, -2)));
					has_option = true;
				}
			}
			Array_v__ast__Attr prev_attrs = p->attrs;
			p->attrs = builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0);
			if (p->tok.kind == v__token__Kind__lsbr) {
				p->inside_struct_attr_decl = true;
				v__parser__Parser_attributes(p);
				for (int _t30 = 0; _t30 < p->attrs.len; ++_t30) {
					v__ast__Attr fa = ((v__ast__Attr*)p->attrs.data)[_t30];
					if (builtin__fast_string_eq(fa.name, _S("deprecated"))) {
						is_field_deprecated = true;
					}
				}
				p->inside_struct_attr_decl = false;
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t31, Array_v__ast__Comment);
			v__ast__Expr default_expr = _const_v__ast__empty_expr;
			bool has_default_expr = false;
			if (!is_embed) {
				if (p->tok.kind == v__token__Kind__assign) {
					v__parser__Parser_next(p);
					bool old_assign_rhs = p->inside_assign_rhs;
					p->inside_assign_rhs = true;
					default_expr = v__parser__Parser_expr(p, 0);
					p->inside_assign_rhs = old_assign_rhs;
					if (default_expr._typ == 278 /* v.ast.EnumVal */) {
						(*default_expr._v__ast__EnumVal).typ = typ;
					}
					
					else {
					}
					
					has_default_expr = true;
					_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t32, Array_v__ast__Comment);
				}
				if (p->tok.kind == v__token__Kind__at) {
					p->inside_struct_attr_decl = true;
					v__parser__Parser_attributes(p);
					for (int _t33 = 0; _t33 < p->attrs.len; ++_t33) {
						v__ast__Attr fa = ((v__ast__Attr*)p->attrs.data)[_t33];
						if (builtin__fast_string_eq(fa.name, _S("deprecated"))) {
							is_field_deprecated = true;
						}
					}
					p->inside_struct_attr_decl = false;
					_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t34, Array_v__ast__Comment);
				}
				next_field_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}));
				builtin__array_push((array*)&ast_fields, _MOV((v__ast__StructField[]){ ((v__ast__StructField){
					.anon_struct_decl = p->anon_struct_decl,
					.attrs = p->attrs,
					.pre_comments = pre_field_comments,
					.comments = comments,
					.next_comments = next_field_comments,
					.default_val = (string){.str=(byteptr)"", .is_lit=1},
					.name = field_name,
					.default_expr = default_expr,
					.pos = field_pos,
					.type_pos = type_pos,
					.option_pos = option_pos,
					.default_expr_typ = 0,
					.container_typ = 0,
					.typ = typ,
					.unaliased_typ = 0,
					.i = i,
					.is_pub = is_embed || is_field_pub,
					.has_break_line = has_break_line,
					.is_recursive = 0,
					.is_mut = is_embed || is_field_mut,
					.has_prev_newline = has_prev_newline,
					.has_default_expr = has_default_expr,
					.is_part_of_union = 0,
					.is_global = is_field_global,
					.is_volatile = is_field_volatile,
					.is_deprecated = is_field_deprecated,
					.is_embed = 0,
				}) }));
			}
			builtin__array_push((array*)&fields, _MOV((v__ast__StructField[]){ ((v__ast__StructField){
				.anon_struct_decl = p->anon_struct_decl,
				.attrs = p->attrs,
				.pre_comments = pre_field_comments,
				.comments = comments,
				.next_comments = next_field_comments,
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.name = field_name,
				.default_expr = default_expr,
				.pos = (is_embed ? (type_pos) : (field_pos)),
				.type_pos = type_pos,
				.option_pos = option_pos,
				.default_expr_typ = 0,
				.container_typ = 0,
				.typ = typ,
				.unaliased_typ = 0,
				.i = i,
				.is_pub = is_embed || is_field_pub,
				.has_break_line = 0,
				.is_recursive = 0,
				.is_mut = is_embed || is_field_mut,
				.has_prev_newline = 0,
				.has_default_expr = has_default_expr,
				.is_part_of_union = 0,
				.is_global = is_field_global,
				.is_volatile = is_field_volatile,
				.is_deprecated = is_field_deprecated,
				.is_embed = is_embed,
			}) }));
			p->anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			p->attrs = prev_attrs;
			i++;
		}
		v__parser__Parser_top_level_statement_end(p);
		last_line = p->tok.line_nr;
		v__parser__Parser_check(p, v__token__Kind__rcbr);
		end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
	}
	string scoped_name = _S("");
	if (!is_anon && p->inside_fn && p->cur_fn_scope != ((void*)0)) {
		scoped_name = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("_"), 0xfe10, {.d_s = name}}, {_S("_"), 0xfe07, {.d_i32 = p->cur_fn_scope->start_pos}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	bool is_minify = Array_v__ast__Attr_contains(attrs, _S("minify"));
	v__ast__TypeSymbol sym = ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.name = name,
		.cname = v__util__no_dots(name),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(name),
		.info = v__ast__Struct_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Struct, (((v__ast__Struct){
			.generic_types = generic_types,
			.embeds = embed_types,
			.fields = fields,
			.attrs = attrs,
			.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
			.scoped_name = scoped_name,
			.name_pos = name_pos,
			.parent_type = 0,
			.is_anon = is_anon,
			.is_generic = generic_types.len > 0,
			.is_shared = is_shared,
			.is_markused = Array_v__ast__Attr_contains(attrs, _S("markused")),
			.has_option = has_option,
			.is_heap = Array_v__ast__Attr_contains(attrs, _S("heap")),
			.is_union = is_union,
			.is_minify = is_minify,
			.is_typedef = Array_v__ast__Attr_contains(attrs, _S("typedef")),
		}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__struct,
		.language = language,
		.is_pub = is_pub,
		.is_builtin = (Array_string_contains(_const_v__ast__builtins, name)),
	});
	if (v__ast__Table_has_deep_child_no_ref(p->table, &sym, name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("invalid recursive struct `"), 0xfe10, {.d_s = orig_name}}, {_S("`"), 0, { .d_c = 0 }}})), name_pos);
		v__ast__StructDecl _t37 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			{ // defer begin
				v__ast__Table_reset_parsing_type(p->table);
			} // defer end
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t37;
	}
	int ret = v__ast__Table_register_sym(p->table, sym);
	if (is_anon) {
		if (is_union) {
			v__ast__Table_register_anon_union(p->table, name, ret);
		} else {
			v__ast__Table_register_anon_struct(p->table, name, ret);
		}
	}
	if (ret == -1 && language != v__ast__Language__c && !p->pref->is_fmt) {
		string msg = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register struct `"), 0xfe10, {.d_s = name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}}));
		multi_return_ref_v__ast__TypeSymbol_int mr_14856 = v__ast__Table_find_sym_and_type_idx(p->table, name);
		v__ast__TypeSymbol* existing_sym = mr_14856.arg0;
		int existing_idx = mr_14856.arg1;
		if (existing_idx <= 0 && builtin__string_starts_with(name, _S("main."))) {
			multi_return_ref_v__ast__TypeSymbol_int mr_14979 = v__ast__Table_find_sym_and_type_idx(p->table, builtin__string_trim_string_left(name, _S("main.")));
			existing_sym = mr_14979.arg0;
			existing_idx = mr_14979.arg1;
		}
		if (existing_idx > 0) {
			_option_v__token__Pos _t38;
			if (_t38 = v__ast__TypeInfo_get_name_pos(existing_sym->info), _t38.state == 0) {
				v__token__Pos existing_name_pos = *(v__token__Pos*)_t38.data;
				string existing_file_path = (existing_name_pos.file_idx < 0 ? (p->file_path) : ((*(string*)builtin__array_get(p->table->filelist, existing_name_pos.file_idx))));
				string error_file_path = (name_pos.file_idx < 0 ? (p->file_path) : ((*(string*)builtin__array_get(p->table->filelist, name_pos.file_idx))));
				v__parser__Parser_error_with_error(p, ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = msg,.details = v__util__formatted_error(_S("details:"), _S("another declaration was found here"), existing_file_path, existing_name_pos),.file_path = error_file_path,.pos = name_pos,.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}));
				v__ast__StructDecl _t39 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
					{ // defer begin
						v__ast__Table_reset_parsing_type(p->table);
					} // defer end
					if (v__parser__Parser_struct_decl_defer_0) { // defer begin
						p->struct_language = old_struct_language;
					} // defer end
				return _t39;
			}
		}
		v__parser__Parser_error_with_pos(p, msg, name_pos);
		v__ast__StructDecl _t40 = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,});
			{ // defer begin
				v__ast__Table_reset_parsing_type(p->table);
			} // defer end
			if (v__parser__Parser_struct_decl_defer_0) { // defer begin
				p->struct_language = old_struct_language;
			} // defer end
		return _t40;
	}
	p->expr_mod = _S("");
	v__ast__StructDecl struct_decl = ((v__ast__StructDecl){
		.fields = ast_fields,
		.implements_types = implements_types,
		.embeds = embeds,
		.attrs = (is_anon ? (builtin____new_array_with_default(0, 0, sizeof(v__ast__Attr), 0)) : (attrs)),
		.pre_comments = pre_comments,
		.end_comments = end_comments,
		.generic_types = generic_types,
		.name = name,
		.scoped_name = scoped_name,
		.pos = v__token__Pos_extend_with_last_line(start_pos, name_pos, last_line),
		.idx = 0,
		.mut_pos = mut_pos,
		.pub_pos = pub_pos,
		.pub_mut_pos = pub_mut_pos,
		.global_pos = global_pos,
		.module_pos = module_pos,
		.language = language,
		.is_aligned = Array_v__ast__Attr_contains(attrs, _S("aligned")),
		.is_implements = is_implements,
		.is_option = is_option,
		.is_union = is_union,
		.is_pub = is_pub,
	});
	if (p->pref->is_vls) {
		string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("struct_"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		bool has_decl_end_comment = false;
		if (struct_decl.pre_comments.len > 0 && (*(v__ast__Comment*)builtin__array_get(struct_decl.pre_comments, 0)).pos.line_nr == struct_decl.pos.line_nr) {
			builtin__array_push((array*)&comments_before_key_struct, _MOV((v__ast__Comment[]){ (*(v__ast__Comment*)builtin__array_get(struct_decl.pre_comments, 0)) }));
			has_decl_end_comment = true;
		}
		v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = struct_decl.pos,.doc = builtin__string__plus(v__parser__Parser_keyword_comments_to_string(p, orig_name, comments_before_key_struct), v__parser__Parser_comments_to_string(p, struct_decl.end_comments)),});
		v__ast__Table_register_vls_info(p->table, key, val);
		for (int i = 0; i < ast_fields.len; ++i) {
			v__ast__StructField f = ((v__ast__StructField*)ast_fields.data)[i];
			string f_key = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("struct_"), 0xfe10, {.d_s = name}}, {_S("."), 0xfe10, {.d_s = f.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
			v__ast__VlsInfo _t42; /* if prepend */
			if (i == 0) {
				Array_v__ast__Comment _t44; /* if prepend */
				if (has_decl_end_comment) {
					_t44 = builtin__array_clone_static_to_depth(builtin__array_slice(struct_decl.pre_comments, 1, 2147483647), 0);
					goto _t45;
				};
				{
					_t44 = struct_decl.pre_comments;
				}
	_t45: {};
								Array_v__ast__Comment first_field_pre_comment = _t44;
				_t42 = ((v__ast__VlsInfo){.pos = f.pos,.doc = builtin__string__plus(v__parser__Parser_comments_to_string(p, first_field_pre_comment), v__parser__Parser_comments_to_string(p, f.comments)),});
				goto _t43;
			};
			{
				_t42 = ((v__ast__VlsInfo){.pos = f.pos,.doc = builtin__string__plus(v__parser__Parser_comments_to_string(p, (*(v__ast__StructField*)builtin__array_get(ast_fields, (int)(i - 1))).next_comments), v__parser__Parser_comments_to_string(p, f.comments)),});
			}
	_t43: {};
						v__ast__VlsInfo f_val = _t42;
			v__ast__Table_register_vls_info(p->table, f_key, f_val);
		}
	}
	v__ast__StructDecl _t46 = struct_decl;
		{ // defer begin
			v__ast__Table_reset_parsing_type(p->table);
		} // defer end
		if (v__parser__Parser_struct_decl_defer_0) { // defer begin
			p->struct_language = old_struct_language;
		} // defer end
	return _t46;
}
VV_LOC v__ast__StructInit v__parser__Parser_struct_init(v__parser__Parser* p, string typ_str, v__ast__StructInitKind kind, bool is_option) {
	v__token__Pos first_pos = v__token__Token_pos(ADDR(v__token__Token, ((kind == v__ast__StructInitKind__short_syntax && p->prev_tok.kind == v__token__Kind__lcbr ? (p->prev_tok) : (p->tok)))));
	p->init_generic_types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0);
	v__ast__Type typ = (kind == v__ast__StructInitKind__short_syntax ? (_const_v__ast__void_type) : (v__parser__Parser_parse_type(p)));
	v__ast__TypeSymbol* sym = v__ast__Table_sym(p->table, typ);
	string struct_name = builtin__string_all_after_last(sym->name, _S("."));
	if (sym->kind == v__ast__Kind__placeholder && struct_name.len > 0 && !builtin__u8_is_capital(builtin__string_at(struct_name, 0)) && !builtin__string_starts_with(sym->name, _S("C."))) {
		v__parser__Parser_error_with_pos(p, _S("struct name must begin with capital letter"), first_pos);
		return ((v__ast__StructInit){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.init_fields = builtin____new_array(0, 0, sizeof(v__ast__StructInitField)),.update_expr_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.typ_str = (string){.str=(byteptr)"", .is_lit=1},.update_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.update_expr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.update_expr_type = 0,.typ = 0,.language = 0,.has_update_expr = 0,.is_short_syntax = 0,.no_keys = 0,.is_update_embed = 0,.is_anon = 0,.unresolved = 0,});
	}
	Array_v__ast__Type struct_init_generic_types = builtin__array_clone_to_depth(&p->init_generic_types, 0);
	if (is_option) {
		typ = v__ast__Type_set_flag(typ, v__ast__TypeFlag__option);
	}
	p->expr_mod = _S("");
	if (kind != v__ast__StructInitKind__short_syntax) {
		v__parser__Parser_check(p, v__token__Kind__lcbr);
	}
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	Array_v__ast__StructInitField init_fields = builtin____new_array_with_default(0, 0, sizeof(v__ast__StructInitField), 0);
	int i = 0;
	bool no_keys = p->peek_tok.kind != v__token__Kind__colon && p->tok.kind != v__token__Kind__rcbr && p->tok.kind != v__token__Kind__ellipsis;
	bool saved_is_amp = p->is_amp;
	p->is_amp = false;
	v__ast__Expr update_expr = _const_v__ast__empty_expr;
	Array_v__ast__Comment update_expr_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	bool has_update_expr = false;
	v__token__Pos update_expr_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
	bool has_prev_newline = false;
	bool has_break_line = false;
	for (;;) {
		if (!(!(p->tok.kind == v__token__Kind__rcbr || p->tok.kind == v__token__Kind__rpar || p->tok.kind == v__token__Kind__eof))) break;
		string field_name = _S("");
		v__ast__Expr expr = _const_v__ast__empty_expr;
		v__token__Pos field_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		v__token__Pos first_field_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,});
		Array_v__ast__Comment prev_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		Array_v__ast__Comment end_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		Array_v__ast__Comment nline_comments = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
		bool is_update_expr = init_fields.len == 0 && p->tok.kind == v__token__Kind__ellipsis;
		if (no_keys) {
			expr = v__parser__Parser_expr(p, 0);
			field_pos = v__ast__Expr_pos(expr);
			first_field_pos = field_pos;
			end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
		} else if (is_update_expr) {
			update_expr_pos = v__token__Token_pos(&p->tok);
			v__parser__Parser_check(p, v__token__Kind__ellipsis);
			update_expr = v__parser__Parser_expr(p, 0);
			_PUSH_MANY(&update_expr_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t2, Array_v__ast__Comment);
			has_update_expr = true;
		} else {
			prev_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			first_field_pos = v__token__Token_pos(&p->tok);
			has_prev_newline = v__parser__Parser_has_prev_newline(p);
			has_break_line = has_prev_newline || v__parser__Parser_has_prev_line_comment_or_label(p);
			field_name = v__parser__Parser_check_name(p);
			if (p->is_vls) {
				if (p->tok.kind != v__token__Kind__colon) {
					{ // Unsafe block
						goto end;
					}
				}
			}
			v__parser__Parser_check(p, v__token__Kind__colon);
			expr = v__parser__Parser_expr(p, 0);
			end_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}));
			v__token__Pos last_field_pos = v__ast__Expr_pos(expr);
			int field_len = (last_field_pos.len > 0 ? ((int)((int)(last_field_pos.pos - first_field_pos.pos) + last_field_pos.len)) : ((int)(first_field_pos.len + 1)));
			field_pos = ((v__token__Pos){.len = field_len,.line_nr = first_field_pos.line_nr,.pos = first_field_pos.pos,.col = first_field_pos.col,.file_idx = -1,.last_line = 0,});
		}
		i++;
		if (p->tok.kind == v__token__Kind__comma) {
			v__parser__Parser_next(p);
		}
		_PUSH_MANY(&end_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t3, Array_v__ast__Comment);
		_PUSH_MANY(&nline_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}))), _t4, Array_v__ast__Comment);
		if (!is_update_expr) {
			builtin__array_push((array*)&init_fields, _MOV((v__ast__StructInitField[]){ ((v__ast__StructInitField){
				.pos = field_pos,
				.name_pos = first_field_pos,
				.pre_comments = prev_comments,
				.end_comments = end_comments,
				.next_comments = nline_comments,
				.has_prev_newline = has_prev_newline,
				.has_break_line = has_break_line,
				.is_embed = field_name.len > 0 && builtin__u8_is_capital(builtin__string_at(field_name, 0)),
				.expr = expr,
				.name = field_name,
				.typ = 0,
				.expected_type = 0,
				.parent_type = typ,
			}) }));
		}
	}
	if (kind != v__ast__StructInitKind__short_syntax) {
		v__parser__Parser_check(p, v__token__Kind__rcbr);
	}
	p->is_amp = saved_is_amp;
	end: {}
	return ((v__ast__StructInit){
		.pre_comments = pre_comments,
		.generic_types = struct_init_generic_types,
		.init_fields = init_fields,
		.update_expr_comments = update_expr_comments,
		.typ_str = typ_str,
		.update_expr = update_expr,
		.pos = v__token__Pos_extend(first_pos, (kind == v__ast__StructInitKind__short_syntax ? (v__token__Token_pos(&p->tok)) : (v__token__Token_pos(&p->prev_tok)))),
		.name_pos = first_pos,
		.update_expr_pos = update_expr_pos,
		.update_expr_type = 0,
		.typ = typ,
		.language = 0,
		.has_update_expr = has_update_expr,
		.is_short_syntax = kind == v__ast__StructInitKind__short_syntax,
		.no_keys = no_keys,
		.is_update_embed = 0,
		.is_anon = kind == v__ast__StructInitKind__anon,
		.unresolved = v__ast__Type_has_flag(typ, v__ast__TypeFlag__generic),
	});
}
VV_LOC v__ast__InterfaceDecl v__parser__Parser_interface_decl(v__parser__Parser* p) {
	v__parser__Parser_top_level_statement_start(p);
	v__token__Pos pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Attr attrs = p->attrs;
	bool is_pub = p->tok.kind == v__token__Kind__key_pub;
	if (is_pub) {
		v__parser__Parser_next(p);
	}
	v__parser__Parser_next(p);
	v__ast__Language language = v__parser__Parser_parse_language(p);
	v__token__Pos name_pos = v__token__Token_pos(&p->tok);
	Array_v__ast__Comment _t1; /* if prepend */
	if (p->pref->is_vls) {
		_t1 = builtin__array_clone_to_depth(&p->cur_comments, 0);
		goto _t2;
	};
	{
		_t1 = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
	}
	_t2: {};
		Array_v__ast__Comment comments_before_key_interface = _t1;
	string pre_comment_string = _S("");
	v__parser__Parser_check_for_impure_v(p, language, name_pos);
	if (v__parser__Parser_disallow_declarations_in_script_mode(p)) {
		return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
	}
	string modless_name = v__parser__Parser_check_name(p);
	if (modless_name.len == 1 && builtin__u8_is_capital(builtin__string_at(modless_name, 0))) {
		v__parser__Parser_error_with_pos(p, _S("single letter capital names are reserved for generic template types."), name_pos);
		return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
	}
	if (_SLIT_EQ(modless_name.str, modless_name.len, "IError") && !builtin__fast_string_eq(p->mod, _S("builtin"))) {
		v__parser__Parser_error_with_pos(p, _S("cannot register interface `IError`, it is builtin interface type"), name_pos);
	}
	string interface_name = _S("");
	if (language == v__ast__Language__js) {
		interface_name = builtin__string__plus(_S("JS."), modless_name);
	} else {
		interface_name = v__parser__Parser_prepend_mod(p, modless_name);
	}
	multi_return_Array_v__ast__Type_Array_string mr_23115 = v__parser__Parser_parse_generic_types(p);
	Array_v__ast__Type generic_types = mr_23115.arg0;
	Array_v__ast__Comment pre_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
	v__parser__Parser_check(p, v__token__Kind__lcbr);
	_PUSH_MANY(&pre_comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}))), _t5, Array_v__ast__Comment);
	if (p->pref->is_vls) {
		pre_comment_string = (pre_comments.len > 0 && (*(v__ast__Comment*)builtin__array_get(pre_comments, 0)).pos.line_nr == pos.line_nr ? (v__parser__Parser_comments_to_string(p, builtin__array_slice(pre_comments, 1, 2147483647))) : (v__parser__Parser_comments_to_string(p, pre_comments)));
	}
	if (v__parser__Parser_is_imported_symbol(p, modless_name)) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register interface `"), 0xfe10, {.d_s = interface_name}}, {_S("`, this type was already imported"), 0, { .d_c = 0 }}})), name_pos);
		return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
	}
	int reg_idx = v__ast__Table_register_sym(p->table, ((v__ast__TypeSymbol){
		.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
		.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
		.mod = p->mod,
		.name = interface_name,
		.cname = v__util__no_dots(interface_name),
		.rname = (string){.str=(byteptr)"", .is_lit=1},
		.ngname = v__ast__strip_generic_params(interface_name),
		.info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(ADDR(v__ast__Interface, (((v__ast__Interface){.generic_types = generic_types,.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Type)),.types = builtin____new_array_with_default(0, 0, sizeof(v__ast__Type), 0),.concrete_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.conversions = (__shared__Map_int_Array_v__ast__Type*)__dup__shared__Map_int_Array_v__ast__Type(&(__shared__Map_int_Array_v__ast__Type){.mtx= {0}, .val=builtin__new_map(sizeof(int), sizeof(Array_v__ast__Type), &builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop)}, sizeof(__shared__Map_int_Array_v__ast__Type)),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.parent_type = 0,.is_markused = Array_v__ast__Attr_contains(attrs, _S("markused")),.is_generic = generic_types.len > 0,}))), false),
		.align = -1,
		.idx = 0,
		.size = -1,
		.parent_idx = 0,
		.kind = v__ast__Kind__interface,
		.language = language,
		.is_pub = is_pub,
		.is_builtin = 0,
	}));
	if (reg_idx == -1 && !p->pref->is_fmt) {
		v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot register interface `"), 0xfe10, {.d_s = interface_name}}, {_S("`, another type with this name exists"), 0, { .d_c = 0 }}})), name_pos);
		return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
	}
	v__ast__Type typ = v__ast__new_type(reg_idx);
	v__ast__TypeSymbol* ts = v__ast__Table_sym(p->table, typ);
	v__ast__Interface info = *(v__ast__Interface*)builtin____as_cast((ts->info)._v__ast__Interface,(ts->info)._typ, 485);
	ts->methods = builtin____new_array_with_default(0, 20, sizeof(v__ast__Fn), 0);
	Array_v__ast__StructField fields = builtin____new_array_with_default(0, 20, sizeof(v__ast__StructField), 0);
	Array_v__ast__FnDecl methods = builtin____new_array_with_default(0, 20, sizeof(v__ast__FnDecl), 0);
	Array_v__ast__InterfaceEmbedding embeds = builtin____new_array_with_default(0, 0, sizeof(v__ast__InterfaceEmbedding), 0);
	bool is_mut = false;
	int mut_pos = -1;
	for (;;) {
		if (!(p->tok.kind != v__token__Kind__rcbr && p->tok.kind != v__token__Kind__eof)) break;
		if (p->tok.kind == v__token__Kind__name && p->tok.lit.len > 0 && builtin__u8_is_capital(builtin__string_at(p->tok.lit, 0)) && (p->peek_tok.line_nr != p->tok.line_nr || !(p->peek_tok.kind == v__token__Kind__name || p->peek_tok.kind == v__token__Kind__amp || p->peek_tok.kind == v__token__Kind__lsbr || p->peek_tok.kind == v__token__Kind__lpar) || (p->peek_tok.kind == v__token__Kind__lsbr && v__token__Token_is_next_to(p->peek_tok, p->tok)))) {
			v__token__Pos iface_pos = v__token__Token_pos(&p->tok);
			string iface_name = p->tok.lit;
			v__ast__Type iface_type = v__parser__Parser_parse_type(p);
			if (_SLIT_EQ(iface_name.str, iface_name.len, "JS")) {
				iface_name = v__ast__Table_sym(p->table, iface_type)->name;
			}
			Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			builtin__array_push((array*)&embeds, _MOV((v__ast__InterfaceEmbedding[]){ ((v__ast__InterfaceEmbedding){.name = iface_name,.typ = iface_type,.pos = iface_pos,.comments = comments,}) }));
			if (p->tok.kind == v__token__Kind__rcbr) {
				break;
			}
			continue;
		}
		if (p->tok.kind == v__token__Kind__name && p->peek_tok.kind == v__token__Kind__dot) {
			if (!_IN_MAP(ADDR(string, p->tok.lit), ADDR(map, p->imports))) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("mod `"), 0xfe10, {.d_s = p->tok.lit}}, {_S("` not imported"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->tok));
				break;
			}
			string mod_name = p->tok.lit;
			v__ast__Type from_mod_typ = v__parser__Parser_parse_type(p);
			string from_mod_name = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = mod_name}}, {_S("."), 0xfe10, {.d_s = p->prev_tok.lit}}, {_SLIT0, 0, { .d_c = 0 }}}));
			if (builtin__string_is_lower(from_mod_name)) {
				v__parser__Parser_error_with_pos(p, _S("the interface name need to have the pascal case"), v__token__Token_pos(&p->prev_tok));
				break;
			}
			Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
			builtin__array_push((array*)&embeds, _MOV((v__ast__InterfaceEmbedding[]){ ((v__ast__InterfaceEmbedding){.name = from_mod_name,.typ = from_mod_typ,.pos = v__token__Token_pos(&p->prev_tok),.comments = comments,}) }));
			if (p->tok.kind == v__token__Kind__rcbr) {
				break;
			}
			continue;
		}
		if (p->tok.kind == v__token__Kind__key_mut) {
			if (is_mut) {
				v__parser__Parser_error_with_pos(p, _S("redefinition of `mut` section"), v__token__Token_pos(&p->tok));
				return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
			}
			v__parser__Parser_next(p);
			v__parser__Parser_check(p, v__token__Kind__colon);
			is_mut = true;
			mut_pos = fields.len;
		}
		if (p->peek_tok.kind == v__token__Kind__lsbr && v__token__Token_is_next_to(p->peek_tok, p->tok)) {
			if (generic_types.len == 0) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("non-generic interface `"), 0xfe10, {.d_s = interface_name}}, {_S("` cannot define a generic method"), 0, { .d_c = 0 }}})), v__token__Token_pos(&p->peek_tok));
			} else {
				v__parser__Parser_error_with_pos(p, _S("no need to add generic type names in generic interface's method"), v__token__Token_pos(&p->peek_tok));
			}
			return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
		}
		Array_v__ast__Comment comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = 0,}));
		if (p->peek_tok.kind == v__token__Kind__lpar) {
			v__token__Pos method_start_pos = v__token__Token_pos(&p->tok);
			bool has_prev_newline = v__parser__Parser_has_prev_newline(p);
			bool has_break_line = has_prev_newline || v__parser__Parser_has_prev_line_comment_or_label(p);
			int line_nr = p->tok.line_nr;
			string name = v__parser__Parser_check_name(p);
			if (_SLIT_EQ(name.str, name.len, "type_name") || _SLIT_EQ(name.str, name.len, "type_idx")) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("cannot override built-in method `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), method_start_pos);
				return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
			}
			if (v__ast__TypeSymbol_has_method(ts, name)) {
				v__parser__Parser_error_with_pos(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("duplicate method `"), 0xfe10, {.d_s = name}}, {_S("`"), 0, { .d_c = 0 }}})), method_start_pos);
				return ((v__ast__InterfaceDecl){.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__InterfaceEmbedding)),.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.field_names = builtin____new_array(0, 0, sizeof(string)),.methods = builtin____new_array(0, 0, sizeof(v__ast__FnDecl)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.mut_pos = 0,.typ = 0,.language = 0,.is_pub = 0,.are_embeds_expanded = 0,});
			}
			multi_return_Array_v__ast__Param_bool_bool_bool mr_27353 = v__parser__Parser_fn_params(p);
			Array_v__ast__Param params_t = mr_27353.arg0;
			bool is_variadic = mr_27353.arg2;
			Array_v__ast__Param params = builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Param), _MOV((v__ast__Param[1]){((v__ast__Param){.name = _S("x"),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.typ = typ,.is_atomic = 0,.is_shared = 0,.is_hidden = true,.on_newline = 0,.is_mut = is_mut,})}));
			_PUSH_MANY(&params, (params_t), _t14, Array_v__ast__Param);
			v__ast__FnDecl method = ((v__ast__FnDecl){
				.receiver = ((v__ast__StructField){.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.default_val = (string){.str=(byteptr)"", .is_lit=1},.name = (string){.str=(byteptr)"", .is_lit=1},.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.default_expr_typ = 0,.container_typ = 0,.typ = 0,.unaliased_typ = 0,.i = 0,.is_pub = 0,.has_break_line = 0,.is_recursive = 0,.is_mut = 0,.has_prev_newline = 0,.has_default_expr = 0,.is_part_of_union = 0,.is_global = 0,.is_volatile = 0,.is_deprecated = 0,.is_embed = 0,}),
				.trace_fns = builtin__new_map(sizeof(string), sizeof(v__ast__FnTrace), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),
				.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.label_names = builtin____new_array(0, 0, sizeof(string)),
				.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.defer_stmts = builtin____new_array(0, 0, sizeof(v__ast__DeferStmt)),
				.stmts = builtin____new_array(0, 0, sizeof(v__ast__Stmt)),
				.params = params,
				.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
				.generic_names = builtin____new_array(0, 0, sizeof(string)),
				.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.name = name,
				.file = p->file_path,
				.mod = p->mod,
				.short_name = name,
				.scope = p->scope,
				.source_file = ((void*)0),
				.receiver_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.static_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.method_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.body_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.pos = v__token__Pos_extend(method_start_pos, v__token__Token_pos(&p->prev_tok)),
				.end_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.ninstances = 0,
				.return_type = _const_v__ast__void_type,
				.idx = 0,
				.ctdefine_idx = -1,
				.method_idx = 0,
				.kind = 0,
				.language = 0,
				.file_mode = 0,
				.rec_share = 0,
				.is_exported = 0,
				.is_keep_alive = 0,
				.no_body = 0,
				.is_builtin = 0,
				.is_deprecated = 0,
				.rec_mut = 0,
				.is_conditional = 0,
				.is_test = 0,
				.is_direct_arr = 0,
				.is_main = 0,
				.is_pub = true,
				.is_c_variadic = 0,
				.is_manualfree = 0,
				.is_noreturn = 0,
				.is_weak = 0,
				.is_anon = 0,
				.is_static_type_method = 0,
				.is_expand_simple_interpolation = 0,
				.has_return = 0,
				.should_be_skipped = 0,
				.is_method = 0,
				.has_await = 0,
				.is_variadic = is_variadic,
				.is_c_extern = 0,
				.is_unsafe = 0,
				.is_must_use = 0,
				.is_markused = 0,
				.is_ignore_overflow = 0,
				.is_file_translated = 0,
				.is_closure = 0,
				.has_break_line = has_break_line,
				.has_prev_newline = has_prev_newline,
			});
			if (v__token__Kind_is_start_of_type(p->tok.kind) && p->tok.line_nr == line_nr) {
				method.return_type_pos = v__token__Token_pos(&p->tok);
				bool last_inside_return = p->inside_fn_return;
				p->inside_fn_return = true;
				method.return_type = v__parser__Parser_parse_type(p);
				p->inside_fn_return = last_inside_return;
				method.return_type_pos = v__token__Pos_extend(method.return_type_pos, v__token__Token_pos(&p->tok));
				method.pos = v__token__Pos_extend(method.pos, method.return_type_pos);
			}
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = true,.follow_up = 0,}))), _t15, Array_v__ast__Comment);
			Array_v__ast__Comment mnext_comments = v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}));
			method.comments = comments;
			method.next_comments = mnext_comments;
			builtin__array_push((array*)&methods, _MOV((v__ast__FnDecl[]){ method }));
			v__ast__Fn tmethod = ((v__ast__Fn){
				.params = params,
				.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
				.dep_names = builtin____new_array(0, 0, sizeof(string)),
				.generic_names = builtin____new_array(0, 0, sizeof(string)),
				.file = (string){.str=(byteptr)"", .is_lit=1},
				.name = name,
				.mod = (string){.str=(byteptr)"", .is_lit=1},
				.source_fn = 0,
				.name_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.pos = method.pos,
				.return_type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.receiver_type = typ,
				.usages = 0,
				.return_type = method.return_type,
				.from_embedded_type = 0,
				.ctdefine_idx = 0,
				.file_mode = 0,
				.language = 0,
				.is_expand_simple_interpolation = 0,
				.is_c_variadic = 0,
				.is_pub = true,
				.is_ctor_new = 0,
				.is_deprecated = 0,
				.is_noreturn = 0,
				.is_unsafe = 0,
				.is_must_use = 0,
				.is_placeholder = 0,
				.is_main = 0,
				.is_test = 0,
				.is_keep_alive = 0,
				.is_method = true,
				.is_static_type_method = 0,
				.no_body = true,
				.is_file_translated = 0,
				.is_conditional = 0,
				.is_variadic = is_variadic,
			});
			v__ast__TypeSymbol_register_method(ts, tmethod);
			builtin__array_push((array*)&info.methods, _MOV((v__ast__Fn[]){ tmethod }));
			if (p->pref->is_vls) {
				string f_key = builtin__str_intp(4, _MOV((StrIntpData[]){{_S("fn_"), 0xfe10, {.d_s = p->mod}}, {_S("["), 0xfe10, {.d_s = modless_name}}, {_S("]"), 0xfe10, {.d_s = name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__ast__VlsInfo f_val = ((v__ast__VlsInfo){.pos = method.pos,.doc = builtin__string__plus(pre_comment_string, v__parser__Parser_comments_to_string(p, comments)),});
				v__ast__Table_register_vls_info(p->table, f_key, f_val);
				pre_comment_string = v__parser__Parser_comments_to_string(p, mnext_comments);
			}
		} else {
			v__token__Pos field_pos = v__token__Token_pos(&p->tok);
			bool has_prev_newline = v__parser__Parser_has_prev_newline(p);
			bool has_break_line = has_prev_newline || v__parser__Parser_has_prev_line_comment_or_label(p);
			string field_name = v__parser__Parser_check_name(p);
			v__token__Pos type_pos = v__token__Token_pos(&p->tok);
			v__ast__Type field_typ = v__parser__Parser_parse_type(p);
			type_pos = v__token__Pos_extend(type_pos, v__token__Token_pos(&p->prev_tok));
			_PUSH_MANY(&comments, (v__parser__Parser_eat_comments(p, ((v__parser__EatCommentsConfig){.same_line = 0,.follow_up = true,}))), _t18, Array_v__ast__Comment);
			builtin__array_push((array*)&fields, _MOV((v__ast__StructField[]){ ((v__ast__StructField){
				.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
				.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
				.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.comments = comments,
				.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.name = field_name,
				.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
				.pos = field_pos,
				.type_pos = type_pos,
				.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.default_expr_typ = 0,
				.container_typ = 0,
				.typ = field_typ,
				.unaliased_typ = 0,
				.i = 0,
				.is_pub = true,
				.has_break_line = has_break_line,
				.is_recursive = 0,
				.is_mut = 0,
				.has_prev_newline = has_prev_newline,
				.has_default_expr = 0,
				.is_part_of_union = 0,
				.is_global = 0,
				.is_volatile = 0,
				.is_deprecated = 0,
				.is_embed = 0,
			}) }));
			builtin__array_push((array*)&info.fields, _MOV((v__ast__StructField[]){ ((v__ast__StructField){
				.anon_struct_decl = ((v__ast__StructDecl){.fields = builtin____new_array(0, 0, sizeof(v__ast__StructField)),.implements_types = builtin____new_array(0, 0, sizeof(v__ast__TypeNode)),.embeds = builtin____new_array(0, 0, sizeof(v__ast__Embed)),.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.end_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),.name = (string){.str=(byteptr)"", .is_lit=1},.scoped_name = (string){.str=(byteptr)"", .is_lit=1},.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),.idx = 0,.mut_pos = -1,.pub_pos = -1,.pub_mut_pos = -1,.global_pos = -1,.module_pos = -1,.language = 0,.is_aligned = 0,.is_implements = 0,.is_option = 0,.is_union = 0,.is_pub = 0,}),
				.attrs = builtin____new_array(0, 0, sizeof(v__ast__Attr)),
				.pre_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.next_comments = builtin____new_array(0, 0, sizeof(v__ast__Comment)),
				.default_val = (string){.str=(byteptr)"", .is_lit=1},
				.name = field_name,
				.default_expr = (v__ast__Expr){._v__ast__NodeError=HEAP(v__ast__NodeError, ((v__ast__NodeError){.idx = 0,.pos = (v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,},})),._typ=258},
				.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.type_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.option_pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),
				.default_expr_typ = 0,
				.container_typ = 0,
				.typ = field_typ,
				.unaliased_typ = 0,
				.i = 0,
				.is_pub = true,
				.has_break_line = has_break_line,
				.is_recursive = 0,
				.is_mut = is_mut,
				.has_prev_newline = has_prev_newline,
				.has_default_expr = 0,
				.is_part_of_union = 0,
				.is_global = 0,
				.is_volatile = 0,
				.is_deprecated = 0,
				.is_embed = 0,
			}) }));
			if (p->pref->is_vls) {
				v__ast__Comment f_end_comment = ((v__ast__Comment){.text = (string){.str=(byteptr)"", .is_lit=1},.is_multi = 0,.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),});
				Array_v__ast__Comment f_nxt_comment = builtin____new_array_with_default(0, 0, sizeof(v__ast__Comment), 0);
				if (comments.len > 0 && (*(v__ast__Comment*)builtin__array_get(comments, 0)).pos.line_nr == type_pos.line_nr) {
					f_end_comment = (*(v__ast__Comment*)builtin__array_get(comments, 0));
					f_nxt_comment = builtin__array_clone_static_to_depth(builtin__array_slice(comments, 1, 2147483647), 0);
				} else {
					f_nxt_comment = builtin__array_clone_to_depth(&comments, 0);
				}
				string f_key = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("interface_"), 0xfe10, {.d_s = interface_name}}, {_S("."), 0xfe10, {.d_s = field_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
				v__ast__VlsInfo f_val = ((v__ast__VlsInfo){.pos = field_pos,.doc = builtin__string__plus(pre_comment_string, v__parser__Parser_comments_to_string(p, builtin__new_array_from_c_array(1, 1, sizeof(v__ast__Comment), _MOV((v__ast__Comment[1]){f_end_comment})))),});
				v__ast__Table_register_vls_info(p->table, f_key, f_val);
				pre_comment_string = v__parser__Parser_comments_to_string(p, f_nxt_comment);
			}
		}
	}
	Array_v__ast__Type _t21 = {0};
	Array_v__ast__InterfaceEmbedding _t21_orig = embeds;
	int _t21_len = _t21_orig.len;
	_t21 = builtin____new_array(0, _t21_len, sizeof(v__ast__Type));

	for (int _t23 = 0; _t23 < _t21_len; ++_t23) {
		v__ast__InterfaceEmbedding it = ((v__ast__InterfaceEmbedding*) _t21_orig.data)[_t23];
		v__ast__Type _t22 = it.typ;
		builtin__array_push((array*)&_t21, &_t22);
	}
	info.embeds =_t21;
	ts->info = v__ast__Interface_to_sumtype_v__ast__TypeInfo(&info, false);
	v__parser__Parser_top_level_statement_end(p);
	v__parser__Parser_check(p, v__token__Kind__rcbr);
	pos = v__token__Pos_extend_with_last_line(pos, v__token__Token_pos(&p->prev_tok), p->prev_tok.line_nr);
	v__ast__InterfaceDecl res = ((v__ast__InterfaceDecl){
		.pre_comments = pre_comments,
		.generic_types = generic_types,
		.embeds = embeds,
		.fields = fields,
		.field_names = builtin____new_array(0, 0, sizeof(string)),
		.methods = methods,
		.attrs = attrs,
		.name = interface_name,
		.pos = pos,
		.name_pos = name_pos,
		.mut_pos = mut_pos,
		.typ = typ,
		.language = language,
		.is_pub = is_pub,
		.are_embeds_expanded = 0,
	});
	v__ast__Table_register_interface(p->table, res);
	if (p->pref->is_vls) {
		string key = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("interface_"), 0xfe10, {.d_s = interface_name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (res.pre_comments.len > 0 && (*(v__ast__Comment*)builtin__array_get(res.pre_comments, 0)).pos.line_nr == res.pos.line_nr) {
			builtin__array_push((array*)&comments_before_key_interface, _MOV((v__ast__Comment[]){ (*(v__ast__Comment*)builtin__array_get(res.pre_comments, 0)) }));
		}
		v__ast__VlsInfo val = ((v__ast__VlsInfo){.pos = res.pos,.doc = v__parser__Parser_keyword_comments_to_string(p, modless_name, comments_before_key_interface),});
		v__ast__Table_register_vls_info(p->table, key, val);
	}
	return res;
}
VV_LOC void v__parser__State_update(v__parser__State* state, string line) {
	string trimmed_line = builtin__string_trim_space(line);
	if (v__parser__is_html_open_tag(_S("style"), line)) {
		*state = v__parser__State__css;
	} else if (_SLIT_EQ(trimmed_line.str, trimmed_line.len, "</style>")) {
		*state = v__parser__State__html;
	} else if (v__parser__is_html_open_tag(_S("script"), line)) {
		*state = v__parser__State__js;
	} else if (_SLIT_EQ(trimmed_line.str, trimmed_line.len, "</script>")) {
		*state = v__parser__State__html;
	}
}
VV_LOC bool v__parser__is_html_open_tag(string name, string s) {
	string trimmed_line = builtin__string_trim_space(s);
	int len = trimmed_line.len;
	if (len < name.len) {
		return false;
	}
	string sub = builtin__string_substr(trimmed_line, 0, 1);
	if (_SLIT_NE(sub.str, sub.len, "<")) {
		return false;
	}
	sub = builtin__string_substr(trimmed_line, (int)(len - 1), len);
	if (_SLIT_NE(sub.str, sub.len, ">")) {
		return false;
	}
	sub = builtin__string_substr(trimmed_line, (int)(len - 2), (int)(len - 1));
	if (_SLIT_EQ(sub.str, sub.len, "/")) {
		return false;
	}
	sub = builtin__string_substr(trimmed_line, 1, (int)(len - 1));
	if (builtin__string_contains_any(sub, _S("<>"))) {
		return false;
	}
	if (builtin__string__eq(sub, name)) {
		return true;
	} else {
		len = name.len;
		if (sub.len <= len) {
			return false;
		}
		if (!builtin__string__eq(builtin__string_substr(sub, 0, (int)(len + 1)), builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = name}}, {_S(" "), 0, { .d_c = 0 }}})))) {
			return false;
		}
		return true;
	}
	return 0;
}
VV_LOC string v__parser__insert_template_code(string fn_name, string tmpl_str_start, string line) {
	string trailing_bs = builtin__string__plus(builtin__string__plus(_S("')\n"), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("sb_"), 0xfe10, {.d_s = fn_name}}, {_S(".write_u8(92)\n"), 0, { .d_c = 0 }}}))), tmpl_str_start);
	Array_string replace_pairs = builtin__new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
			_S("\\"), _S("\\\\"), _S("'"), _S("\\'"), _S("@@"), _S("@"), _S("@"), _S("$"), _S("$$"),
			_S("\\@")}));
	string rline = builtin__string_replace_each(line, replace_pairs);
	string comptime_call_str = builtin__string_find_between(rline, _S("${"), _S("}"));
	if (builtin__string_contains(comptime_call_str, _S("\\'"))) {
		rline = builtin__string_replace(rline, comptime_call_str, builtin__string_replace(comptime_call_str, _S("\\'"), _S("'")));
	}
	if (builtin__string_ends_with(rline, _S("\\"))) {
		rline = builtin__string__plus(builtin__string_substr(rline, 0, (int)(rline.len - 2)), trailing_bs);
	}
	return rline;
}
VV_LOC string v__parser__IncludeError_msg(v__parser__IncludeError err) {
	return err.message;
}
VV_LOC int v__parser__IncludeError_line_nr(v__parser__IncludeError err) {
	return err.line_nr;
}
VV_LOC int v__parser__IncludeError_pos(v__parser__IncludeError err) {
	return err.position;
}
VV_LOC string v__parser__IncludeError_calling_file(v__parser__IncludeError err) {
	return err.calling_file;
}
VV_LOC u16 v__parser__IncludeError_col(v__parser__IncludeError err) {
	return err.col;
}
VV_LOC _result_Array_string v__parser__Parser_process_includes(v__parser__Parser* p, string calling_file, int line_number, string line, v__parser__DependencyCache* dc) {
	string base_path = os__dir(calling_file);
	int tline_number = line_number;
	string _t1; /* if prepend */
	if (builtin__string_contains(line, _S("\""))) {
		_t1 = (*(string*)builtin__array_get(builtin__string_split(line, _S("\"")), 1));
		goto _t2;
	};
	if (builtin__string_contains(line, _S("'"))) {
		_t1 = (*(string*)builtin__array_get(builtin__string_split(line, _S("'")), 1));
		goto _t2;
	};
	{
		_option_int _t3 = builtin__string_index(line, _S("@include "));
		if (_t3.state != 0) {
			*(int*) _t3.data = 0;
		}
		
 		int position = (*(int*)_t3.data);
		return (_result_Array_string){ .is_error=true, .err=I_v__parser__IncludeError_to_Interface_IError(((v__parser__IncludeError*)builtin__memdup(&(v__parser__IncludeError){.Error = ((Error){E_STRUCT}),.calling_file = calling_file,.line_nr = tline_number,.position = (int)(position + 9),.col = ((u16)((int)(position + 9))),.message = _S("path for @include must be quoted with \' or \""),}, sizeof(v__parser__IncludeError)))), .data={E_STRUCT} };
	}
	_t2: {};
		string file_name = _t1;
	string file_ext = os__file_ext(file_name);
	if ((file_ext).len == 0) {
		file_ext = _S(".html");
	}
	file_name = builtin__string_replace(file_name, file_ext, _S(""));
	string file_path = os__real_path(os__join_path_single(base_path, builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = file_name}}, {_SLIT0, 0xfe10, {.d_s = file_ext}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	if (!os__exists(file_path) && !builtin__string_contains(file_name, _S("../"))) {
		Array_string path_arr = builtin__string_split_any(base_path, _S("/\\"));
		int idx = Array_string_index(path_arr, _S("templates"));
		string root_path = Array_string_join(builtin__array_slice(path_arr, 0, (int)(idx + 1)), _S("/"));
		file_name = (*(string*)builtin__array_get(builtin__string_rsplit(file_name, _S("../")), 0));
		file_path = os__real_path(os__join_path_single(root_path, builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = file_name}}, {_SLIT0, 0xfe10, {.d_s = file_ext}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	}
	if (!Array_string_contains((*(Array_string*)builtin__map_get(ADDR(map, dc->dependencies), &(string[]){file_path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })), calling_file)) {
		builtin__array_push((array*)&(*(Array_string*)builtin__map_get_and_set((map*)&dc->dependencies, &(string[]){file_path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })), _MOV((string[]){ builtin__string_clone(calling_file) }));
	}
	Array_string _t6 = (*(Array_string*)builtin__map_get(ADDR(map, dc->dependencies), &(string[]){file_path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) }));
	for (int _t7 = 0; _t7 < _t6.len; ++_t7) {
		string callee = ((string*)_t6.data)[_t7];
		if (Array_string_contains((*(Array_string*)builtin__map_get(ADDR(map, dc->dependencies), &(string[]){callee}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })), file_path)) {
			_option_int _t9 = builtin__string_index(line, _S("@include "));
			if (_t9.state != 0) {
				*(int*) _t9.data = 0;
			}
			
 			return (_result_Array_string){ .is_error=true, .err=I_v__parser__IncludeError_to_Interface_IError(((v__parser__IncludeError*)builtin__memdup(&(v__parser__IncludeError){.Error = ((Error){E_STRUCT}),.calling_file = calling_file,.line_nr = tline_number,.position = (*(int*)_t9.data),.col = 0,.message = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("A recursive call is being made on template "), 0xfe10, {.d_s = file_name}}, {_SLIT0, 0, { .d_c = 0 }}})),}, sizeof(v__parser__IncludeError)))), .data={E_STRUCT} };
		}
	}
	Array_string file_content = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	if (_IN_MAP(ADDR(string, file_path), ADDR(map, dc->cache))) {
		file_content = (*(Array_string*)builtin__map_get(ADDR(map, dc->cache), &(string[]){file_path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) }));
	} else {
		_result_Array_string _t10 = os__read_lines(file_path);
		if (_t10.is_error) {
			_option_int _t11 = builtin__string_index(line, _S("@include "));
			if (_t11.state != 0) {
				*(int*) _t11.data = 0;
			}
			
 			int position = (int)((*(int*)_t11.data) + 9);
			return (_result_Array_string){ .is_error=true, .err=I_v__parser__IncludeError_to_Interface_IError(((v__parser__IncludeError*)builtin__memdup(&(v__parser__IncludeError){.Error = ((Error){E_STRUCT}),.calling_file = calling_file,.line_nr = tline_number,.position = position,.col = 0,.message = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("Reading file `"), 0xfe10, {.d_s = file_name}}, {_S("` from path: "), 0xfe10, {.d_s = file_path}}, {_S(" failed"), 0, { .d_c = 0 }}})),}, sizeof(v__parser__IncludeError)))), .data={E_STRUCT} };
		}
		
 		file_content = (*(Array_string*)_t10.data);
	}
	tline_number = 1;
	for (int i = 0; i < file_content.len; ++i) {
		string l = ((string*)file_content.data)[i];
		if (builtin__string_contains(l, _S("@include "))) {
			_result_Array_string _t13 = v__parser__Parser_process_includes(p, file_path, tline_number, l, dc);
			if (_t13.is_error) {
				IError err = _t13.err;
				return (_result_Array_string){ .is_error=true, .err=err, .data={E_STRUCT} };
			}
			
 			Array_string processed = (*(Array_string*)_t13.data);
			builtin__array_delete(&file_content, i);
			Array_string _t15 = builtin__array_reverse(processed);
			for (int _t16 = 0; _t16 < _t15.len; ++_t16) {
				string processed_line = ((string*)_t15.data)[_t16];
				builtin__array_insert(&file_content, i, &(string[]){builtin__string_clone(processed_line)});
				tline_number--;
			}
		}
	}
	builtin__array_push((array*)&p->template_paths, _MOV((string[]){ builtin__string_clone(file_path) }));
	(*(Array_string*)builtin__map_get_and_set((map*)&dc->cache, &(string[]){file_path}, &(Array_string[]){ builtin____new_array(0, 0, sizeof(string)) })) = file_content;
	_result_Array_string _t18;
	builtin___result_ok(&(Array_string[]) { file_content }, (_result*)(&_t18), sizeof(Array_string));
	 
	return _t18;
}
string v__parser__Parser_compile_template_file(v__parser__Parser* p, string template_file, string fn_name) {
	_result_Array_string _t1 = os__read_lines(template_file);
	if (_t1.is_error) {
		v__parser__Parser_error(p, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("reading from "), 0xfe10, {.d_s = template_file}}, {_S(" failed"), 0, { .d_c = 0 }}})));
		return _S("");
	}
	
 	Array_string lines = (*(Array_string*)_t1.data);
	builtin__array_push((array*)&p->template_paths, _MOV((string[]){ builtin__string_clone(template_file) }));
	v__parser__DependencyCache dc = ((v__parser__DependencyCache){.dependencies = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.cache = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
	int lstartlength = (int)(lines.len * 30);
	string tmpl_str_start = builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\tsb_"), 0xfe10, {.d_s = fn_name}}, {_S(".write_string('"), 0, { .d_c = 0 }}}));
	strings__Builder source = strings__new_builder(1000);
	p->template_line_map = builtin____new_array_with_default(0, 0, sizeof(v__ast__TemplateLineInfo), 0);
	strings__Builder_writeln(&source, builtin__str_intp(5, _MOV((StrIntpData[]){{_S("\nimport strings\n// === veb html template for file: "), 0xfe10, {.d_s = template_file}}, {_S(" ===\nfn veb_tmpl_"), 0xfe10, {.d_s = fn_name}}, {_S("() string {\n\011mut sb_"), 0xfe10, {.d_s = fn_name}}, {_S(" := strings.new_builder("), 0xfe07, {.d_i32 = lstartlength}}, {_S(")\n\n\n"), 0, { .d_c = 0 }}})));
	for (int _t4 = 0; _t4 < 8; ++_t4) {
		builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = 0,}) }));
	}
	strings__Builder_write_string(&source, tmpl_str_start);
	v__parser__State state = v__parser__State__simple;
	string template_ext = os__file_ext(template_file);
	if (builtin__string__eq(builtin__string_to_lower_ascii(template_ext), _S(".html"))) {
		state = v__parser__State__html;
	}
	bool in_span = false;
	int end_of_line_pos = 0;
	int start_of_line_pos = 0;
	int tline_number = -1;
	for (int i = 0; i < lines.len; i++) {
		string line = (*(string*)builtin__array_get(lines, i));
		tline_number++;
		start_of_line_pos = end_of_line_pos;
		end_of_line_pos += (int)(line.len + 1);
		if (state != v__parser__State__simple) {
			v__parser__State_update(&state, line);
		}
		if (builtin__string_contains(line, _S("@header"))) {
			_option_int _t6 = builtin__string_index(line, _S("@header"));
			if (_t6.state != 0) {
				*(int*) _t6.data = 0;
			}
			
 			int position = (*(int*)_t6.data);
			v__parser__Parser_error_with_error(p, ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = _S("Please use @include 'header' instead of @header (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = ((v__token__Pos){.len = 7,.line_nr = tline_number,.pos = (int)(start_of_line_pos + position),.col = 0,.file_idx = -1,.last_line = lines.len,}),.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}));
			continue;
		}
		if (builtin__string_contains(line, _S("@footer"))) {
			_option_int _t7 = builtin__string_index(line, _S("@footer"));
			if (_t7.state != 0) {
				*(int*) _t7.data = 0;
			}
			
 			int position = (*(int*)_t7.data);
			v__parser__Parser_error_with_error(p, ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = _S("Please use @include 'footer' instead of @footer (deprecated)"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = ((v__token__Pos){.len = 7,.line_nr = tline_number,.pos = (int)(start_of_line_pos + position),.col = 0,.file_idx = -1,.last_line = lines.len,}),.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}));
			continue;
		}
		if (builtin__string_contains(line, _S("@include "))) {
			builtin__array_delete(&lines, i);
			_result_Array_string _t8 = v__parser__Parser_process_includes(p, template_file, tline_number, line, &dc);
			if (_t8.is_error) {
				IError err = _t8.err;
				Array_string _t9; /* if prepend */
				if ((err)._typ == _IError_v__parser__IncludeError_index) {
					v__parser__Parser_error_with_error(p, ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = v__parser__IncludeError_msg(*(err._v__parser__IncludeError)),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = v__parser__IncludeError_calling_file(*(err._v__parser__IncludeError)),.pos = ((v__token__Pos){.len = 9,.line_nr = v__parser__IncludeError_line_nr(*(err._v__parser__IncludeError)),.pos = (int)(start_of_line_pos + v__parser__IncludeError_pos(*(err._v__parser__IncludeError))),.col = v__parser__IncludeError_col(*(err._v__parser__IncludeError)),.file_idx = -1,.last_line = lines.len,}),.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}));
					_t9 = builtin____new_array_with_default(0, 0, sizeof(string), 0);
					goto _t10;
				};
				{
					v__parser__Parser_error_with_error(p, ((v__errors__Error){.CompilerMessage = ((v__errors__CompilerMessage){.message = _S("An unknown error has occurred"),.details = (string){.str=(byteptr)"", .is_lit=1},.file_path = template_file,.pos = ((v__token__Pos){.len = 9,.line_nr = tline_number,.pos = start_of_line_pos,.col = 0,.file_idx = -1,.last_line = lines.len,}),.reporter = v__errors__Reporter__parser,.call_stack = builtin____new_array(0, 0, sizeof(v__errors__CallStackItem)),}),}));
					_t9 = builtin____new_array_with_default(0, 0, sizeof(string), 0);
				}
	_t10: {};
								*(Array_string*) _t8.data = _t9;
			}
			
 			Array_string resolved = (*(Array_string*)_t8.data);
			Array_string _t11 = builtin__array_reverse(resolved);
			for (int _t12 = 0; _t12 < _t11.len; ++_t12) {
				string resolved_line = ((string*)_t11.data)[_t12];
				tline_number--;
				builtin__array_insert(&lines, i, &(string[]){builtin__string_clone(resolved_line)});
			}
			i--;
			continue;
		}
		if (builtin__string_contains(line, _S("@if "))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			_option_int _t15 = builtin__string_index(line, _S("@if"));
			if (_t15.state != 0) {
				continue;
			}
			
 			int pos = (*(int*)_t15.data);
			strings__Builder_writeln(&source, builtin__string__plus(builtin__string__plus(_S("if "), builtin__string_substr(line, (int)(pos + 4), 2147483647)), _S("{")));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			strings__Builder_write_string(&source, tmpl_str_start);
			continue;
		}
		if (builtin__string_contains(line, _S("@end"))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			strings__Builder_writeln(&source, _S("}"));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			strings__Builder_write_string(&source, tmpl_str_start);
			continue;
		}
		if (builtin__string_contains(line, _S("@else"))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			_option_int _t22 = builtin__string_index(line, _S("@else"));
			if (_t22.state != 0) {
				continue;
			}
			
 			int pos = (*(int*)_t22.data);
			strings__Builder_writeln(&source, builtin__string__plus(builtin__string__plus(_S("}"), builtin__string_substr(line, (int)(pos + 1), 2147483647)), _S("{")));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			strings__Builder_write_string(&source, tmpl_str_start);
			continue;
		}
		if (builtin__string_contains(line, _S("@for"))) {
			strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			_option_int _t26 = builtin__string_index(line, _S("@for"));
			if (_t26.state != 0) {
				continue;
			}
			
 			int pos = (*(int*)_t26.data);
			strings__Builder_writeln(&source, builtin__string__plus(builtin__string__plus(_S("for "), builtin__string_substr(line, (int)(pos + 4), 2147483647)), _S("{")));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			strings__Builder_write_string(&source, tmpl_str_start);
			continue;
		}
		if (state == v__parser__State__simple) {
			strings__Builder_writeln(&source, v__parser__insert_template_code(fn_name, tmpl_str_start, line));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			continue;
		}
		if (state != v__parser__State__simple) {
			if (builtin__string_contains(line, _S("@js "))) {
				_option_int _t29 = builtin__string_index(line, _S("@js"));
				if (_t29.state != 0) {
					continue;
				}
				
 				int pos = (*(int*)_t29.data);
				strings__Builder_write_string(&source, _S("<script src=\""));
				strings__Builder_write_string(&source, builtin__string_substr(line, (int)(pos + 5), (int)(line.len - 1)));
				strings__Builder_writeln(&source, _S("\"></script>"));
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				continue;
			}
			if (builtin__string_contains(line, _S("@css "))) {
				_option_int _t31 = builtin__string_index(line, _S("@css"));
				if (_t31.state != 0) {
					continue;
				}
				
 				int pos = (*(int*)_t31.data);
				strings__Builder_write_string(&source, _S("<link href=\""));
				strings__Builder_write_string(&source, builtin__string_substr(line, (int)(pos + 6), (int)(line.len - 1)));
				strings__Builder_writeln(&source, _S("\" rel=\"stylesheet\" type=\"text/css\">"));
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				continue;
			}
		}

		if (state == (v__parser__State__html)) {
			string line_t = builtin__string_trim_space(line);
			if (builtin__string_starts_with(line_t, _S("span.")) && builtin__string_ends_with(line, _S("{"))) {
				string __v_class = builtin__string_trim_space(builtin__string_find_between(line, _S("span."), _S("{")));
				strings__Builder_writeln(&source, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("<span class=\""), 0xfe10, {.d_s = __v_class}}, {_S("\">"), 0, { .d_c = 0 }}})));
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				in_span = true;
				continue;
			} else if (builtin__string_starts_with(line_t, _S(".")) && builtin__string_ends_with(line, _S("{"))) {
				string __v_class = builtin__string_trim_space(builtin__string_find_between(line, _S("."), _S("{")));
				string trimmed = builtin__string_trim_space(line);
				strings__Builder_write_string(&source, strings__repeat('\t', (int)(line.len - trimmed.len)));
				strings__Builder_writeln(&source, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("<div class=\""), 0xfe10, {.d_s = __v_class}}, {_S("\">"), 0, { .d_c = 0 }}})));
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				continue;
			} else if (builtin__string_starts_with(line_t, _S("#")) && builtin__string_ends_with(line, _S("{"))) {
				string __v_class = builtin__string_trim_space(builtin__string_find_between(line, _S("#"), _S("{")));
				strings__Builder_writeln(&source, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("<div id=\""), 0xfe10, {.d_s = __v_class}}, {_S("\">"), 0, { .d_c = 0 }}})));
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				continue;
			} else if (_SLIT_EQ(line_t.str, line_t.len, "}")) {
				strings__Builder_write_string(&source, strings__repeat('\t', (int)(line.len - line_t.len)));
				if (in_span) {
					strings__Builder_writeln(&source, _S("</span>"));
					in_span = false;
				} else {
					strings__Builder_writeln(&source, _S("</div>"));
				}
				builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
				continue;
			}
		}
		else if (state == (v__parser__State__js)) {
			strings__Builder_writeln(&source, v__parser__insert_template_code(fn_name, tmpl_str_start, line));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			continue;
		}
		else if (state == (v__parser__State__css)) {
			strings__Builder_writeln(&source, builtin__string_replace(builtin__string_replace(line, _S(".$"), _S(".@")), _S("'"), _S("\\'")));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
			continue;
		}
		else {
		}
		string line_ = line;
		int search_start = 0;
		for (;;) {
			_option_int _t39 = builtin__string_index_after(line_, _S("%"), search_start);
			if (_t39.state != 0) {
				break;
			}
			
 			int pos = (*(int*)_t39.data);
			bool is_raw = (int)(pos + 4) < line_.len && builtin__string__eq(builtin__string_substr(line_, pos, (int)(pos + 5)), _S("%raw "));
			if (is_raw) {
				int end = (int)(pos + 5);
				for (;;) {
					if (!(end < line_.len && (builtin__u8_is_letter(builtin__string_at(line_, end)) || builtin__string_at(line_, end) == '_'))) break;
					end++;
				}
				string key = builtin__string_substr(line_, (int)(pos + 5), end);
				if (key.len > 0) {
					line_ = builtin__string_replace(line_, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("%raw "), 0xfe10, {.d_s = key}}, {_SLIT0, 0, { .d_c = 0 }}})), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("${veb.raw(veb.tr(ctx.lang.str(), \""), 0xfe10, {.d_s = key}}, {_S("\"))}"), 0, { .d_c = 0 }}})));
				}
				search_start = (int)(pos + 1);
			} else {
				if ((int)(pos + 1) < line_.len && builtin__u8_is_letter(builtin__string_at(line_, (int)(pos + 1)))) {
					int end = (int)(pos + 1);
					for (;;) {
						if (!(end < line_.len && (builtin__u8_is_letter(builtin__string_at(line_, end)) || builtin__string_at(line_, end) == '_'))) break;
						end++;
					}
					string key = builtin__string_substr(line_, (int)(pos + 1), end);
					line_ = builtin__string_replace(line_, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("%"), 0xfe10, {.d_s = key}}, {_SLIT0, 0, { .d_c = 0 }}})), builtin__str_intp(2, _MOV((StrIntpData[]){{_S("${veb.tr(ctx.lang.str(), \""), 0xfe10, {.d_s = key}}, {_S("\")}"), 0, { .d_c = 0 }}})));
					search_start = (int)(pos + 1);
				} else {
					search_start = (int)(pos + 1);
				}
			}
		}
		if (!builtin__string__eq(line_, line)) {
			strings__Builder_writeln(&source, v__parser__insert_template_code(fn_name, tmpl_str_start, line_));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
		} else {
			strings__Builder_writeln(&source, v__parser__insert_template_code(fn_name, tmpl_str_start, line));
			builtin__array_push((array*)&p->template_line_map, _MOV((v__ast__TemplateLineInfo[]){ ((v__ast__TemplateLineInfo){.tmpl_path = template_file,.tmpl_line = tline_number,}) }));
		}
	}
	strings__Builder_writeln(&source, _const_v__parser__tmpl_str_end);
	strings__Builder_writeln(&source, builtin__str_intp(3, _MOV((StrIntpData[]){{_S("\t_tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_S(" := sb_"), 0xfe10, {.d_s = fn_name}}, {_S(".str() "), 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&source, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\treturn _tmpl_res_"), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	strings__Builder_writeln(&source, _S("}"));
	strings__Builder_writeln(&source, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("// === end of veb html template_file: "), 0xfe10, {.d_s = template_file}}, {_S(" ==="), 0, { .d_c = 0 }}})));
	string result = strings__Builder_str(&source);
	if (builtin__string_contains(result, _S("veb."))) {
		result = builtin__string__plus(_S("import veb\n"), result);
	}
	return result;
}
_result_void vphp__compiler__Compiler_generate_all(vphp__compiler__Compiler* c) {
	_result_void _t1 = vphp__compiler__Compiler_generate_h(c);
	if (_t1.is_error) {
		_result_void _t2 = {0};
		_t2.is_error = true;
		_t2.err = _t1.err;
		return _t2;
	}
	
 ;
	_result_void _t3 = vphp__compiler__Compiler_generate_c(c);
	if (_t3.is_error) {
		_result_void _t4 = {0};
		_t4.is_error = true;
		_t4.err = _t3.err;
		return _t4;
	}
	
 ;
	_result_void _t5 = vphp__compiler__Compiler_generate_v_glue(c);
	if (_t5.is_error) {
		_result_void _t6 = {0};
		_t6.is_error = true;
		_t6.err = _t5.err;
		return _t6;
	}
	
 ;
	return (_result_void){0};
}
VV_LOC _result_void vphp__compiler__Compiler_generate_c(vphp__compiler__Compiler* c) {
	strings__Builder res = strings__new_builder(2048);
	{
		strings__Builder_write_string(&res, _S("/* \342\232\240\357\270\217 VPHP Compiler Generated for "));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S(" */\n"));
	}
	strings__Builder_write_string(&res, _S("#include \"php_bridge.h\"\n\n"));
	strings__Builder_write_string(&res, _S("#include \"../vphp/v_bridge.h\"\n\n"));
	strings__Builder_write_string(&res, _S("extern void vphp_framework_init(int module_number);\n"));
	strings__Builder_write_string(&res, _S("extern void vphp_task_auto_startup();\n\n"));
	for (int _t1 = 0; _t1 < c->elements.len; ++_t1) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t1;
		strings__Builder_write_string(&res, builtin__string__plus(Array_string_join(vphp__compiler__PhpRepr_name_table[el->_typ]._method_gen_c(el->_object), _S("\n")), _S("\n")));
	}
	Array_string internal_funcs = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("v_spawn"), _S("v_wait")}));
	for (int _t2 = 0; _t2 < internal_funcs.len; ++_t2) {
		string f = ((string*)internal_funcs.data)[_t2];
		{
			strings__Builder_write_string(&res, _S("ZEND_BEGIN_ARG_INFO_EX(arginfo_"));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S(", 0, 0, 0)\nZEND_END_ARG_INFO()\n"));
		}
		{
			strings__Builder_write_string(&res, _S("void "));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S("(zend_execute_data *execute_data, zval *return_value);\n"));
		}
		{
			strings__Builder_write_string(&res, _S("PHP_FUNCTION("));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S(") { "));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S("(execute_data, return_value); }\n\n"));
		}
	}
	{
		strings__Builder_write_string(&res, _S("static const zend_function_entry "));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_functions[] = {\n"));
	}
	for (int _t3 = 0; _t3 < c->elements.len; ++_t3) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t3;
		if ((el)->_typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpFuncRepr_index) {
			vphp__compiler__PhpFuncRepr* f = (el->_vphp__compiler__PhpFuncRepr);
			{
				strings__Builder_write_string(&res, _S("    PHP_FE("));
				strings__Builder_write_string(&res, f->name);
				strings__Builder_write_string(&res, _S(", arginfo_"));
				strings__Builder_write_string(&res, f->name);
				strings__Builder_write_string(&res, _S(")\n"));
			}
		}
	}
	for (int _t4 = 0; _t4 < internal_funcs.len; ++_t4) {
		string f = ((string*)internal_funcs.data)[_t4];
		{
			strings__Builder_write_string(&res, _S("    PHP_FE("));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S(", arginfo_"));
			strings__Builder_write_string(&res, f);
			strings__Builder_write_string(&res, _S(")\n"));
		}
	}
	strings__Builder_write_string(&res, _S("    PHP_FE_END\n};\n\n"));
	{
		strings__Builder_write_string(&res, _S("PHP_MINIT_FUNCTION("));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S(") {\n"));
	}
	strings__Builder_write_string(&res, _S("    vphp_framework_init(module_number);\n"));
	for (int _t5 = 0; _t5 < c->elements.len; ++_t5) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t5;
		strings__Builder_write_string(&res, builtin__string__plus(Array_string_join(vphp__compiler__PhpRepr_name_table[el->_typ]._method_gen_minit(el->_object), _S("\n")), _S("\n")));
	}
	strings__Builder_write_string(&res, _S("    vphp_task_auto_startup();\n"));
	strings__Builder_write_string(&res, _S("    return SUCCESS;\n}\n\n"));
	{
		strings__Builder_write_string(&res, _S("zend_module_entry "));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_module_entry = {\n"));
	}
	{
		strings__Builder_write_string(&res, _S("    STANDARD_MODULE_HEADER, \""));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("\", "));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_functions,\n"));
	}
	{
		strings__Builder_write_string(&res, _S("    PHP_MINIT("));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("), NULL, NULL, NULL, NULL, \"1.0.0\",\n"));
	}
	strings__Builder_write_string(&res, _S("    STANDARD_MODULE_PROPERTIES\n};\n\n"));
	{
		strings__Builder_write_string(&res, _S("#ifndef COMPILE_DL_"));
		strings__Builder_write_string(&res, builtin__string_to_upper(c->ext_name));
		strings__Builder_write_string(&res, _S("\n"));
	}
	{
		strings__Builder_write_string(&res, _S("#define COMPILE_DL_"));
		strings__Builder_write_string(&res, builtin__string_to_upper(c->ext_name));
		strings__Builder_write_string(&res, _S("\n\n"));
	}
	{
		strings__Builder_write_string(&res, _S("ZEND_GET_MODULE("));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S(")\n"));
	}
	strings__Builder_write_string(&res, _S("#endif\n"));
	_result_void _t6 = os__write_file(_S("php_bridge.c"), strings__Builder_str(&res));
	if (_t6.is_error) {
		_result_void _t7 = {0};
		_t7.is_error = true;
		_t7.err = _t6.err;
		return _t7;
	}
	
 ;
	return (_result_void){0};
}
VV_LOC _result_void vphp__compiler__Compiler_generate_v_glue(vphp__compiler__Compiler* c) {
	Array_string v = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__array_push((array*)&v, _MOV((string[]){ _S("module main\nimport vphp\n") }));
	builtin__array_push((array*)&v, _MOV((string[]){ _S("@[export: \"vphp_task_auto_startup\"]\nfn vphp_task_auto_startup() {") }));
	for (int _t3 = 0; _t3 < c->elements.len; ++_t3) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t3;
		if ((el)->_typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpTaskRepr_index) {
			vphp__compiler__PhpTaskRepr* t = (el->_vphp__compiler__PhpTaskRepr);
			builtin__array_push((array*)&v, _MOV((string[]){ vphp__compiler__PhpTaskRepr_gen_v_glue(*t) }));
		}
	}
	builtin__array_push((array*)&v, _MOV((string[]){ _S("}") }));
	for (int _t6 = 0; _t6 < c->elements.len; ++_t6) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t6;
		if ((el)->_typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) {
			vphp__compiler__PhpClassRepr* p = (el->_vphp__compiler__PhpClassRepr);
			builtin__array_push((array*)&v, _MOV((string[]){ vphp__compiler__PhpClassRepr_gen_v_property_mapper(*p) }));
		}
	}
	for (int _t8 = 0; _t8 < c->elements.len; ++_t8) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t8;
		if ((el)->_typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) {
			vphp__compiler__PhpClassRepr* s = (el->_vphp__compiler__PhpClassRepr);
			builtin__array_push((array*)&v, _MOV((string[]){ vphp__compiler__PhpClassRepr_gen_v_sync_mapper(*s) }));
		}
	}
	_result_void _t10 = os__write_file(_S("_task_glue.v"), Array_string_join(v, _S("\n")));
	if (_t10.is_error) {
		_result_void _t11 = {0};
		_t11.is_error = true;
		_t11.err = _t10.err;
		return _t11;
	}
	
 ;
	return (_result_void){0};
}
VV_LOC _result_void vphp__compiler__Compiler_generate_h(vphp__compiler__Compiler* c) {
	strings__Builder res = strings__new_builder(1024);
	strings__Builder_write_string(&res, _S("/* \342\232\240\357\270\217 VPHP Compiler Generated\357\274\214\350\257\267\345\213\277\346\211\213\345\212\250\344\277\256\346\224\271 */\n"));
	strings__Builder_write_string(&res, _S("#ifndef VPHP_BRIDGE_H\n"));
	strings__Builder_write_string(&res, _S("#define VPHP_BRIDGE_H\n\n"));
	strings__Builder_write_string(&res, _S("#include <php.h>\n\n"));
	{
		strings__Builder_write_string(&res, _S("extern zend_module_entry "));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_module_entry;\n"));
	}
	{
		strings__Builder_write_string(&res, _S("#define phpext_"));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_ptr &"));
		strings__Builder_write_string(&res, c->ext_name);
		strings__Builder_write_string(&res, _S("_module_entry\n\n"));
	}
	for (int _t1 = 0; _t1 < c->elements.len; ++_t1) {
		vphp__compiler__PhpRepr* el = ((vphp__compiler__PhpRepr*)c->elements.data) + _t1;
		Array_string lines = vphp__compiler__PhpRepr_name_table[el->_typ]._method_gen_h(el->_object);
		if (lines.len > 0) {
			strings__Builder_write_string(&res, builtin__string__plus(Array_string_join(lines, _S("\n")), _S("\n")));
		}
	}
	strings__Builder_write_string(&res, _S("\n/* Framework Internal Functions */\n"));
	strings__Builder_write_string(&res, _S("PHP_FUNCTION(v_spawn);\n"));
	strings__Builder_write_string(&res, _S("PHP_FUNCTION(v_wait);\n\n"));
	strings__Builder_write_string(&res, _S("#endif\n"));
	_result_void _t2 = os__write_file(_S("php_bridge.h"), strings__Builder_str(&res));
	if (_t2.is_error) {
		IError err = _t2.err;
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\346\227\240\346\263\225\345\206\231\345\205\245 php_bridge.h: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	
 ;
	builtin__println(_S("  - [Generator] \345\267\262\347\224\237\346\210\220 php_bridge.h"));
	return (_result_void){0};
}
VV_LOC vphp__compiler__PhpClassRepr* vphp__compiler__new_class_repr(void) {
	return ((vphp__compiler__PhpClassRepr*)builtin__memdup(&(vphp__compiler__PhpClassRepr){.name = (string){.str=(byteptr)"", .is_lit=1},.parent = (string){.str=(byteptr)"", .is_lit=1},.is_final = 0,.constants = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpClassConst)),.properties = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpClassProp)),.methods = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpMethodRepr)),}, sizeof(vphp__compiler__PhpClassRepr)));
}
VV_LOC bool vphp__compiler__PhpClassRepr_parse(vphp__compiler__PhpClassRepr* r, v__ast__Stmt stmt, v__ast__Table* table) {
	if ((stmt)._typ == 228 /* v.ast.StructDecl */) {
		bool _t1 = false;
		Array_v__ast__Attr _t1_orig = (*stmt._v__ast__StructDecl).attrs;
		int _t1_len = _t1_orig.len;
		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			v__ast__Attr it = ((v__ast__Attr*) _t1_orig.data)[_t2];
			if (builtin__fast_string_eq(it.name, _S("php_class"))) {
				_t1 = true;
				break;
			}
		}
		if (_t1) {
			r->name = builtin__string_all_after((*stmt._v__ast__StructDecl).name, _S("."));
			_option_v__ast__Attr _t3;
			if (_t3 = Array_v__ast__Attr_find_first((*stmt._v__ast__StructDecl).attrs, _S("php_parent")), _t3.state == 0) {
				v__ast__Attr attr = *(v__ast__Attr*)_t3.data;
				r->parent = attr.arg;
			}
			for (int _t4 = 0; _t4 < (*stmt._v__ast__StructDecl).fields.len; ++_t4) {
				v__ast__StructField field = ((v__ast__StructField*)(*stmt._v__ast__StructDecl).fields.data)[_t4];
				string type_name = v__ast__Table_get_type_name(table, field.typ);
				bool _t6 = false;
				Array_v__ast__Attr _t6_orig = field.attrs;
				int _t6_len = _t6_orig.len;
				for (int _t7 = 0; _t7 < _t6_len; ++_t7) {
					v__ast__Attr it = ((v__ast__Attr*) _t6_orig.data)[_t7];
					if (builtin__fast_string_eq(it.name, _S("static"))) {
						_t6 = true;
						break;
					}
				}
				builtin__array_push((array*)&r->properties, _MOV((vphp__compiler__PhpClassProp[]){ ((vphp__compiler__PhpClassProp){.name = field.name,.v_type = type_name,.visibility = (field.is_pub ? (_S("public")) : (_S("protected"))),.is_static =_t6,}) }));
			}
			return true;
		}
	}
	return false;
}
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_h(vphp__compiler__PhpClassRepr r) {
	return builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__str_intp(2, _MOV((StrIntpData[]){{_S("extern zend_class_entry *"), 0xfe10, {.d_s = builtin__string_to_lower(r.name)}}, {_S("_ce;"), 0, { .d_c = 0 }}}))}));
}
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_c(vphp__compiler__PhpClassRepr r) {
	Array_string c = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string lower_name = builtin__string_to_lower(r.name);
	builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("zend_class_entry *"), 0xfe10, {.d_s = lower_name}}, {_S("_ce = NULL;"), 0, { .d_c = 0 }}})) }));
	for (int _t2 = 0; _t2 < r.methods.len; ++_t2) {
		vphp__compiler__PhpMethodRepr m = ((vphp__compiler__PhpMethodRepr*)r.methods.data)[_t2];
		builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("ZEND_BEGIN_ARG_INFO_EX(arginfo_"), 0xfe10, {.d_s = lower_name}}, {_S("_"), 0xfe10, {.d_s = m.name}}, {_S(", 0, 0, 0)"), 0, { .d_c = 0 }}})) }));
		builtin__array_push((array*)&c, _MOV((string[]){ _S("ZEND_END_ARG_INFO()") }));
	}
	for (int _t5 = 0; _t5 < r.methods.len; ++_t5) {
		vphp__compiler__PhpMethodRepr m = ((vphp__compiler__PhpMethodRepr*)r.methods.data)[_t5];
		string v_c_func = builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = r.name}}, {_S("_"), 0xfe10, {.d_s = m.name}}, {_SLIT0, 0, { .d_c = 0 }}}));
		string lower_class = builtin__string_to_lower(r.name);
		builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("    PHP_METHOD("), 0xfe10, {.d_s = r.name}}, {_S(", "), 0xfe10, {.d_s = m.name}}, {_S(") {"), 0, { .d_c = 0 }}})) }));
		builtin__array_push((array*)&c, _MOV((string[]){ _S("        typedef struct { void* ex; void* ret; } vphp_context_internal;") }));
		builtin__array_push((array*)&c, _MOV((string[]){ _S("        vphp_context_internal ctx = { .ex = (void*)execute_data, .ret = (void*)return_value };") }));
		if (m.is_static) {
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        extern void* "), 0xfe10, {.d_s = v_c_func}}, {_S("(vphp_context_internal ctx);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        void* v_instance = "), 0xfe10, {.d_s = v_c_func}}, {_S("(ctx);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        if (!v_instance) RETURN_NULL();") }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        object_init_ex(return_value, "), 0xfe10, {.d_s = lower_class}}, {_S("_ce);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        vphp_object_wrapper *wrapper = vphp_obj_from_obj(Z_OBJ_P(return_value));") }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        wrapper->v_ptr = v_instance;") }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        extern void "), 0xfe10, {.d_s = r.name}}, {_S("_get_prop(void*, const char*, zval*);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        wrapper->prop_handler = "), 0xfe10, {.d_s = r.name}}, {_S("_get_prop;"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("            extern void "), 0xfe10, {.d_s = r.name}}, {_S("_sync_props(void*, zval*);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("            wrapper->sync_handler = "), 0xfe10, {.d_s = r.name}}, {_S("_sync_props;"), 0, { .d_c = 0 }}})) }));
		} else {
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        extern bool "), 0xfe10, {.d_s = v_c_func}}, {_S("(void* v_ptr, vphp_context_internal ctx);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        vphp_object_wrapper *wrapper = vphp_obj_from_obj(Z_OBJ_P(getThis()));") }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        if (!wrapper->v_ptr) RETURN_FALSE;") }));
			builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        bool res = "), 0xfe10, {.d_s = v_c_func}}, {_S("(wrapper->v_ptr, ctx);"), 0, { .d_c = 0 }}})) }));
			builtin__array_push((array*)&c, _MOV((string[]){ _S("        RETURN_BOOL(res);") }));
		}
		builtin__array_push((array*)&c, _MOV((string[]){ _S("    }") }));
	}
	builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("static const zend_function_entry "), 0xfe10, {.d_s = lower_name}}, {_S("_methods[] = {"), 0, { .d_c = 0 }}})) }));
	for (int _t26 = 0; _t26 < r.methods.len; ++_t26) {
		vphp__compiler__PhpMethodRepr m = ((vphp__compiler__PhpMethodRepr*)r.methods.data)[_t26];
		string flags = (m.is_static ? (_S("ZEND_ACC_PUBLIC | ZEND_ACC_STATIC")) : (_S("ZEND_ACC_PUBLIC")));
		builtin__array_push((array*)&c, _MOV((string[]){ builtin__str_intp(6, _MOV((StrIntpData[]){{_S("    PHP_ME("), 0xfe10, {.d_s = r.name}}, {_S(", "), 0xfe10, {.d_s = m.name}}, {_S(", arginfo_"), 0xfe10, {.d_s = lower_name}}, {_S("_"), 0xfe10, {.d_s = m.name}}, {_S(", "), 0xfe10, {.d_s = flags}}, {_S(")"), 0, { .d_c = 0 }}})) }));
	}
	builtin__array_push((array*)&c, _MOV((string[]){ _S("    PHP_FE_END") }));
	builtin__array_push((array*)&c, _MOV((string[]){ _S("};") }));
	return c;
}
VV_LOC Array_string vphp__compiler__PhpClassRepr_gen_minit(vphp__compiler__PhpClassRepr r) {
	Array_string m = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string lower_name = builtin__string_to_lower(r.name);
	string ce_ptr = builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = lower_name}}, {_S("_ce"), 0, { .d_c = 0 }}}));
	builtin__array_push((array*)&m, _MOV((string[]){ _S("    {   zend_class_entry ce;") }));
	builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(3, _MOV((StrIntpData[]){{_S("        INIT_CLASS_ENTRY(ce, \""), 0xfe10, {.d_s = r.name}}, {_S("\", "), 0xfe10, {.d_s = lower_name}}, {_S("_methods);"), 0, { .d_c = 0 }}})) }));
	if ((r.parent).len != 0) {
		builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(4, _MOV((StrIntpData[]){{_S("        "), 0xfe10, {.d_s = lower_name}}, {_S("_ce = zend_register_internal_class_ex(&ce, zend_hash_str_find_ptr(CG(class_table), \""), 0xfe10, {.d_s = r.parent}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = r.parent}}, {_S("\")-1));"), 0, { .d_c = 0 }}})) }));
	} else {
		builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        "), 0xfe10, {.d_s = lower_name}}, {_S("_ce = zend_register_internal_class(&ce);"), 0, { .d_c = 0 }}})) }));
	}
	builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        "), 0xfe10, {.d_s = ce_ptr}}, {_S("->create_object = vphp_create_object_handler;"), 0, { .d_c = 0 }}})) }));
	for (int _t6 = 0; _t6 < r.constants.len; ++_t6) {
		vphp__compiler__PhpClassConst con = ((vphp__compiler__PhpClassConst*)r.constants.data)[_t6];
		builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_class_constant_string("), 0xfe10, {.d_s = lower_name}}, {_S("_ce, \""), 0xfe10, {.d_s = con.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = con.name}}, {_S("\")-1, \""), 0xfe10, {.d_s = con.value}}, {_S("\");"), 0, { .d_c = 0 }}})) }));
	}
	for (int _t8 = 0; _t8 < r.properties.len; ++_t8) {
		vphp__compiler__PhpClassProp prop = ((vphp__compiler__PhpClassProp*)r.properties.data)[_t8];
		string flags = (prop.is_static ? (_S("ZEND_ACC_PUBLIC | ZEND_ACC_STATIC")) : (_S("ZEND_ACC_PUBLIC")));

		if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "int") || _SLIT_EQ(prop.v_type.str, prop.v_type.len, "i64") || _SLIT_EQ(prop.v_type.str, prop.v_type.len, "isize")) {
			builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_property_long("), 0xfe10, {.d_s = ce_ptr}}, {_S(", \""), 0xfe10, {.d_s = prop.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = prop.name}}, {_S("\")-1, 0, "), 0xfe10, {.d_s = flags}}, {_S(");"), 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "f64") || _SLIT_EQ(prop.v_type.str, prop.v_type.len, "f32")) {
			builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_property_double("), 0xfe10, {.d_s = ce_ptr}}, {_S(", \""), 0xfe10, {.d_s = prop.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = prop.name}}, {_S("\")-1, 0.0, "), 0xfe10, {.d_s = flags}}, {_S(");"), 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "bool")) {
			builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_property_bool("), 0xfe10, {.d_s = ce_ptr}}, {_S(", \""), 0xfe10, {.d_s = prop.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = prop.name}}, {_S("\")-1, 0, "), 0xfe10, {.d_s = flags}}, {_S(");"), 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "string")) {
			builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_property_string("), 0xfe10, {.d_s = ce_ptr}}, {_S(", \""), 0xfe10, {.d_s = prop.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = prop.name}}, {_S("\")-1, \"\", "), 0xfe10, {.d_s = flags}}, {_S(");"), 0, { .d_c = 0 }}})) }));
		}
		else {
			builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(5, _MOV((StrIntpData[]){{_S("        zend_declare_property_null("), 0xfe10, {.d_s = ce_ptr}}, {_S(", \""), 0xfe10, {.d_s = prop.name}}, {_S("\", sizeof(\""), 0xfe10, {.d_s = prop.name}}, {_S("\")-1, "), 0xfe10, {.d_s = flags}}, {_S(");"), 0, { .d_c = 0 }}})) }));
		}
	}
	builtin__array_push((array*)&m, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        "), 0xfe10, {.d_s = ce_ptr}}, {_S("->create_object = vphp_create_object_handler;"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&m, _MOV((string[]){ _S("    }") }));
	return m;
}
void vphp__compiler__PhpClassRepr_add_method(vphp__compiler__PhpClassRepr* r, v__ast__FnDecl stmt, v__ast__Table* table) {
	bool _t1 = false;
	Array_v__ast__Attr _t1_orig = stmt.attrs;
	int _t1_len = _t1_orig.len;
	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__Attr it = ((v__ast__Attr*) _t1_orig.data)[_t2];
		if (builtin__fast_string_eq(it.name, _S("php_method"))) {
			_t1 = true;
			break;
		}
	}
	if (!_t1) {
		return;
	}
	builtin__array_push((array*)&r->methods, _MOV((vphp__compiler__PhpMethodRepr[]){ ((vphp__compiler__PhpMethodRepr){.name = stmt.name,.v_c_func = (string){.str=(byteptr)"", .is_lit=1},.is_static = false,.return_type = (string){.str=(byteptr)"", .is_lit=1},.args = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpArg)),.visibility = (stmt.is_pub ? (_S("public")) : (_S("protected"))),}) }));
}
void vphp__compiler__PhpClassRepr_add_static_method(vphp__compiler__PhpClassRepr* r, v__ast__FnDecl stmt, v__ast__Table* table, string method_name) {
	bool _t1 = false;
	Array_v__ast__Attr _t1_orig = stmt.attrs;
	int _t1_len = _t1_orig.len;
	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		v__ast__Attr it = ((v__ast__Attr*) _t1_orig.data)[_t2];
		if (builtin__fast_string_eq(it.name, _S("php_method"))) {
			_t1 = true;
			break;
		}
	}
	if (!_t1) {
		return;
	}
	builtin__array_push((array*)&r->methods, _MOV((vphp__compiler__PhpMethodRepr[]){ ((vphp__compiler__PhpMethodRepr){.name = method_name,.v_c_func = (string){.str=(byteptr)"", .is_lit=1},.is_static = true,.return_type = (string){.str=(byteptr)"", .is_lit=1},.args = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpArg)),.visibility = _S("public"),}) }));
}
string vphp__compiler__PhpClassRepr_gen_v_property_mapper(vphp__compiler__PhpClassRepr r) {
	Array_string out = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string lower_name = builtin__string_to_lower(r.name);
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("@[export: '"), 0xfe10, {.d_s = r.name}}, {_S("_get_prop']"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("pub fn "), 0xfe10, {.d_s = lower_name}}, {_S("_get_prop(ptr voidptr, name_ptr &char, name_len int, rv &C.zval) {"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("    unsafe {") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        // 1. \345\256\211\345\205\250\346\236\204\351\200\240 V \345\255\227\347\254\246\344\270\262\357\274\214\350\247\243\345\206\263 C \344\274\240\345\217\202\345\257\274\350\207\264\347\232\204\345\206\205\345\255\230\351\224\231\344\275\215") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        name := name_ptr.vstring_with_len(name_len)") }));
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        mut a := &"), 0xfe10, {.d_s = r.name}}, {_S("(ptr)"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        ") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        match name {") }));
	for (int _t9 = 0; _t9 < r.properties.len; ++_t9) {
		vphp__compiler__PhpClassProp prop = ((vphp__compiler__PhpClassProp*)r.properties.data)[_t9];
		builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("            '"), 0xfe10, {.d_s = prop.name}}, {_S("' { "), 0, { .d_c = 0 }}})) }));

		if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "string")) {
			builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("                vphp.return_val_raw(rv, a."), 0xfe10, {.d_s = prop.name}}, {_S(")"), 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "int") || _SLIT_EQ(prop.v_type.str, prop.v_type.len, "i64") || _SLIT_EQ(prop.v_type.str, prop.v_type.len, "isize")) {
			builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("                vphp.return_val_raw(rv, i64(a."), 0xfe10, {.d_s = prop.name}}, {_S("))"), 0, { .d_c = 0 }}})) }));
		}
		else if (_SLIT_EQ(prop.v_type.str, prop.v_type.len, "bool")) {
			builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("                vphp.return_val_raw(rv, a."), 0xfe10, {.d_s = prop.name}}, {_S(")"), 0, { .d_c = 0 }}})) }));
		}
		else {
			builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("                // \346\232\202\344\270\215\346\224\257\346\214\201\350\207\252\345\212\250\346\230\240\345\260\204 "), 0xfe10, {.d_s = prop.v_type}}, {_SLIT0, 0, { .d_c = 0 }}})) }));
		}
		builtin__array_push((array*)&out, _MOV((string[]){ _S("            }") }));
	}
	builtin__array_push((array*)&out, _MOV((string[]){ _S("            else { /* \344\277\235\346\214\201 rv \344\270\272 IS_UNDEF\357\274\214\350\247\246\345\217\221 C \344\276\247\345\233\236\351\200\200\345\210\260 PHP \351\273\230\350\256\244\345\261\236\346\200\247\346\247\275 */ }") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        }") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("    }") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("}") }));
	return Array_string_join(out, _S("\n"));
}
string vphp__compiler__PhpClassRepr_gen_v_sync_mapper(vphp__compiler__PhpClassRepr r) {
	Array_string out = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	string lower_name = builtin__string_to_lower(r.name);
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("@[export: '"), 0xfe10, {.d_s = r.name}}, {_S("_sync_props']"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("pub fn "), 0xfe10, {.d_s = lower_name}}, {_S("_sync_props(ptr voidptr, zv &C.zval) {"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("    unsafe {") }));
	builtin__array_push((array*)&out, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("        mut a := &"), 0xfe10, {.d_s = r.name}}, {_S("(ptr)"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        // \345\214\205\350\243\205\344\270\200\344\270\252\344\270\264\346\227\266\347\232\204 context\357\274\214\345\210\251\347\224\250\347\216\260\346\234\211\347\232\204\345\217\215\345\260\204\345\220\214\346\255\245\351\200\273\350\276\221") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        ctx := vphp.Context{ ex: 0, ret: zv }") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("        ctx.sync_props(a)") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("    }") }));
	builtin__array_push((array*)&out, _MOV((string[]){ _S("}") }));
	return Array_string_join(out, _S("\n"));
}
VV_LOC vphp__compiler__PhpConstRepr* vphp__compiler__new_const_repr(void) {
	return ((vphp__compiler__PhpConstRepr*)builtin__memdup(&(vphp__compiler__PhpConstRepr){.name = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(vphp__compiler__PhpConstRepr)));
}
VV_LOC bool vphp__compiler__PhpConstRepr_parse(vphp__compiler__PhpConstRepr* r, v__ast__Stmt stmt, v__ast__Table* table) {
	if ((stmt)._typ == 231 /* v.ast.ConstDecl */) {
		for (int _t1 = 0; _t1 < (*stmt._v__ast__ConstDecl).fields.len; ++_t1) {
			v__ast__ConstField field = ((v__ast__ConstField*)(*stmt._v__ast__ConstDecl).fields.data)[_t1];
			if (builtin__string_starts_with(field.name, _S("PHP_"))) {
				r->name = builtin__string_all_after(field.name, _S("PHP_"));
				r->value = v__ast__Expr_str(field.expr);
				return true;
			}
		}
	}
	return false;
}
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_h(vphp__compiler__PhpConstRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_c(vphp__compiler__PhpConstRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
VV_LOC Array_string vphp__compiler__PhpConstRepr_gen_minit(vphp__compiler__PhpConstRepr r) {
	return builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__str_intp(3, _MOV((StrIntpData[]){{_S("    REGISTER_LONG_CONSTANT(\""), 0xfe10, {.d_s = r.name}}, {_S("\", "), 0xfe10, {.d_s = r.value}}, {_S(", CONST_CS | CONST_PERSISTENT);"), 0, { .d_c = 0 }}}))}));
}
vphp__compiler__PhpFuncRepr* vphp__compiler__new_func_repr(void) {
	return ((vphp__compiler__PhpFuncRepr*)builtin__memdup(&(vphp__compiler__PhpFuncRepr){.name = (string){.str=(byteptr)"", .is_lit=1},.is_internal = 0,}, sizeof(vphp__compiler__PhpFuncRepr)));
}
VV_LOC bool vphp__compiler__PhpFuncRepr_parse(vphp__compiler__PhpFuncRepr* r, v__ast__Stmt stmt, v__ast__Table* table) {
	if ((stmt)._typ == 229 /* v.ast.FnDecl */) {
		if ((*stmt._v__ast__FnDecl).is_method) {
			return false;
		}
		for (int _t2 = 0; _t2 < (*stmt._v__ast__FnDecl).attrs.len; ++_t2) {
			v__ast__Attr attr = ((v__ast__Attr*)(*stmt._v__ast__FnDecl).attrs.data)[_t2];
			if (builtin__fast_string_eq(attr.name, _S("export")) && (attr.arg).len != 0) {
				string exp_name = attr.arg;
				if (builtin__string_starts_with(exp_name, _S("vphp_")) || builtin__string_starts_with(exp_name, _S("zm_"))) {
					return false;
				}
				r->name = exp_name;
				return true;
			}
		}
	}
	return false;
}
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_h(vphp__compiler__PhpFuncRepr r) {
	return builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){builtin__str_intp(2, _MOV((StrIntpData[]){{_S("PHP_FUNCTION("), 0xfe10, {.d_s = r.name}}, {_S(");"), 0, { .d_c = 0 }}}))}));
}
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_c(vphp__compiler__PhpFuncRepr f) {
	Array_string r = builtin____new_array_with_default(0, 0, sizeof(string), 0);
	builtin__array_push((array*)&r, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("ZEND_BEGIN_ARG_INFO_EX(arginfo_"), 0xfe10, {.d_s = f.name}}, {_S(", 0, 0, 0)"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&r, _MOV((string[]){ _S("ZEND_END_ARG_INFO()") }));
	builtin__array_push((array*)&r, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("extern void "), 0xfe10, {.d_s = f.name}}, {_S("(zend_execute_data *execute_data, zval *return_value);"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&r, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("PHP_FUNCTION("), 0xfe10, {.d_s = f.name}}, {_S(") {"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&r, _MOV((string[]){ builtin__str_intp(2, _MOV((StrIntpData[]){{_S("    "), 0xfe10, {.d_s = f.name}}, {_S("(execute_data, return_value);"), 0, { .d_c = 0 }}})) }));
	builtin__array_push((array*)&r, _MOV((string[]){ _S("}") }));
	return r;
}
VV_LOC Array_string vphp__compiler__PhpFuncRepr_gen_minit(vphp__compiler__PhpFuncRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
vphp__compiler__Compiler vphp__compiler__new(string target_file) {
	return ((vphp__compiler__Compiler){.target_file = target_file,.ext_name = _S(""),.elements = builtin____new_array(0, 0, sizeof(vphp__compiler__PhpRepr)),.table = v__ast__new_table(),.pref_set = v__pref__new_preferences(),.class_index = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),});
}
_result_void vphp__compiler__Compiler_compile(vphp__compiler__Compiler* c) {
	v__ast__File* file_ast = v__parser__parse_file(c->target_file, c->table, v__scanner__CommentsMode__parse_comments, c->pref_set);
	if (file_ast->errors.len > 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("AST \350\247\243\346\236\220\345\244\261\350\264\245: "), 0xfe10, {.d_s = (*(v__errors__Error*)builtin__array_get(file_ast->errors, 0)).CompilerMessage.message}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	vphp__compiler__Compiler_set_ext_name(c, file_ast);
	if ((c->ext_name).len == 0) {
		return (_result_void){ .is_error=true, .err=builtin___v_error(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\346\227\240\346\263\225\345\234\250 "), 0xfe10, {.d_s = c->target_file}}, {_S(" \344\270\255\346\211\276\345\210\260 ext_config \351\205\215\347\275\256\357\274\214\350\257\267\347\241\256\344\277\235\345\256\232\344\271\211\344\272\206 ExtensionConfig"), 0, { .d_c = 0 }}}))), .data={E_STRUCT} };
	}
	builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("  - [Compiler] \350\257\206\345\210\253\345\210\260\346\211\251\345\261\225\345\220\215: "), 0xfe10, {.d_s = c->ext_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
	for (int _t3 = 0; _t3 < file_ast->stmts.len; ++_t3) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file_ast->stmts.data)[_t3];
		if ((stmt)._typ == 228 /* v.ast.StructDecl */) {
			vphp__compiler__PhpClassRepr* cls = vphp__compiler__new_class_repr();
			if (vphp__compiler__PhpClassRepr_parse(cls, stmt, c->table)) {
				builtin__map_set(&c->class_index, &(string[]){cls->name}, &(int[]) { c->elements.len });
				builtin__array_push((array*)&c->elements, _MOV((vphp__compiler__PhpRepr[]){ I_vphp__compiler__PhpClassRepr_to_Interface_vphp__compiler__PhpRepr(cls) }));
			}
		}
	}
	for (int _t5 = 0; _t5 < file_ast->stmts.len; ++_t5) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file_ast->stmts.data)[_t5];
		if ((stmt)._typ == 229 /* v.ast.FnDecl */) {
			if ((*stmt._v__ast__FnDecl).is_method) {
				string receiver_type = builtin__string_all_after(v__ast__Table_get_type_name(c->table, (*stmt._v__ast__FnDecl).receiver.typ), _S("."));
				if (_IN_MAP(ADDR(string, receiver_type), ADDR(map, c->class_index))) {
					int idx = (*(int*)builtin__map_get(ADDR(map, c->class_index), &(string[]){receiver_type}, &(int[]){ 0 }));
					vphp__compiler__PhpRepr el = (*(vphp__compiler__PhpRepr*)builtin__array_get(c->elements, idx));
					if ((el)._typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) {
						vphp__compiler__PhpClassRepr_add_method((el._vphp__compiler__PhpClassRepr), (*stmt._v__ast__FnDecl), c->table);
					}
					continue;
				}
			}
			if (builtin__string_contains((*stmt._v__ast__FnDecl).name, _S("__static__"))) {
				Array_string parts = builtin__string_split((*stmt._v__ast__FnDecl).name, _S("__static__"));
				if (parts.len == 2) {
					string raw_class = (*(string*)builtin__array_get(parts, 0));
					string class_name = (builtin__string_contains(raw_class, _S(".")) ? (builtin__string_all_after(raw_class, _S("."))) : (raw_class));
					string method_name = (*(string*)builtin__array_get(parts, 1));
					if (_IN_MAP(ADDR(string, class_name), ADDR(map, c->class_index))) {
						int idx = (*(int*)builtin__map_get(ADDR(map, c->class_index), &(string[]){class_name}, &(int[]){ 0 }));
						vphp__compiler__PhpRepr el = (*(vphp__compiler__PhpRepr*)builtin__array_get(c->elements, idx));
						if ((el)._typ == _vphp__compiler__PhpRepr_vphp__compiler__PhpClassRepr_index) {
							vphp__compiler__PhpClassRepr_add_static_method((el._vphp__compiler__PhpClassRepr), (*stmt._v__ast__FnDecl), c->table, method_name);
						}
						continue;
					}
				}
			}
			vphp__compiler__PhpFuncRepr* func = vphp__compiler__new_func_repr();
			if (vphp__compiler__PhpFuncRepr_parse(func, stmt, c->table)) {
				builtin__array_push((array*)&c->elements, _MOV((vphp__compiler__PhpRepr[]){ I_vphp__compiler__PhpFuncRepr_to_Interface_vphp__compiler__PhpRepr(func) }));
				continue;
			}
		}
		vphp__compiler__PhpConstRepr* con = vphp__compiler__new_const_repr();
		if (vphp__compiler__PhpConstRepr_parse(con, stmt, c->table)) {
			builtin__array_push((array*)&c->elements, _MOV((vphp__compiler__PhpRepr[]){ I_vphp__compiler__PhpConstRepr_to_Interface_vphp__compiler__PhpRepr(con) }));
			continue;
		}
		vphp__compiler__PhpTaskRepr* task = vphp__compiler__new_task_repr();
		if (vphp__compiler__PhpTaskRepr_parse(task, stmt, c->table)) {
			builtin__array_push((array*)&c->elements, _MOV((vphp__compiler__PhpRepr[]){ I_vphp__compiler__PhpTaskRepr_to_Interface_vphp__compiler__PhpRepr(task) }));
			continue;
		}
	}
	return (_result_void){0};
}
VV_LOC void vphp__compiler__Compiler_set_ext_name(vphp__compiler__Compiler* c, v__ast__File* file_ast) {
	for (int _t1 = 0; _t1 < file_ast->stmts.len; ++_t1) {
		v__ast__Stmt stmt = ((v__ast__Stmt*)file_ast->stmts.data)[_t1];
		if ((stmt)._typ == 231 /* v.ast.ConstDecl */) {
			for (int _t2 = 0; _t2 < (*stmt._v__ast__ConstDecl).fields.len; ++_t2) {
				v__ast__ConstField field = ((v__ast__ConstField*)(*stmt._v__ast__ConstDecl).fields.data)[_t2];
				if (builtin__string_ends_with(field.name, _S("ext_config")) && (field.expr)._typ == 236 /* v.ast.StructInit */) {
					v__ast__StructInit expr = (*field.expr._v__ast__StructInit);
					for (int _t3 = 0; _t3 < expr.init_fields.len; ++_t3) {
						v__ast__StructInitField f = ((v__ast__StructInitField*)expr.init_fields.data)[_t3];
						if (builtin__fast_string_eq(f.name, _S("name")) && (f.expr)._typ == 237 /* v.ast.StringLiteral */) {
							c->ext_name = ((*f.expr._v__ast__StringLiteral)).val;
							return;
						}
					}
				}
			}
		}
	}
}
vphp__compiler__PhpTaskRepr* vphp__compiler__new_task_repr(void) {
	return ((vphp__compiler__PhpTaskRepr*)builtin__memdup(&(vphp__compiler__PhpTaskRepr){.task_name = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(vphp__compiler__PhpTaskRepr)));
}
VV_LOC bool vphp__compiler__PhpTaskRepr_parse(vphp__compiler__PhpTaskRepr* r, v__ast__Stmt stmt, v__ast__Table* table) {
	if ((stmt)._typ == 229 /* v.ast.FnDecl */) {
		if ((*stmt._v__ast__FnDecl).is_method && builtin__fast_string_eq((*stmt._v__ast__FnDecl).name, _S("run"))) {
			string raw_name = v__ast__Table_get_type_name(table, (*stmt._v__ast__FnDecl).receiver.typ);
			r->task_name = builtin__string_all_after(raw_name, _S("."));
			return true;
		}
	}
	return false;
}
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_h(vphp__compiler__PhpTaskRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_c(vphp__compiler__PhpTaskRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
VV_LOC Array_string vphp__compiler__PhpTaskRepr_gen_minit(vphp__compiler__PhpTaskRepr r) {
	return builtin____new_array_with_default(0, 0, sizeof(string), 0);
}
string vphp__compiler__PhpTaskRepr_gen_v_glue(vphp__compiler__PhpTaskRepr r) {
	return builtin__str_intp(3, _MOV((StrIntpData[]){{_S("    vphp.ITask.register('"), 0xfe10, {.d_s = r.task_name}}, {_S("', fn(s string) vphp.ITask { return "), 0xfe10, {.d_s = r.task_name}}, {_S("{ json_data: s } })"), 0, { .d_c = 0 }}}));
}
VV_LOC void main__vphp_task_auto_startup(void) {
	vphp__ITask__static__register(_S("AnalyzeTask"), (voidptr)	anon_fn_e0873e5963f3179a_40_string__vphp__ITask_154);
}
// export alias: vphp_task_auto_startup -> main__vphp_task_auto_startup
void vphp_task_auto_startup(void) {
	return main__vphp_task_auto_startup();
}
void main__article_get_prop(voidptr ptr, char* name_ptr, int name_len, zval* rv) {
	{ // Unsafe block
		string name = builtin__char_vstring_with_len(name_ptr, name_len);
		main__Article* a = ((main__Article*)(ptr));

		if (_SLIT_EQ(name.str, name.len, "id")) {
			vphp__return_val_raw_T_i64(rv, ((i64)(a->id)));
		}
		else if (_SLIT_EQ(name.str, name.len, "title")) {
			vphp__return_val_raw_T_string(rv, a->title);
		}
		else if (_SLIT_EQ(name.str, name.len, "is_top")) {
			vphp__return_val_raw_T_bool(rv, a->is_top);
		}
		else {
		}
	}
}
// export alias: Article_get_prop -> main__article_get_prop
void Article_get_prop(voidptr ptr, char* name_ptr, int name_len, zval* rv) {
	return main__article_get_prop(ptr, name_ptr, name_len, rv);
}
void main__article_sync_props(voidptr ptr, zval* zv) {
	{ // Unsafe block
		main__Article* a = ((main__Article*)(ptr));
		vphp__Context ctx = ((vphp__Context){.ex = 0,.ret = zv,});
		vphp__Context_sync_props_T_main__Article(ctx, a);
	}
}
// export alias: Article_sync_props -> main__article_sync_props
void Article_sync_props(voidptr ptr, zval* zv) {
	return main__article_sync_props(ptr, zv);
}
VV_LOC void main__main(void) {
	string target_file = _S("v_logic.v");
	builtin__println(_S("\360\237\233\240\357\270\217  1. \345\220\257\345\212\250 VPHP Compiler \346\265\201\347\250\213..."));
	vphp__compiler__Compiler vphp_c = vphp__compiler__new(target_file);
	_result_void _t1 = vphp__compiler__Compiler_compile(&vphp_c);
	if (_t1.is_error) {
		IError err = _t1.err;
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\342\235\214 \347\274\226\350\257\221\351\230\266\346\256\265\345\244\261\350\264\245: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	
 ;
	_result_void _t2 = vphp__compiler__Compiler_generate_all(&vphp_c);
	if (_t2.is_error) {
		IError err = _t2.err;
		builtin__eprintln(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\342\235\214 \344\273\243\347\240\201\347\224\237\346\210\220\345\244\261\350\264\245: "), 0xfe10, {.d_s = builtin__IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	
 ;
	string disabled_warnings = _S("-Wno-pointer-to-int-cast -Wno-incompatible-pointer-types");
	string brew_path = _S("/opt/homebrew");
	os__setenv(_S("C_INCLUDE_PATH"), builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = brew_path}}, {_S("/include/cjson"), 0, { .d_c = 0 }}})), true);
	builtin__println(_S("\360\237\233\240\357\270\217  2. \350\275\254\350\257\221 V \351\200\273\350\276\221\344\270\272 C..."));
	os__Result v_res = os__execute(_S("v -enable-globals -gc none -path \"@vlib:.:..\" -shared -o v_logic.c ."));
	if (v_res.exit_code != 0) {
		builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("\342\235\214 V \347\274\226\350\257\221\345\244\261\350\264\245: "), 0xfe10, {.d_s = v_res.output}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	builtin__println(_S("\360\237\233\240\357\270\217  3. GCC \346\234\200\347\273\210\351\223\276\346\216\245..."));
	string php_inc = builtin__string_trim_space(os__execute(_S("php-config --includes")).output);
	string php_ldflags = builtin__string_trim_space(os__execute(_S("php-config --ldflags")).output);
	string php_libs = builtin__string_trim_space(builtin__string_replace(os__execute(_S("php-config --libs")).output, _S("-lzip"), _S("")));
	string gcc_cmd = builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__string__plus(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("gcc -shared -fPIC "), 0xfe10, {.d_s = disabled_warnings}}, {_S(" -DCOMPILE_DL_V_PHP_EXT=1 "), 0, { .d_c = 0 }}})), builtin__str_intp(3, _MOV((StrIntpData[]){{_S("-I"), 0xfe10, {.d_s = brew_path}}, {_S("/include -L"), 0xfe10, {.d_s = brew_path}}, {_S("/lib -lcjson "), 0, { .d_c = 0 }}}))), _S("-DcJSON_GetErrorPos=cJSON_GetErrorPtr ")), builtin__str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = php_inc}}, {_S(" v_logic.c php_bridge.c ../vphp/v_bridge.c -o v_php_ext.so "), 0, { .d_c = 0 }}}))), _S("-I../vphp ")), builtin__str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = php_ldflags}}, {_S(" "), 0xfe10, {.d_s = php_libs}}, {_S(" -undefined dynamic_lookup -fvisibility=default"), 0, { .d_c = 0 }}})));
	if (os__system(gcc_cmd) != 0) {
		builtin__eprintln(_S("\342\235\214 GCC \347\274\226\350\257\221\345\244\261\350\264\245"));
		return;
	}
	builtin__println(_S("\342\234\205 \346\236\204\345\273\272\346\210\220\345\212\237\357\274\201v_php_ext.so \345\267\262\345\260\261\347\273\252\343\200\202"));
}
VV_LOC void main__v_reverse_string(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	{ // Unsafe block
		zval* raw_in = vphp_get_arg_ptr(ex, 1);
		if (raw_in == 0) {
			return;
		}
		vphp__Val in_val = ((vphp__Val){.raw = raw_in,});
		if (!vphp__Val_is_string(in_val)) {
			vphp__throw_exception(_S("Expected string input"), 401);
			return;
		}
		string s = vphp__Val_to_string(in_val);
		if ((s).len == 0) {
			vphp__throw_exception(_S("String is empty!"), 400);
			return;
		}
		vphp__Val out = ((vphp__Val){.raw = retval,});
		vphp__Val_set_string(out, builtin__string_reverse(s));
	}
}
// export alias: v_reverse_string -> main__v_reverse_string
void v_reverse_string(zend_execute_data* ex, zval* retval) {
	return main__v_reverse_string(ex, retval);
}
VV_LOC void main__v_logic_main(zend_execute_data* ex, zval* retval) {
	{ // Unsafe block
		Array_vphp__Val args = vphp__get_args(ex);
		if (args.len < 1) {
			vphp__throw_exception(_S("\350\207\263\345\260\221\351\234\200\350\246\201\344\270\200\344\270\252\345\217\202\346\225\260"), 400);
			return;
		}
		string main_str = vphp__Val_to_string((*(vphp__Val*)builtin__array_get(args, 0)));
		int repeat_count = 1;
		if (args.len >= 2) {
			repeat_count = ((int)(vphp__Val_as_int((*(vphp__Val*)builtin__array_get(args, 1)))));
		}
		string res = builtin__string_reverse(builtin__string_repeat(main_str, repeat_count));
		vphp__Val out = ((vphp__Val){.raw = retval,});
		vphp__Val_set_string(out, res);
	}
}
// export alias: v_logic_main -> main__v_logic_main
void v_logic_main(zend_execute_data* ex, zval* retval) {
	return main__v_logic_main(ex, retval);
}
VV_LOC void main__v_add(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	i64 a = vphp__Context_arg_T_i64(ctx, 0);
	i64 b = vphp__Context_arg_T_i64(ctx, 1);
	vphp__return_val_T_i64(ctx, (i64)(a + b));
}
// export alias: v_add -> main__v_add
void v_add(zend_execute_data* ex, zval* retval) {
	return main__v_add(ex, retval);
}
VV_LOC void main__v_greet(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	string name = vphp__Context_arg_T_string(ctx, 0);
	vphp__return_val_T_string(ctx, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Hello, "), 0xfe10, {.d_s = name}}, {_S(" from V!"), 0, { .d_c = 0 }}})));
}
// export alias: v_greet -> main__v_greet
void v_greet(zend_execute_data* ex, zval* retval) {
	return main__v_greet(ex, retval);
}
VV_LOC void main__v_process_list(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	Array_string input_list = vphp__Context_arg_T_Array_string(ctx, 0);
	{ // Unsafe block
		vphp_array_init(retval);
		for (int i = (int)(input_list.len - 1); i >= 0; i--) {
			string val = (*(string*)builtin__array_get(input_list, i));
			vphp_array_push_string(retval, ((char*)(val.str)));
		}
	}
}
// export alias: v_process_list -> main__v_process_list
void v_process_list(zend_execute_data* ex, zval* retval) {
	return main__v_process_list(ex, retval);
}
VV_LOC void main__v_test_map(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	Map_string_string config = vphp__Context_arg_T_Map_string_string(ctx, 0);
	if (_IN_MAP(ADDR(string, _S("name")), ADDR(map, config))) {
		builtin__println(builtin__string__plus(_S("Received name: "), (*(string*)builtin__map_get(ADDR(map, config), &(string[]){_S("name")}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }))));
	}
	vphp__Context_return_string(ctx, builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Map processed, keys: "), 0xfe10, {.d_s = Array_string_str(builtin__map_keys(&config))}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
// export alias: v_test_map -> main__v_test_map
void v_test_map(zend_execute_data* ex, zval* retval) {
	return main__v_test_map(ex, retval);
}
VV_LOC void main__v_get_config(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val input = vphp__Context_arg_raw(ctx, 0);
	_result_vphp__Val _t1 = vphp__Val_get(input, _S("db_name"));
	if (_t1.is_error) {
		vphp__report_error(_const_vphp__e_warning, _S("db_name is missing, using default"));
		vphp__Context_return_string(ctx, _S("bullsoft_db"));
		return;
	}
	
 	vphp__Val db_val = (*(vphp__Val*)_t1.data);
	vphp__Context_return_string(ctx, vphp__Val_to_string(db_val));
}
// export alias: v_get_config -> main__v_get_config
void v_get_config(zend_execute_data* ex, zval* retval) {
	return main__v_get_config(ex, retval);
}
VV_LOC void main__v_get_user(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val raw_id = vphp__Context_arg_raw(ctx, 0);
	builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("DEBUG: PHP ID Type: "), 0xfe07, {.d_i32 = vphp__Val_type_id(raw_id)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	i64 user_id = vphp__Context_arg_T_i64(ctx, 0);
	Map_string_string user_data = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	builtin__map_set(&user_data, &(string[]){_S("id")}, &(string[]) { builtin__i64_str(user_id) });
	builtin__map_set(&user_data, &(string[]){_S("name")}, &(string[]) { _S("Gu Weigang") });
	builtin__map_set(&user_data, &(string[]){_S("role")}, &(string[]) { _S("Developer") });
	builtin__map_set(&user_data, &(string[]){_S("company")}, &(string[]) { _S("Bullsoft") });
	vphp__Context_return_object(ctx, user_data);
}
// export alias: v_get_user -> main__v_get_user
void v_get_user(zend_execute_data* ex, zval* retval) {
	return main__v_get_user(ex, retval);
}
VV_LOC void main__v_call_back(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val php_version = vphp__call_php(_S("phpversion"), builtin____new_array_with_default(0, 0, sizeof(vphp__Val), 0));
	vphp__Context_return_string(ctx, builtin__string__plus(_S("V knows PHP version is: "), vphp__Val_to_string(php_version)));
}
// export alias: v_call_back -> main__v_call_back
void v_call_back(zend_execute_data* ex, zval* retval) {
	return main__v_call_back(ex, retval);
}
VV_LOC void main__v_new_coach(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	{ // Unsafe block
		u8* p = builtin___v_malloc(sizeof(main__Coach));
		main__Coach* c = ((main__Coach*)(p));
		c->name = _S("Bullsoft_Master");
		vphp__Context_return_res(ctx, p, _S("coach"));
	}
}
// export alias: v_new_coach -> main__v_new_coach
void v_new_coach(zend_execute_data* ex, zval* retval) {
	return main__v_new_coach(ex, retval);
}
VV_LOC void main__v_new_db(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	{ // Unsafe block
		u8* p = builtin___v_malloc(sizeof(main__Database));
		main__Database* db = ((main__Database*)(p));
		db->connected = true;
		vphp__Context_return_res(ctx, p, _S("db"));
	}
}
// export alias: v_new_db -> main__v_new_db
void v_new_db(zend_execute_data* ex, zval* retval) {
	return main__v_new_db(ex, retval);
}
VV_LOC void main__v_check_res(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val res_val = vphp__Context_arg_raw(ctx, 0);
	{ // Unsafe block
		voidptr ptr = vphp__Val_to_res(res_val);
		if (ptr == ((void*)0)) {
			vphp__Context_return_string(ctx, _S("Invalid Resource"));
			return;
		}
		main__Coach* coach = ((main__Coach*)(ptr));
		vphp__Context_return_string(ctx, builtin__string__plus(_S("Hello, "), coach->name));
	}
}
// export alias: v_check_res -> main__v_check_res
void v_check_res(zend_execute_data* ex, zval* retval) {
	return main__v_check_res(ex, retval);
}
VV_LOC void main__v_analyze_fitness_data(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	string name = vphp__Context_arg_T_string(ctx, 0);
	Array_f64 hr_data = vphp__Context_arg_T_Array_f64(ctx, 1);
	Map_string_string config = vphp__Context_arg_T_Map_string_string(ctx, 2);
	if (vphp__Context_has_exception(ctx)) {
		return;
	}
	if (hr_data.len == 0) {
		vphp__Context_return_string(ctx, _S("Error: No heart rate data provided"));
		return;
	}
	f64 total = 0.0;
	f64 max = 0.0;
	f64 min = (*(f64*)builtin__array_get(hr_data, 0));
	for (int _t1 = 0; _t1 < hr_data.len; ++_t1) {
		f64 hr = ((f64*)hr_data.data)[_t1];
		total += hr;
		if (hr > max) {
			max = hr;
		}
		if (hr < min) {
			min = hr;
		}
	}
	f64 avg = (f64)(total / ((f64)(hr_data.len)));
	string* _t3 = (string*)(builtin__map_get_check(ADDR(map, config), &(string[]){_S("mode")}));
	_option_string _t2 = {0};
	if (_t3) {
		*((string*)&_t2.data) = *((string*)_t3);
	} else {
		_t2.state = 2; _t2.err = builtin___v_error(_S("map key does not exist"));
	}
	;
	if (_t2.state != 0) {
		*(string*) _t2.data = _S("standard");
	}
	
	string mode = (*(string*)_t2.data);
	string risk = _S("Low");
	if (max > 170) {
		risk = _S("High Risk");
	}
	main__MotionReport report = ((main__MotionReport){
		.user_name = name,
		.max_hr = max,
		.min_hr = min,
		.avg_hr = avg,
		.risk_level = risk,
		.device_mode = mode,
	});
	vphp__Context_return_struct_T_main__MotionReport(ctx, report);
}
// export alias: v_analyze_fitness_data -> main__v_analyze_fitness_data
void v_analyze_fitness_data(zend_execute_data* ex, zval* retval) {
	return main__v_analyze_fitness_data(ex, retval);
}
VV_LOC void main__v_get_alerts(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	Array_main__HeartPoint alerts = builtin____new_array_with_default(0, 0, sizeof(main__HeartPoint), 0);
	builtin__array_push((array*)&alerts, _MOV((main__HeartPoint[]){ ((main__HeartPoint){.timestamp = 1677481200,.hr = 155.0,}) }));
	builtin__array_push((array*)&alerts, _MOV((main__HeartPoint[]){ ((main__HeartPoint){.timestamp = 1677481260,.hr = 162.5,}) }));
	vphp__Context_return_list_T_main__HeartPoint(ctx, alerts);
}
// export alias: v_get_alerts -> main__v_get_alerts
void v_get_alerts(zend_execute_data* ex, zval* retval) {
	return main__v_get_alerts(ex, retval);
}
VV_LOC void main__v_complex_test(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	string s = vphp__Context_arg_T_string(ctx, 0);
	int i = vphp__Context_arg_T_int(ctx, 1);
	bool b = vphp__Context_arg_T_bool(ctx, 2);
	Array_f64 list = vphp__Context_arg_T_Array_f64(ctx, 3);
	if (vphp__Context_has_exception(ctx)) {
		return;
	}
	Map_string_string res = builtin__new_map(sizeof(string), sizeof(string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
	;
	builtin__map_set(&res, &(string[]){_S("str_val")}, &(string[]) { s });
	builtin__map_set(&res, &(string[]){_S("int_val")}, &(string[]) { builtin__int_str(i) });
	builtin__map_set(&res, &(string[]){_S("bool_val")}, &(string[]) { builtin__bool_str(b) });
	builtin__map_set(&res, &(string[]){_S("list_len")}, &(string[]) { builtin__int_str(list.len) });
	vphp__Context_return_map(ctx, res);
}
// export alias: v_complex_test -> main__v_complex_test
void v_complex_test(zend_execute_data* ex, zval* retval) {
	return main__v_complex_test(ex, retval);
}
VV_LOC void main__v_analyze_user_object(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val user_obj = vphp__Context_arg_raw(ctx, 0);
	if (!vphp__Val_is_object(user_obj)) {
		vphp__throw_exception(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Expected object, got "), 0xfe10, {.d_s = vphp__Val_type_name(user_obj)}}, {_SLIT0, 0, { .d_c = 0 }}})), 0);
		return;
	}
	string name = vphp__Val_get_prop_string(user_obj, _S("name"));
	int age = vphp__Val_get_prop_int(user_obj, _S("age"));
	if (vphp__Context_has_exception(ctx)) {
		return;
	}
	string res_msg = builtin__str_intp(3, _MOV((StrIntpData[]){{_S("V \344\276\247\346\224\266\345\210\260\345\257\271\350\261\241\346\225\260\346\215\256\357\274\232\345\247\223\345\220\215="), 0xfe10, {.d_s = name}}, {_S(", \345\271\264\351\276\204="), 0xfe07, {.d_i32 = age}}, {_SLIT0, 0, { .d_c = 0 }}}));
	vphp__Context_return_string(ctx, res_msg);
}
// export alias: v_analyze_user_object -> main__v_analyze_user_object
void v_analyze_user_object(zend_execute_data* ex, zval* retval) {
	return main__v_analyze_user_object(ex, retval);
}
VV_LOC void main__v_trigger_user_action(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val user_obj = vphp__Context_arg_raw(ctx, 0);
	if (!vphp__Val_is_object(user_obj)) {
		vphp__throw_exception(_S("\351\234\200\350\246\201 User \345\257\271\350\261\241"), 0);
		return;
	}
	vphp__Val score_val = ((vphp__Val){.raw = vphp_new_zval(),});
	vphp__Val_set_int(score_val, 100);
	vphp__Val res = vphp__Val_call(user_obj, _S("updateScore"), builtin__new_array_from_c_array(1, 1, sizeof(vphp__Val), _MOV((vphp__Val[1]){score_val})));
	if (vphp__Context_has_exception(ctx)) {
		return;
	}
	vphp__Context_return_string(ctx, builtin__string__plus(_S("Action triggered, PHP returned: "), vphp__Val_to_string(res)));
}
// export alias: v_trigger_user_action -> main__v_trigger_user_action
void v_trigger_user_action(zend_execute_data* ex, zval* retval) {
	return main__v_trigger_user_action(ex, retval);
}
VV_LOC void main__v_call_php_closure(zend_execute_data* ex, zval* retval) {
	vphp__Context ctx = vphp__new_context(ex, retval);
	vphp__Val cb = vphp__Context_arg_raw(ctx, 0);
	vphp__Val msg = ((vphp__Val){.raw = vphp_new_zval(),});
	vphp__Val_set_string(msg, _S("Message from V Engine"));
	vphp__Val res = vphp__Val_invoke(cb, builtin__new_array_from_c_array(1, 1, sizeof(vphp__Val), _MOV((vphp__Val[1]){msg})));
	if (vphp__Context_has_exception(ctx)) {
		return;
	}
	vphp__Context_return_string(ctx, builtin__string__plus(_S("Closure executed, PHP said: "), vphp__Val_to_string(res)));
}
// export alias: v_call_php_closure -> main__v_call_php_closure
void v_call_php_closure(zend_execute_data* ex, zval* retval) {
	return main__v_call_php_closure(ex, retval);
}
VV_LOC Array_f64 main__AnalyzeTask_run(main__AnalyzeTask t) {
	// json.decode
	cJSON* _t2 = json__json_parse(t.json_data);
	_result_main__StockParams _t3 = json__decode_main__StockParams(_t2);
	cJSON_Delete(_t2); // del
	_result_main__StockParams _t1 = (_t3);
	if (_t1.is_error) {
		return builtin____new_array_with_default(0, 0, sizeof(f64), 0);
	}
	
 	main__StockParams params = (*(main__StockParams*)_t1.data);
	builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("V: \346\255\243\345\234\250\345\244\204\347\220\206 "), 0xfe10, {.d_s = params.symbol}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return builtin__new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){1.0, 2.0}));
}
main__Article* main__Article__static__create(vphp__Context ctx) {
	string title = vphp__Context_arg_T_string(ctx, 0);
	main__Article* a = ((main__Article*)builtin__memdup(&(main__Article){.id = 1024,.title = title,.is_top = true,}, sizeof(main__Article)));
	return a;
}
// export alias: Article_create -> main__Article__static__create
main__Article* Article_create(vphp__Context ctx) {
	return main__Article__static__create(ctx);
}
bool main__Article_save(main__Article* a, vphp__Context ctx) {
	builtin__println(builtin__str_intp(2, _MOV((StrIntpData[]){{_S("Saving article: "), 0xfe10, {.d_s = a->title}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return true;
}
// export alias: Article_save -> main__Article_save
bool Article_save(main__Article* a, vphp__Context ctx) {
	return main__Article_save(a, ctx);
}
void _vinit(int ___argc, voidptr ___argv) {
	as_cast_type_indexes = builtin__new_array_from_c_array(107, 107, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[107]){
		  (VCastTypeIndexName){.tindex = 0, .tname = _S("unknown")}
		, (VCastTypeIndexName){.tindex = 258, .tname = _S("v.ast.NodeError")}
		, (VCastTypeIndexName){.tindex = 259, .tname = _S("v.ast.AnonFn")}
		, (VCastTypeIndexName){.tindex = 260, .tname = _S("v.ast.ArrayDecompose")}
		, (VCastTypeIndexName){.tindex = 261, .tname = _S("v.ast.ArrayInit")}
		, (VCastTypeIndexName){.tindex = 262, .tname = _S("v.ast.AsCast")}
		, (VCastTypeIndexName){.tindex = 263, .tname = _S("v.ast.Assoc")}
		, (VCastTypeIndexName){.tindex = 264, .tname = _S("v.ast.AtExpr")}
		, (VCastTypeIndexName){.tindex = 265, .tname = _S("v.ast.BoolLiteral")}
		, (VCastTypeIndexName){.tindex = 266, .tname = _S("v.ast.CTempVar")}
		, (VCastTypeIndexName){.tindex = 267, .tname = _S("v.ast.CallExpr")}
		, (VCastTypeIndexName){.tindex = 268, .tname = _S("v.ast.CastExpr")}
		, (VCastTypeIndexName){.tindex = 269, .tname = _S("v.ast.ChanInit")}
		, (VCastTypeIndexName){.tindex = 270, .tname = _S("v.ast.CharLiteral")}
		, (VCastTypeIndexName){.tindex = 271, .tname = _S("v.ast.Comment")}
		, (VCastTypeIndexName){.tindex = 272, .tname = _S("v.ast.ComptimeCall")}
		, (VCastTypeIndexName){.tindex = 273, .tname = _S("v.ast.ComptimeSelector")}
		, (VCastTypeIndexName){.tindex = 274, .tname = _S("v.ast.ComptimeType")}
		, (VCastTypeIndexName){.tindex = 275, .tname = _S("v.ast.ConcatExpr")}
		, (VCastTypeIndexName){.tindex = 276, .tname = _S("v.ast.DumpExpr")}
		, (VCastTypeIndexName){.tindex = 277, .tname = _S("v.ast.EmptyExpr")}
		, (VCastTypeIndexName){.tindex = 278, .tname = _S("v.ast.EnumVal")}
		, (VCastTypeIndexName){.tindex = 279, .tname = _S("v.ast.FloatLiteral")}
		, (VCastTypeIndexName){.tindex = 280, .tname = _S("v.ast.GoExpr")}
		, (VCastTypeIndexName){.tindex = 281, .tname = _S("v.ast.Ident")}
		, (VCastTypeIndexName){.tindex = 282, .tname = _S("v.ast.IfExpr")}
		, (VCastTypeIndexName){.tindex = 283, .tname = _S("v.ast.IfGuardExpr")}
		, (VCastTypeIndexName){.tindex = 284, .tname = _S("v.ast.IndexExpr")}
		, (VCastTypeIndexName){.tindex = 285, .tname = _S("v.ast.InfixExpr")}
		, (VCastTypeIndexName){.tindex = 286, .tname = _S("v.ast.IntegerLiteral")}
		, (VCastTypeIndexName){.tindex = 287, .tname = _S("v.ast.IsRefType")}
		, (VCastTypeIndexName){.tindex = 288, .tname = _S("v.ast.LambdaExpr")}
		, (VCastTypeIndexName){.tindex = 289, .tname = _S("v.ast.Likely")}
		, (VCastTypeIndexName){.tindex = 290, .tname = _S("v.ast.LockExpr")}
		, (VCastTypeIndexName){.tindex = 291, .tname = _S("v.ast.MapInit")}
		, (VCastTypeIndexName){.tindex = 292, .tname = _S("v.ast.MatchExpr")}
		, (VCastTypeIndexName){.tindex = 293, .tname = _S("v.ast.Nil")}
		, (VCastTypeIndexName){.tindex = 294, .tname = _S("v.ast.None")}
		, (VCastTypeIndexName){.tindex = 295, .tname = _S("v.ast.OffsetOf")}
		, (VCastTypeIndexName){.tindex = 296, .tname = _S("v.ast.OrExpr")}
		, (VCastTypeIndexName){.tindex = 297, .tname = _S("v.ast.ParExpr")}
		, (VCastTypeIndexName){.tindex = 298, .tname = _S("v.ast.PostfixExpr")}
		, (VCastTypeIndexName){.tindex = 299, .tname = _S("v.ast.PrefixExpr")}
		, (VCastTypeIndexName){.tindex = 300, .tname = _S("v.ast.RangeExpr")}
		, (VCastTypeIndexName){.tindex = 301, .tname = _S("v.ast.SelectExpr")}
		, (VCastTypeIndexName){.tindex = 302, .tname = _S("v.ast.SelectorExpr")}
		, (VCastTypeIndexName){.tindex = 303, .tname = _S("v.ast.SizeOf")}
		, (VCastTypeIndexName){.tindex = 304, .tname = _S("v.ast.SpawnExpr")}
		, (VCastTypeIndexName){.tindex = 305, .tname = _S("v.ast.SqlExpr")}
		, (VCastTypeIndexName){.tindex = 306, .tname = _S("v.ast.StringInterLiteral")}
		, (VCastTypeIndexName){.tindex = 237, .tname = _S("v.ast.StringLiteral")}
		, (VCastTypeIndexName){.tindex = 236, .tname = _S("v.ast.StructInit")}
		, (VCastTypeIndexName){.tindex = 307, .tname = _S("v.ast.TypeNode")}
		, (VCastTypeIndexName){.tindex = 308, .tname = _S("v.ast.TypeOf")}
		, (VCastTypeIndexName){.tindex = 309, .tname = _S("v.ast.UnsafeExpr")}
		, (VCastTypeIndexName){.tindex = 498, .tname = _S("v.ast.UnknownTypeInfo")}
		, (VCastTypeIndexName){.tindex = 480, .tname = _S("v.ast.Aggregate")}
		, (VCastTypeIndexName){.tindex = 482, .tname = _S("v.ast.Alias")}
		, (VCastTypeIndexName){.tindex = 452, .tname = _S("v.ast.Array")}
		, (VCastTypeIndexName){.tindex = 491, .tname = _S("v.ast.ArrayFixed")}
		, (VCastTypeIndexName){.tindex = 492, .tname = _S("v.ast.Chan")}
		, (VCastTypeIndexName){.tindex = 490, .tname = _S("v.ast.Enum")}
		, (VCastTypeIndexName){.tindex = 495, .tname = _S("v.ast.FnType")}
		, (VCastTypeIndexName){.tindex = 496, .tname = _S("v.ast.GenericInst")}
		, (VCastTypeIndexName){.tindex = 485, .tname = _S("v.ast.Interface")}
		, (VCastTypeIndexName){.tindex = 453, .tname = _S("v.ast.Map")}
		, (VCastTypeIndexName){.tindex = 494, .tname = _S("v.ast.MultiReturn")}
		, (VCastTypeIndexName){.tindex = 457, .tname = _S("v.ast.Struct")}
		, (VCastTypeIndexName){.tindex = 486, .tname = _S("v.ast.SumType")}
		, (VCastTypeIndexName){.tindex = 493, .tname = _S("v.ast.Thread")}
		, (VCastTypeIndexName){.tindex = 337, .tname = _S("v.ast.EmptyScopeObject")}
		, (VCastTypeIndexName){.tindex = 338, .tname = _S("v.ast.AsmRegister")}
		, (VCastTypeIndexName){.tindex = 339, .tname = _S("v.ast.ConstField")}
		, (VCastTypeIndexName){.tindex = 340, .tname = _S("v.ast.GlobalField")}
		, (VCastTypeIndexName){.tindex = 341, .tname = _S("v.ast.Var")}
		, (VCastTypeIndexName){.tindex = 311, .tname = _S("v.ast.AsmStmt")}
		, (VCastTypeIndexName){.tindex = 312, .tname = _S("v.ast.AssertStmt")}
		, (VCastTypeIndexName){.tindex = 313, .tname = _S("v.ast.AssignStmt")}
		, (VCastTypeIndexName){.tindex = 314, .tname = _S("v.ast.Block")}
		, (VCastTypeIndexName){.tindex = 315, .tname = _S("v.ast.BranchStmt")}
		, (VCastTypeIndexName){.tindex = 316, .tname = _S("v.ast.ComptimeFor")}
		, (VCastTypeIndexName){.tindex = 231, .tname = _S("v.ast.ConstDecl")}
		, (VCastTypeIndexName){.tindex = 317, .tname = _S("v.ast.DebuggerStmt")}
		, (VCastTypeIndexName){.tindex = 318, .tname = _S("v.ast.DeferStmt")}
		, (VCastTypeIndexName){.tindex = 319, .tname = _S("v.ast.EmptyStmt")}
		, (VCastTypeIndexName){.tindex = 320, .tname = _S("v.ast.EnumDecl")}
		, (VCastTypeIndexName){.tindex = 321, .tname = _S("v.ast.ExprStmt")}
		, (VCastTypeIndexName){.tindex = 229, .tname = _S("v.ast.FnDecl")}
		, (VCastTypeIndexName){.tindex = 322, .tname = _S("v.ast.ForCStmt")}
		, (VCastTypeIndexName){.tindex = 323, .tname = _S("v.ast.ForInStmt")}
		, (VCastTypeIndexName){.tindex = 324, .tname = _S("v.ast.ForStmt")}
		, (VCastTypeIndexName){.tindex = 325, .tname = _S("v.ast.GlobalDecl")}
		, (VCastTypeIndexName){.tindex = 326, .tname = _S("v.ast.GotoLabel")}
		, (VCastTypeIndexName){.tindex = 327, .tname = _S("v.ast.GotoStmt")}
		, (VCastTypeIndexName){.tindex = 328, .tname = _S("v.ast.HashStmt")}
		, (VCastTypeIndexName){.tindex = 329, .tname = _S("v.ast.Import")}
		, (VCastTypeIndexName){.tindex = 330, .tname = _S("v.ast.InterfaceDecl")}
		, (VCastTypeIndexName){.tindex = 331, .tname = _S("v.ast.Module")}
		, (VCastTypeIndexName){.tindex = 332, .tname = _S("v.ast.Return")}
		, (VCastTypeIndexName){.tindex = 333, .tname = _S("v.ast.SemicolonStmt")}
		, (VCastTypeIndexName){.tindex = 334, .tname = _S("v.ast.SqlStmt")}
		, (VCastTypeIndexName){.tindex = 228, .tname = _S("v.ast.StructDecl")}
		, (VCastTypeIndexName){.tindex = 257, .tname = _S("v.ast.TypeDecl")}
		, (VCastTypeIndexName){.tindex = 429, .tname = _S("v.ast.AsmAddressing")}
		, (VCastTypeIndexName){.tindex = 430, .tname = _S("v.ast.AsmAlias")}
		, (VCastTypeIndexName){.tindex = 431, .tname = _S("v.ast.AsmDisp")}
		, (VCastTypeIndexName){.tindex = 21, .tname = _S("string")}
	}));


	// Initializations of consts for module builtin.closure
	g_closure = ((builtin__closure__Closure){.ClosureMutex = ((builtin__closure__ClosureMutex){E_STRUCT}),.closure_ptr = 0,.closure_get_data = ((void*)0),.closure_cap = 0,.v_page_size = ((int)(0x4000)),}); // global 3
{
{
Array_fixed_u8_12 _t1;
#if defined(__V_amd64)
#elif defined(__V_x86)
#elif defined(__V_arm64)
	{ Array_fixed_u8_12 _t2 = {((u8)(0x11)), 0x00, 0xFE, 0x5C, 0x30, 0x00, 0xFE, 0x58, 0x00, 0x02, 0x1F, 0xD6}	;
	memcpy(&_t1, &_t2, sizeof(Array_fixed_u8_12));
	}
	;
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	memcpy(&_const_builtin__closure__closure_thunk, &_t1, sizeof(Array_fixed_u8_12));
}
}
{
{
Array_fixed_u8_8 _t3;
#if defined(__V_amd64)
#elif defined(__V_x86)
#elif defined(__V_arm64)
	{ Array_fixed_u8_8 _t4 = {((u8)(0x20)), 0x02, 0x66, 0x9E, 0xC0, 0x03, 0x5F, 0xD6}	;
	memcpy(&_t3, &_t4, sizeof(Array_fixed_u8_8));
	}
	;
#elif defined(__V_arm32)
#elif defined(__V_rv64)
#elif defined(__V_rv32)
#elif defined(__V_s390x)
#elif defined(__V_ppc64le)
#elif defined(__V_loongarch64)
#else
#endif
	memcpy(&_const_builtin__closure__closure_get_data_bytes, &_t3, sizeof(Array_fixed_u8_8));
}
}
{
{
	_const_builtin__closure__closure_size_1 = ((u32)(2 * ((u32)(sizeof(voidptr)))) > ((u32)(12)) ? ((u32)(2 * ((u32)(sizeof(voidptr))))) : ((u32)((u32)(((u32)(12)) + ((u32)(sizeof(voidptr)))) - 1)));
}
}
	_const_builtin__closure__closure_size = ((int)((_const_builtin__closure__closure_size_1 & ~((u32)(((u32)(sizeof(voidptr))) - 1)))));
	// Initializations of consts for module math.bits
	_const_math__bits__overflow_error = _S("Overflow Error");
	// Initializations of consts for module strconv
	_const_strconv__digit_pairs = _S("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _S("0123456789abcdefghijklmnopqrstuvwxyz");
	_const_strconv__i64_min_int32 = (i64)(((i64)(-2147483647)) - 1);
	_const_strconv__i64_max_int32 = (i64)(((i64)(2147483646)) + 1);
	// Initializations of consts for module builtin
	_const_digit_pairs = _S("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_si_s_code = _S("0xfe10");
	_const_si_g32_code = _S("0xfe0e");
	_const_si_g64_code = _S("0xfe0f");
	g_live_reload_info = *(voidptr*)&((voidptr[]){0}[0]); // global 5
	_const_none__ = I_None___to_Interface_IError(((None__*)builtin__memdup(&(None__){.Error = ((Error){E_STRUCT}),}, sizeof(None__))));
	_const_min_i64 = ((i64)((int_literal)(-9223372036854775807LL - 1)));
	_const_max_i64 = ((i64)(9223372036854775807LL));
	// Initializations of consts for module v.token
	_const_v__token__orm_custom_operators = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("like"), _S("ilike")}));
{
	_const_v__token__assign_tokens = builtin__new_array_from_c_array(15, 15, sizeof(v__token__Kind), _MOV((v__token__Kind[15]){
		v__token__Kind__assign, v__token__Kind__decl_assign, v__token__Kind__plus_assign, v__token__Kind__minus_assign, v__token__Kind__mult_assign, v__token__Kind__div_assign, v__token__Kind__xor_assign, v__token__Kind__mod_assign, v__token__Kind__or_assign,
		v__token__Kind__and_assign, v__token__Kind__right_shift_assign, v__token__Kind__left_shift_assign, v__token__Kind__unsigned_right_shift_assign, v__token__Kind__boolean_and_assign, v__token__Kind__boolean_or_assign}));
}
{
	_const_v__token__valid_at_tokens = builtin__new_array_from_c_array(25, 25, sizeof(string), _MOV((string[25]){
		_S("@VROOT"), _S("@VMODROOT"), _S("@VEXEROOT"), _S("@FN"), _S("@METHOD"), _S("@MOD"), _S("@STRUCT"), _S("@VEXE"), _S("@FILE"),
		_S("@DIR"), _S("@LINE"), _S("@COLUMN"), _S("@VHASH"), _S("@VCURRENTHASH"), _S("@VMOD_FILE"), _S("@VMODHASH"), _S("@FILE_LINE"),
		_S("@LOCATION"), _S("@BUILD_DATE"), _S("@BUILD_TIME"), _S("@BUILD_TIMESTAMP"), _S("@OS"), _S("@CCOMPILER"), _S("@BACKEND"), _S("@PLATFORM")}));
}
	_const_v__token__token_str = v__token__build_token_str();
	_const_v__token__precedences = v__token__build_precedences();
	_const_v__token__keywords = v__token__build_keys();
	_const_v__token__scanner_matcher = v__token__new_keywords_matcher_trie_T_v__token__Kind(_const_v__token__keywords);
	// Initializations of consts for module time
	_const_time__days_string = _S("MonTueWedThuFriSatSun");
	_const_time__months_string = _S("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__infinite = ((((i64)(9223372036854775807LL))));
{
	_const_time__tokens_2 = builtin__new_array_from_c_array(18, 18, sizeof(string), _MOV((string[18]){
		_S("MM"), _S("Mo"), _S("DD"), _S("Do"), _S("YY"), _S("ss"), _S("kk"), _S("NN"), _S("mm"),
		_S("hh"), _S("HH"), _S("ii"), _S("ZZ"), _S("dd"), _S("Qo"), _S("QQ"), _S("wo"),
		_S("ww")}));
}
	_const_time__tokens_3 = builtin__new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_S("MMM"), _S("DDD"), _S("ZZZ"), _S("ddd")}));
	_const_time__tokens_4 = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("MMMM"), _S("DDDD"), _S("DDDo"), _S("dddd"), _S("YYYY")}));
{
	_const_time__long_months = builtin__new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_S("January"), _S("February"), _S("March"), _S("April"), _S("May"), _S("June"), _S("July"), _S("August"), _S("September"),
		_S("October"), _S("November"), _S("December")}));
}
	_const_time__absolute_zero_year = ((i64)(-292277022399LL));
	_const_time__start_time = mach_absolute_time();
	_const_time__time_base = time__init_time_base();
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	// Initializations of consts for module flag
	_const_flag__space = _S("                            ");
	_const_flag__underline = _S("-----------------------------------------------");
	// Initializations of consts for module semver
	_const_semver__comparator_sep = _S(" ");
	_const_semver__comparator_set_sep = _S(" || ");
	_const_semver__hyphen_range_sep = _S(" - ");
	_const_semver__x_range_symbols = _S("Xx*");
	_const_semver__versions = builtin__new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_semver__ver_major, _const_semver__ver_minor, _const_semver__ver_patch}));
	// Initializations of consts for module vphp
	g_registry = *(vphp__TaskRegistry**)&((vphp__TaskRegistry*[]){0}[0]); // global 5
	// Initializations of consts for module os
	_const_os__fslash_str = _S("/");
	_const_os__dot_dot = _S("..");
	_const_os__empty_str = _S("");
	_const_os__dot_str = _S(".");
	_const_os__path_separator = _S("/");
	_const_os__path_delimiter = _S(":");
	_const_os__path_devnull = _S("/dev/null");
{
{
	_const_os__o_rdonly = O_RDONLY;
}
}
{
{
	_const_os__o_wronly = O_WRONLY;
}
}
{
{
	_const_os__o_rdwr = O_RDWR;
}
}
{
{
	_const_os__o_create = O_CREAT;
}
}
{
{
	_const_os__o_noctty = O_NOCTTY;
}
}
{
{
	_const_os__o_trunc = O_TRUNC;
}
}
{
{
	_const_os__o_append = O_APPEND;
}
}
{
{
	_const_os__o_nonblock = O_NONBLOCK;
}
}
{
{
	_const_os__o_sync = O_SYNC;
}
}
	_const_os__wd_at_startup = os__getwd();
	_const_os__executable_suffixes = builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("")}));
{
{
int _t1;
#if defined(_WIN32)
#else
	_t1 = STDOUT_FILENO;
	;
#endif
	_const_os__fd_stdout = _t1;
}
}
{
{
int _t2;
#if defined(_WIN32)
#else
	_t2 = STDERR_FILENO;
	;
#endif
	_const_os__fd_stderr = _t2;
}
}
	g_main_thread_id = ((u64)(pthread_self())); // global 3
	_const_os__args = builtin__arguments();
	// Initializations of consts for module v.cflag
	_const_v__cflag__fexisting_literal = _S("$first_existing");
	_const_v__cflag__wexisting_literal = _S("$when_first_existing");
	// Initializations of consts for module v.pkgconfig
	_const_v__pkgconfig__version = _S("0.3.4");
{
	_const_v__pkgconfig__default_paths = builtin__new_array_from_c_array(18, 18, sizeof(string), _MOV((string[18]){
		_S("/usr/local/lib/x86_64-linux-gnu/pkgconfig"), _S("/usr/local/lib64/pkgconfig"), _S("/usr/local/lib/pkgconfig"), _S("/usr/local/share/pkgconfig"), _S("/usr/lib/x86_64-linux-gnu/pkgconfig"), _S("/usr/lib/aarch64-linux-gnu/pkgconfig"), _S("/usr/lib64/pkgconfig"), _S("/usr/lib/pkgconfig"), _S("/usr/share/pkgconfig"),
		_S("/opt/homebrew/lib/pkgconfig"), _S("/opt/homebrew/share/pkgconfig"), _S("/opt/homebrew/Library/Homebrew/os/mac/pkgconfig/11"), _S("/opt/local/lib/pkgconfig"), _S("/usr/local/libdata/pkgconfig"), _S("/usr/libdata/pkgconfig"), _S("/usr/lib/i386-linux-gnu/pkgconfig"), _S("/data/data/com.termux/files/usr/lib/pkgconfig"),
		_S("/usr/pkg/lib/pkgconfig")}));
}
	// Initializations of consts for module v.vmod
	_const_v__vmod__err_label = _S("vmod:");
	_const_v__vmod__mod_file_stop_paths = builtin__new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_S(".git"), _S(".hg"), _S(".svn"), _S(".v.mod.stop")}));
	_const_v__vmod__private_file_cacher = v__vmod__new_mod_file_cacher();
	// Initializations of consts for module rand
	_const_rand__ulid_encoding = _S("0123456789ABCDEFGHJKMNPQRSTVWXYZ");
	_const_rand__english_letters = _S("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	_const_rand__hex_chars = _S("0123456789abcdef");
	_const_rand__ascii_chars = _S("!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`abcdefghijklmnopqrstuvwxyz{|}~");
	default_rng = *(rand__PRNG**)&((rand__PRNG*[]){0}[0]); // global 5
	_const_rand__reciprocal_2_23rd = (f64)(((f64)(1.0)) / ((f64)((((u32)(1)) << 23))));
	_const_rand__reciprocal_2_52nd = (f64)(((f64)(1.0)) / ((f64)((((u64)(1)) << 52))));
	_const_rand__ieee754_mantissa_f32_mask = (u32)(((((u32)(1)) << 23)) - 1);
	// Calling fn init() for module rand
	rand__init();
	// Initializations of consts for module v.pref
	_const_v__pref__supported_test_runners = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("normal"), _S("simple"), _S("tap"), _S("dump"), _S("teamcity")}));
	_const_v__pref__default_module_path = os__vmodules_dir();
	// Initializations of consts for module v.util
	_const_v__util__d_sig = _S("$d('");
	_const_v__util__double_escape = _S("\\\\");
	_const_v__util__map_prefix = _S("map[string]");
	_const_v__util__verror_paths_absolute = builtin__string__eq(os__getenv(_S("VERROR_PATHS")), _S("absolute"));
	lines_cache = ((v__util__LinesCache*)builtin__memdup(&(v__util__LinesCache){.lines = builtin__new_map(sizeof(string), sizeof(Array_string), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),}, sizeof(v__util__LinesCache))); // global 3
	_const_v__util__invalid_escapes = builtin__string_bytes(_S("({$`."));
	memcpy(&_const_v__util__name_char_table, v__util__get_name_char_table().ret_arr, sizeof(Array_fixed_bool_256));
	memcpy(&_const_v__util__func_char_table, v__util__get_func_char_table().ret_arr, sizeof(Array_fixed_bool_256));
	memcpy(&_const_v__util__non_whitespace_table, v__util__get_non_white_space_table().ret_arr, sizeof(Array_fixed_bool_256));
{
{
	_const_v__util__max_suggestions_limit = 200;
}
}
	g_timers = v__util__new_timers(((v__util__TimerParams){.should_print = false,.label = _S("g_timers"),})); // global 3
	_const_v__util__builtin_module_parts = builtin__new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_S("math.bits"), _S("strconv"), _S("dlmalloc"), _S("strconv.ftoa"), _S("strings"), _S("builtin"), _S("builtin.closure"), _S("builtin.overflow")}));
{
{
	_const_v__util__external_module_dependencies_for_tool = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(Array_string),
	_MOV((string[1]){
		_S("vdoc"),
	}),
	_MOV((Array_string[1]){
		builtin__new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_S("markdown")})), 
	})
)
;
}
}
	_const_v__util__nr_jobs = runtime__nr_jobs();
	_const_v__util__emanager = v__util__new_error_manager();
	_const_v__util__normalised_workdir = builtin__string__plus(builtin__string_replace(_const_os__wd_at_startup, _S("\\"), _S("/")), _S("/"));
	_const_v__util__stable_build_time = v__util__get_build_time();
	// Initializations of consts for module v.ast
	_const_v__ast__result_name = _S("_result");
	_const_v__ast__option_name = _S("_option");
	_const_v__ast__int_type_name = _S("int");
{
	_const_v__ast__global_reserved_type_names = builtin__new_array_from_c_array(22, 22, sizeof(string), _MOV((string[22]){
		_S("byte"), _S("bool"), _S("char"), _S("i8"), _S("i16"), _S("i32"), _S("int"), _S("i64"), _S("u8"),
		_S("u16"), _S("u32"), _S("u64"), _S("f32"), _S("f64"), _S("map"), _S("string"), _S("rune"),
		_S("usize"), _S("isize"), _S("voidptr"), _S("thread"), _S("array")}));
}
	_const_v__ast__empty_expr = v__ast__EmptyExpr_to_sumtype_v__ast__Expr(ADDR(v__ast__EmptyExpr, (((v__ast__EmptyExpr)(0)))), false);
	_const_v__ast__empty_stmt = v__ast__EmptyStmt_to_sumtype_v__ast__Stmt(ADDR(v__ast__EmptyStmt, (((v__ast__EmptyStmt){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
	_const_v__ast__empty_node = v__ast__EmptyNode_to_sumtype_v__ast__Node(ADDR(v__ast__EmptyNode, (((v__ast__EmptyNode){.pos = ((v__token__Pos){.len = 0,.line_nr = 0,.pos = 0,.col = 0,.file_idx = -1,.last_line = 0,}),}))), false);
	_const_v__ast__empty_scope_object = v__ast__EmptyScopeObject_to_sumtype_v__ast__ScopeObject(ADDR(v__ast__EmptyScopeObject, (((v__ast__EmptyScopeObject){.name = _S("empty_scope_object"),.typ = 0,}))), false);
	_const_v__ast__empty_comptime_const_value = v__ast__EmptyExpr_to_sumtype_v__ast__ComptTimeConstValue(ADDR(v__ast__EmptyExpr, (((v__ast__EmptyExpr)(0)))), false);
{
{
	_const_v__ast__x86_no_number_register_list = builtin__new_map_init(&builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop, 4, sizeof(int), sizeof(Array_string),
	_MOV((int[4]){
		8,
		16,
		32,
		64,
	}),
	_MOV((Array_string[4]){
		builtin__new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_S("al"), _S("ah"), _S("bl"), _S("bh"), _S("cl"), _S("ch"), _S("dl"), _S("dh"), _S("bpl"),
		_S("sil"), _S("dil"), _S("spl")})), 
		builtin__new_array_from_c_array(22, 22, sizeof(string), _MOV((string[22]){
		_S("ax"), _S("bx"), _S("cx"), _S("dx"), _S("bp"), _S("si"), _S("di"), _S("sp"), _S("cs"),
		_S("ss"), _S("ds"), _S("es"), _S("fs"), _S("gs"), _S("flags"), _S("ip"), _S("gdtr"),
		_S("idtr"), _S("tr"), _S("ldtr"), _S("fp_ds"), _S("fp_opc")})), 
		builtin__new_array_from_c_array(11, 11, sizeof(string), _MOV((string[11]){
		_S("eax"), _S("ebx"), _S("ecx"), _S("edx"), _S("ebp"), _S("esi"), _S("edi"), _S("esp"), _S("eflags"),
		_S("eip"), _S("mxcsr")})), 
		builtin__new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_S("rax"), _S("rbx"), _S("rcx"), _S("rdx"), _S("rbp"), _S("rsi"), _S("rdi"), _S("rsp"), _S("rflags"),
		_S("rip")})), 
	})
)
;
}
}
{
{
	_const_v__ast__x86_with_number_register_list = builtin__new_map_init(&builtin__map_hash_int_4, &builtin__map_eq_int_4, &builtin__map_clone_int_4, &builtin__map_free_nop, 8, sizeof(int), sizeof(Map_string_int),
	_MOV((int[8]){
		8,
		16,
		32,
		64,
		80,
		128,
		256,
		512,
	}),
	_MOV((Map_string_int[8]){
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("r#b"),
	}),
	_MOV((int[1]){
		16, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("r#w"),
	}),
	_MOV((int[1]){
		16, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("r#d"),
	}),
	_MOV((int[1]){
		16, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 4, sizeof(string), sizeof(int),
	_MOV((string[4]){
		_S("r#"),
		_S("mm#"),
		_S("cr#"),
		_S("dr#"),
	}),
	_MOV((int[4]){
		16, 
		16, 
		16, 
		16, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("st#"),
	}),
	_MOV((int[1]){
		16, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("xmm#"),
	}),
	_MOV((int[1]){
		32, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("ymm#"),
	}),
	_MOV((int[1]){
		32, 
	})
)
, 
		builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("zmm#"),
	}),
	_MOV((int[1]){
		32, 
	})
)
, 
	})
)
;
}
}
	_const_v__ast__arm_no_number_register_list = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("fp"), _S("ip"), _S("sp"), _S("lr"), _S("pc")}));
{
{
	_const_v__ast__arm_with_number_register_list = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 1, sizeof(string), sizeof(int),
	_MOV((string[1]){
		_S("r#"),
	}),
	_MOV((int[1]){
		16, 
	})
)
;
}
}
	_const_v__ast__riscv_no_number_register_list = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("zero"), _S("ra"), _S("sp"), _S("gp"), _S("tp")}));
{
{
	_const_v__ast__riscv_with_number_register_list = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 4, sizeof(string), sizeof(int),
	_MOV((string[4]){
		_S("x#"),
		_S("t#"),
		_S("s#"),
		_S("a#"),
	}),
	_MOV((int[4]){
		32, 
		3, 
		12, 
		8, 
	})
)
;
}
}
	_const_v__ast__s390x_no_number_register_list = builtin____new_array_with_default(0, 0, sizeof(string), 0);
{
{
	_const_v__ast__s390x_with_number_register_list = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 3, sizeof(string), sizeof(int),
	_MOV((string[3]){
		_S("f#"),
		_S("r#"),
		_S("v#"),
	}),
	_MOV((int[3]){
		16, 
		16, 
		32, 
	})
)
;
}
}
	_const_v__ast__ppc64le_no_number_register_list = builtin____new_array_with_default(0, 0, sizeof(string), 0);
{
{
	_const_v__ast__ppc64le_with_number_register_list = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 2, sizeof(string), sizeof(int),
	_MOV((string[2]){
		_S("f#"),
		_S("r#"),
	}),
	_MOV((int[2]){
		32, 
		32, 
	})
)
;
}
}
	_const_v__ast__loongarch64_no_number_register_list = builtin____new_array_with_default(0, 0, sizeof(string), 0);
{
{
	_const_v__ast__loongarch64_with_number_register_list = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 2, sizeof(string), sizeof(int),
	_MOV((string[2]){
		_S("f#"),
		_S("r#"),
	}),
	_MOV((int[2]){
		32, 
		32, 
	})
)
;
}
}
{
	_const_v__ast__valid_comptime_if_os = builtin__new_array_from_c_array(22, 22, sizeof(string), _MOV((string[22]){
		_S("windows"), _S("ios"), _S("macos"), _S("mach"), _S("darwin"), _S("hpux"), _S("gnu"), _S("qnx"), _S("linux"),
		_S("freebsd"), _S("openbsd"), _S("netbsd"), _S("bsd"), _S("dragonfly"), _S("android"), _S("termux"), _S("solaris"),
		_S("haiku"), _S("serenity"), _S("vinix"), _S("plan9"), _S("wasm32_emscripten")}));
}
	_const_v__ast__valid_comptime_if_compilers = builtin__new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_S("gcc"), _S("tinyc"), _S("clang"), _S("mingw"), _S("msvc"), _S("cplusplus")}));
{
	_const_v__ast__valid_comptime_if_platforms = builtin__new_array_from_c_array(10, 10, sizeof(string), _MOV((string[10]){
		_S("amd64"), _S("i386"), _S("aarch64"), _S("arm64"), _S("arm32"), _S("rv64"), _S("rv32"), _S("s390x"), _S("ppc64le"),
		_S("loongarch64")}));
}
	_const_v__ast__valid_comptime_if_cpu_features = builtin__new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_S("x64"), _S("x32"), _S("little_endian"), _S("big_endian")}));
{
	_const_v__ast__valid_comptime_if_other = builtin__new_array_from_c_array(21, 21, sizeof(string), _MOV((string[21]){
		_S("apk"), _S("js"), _S("debug"), _S("prod"), _S("test"), _S("glibc"), _S("prealloc"), _S("no_bounds_checking"), _S("freestanding"),
		_S("threads"), _S("js_node"), _S("js_browser"), _S("js_freestanding"), _S("interpreter"), _S("es5"), _S("profile"), _S("wasm32"),
		_S("wasm32_wasi"), _S("fast_math"), _S("native"), _S("autofree")}));
}
	_const_v__ast__valid_comptime_compression_types = builtin__new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_S("none"), _S("zlib")}));
{
{
	_const_v__ast__system_ident_map = builtin__new_map_init(&builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string, 57, sizeof(string), sizeof(string),
	_MOV((string[57]){
		_S("windows"),
		_S("ios"),
		_S("macos"),
		_S("mach"),
		_S("darwin"),
		_S("hpux"),
		_S("gnu"),
		_S("qnx"),
		_S("linux"),
		_S("serenity"),
		_S("plan9"),
		_S("vinix"),
		_S("freebsd"),
		_S("openbsd"),
		_S("netbsd"),
		_S("bsd"),
		_S("dragonfly"),
		_S("android"),
		_S("termux"),
		_S("solaris"),
		_S("haiku"),
		_S("js"),
		_S("wasm32_emscripten"),
		_S("native"),
		_S("gcc"),
		_S("tinyc"),
		_S("clang"),
		_S("mingw"),
		_S("msvc"),
		_S("cplusplus"),
		_S("threads"),
		_S("gcboehm"),
		_S("debug"),
		_S("prod"),
		_S("profile"),
		_S("test"),
		_S("glibc"),
		_S("prealloc"),
		_S("no_bounds_checking"),
		_S("freestanding"),
		_S("autofree"),
		_S("amd64"),
		_S("aarch64"),
		_S("arm64"),
		_S("arm32"),
		_S("i386"),
		_S("rv64"),
		_S("riscv64"),
		_S("rv32"),
		_S("riscv32"),
		_S("s390x"),
		_S("ppc64le"),
		_S("loongarch64"),
		_S("x64"),
		_S("x32"),
		_S("little_endian"),
		_S("big_endian"),
	}),
	_MOV((string[57]){
		_S("_WIN32"), 
		_S("__TARGET_IOS__"), 
		_S("__APPLE__"), 
		_S("__MACH__"), 
		_S("__DARWIN__"), 
		_S("__HPUX__"), 
		_S("__GNU__"), 
		_S("__QNX__"), 
		_S("__linux__"), 
		_S("__serenity__"), 
		_S("__plan9__"), 
		_S("__vinix__"), 
		_S("__FreeBSD__"), 
		_S("__OpenBSD__"), 
		_S("__NetBSD__"), 
		_S("__BSD__"), 
		_S("__DragonFly__"), 
		_S("__ANDROID__"), 
		_S("__TERMUX__"), 
		_S("__sun"), 
		_S("__HAIKU__"), 
		_S("_VJS"), 
		_S("__EMSCRIPTEN__"), 
		_S("_VNATIVE"), 
		_S("__V_GCC__"), 
		_S("__TINYC__"), 
		_S("__clang__"), 
		_S("__MINGW32__"), 
		_S("_MSC_VER"), 
		_S("__cplusplus"), 
		_S("__VTHREADS__"), 
		_S("_VGCBOEHM"), 
		_S("_VDEBUG"), 
		_S("_VPROD"), 
		_S("_VPROFILE"), 
		_S("_VTEST"), 
		_S("__GLIBC__"), 
		_S("_VPREALLOC"), 
		_S("CUSTOM_DEFINE_no_bounds_checking"), 
		_S("_VFREESTANDING"), 
		_S("_VAUTOFREE"), 
		_S("__V_amd64"), 
		_S("__V_arm64"), 
		_S("__V_arm64"), 
		_S("__V_arm32"), 
		_S("__V_x86"), 
		_S("__V_rv64"), 
		_S("__V_rv64"), 
		_S("__V_rv32"), 
		_S("__V_rv32"), 
		_S("__V_s390x"), 
		_S("__V_ppc64le"), 
		_S("__V_loongarch64"), 
		_S("TARGET_IS_64BIT"), 
		_S("TARGET_IS_32BIT"), 
		_S("TARGET_ORDER_IS_LITTLE"), 
		_S("TARGET_ORDER_IS_BIG"), 
	})
)
;
}
}
	_const_v__ast__native_builtins = builtin__new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_S("assert"), _S("print"), _S("eprint"), _S("println"), _S("eprintln"), _S("exit"), _S("C.syscall")}));
{
{
	_const_v__ast__empty_scope = ((v__ast__Scope*)builtin__memdup(&(v__ast__Scope){.objects = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeObject), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.struct_fields = builtin__new_map(sizeof(string), sizeof(v__ast__ScopeStructField), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string),.parent = ((void*)0),.detached_from_parent = 0,.children = builtin____new_array(0, 0, sizeof(v__ast__Scope*)),.start_pos = 0,.end_pos = 0,}, sizeof(v__ast__Scope)));
}
}
	_const_v__ast__fn_type_escape_seq = builtin__new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_S(" "), _S(""), _S("("), _S("_"), _S(")"), _S("")}));
	_const_v__ast__map_cname_escape_seq = builtin__new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_S("["), _S("_T_"), _S(", "), _S("_"), _S("]"), _S("")}));
	global_table = ((v__ast__Table*)(((void*)0))); // global 3
{
	_const_v__ast__builtin_type_names = builtin__new_array_from_c_array(31, 31, sizeof(string), _MOV((string[31]){
		_S("void"), _S("voidptr"), _S("byteptr"), _S("charptr"), _S("i8"), _S("i16"), _S("i32"), _S("int"), _S("i64"),
		_S("isize"), _S("u8"), _S("u16"), _S("u32"), _S("u64"), _S("usize"), _S("f32"), _S("f64"),
		_S("char"), _S("bool"), _S("none"), _S("string"), _S("rune"), _S("array"), _S("map"), _S("chan"),
		_S("any"), _S("float_literal"), _S("int_literal"), _S("thread"), _S("Error"), _S("nil")}));
}
	_const_v__ast__builtin_array_generic_methods = builtin__new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_S("all"), _S("any"), _S("count"), _S("filter"), _S("map"), _S("sort"), _S("sorted")}));
	_const_v__ast__builtin_array_generic_methods_no_sort = builtin__new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_S("all"), _S("any"), _S("count"), _S("filter"), _S("map")}));
	_const_v__ast__builtins = builtin__new_array_from_c_array(8, 8, sizeof(string), _MOV((string[8]){_S("string"), _S("array"), _S("DenseArray"), _S("map"), _S("Error"), _S("IError"), builtin__string_clone(_const_v__ast__option_name), builtin__string_clone(_const_v__ast__result_name)}));
	_const_v__ast__valid_comptime_not_user_defined = v__ast__all_valid_comptime_idents();
{
{
	_const_v__ast__invalid_type_symbol = ((v__ast__TypeSymbol*)builtin__memdup(&(v__ast__TypeSymbol){.generic_types = builtin____new_array(0, 0, sizeof(v__ast__Type)),
	.methods = builtin____new_array(0, 0, sizeof(v__ast__Fn)),
	.mod = _S("builtin"),
	.name = _S("InvalidType"),
	.cname = _S("InvalidType"),
	.rname = (string){.str=(byteptr)"", .is_lit=1},
	.ngname = (string){.str=(byteptr)"", .is_lit=1},
	.info = (v__ast__TypeInfo){._v__ast__UnknownTypeInfo=HEAP(v__ast__UnknownTypeInfo, ((v__ast__UnknownTypeInfo){E_STRUCT})),._typ=498},
	.align = -1,
	.idx = _const_v__ast__invalid_type_idx,
	.size = -1,
	.parent_idx = _const_v__ast__invalid_type_idx,
	.kind = v__ast__Kind__placeholder,
	.language = v__ast__Language__v,
	.is_pub = 0,
	.is_builtin = false,
}, sizeof(v__ast__TypeSymbol)));
}
}
	_const_v__ast__builtin_type_names_matcher = v__token__new_keywords_matcher_from_array_trie(_const_v__ast__builtin_type_names);
{
	_const_v__ast__integer_type_idxs = builtin__new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__i32_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__u8_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx,
		_const_v__ast__isize_type_idx, _const_v__ast__usize_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__rune_type_idx}));
}
	_const_v__ast__signed_integer_type_idxs = builtin__new_array_from_c_array(7, 7, sizeof(int), _MOV((int[7]){_const_v__ast__char_type_idx, _const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__i32_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__isize_type_idx}));
	_const_v__ast__unsigned_integer_type_idxs = builtin__new_array_from_c_array(5, 5, sizeof(int), _MOV((int[5]){_const_v__ast__u8_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx, _const_v__ast__u64_type_idx, _const_v__ast__usize_type_idx}));
	_const_v__ast__int_promoted_type_idxs = builtin__new_array_from_c_array(5, 5, sizeof(int), _MOV((int[5]){_const_v__ast__char_type_idx, _const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__u8_type_idx, _const_v__ast__u16_type_idx}));
	_const_v__ast__float_type_idxs = builtin__new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){_const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__float_literal_type_idx}));
{
	_const_v__ast__number_type_idxs = builtin__new_array_from_c_array(17, 17, sizeof(int), _MOV((int[17]){
		_const_v__ast__i8_type_idx, _const_v__ast__i16_type_idx, _const_v__ast__int_type_idx, _const_v__ast__i32_type_idx, _const_v__ast__i64_type_idx, _const_v__ast__u8_type_idx, _const_v__ast__char_type_idx, _const_v__ast__u16_type_idx, _const_v__ast__u32_type_idx,
		_const_v__ast__u64_type_idx, _const_v__ast__isize_type_idx, _const_v__ast__usize_type_idx, _const_v__ast__f32_type_idx, _const_v__ast__f64_type_idx, _const_v__ast__int_literal_type_idx, _const_v__ast__float_literal_type_idx, _const_v__ast__rune_type_idx}));
}
	_const_v__ast__pointer_type_idxs = builtin__new_array_from_c_array(4, 4, sizeof(int), _MOV((int[4]){_const_v__ast__voidptr_type_idx, _const_v__ast__byteptr_type_idx, _const_v__ast__charptr_type_idx, _const_v__ast__nil_type_idx}));
	_const_v__ast__invalid_type = v__ast__idx_to_type(_const_v__ast__invalid_type_idx);
	_const_v__ast__no_type = v__ast__idx_to_type(_const_v__ast__no_type_idx);
	_const_v__ast__void_type = v__ast__new_type(_const_v__ast__void_type_idx);
	_const_v__ast__ovoid_type = v__ast__Type_set_flag(v__ast__new_type(_const_v__ast__void_type_idx), v__ast__TypeFlag__option);
	_const_v__ast__rvoid_type = v__ast__Type_set_flag(v__ast__new_type(_const_v__ast__void_type_idx), v__ast__TypeFlag__result);
	_const_v__ast__voidptr_type = v__ast__new_type(_const_v__ast__voidptr_type_idx);
	_const_v__ast__byteptr_type = v__ast__new_type(_const_v__ast__byteptr_type_idx);
	_const_v__ast__charptr_type = v__ast__new_type(_const_v__ast__charptr_type_idx);
	_const_v__ast__i8_type = v__ast__new_type(_const_v__ast__i8_type_idx);
	_const_v__ast__i16_type = v__ast__new_type(_const_v__ast__i16_type_idx);
	_const_v__ast__i32_type = v__ast__new_type(_const_v__ast__i32_type_idx);
	_const_v__ast__int_type = v__ast__new_type(_const_v__ast__int_type_idx);
	_const_v__ast__i64_type = v__ast__new_type(_const_v__ast__i64_type_idx);
	_const_v__ast__isize_type = v__ast__new_type(_const_v__ast__isize_type_idx);
	_const_v__ast__u8_type = v__ast__new_type(_const_v__ast__u8_type_idx);
	_const_v__ast__u16_type = v__ast__new_type(_const_v__ast__u16_type_idx);
	_const_v__ast__u32_type = v__ast__new_type(_const_v__ast__u32_type_idx);
	_const_v__ast__u64_type = v__ast__new_type(_const_v__ast__u64_type_idx);
	_const_v__ast__usize_type = v__ast__new_type(_const_v__ast__usize_type_idx);
	_const_v__ast__f32_type = v__ast__new_type(_const_v__ast__f32_type_idx);
	_const_v__ast__f64_type = v__ast__new_type(_const_v__ast__f64_type_idx);
	_const_v__ast__char_type = v__ast__new_type(_const_v__ast__char_type_idx);
	_const_v__ast__bool_type = v__ast__new_type(_const_v__ast__bool_type_idx);
	_const_v__ast__none_type = v__ast__new_type(_const_v__ast__none_type_idx);
	_const_v__ast__string_type = v__ast__new_type(_const_v__ast__string_type_idx);
	_const_v__ast__rune_type = v__ast__new_type(_const_v__ast__rune_type_idx);
	_const_v__ast__array_type = v__ast__new_type(_const_v__ast__array_type_idx);
	_const_v__ast__map_type = v__ast__new_type(_const_v__ast__map_type_idx);
	_const_v__ast__chan_type = v__ast__new_type(_const_v__ast__chan_type_idx);
	_const_v__ast__any_type = v__ast__new_type(_const_v__ast__any_type_idx);
	_const_v__ast__float_literal_type = v__ast__new_type(_const_v__ast__float_literal_type_idx);
	_const_v__ast__int_literal_type = v__ast__new_type(_const_v__ast__int_literal_type_idx);
	_const_v__ast__thread_type = v__ast__new_type(_const_v__ast__thread_type_idx);
	_const_v__ast__error_type = v__ast__new_type(_const_v__ast__error_type_idx);
	_const_v__ast__nil_type = v__ast__new_type(_const_v__ast__nil_type_idx);
	_const_v__ast__builtin_array_generic_methods_matcher = v__token__new_keywords_matcher_from_array_trie(_const_v__ast__builtin_array_generic_methods);
	_const_v__ast__builtin_array_generic_methods_no_sort_matcher = v__token__new_keywords_matcher_from_array_trie(_const_v__ast__builtin_array_generic_methods_no_sort);
	_const_v__ast__charptr_types = v__ast__new_charptr_types();
	_const_v__ast__byteptr_types = v__ast__new_byteptr_types();
	_const_v__ast__voidptr_types = v__ast__new_voidptr_types();
	_const_v__ast__cptr_types = v__ast__merge_types(builtin__new_array_from_c_array(3, 3, sizeof(Array_v__ast__Type), _MOV((Array_v__ast__Type[3]){_const_v__ast__voidptr_types, _const_v__ast__byteptr_types, _const_v__ast__charptr_types})));
	// Initializations of consts for module v.scanner
	_const_v__scanner__internally_generated_v_code = _S("internally_generated_v_code");
{
{
	_const_v__scanner__workaround_markused_bug = builtin__new_map(sizeof(string), sizeof(int), &builtin__map_hash_string, &builtin__map_eq_string, &builtin__map_clone_string, &builtin__map_free_string)
;
}
}
	memcpy(&_const_v__scanner__digit_table, v__scanner__get_digit_table().ret_arr, sizeof(Array_fixed_bool_256));
	memcpy(&_const_v__scanner__letter_table, v__scanner__get_letter_table().ret_arr, sizeof(Array_fixed_bool_256));
	// Initializations of consts for module v.parser
	_const_v__parser__error_msg = _S("only `$tmpl()`, `$env()`, `$embed_file()`, `$pkgconfig()`, `$veb.html()`, `$vweb.html()`, `$compile_error()`, `$compile_warn()`, `$d()` and `$res()` comptime functions are supported right now");
	_const_v__parser__tmpl_str_end = _S("')\n");
{
	_const_v__parser__allowed_lock_prefix_ins = builtin__new_array_from_c_array(19, 19, sizeof(string), _MOV((string[19]){
		_S("add"), _S("adc"), _S("and"), _S("btc"), _S("btr"), _S("bts"), _S("cmpxchg"), _S("cmpxchg8b"), _S("cmpxchg16b"),
		_S("dec"), _S("inc"), _S("neg"), _S("not"), _S("or"), _S("sbb"), _S("sub"), _S("xor"),
		_S("xadd"), _S("xchg")}));
}
	_const_v__parser__valid_tokens_inside_types = builtin__new_array_from_c_array(6, 6, sizeof(v__token__Kind), _MOV((v__token__Kind[6]){v__token__Kind__lsbr, v__token__Kind__rsbr, v__token__Kind__name, v__token__Kind__dot, v__token__Kind__comma, v__token__Kind__key_fn}));
	codegen_files = builtin____new_array_with_default(0, 0, sizeof(v__ast__File*), 0); // global 3
	_const_v__parser__supported_comptime_calls = builtin__new_array_from_c_array(9, 9, sizeof(string), _MOV((string[9]){
		_S("html"), _S("tmpl"), _S("env"), _S("embed_file"), _S("pkgconfig"), _S("compile_error"), _S("compile_warn"), _S("d"), _S("res")}));
{
	_const_v__parser__comptime_types = builtin__new_array_from_c_array(17, 17, sizeof(string), _MOV((string[17]){
		_S("map"), _S("array"), _S("array_dynamic"), _S("array_fixed"), _S("int"), _S("float"), _S("struct"), _S("interface"), _S("enum"),
		_S("sumtype"), _S("alias"), _S("function"), _S("option"), _S("shared"), _S("string"), _S("pointer"), _S("voidptr")}));
}
	_const_v__parser__normalised_working_folder = builtin__string_replace((builtin__string__plus(os__real_path(os__getwd()), _S("/"))), _S("\\"), _S("/"));
}
void _vcleanup(void) {
}
__attribute__ ((constructor))
void _vinit_caller() {
	static bool once = false; if (once) {return;} once = true;
	_vinit(0,0);
}
__attribute__ ((destructor))
void _vcleanup_caller() {
	static bool once = false; if (once) {return;} once = true;
	_vcleanup();
}

int main(int ___argc, char** ___argv){
	g_main_argc = ___argc;
	g_main_argv = ___argv;
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}
// THE END.
